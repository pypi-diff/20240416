# Comparing `tmp/RsCmwGprfMeas-3.7.30.31.tar.gz` & `tmp/RsCmwGprfMeas-4.0.140.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "dist\RsCmwGprfMeas-3.7.30.31.tar", last modified: Sun May 16 18:17:49 2021, max compression
+gzip compressed data, was "dist\RsCmwGprfMeas-4.0.140.tar", last modified: Tue Apr 16 12:53:55 2024, max compression
```

## Comparing `RsCmwGprfMeas-3.7.30.31.tar` & `RsCmwGprfMeas-4.0.140.tar`

### file list

```diff
@@ -1,420 +1,368 @@
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:49.084664 RsCmwGprfMeas-3.7.30.31/
--rw-rw-rw-   0        0        0     3921 2021-05-16 18:17:49.083664 RsCmwGprfMeas-3.7.30.31/PKG-INFO
--rw-rw-rw-   0        0        0     2720 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/README.md
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:47.533328 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:47.579206 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/CustomFiles/
--rw-rw-rw-   0        0        0        0 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/CustomFiles/__init__.py
--rw-rw-rw-   0        0        0     3304 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/CustomFiles/events.py
--rw-rw-rw-   0        0        0     4517 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/CustomFiles/reliability.py
--rw-rw-rw-   0        0        0    18659 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/CustomFiles/utilities.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:47.649592 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/
--rw-rw-rw-   0        0        0     1071 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Calibration.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:47.662565 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Calibration_/
--rw-rw-rw-   0        0        0     1015 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Calibration_/ExtPwrSensor.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:47.673529 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Calibration_/ExtPwrSensor_/
--rw-rw-rw-   0        0        0     2856 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Calibration_/ExtPwrSensor_/Zero.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Calibration_/ExtPwrSensor_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Calibration_/__init__.py
--rw-rw-rw-   0        0        0     4499 2021-05-16 18:17:42.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:47.727262 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/
--rw-rw-rw-   0        0        0     8726 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/ExtPwrSensor.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:47.736238 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/ExtPwrSensor_/
--rw-rw-rw-   0        0        0     2384 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/ExtPwrSensor_/Attenuation.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/ExtPwrSensor_/__init__.py
--rw-rw-rw-   0        0        0    12499 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/FftSpecAn.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:47.746211 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/FftSpecAn_/
--rw-rw-rw-   0        0        0     5432 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/FftSpecAn_/PeakSearch.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/FftSpecAn_/__init__.py
--rw-rw-rw-   0        0        0    14647 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqRecorder.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:47.770149 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqRecorder_/
--rw-rw-rw-   0        0        0     2875 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqRecorder_/FilterPy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:47.785108 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqRecorder_/FilterPy_/
--rw-rw-rw-   0        0        0     1554 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqRecorder_/FilterPy_/Bandpass.py
--rw-rw-rw-   0        0        0     1512 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqRecorder_/FilterPy_/Gauss.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqRecorder_/FilterPy_/__init__.py
--rw-rw-rw-   0        0        0     7926 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqRecorder_/ListPy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:47.798580 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqRecorder_/ListPy_/
--rw-rw-rw-   0        0        0     3390 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqRecorder_/ListPy_/EnvelopePower.py
--rw-rw-rw-   0        0        0     4082 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqRecorder_/ListPy_/Frequency.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqRecorder_/ListPy_/__init__.py
--rw-rw-rw-   0        0        0     1421 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqRecorder_/Trigger.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqRecorder_/__init__.py
--rw-rw-rw-   0        0        0    10868 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqVsSlot.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:47.812544 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqVsSlot_/
--rw-rw-rw-   0        0        0     6564 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqVsSlot_/ListPy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:47.834486 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqVsSlot_/ListPy_/
--rw-rw-rw-   0        0        0     3250 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqVsSlot_/ListPy_/EnvelopePower.py
--rw-rw-rw-   0        0        0     4044 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqVsSlot_/ListPy_/Frequency.py
--rw-rw-rw-   0        0        0     3643 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqVsSlot_/ListPy_/Retrigger.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqVsSlot_/ListPy_/__init__.py
--rw-rw-rw-   0        0        0     1405 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqVsSlot_/Trigger.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqVsSlot_/__init__.py
--rw-rw-rw-   0        0        0     3493 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Nrpm.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:47.844458 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Nrpm_/
--rw-rw-rw-   0        0        0     1842 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Nrpm_/Sensor.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:47.856427 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Nrpm_/Sensor_/
--rw-rw-rw-   0        0        0     1807 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Nrpm_/Sensor_/Frequency.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Nrpm_/Sensor_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Nrpm_/__init__.py
--rw-rw-rw-   0        0        0     2405 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Ploss.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:47.875376 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Ploss_/
--rw-rw-rw-   0        0        0     1021 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Ploss_/ListPy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:47.885352 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Ploss_/ListPy_/
--rw-rw-rw-   0        0        0     3670 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Ploss_/ListPy_/Frequency.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Ploss_/ListPy_/__init__.py
--rw-rw-rw-   0        0        0      991 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Ploss_/Mpath.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:47.896830 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Ploss_/Mpath_/
--rw-rw-rw-   0        0        0     1023 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Ploss_/Mpath_/ListPy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:47.907801 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Ploss_/Mpath_/ListPy_/
--rw-rw-rw-   0        0        0     4109 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Ploss_/Mpath_/ListPy_/Frequency.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Ploss_/Mpath_/ListPy_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Ploss_/Mpath_/__init__.py
--rw-rw-rw-   0        0        0     1333 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Ploss_/View.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Ploss_/__init__.py
--rw-rw-rw-   0        0        0    12491 2021-05-16 18:17:42.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:47.940715 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/
--rw-rw-rw-   0        0        0     1674 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/Catalog.py
--rw-rw-rw-   0        0        0     2977 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/FilterPy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:47.956671 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/FilterPy_/
--rw-rw-rw-   0        0        0     1642 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/FilterPy_/Bandpass.py
--rw-rw-rw-   0        0        0     1682 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/FilterPy_/Gauss.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/FilterPy_/__init__.py
--rw-rw-rw-   0        0        0    10415 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ListPy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:47.993573 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ListPy_/
--rw-rw-rw-   0        0        0     3328 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ListPy_/EnvelopePower.py
--rw-rw-rw-   0        0        0     4022 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ListPy_/Frequency.py
--rw-rw-rw-   0        0        0     3957 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ListPy_/IqData.py
--rw-rw-rw-   0        0        0     3005 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ListPy_/Irepetition.py
--rw-rw-rw-   0        0        0     3485 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ListPy_/ParameterSetList.py
--rw-rw-rw-   0        0        0     3597 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ListPy_/Retrigger.py
--rw-rw-rw-   0        0        0     2783 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ListPy_/SingleCmw.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.004544 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ListPy_/SingleCmw_/
--rw-rw-rw-   0        0        0     4716 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ListPy_/SingleCmw_/Connector.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ListPy_/SingleCmw_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ListPy_/__init__.py
--rw-rw-rw-   0        0        0     3868 2021-05-16 18:17:42.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.034464 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/
--rw-rw-rw-   0        0        0     1233 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/Catalog.py
--rw-rw-rw-   0        0        0     1489 2021-05-16 18:17:42.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/FilterPy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.054410 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/FilterPy_/
--rw-rw-rw-   0        0        0     1037 2021-05-16 18:17:42.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/FilterPy_/Bandpass.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.062388 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/FilterPy_/Bandpass_/
--rw-rw-rw-   0        0        0     4128 2021-05-16 18:17:42.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/FilterPy_/Bandpass_/Bandwidth.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/FilterPy_/Bandpass_/__init__.py
--rw-rw-rw-   0        0        0     1019 2021-05-16 18:17:42.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/FilterPy_/Gauss.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.072363 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/FilterPy_/Gauss_/
--rw-rw-rw-   0        0        0     3788 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/FilterPy_/Gauss_/Bandwidth.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/FilterPy_/Gauss_/__init__.py
--rw-rw-rw-   0        0        0     4640 2021-05-16 18:17:42.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/FilterPy_/TypePy.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/FilterPy_/__init__.py
--rw-rw-rw-   0        0        0     3740 2021-05-16 18:17:42.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/Mlength.py
--rw-rw-rw-   0        0        0     2446 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/PdefSet.py
--rw-rw-rw-   0        0        0     3132 2021-05-16 18:17:42.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/Slength.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/__init__.py
--rw-rw-rw-   0        0        0     1391 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/Trigger.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/__init__.py
--rw-rw-rw-   0        0        0     9896 2021-05-16 18:17:42.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/RfSettings.py
--rw-rw-rw-   0        0        0     7896 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Spectrum.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.091313 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Spectrum_/
--rw-rw-rw-   0        0        0     1415 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Spectrum_/FreqSweep.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.109264 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Spectrum_/FreqSweep_/
--rw-rw-rw-   0        0        0     2585 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Spectrum_/FreqSweep_/Rbw.py
--rw-rw-rw-   0        0        0     2627 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Spectrum_/FreqSweep_/Swt.py
--rw-rw-rw-   0        0        0     2613 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Spectrum_/FreqSweep_/Vbw.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Spectrum_/FreqSweep_/__init__.py
--rw-rw-rw-   0        0        0     7266 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Spectrum_/Frequency.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.116245 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Spectrum_/Frequency_/
--rw-rw-rw-   0        0        0     3550 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Spectrum_/Frequency_/Span.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Spectrum_/Frequency_/__init__.py
--rw-rw-rw-   0        0        0     2130 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Spectrum_/ZeroSpan.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.131207 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Spectrum_/ZeroSpan_/
--rw-rw-rw-   0        0        0     3824 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Spectrum_/ZeroSpan_/Rbw.py
--rw-rw-rw-   0        0        0     2583 2021-05-16 18:17:43.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Spectrum_/ZeroSpan_/Vbw.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Spectrum_/ZeroSpan_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Spectrum_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/__init__.py
--rw-rw-rw-   0        0        0     8555 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/ExtPwrSensor.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.141178 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/ExtPwrSensor_/
--rw-rw-rw-   0        0        0     1802 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/ExtPwrSensor_/State.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.149158 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/ExtPwrSensor_/State_/
--rw-rw-rw-   0        0        0     1176 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/ExtPwrSensor_/State_/All.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/ExtPwrSensor_/State_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/ExtPwrSensor_/__init__.py
--rw-rw-rw-   0        0        0     7120 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/FftSpecAn.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.177082 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/FftSpecAn_/
--rw-rw-rw-   0        0        0     2016 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/FftSpecAn_/Icomponent.py
--rw-rw-rw-   0        0        0     1237 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/FftSpecAn_/Peaks.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.190049 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/FftSpecAn_/Peaks_/
--rw-rw-rw-   0        0        0     2518 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/FftSpecAn_/Peaks_/Average.py
--rw-rw-rw-   0        0        0     2518 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/FftSpecAn_/Peaks_/Current.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/FftSpecAn_/Peaks_/__init__.py
--rw-rw-rw-   0        0        0     1717 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/FftSpecAn_/Power.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.212988 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/FftSpecAn_/Power_/
--rw-rw-rw-   0        0        0     2331 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/FftSpecAn_/Power_/Average.py
--rw-rw-rw-   0        0        0     2331 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/FftSpecAn_/Power_/Current.py
--rw-rw-rw-   0        0        0     2331 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/FftSpecAn_/Power_/Maximum.py
--rw-rw-rw-   0        0        0     2331 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/FftSpecAn_/Power_/Minimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/FftSpecAn_/Power_/__init__.py
--rw-rw-rw-   0        0        0     2016 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/FftSpecAn_/Qcomponent.py
--rw-rw-rw-   0        0        0     1807 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/FftSpecAn_/State.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.220967 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/FftSpecAn_/State_/
--rw-rw-rw-   0        0        0     1181 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/FftSpecAn_/State_/All.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/FftSpecAn_/State_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/FftSpecAn_/__init__.py
--rw-rw-rw-   0        0        0      997 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Initiate.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.228945 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Initiate_/
--rw-rw-rw-   0        0        0     6250 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Initiate_/Ploss.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Initiate_/__init__.py
--rw-rw-rw-   0        0        0     8743 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqRecorder.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.257867 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqRecorder_/
--rw-rw-rw-   0        0        0     1502 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqRecorder_/Bin.py
--rw-rw-rw-   0        0        0      928 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqRecorder_/Reliability.py
--rw-rw-rw-   0        0        0     1804 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqRecorder_/State.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.266843 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqRecorder_/State_/
--rw-rw-rw-   0        0        0     1178 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqRecorder_/State_/All.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqRecorder_/State_/__init__.py
--rw-rw-rw-   0        0        0      920 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqRecorder_/SymbolRate.py
--rw-rw-rw-   0        0        0     1683 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqRecorder_/Talignment.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqRecorder_/__init__.py
--rw-rw-rw-   0        0        0     7546 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqVsSlot.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.300753 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqVsSlot_/
--rw-rw-rw-   0        0        0     2081 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqVsSlot_/FreqError.py
--rw-rw-rw-   0        0        0     2076 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqVsSlot_/Icomponent.py
--rw-rw-rw-   0        0        0     2045 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqVsSlot_/Level.py
--rw-rw-rw-   0        0        0     3281 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqVsSlot_/OfError.py
--rw-rw-rw-   0        0        0     2045 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqVsSlot_/Phase.py
--rw-rw-rw-   0        0        0     2076 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqVsSlot_/Qcomponent.py
--rw-rw-rw-   0        0        0     1796 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqVsSlot_/State.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.310727 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqVsSlot_/State_/
--rw-rw-rw-   0        0        0     1170 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqVsSlot_/State_/All.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqVsSlot_/State_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqVsSlot_/__init__.py
--rw-rw-rw-   0        0        0     3076 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Nrpm.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.323692 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Nrpm_/
--rw-rw-rw-   0        0        0     1806 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Nrpm_/Sensor.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.332668 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Nrpm_/Sensor_/
--rw-rw-rw-   0        0        0     4185 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Nrpm_/Sensor_/Power.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Nrpm_/Sensor_/__init__.py
--rw-rw-rw-   0        0        0     1455 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Nrpm_/State.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.342641 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Nrpm_/State_/
--rw-rw-rw-   0        0        0      914 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Nrpm_/State_/All.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Nrpm_/State_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Nrpm_/__init__.py
--rw-rw-rw-   0        0        0     4399 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Ploss.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.372561 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Ploss_/
--rw-rw-rw-   0        0        0     1082 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Ploss_/Clear.py
--rw-rw-rw-   0        0        0     1668 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Ploss_/Eval.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.395501 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Ploss_/Eval_/
--rw-rw-rw-   0        0        0     2099 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Ploss_/Eval_/Frequency.py
--rw-rw-rw-   0        0        0     1865 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Ploss_/Eval_/Gain.py
--rw-rw-rw-   0        0        0     2827 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Ploss_/Eval_/State.py
--rw-rw-rw-   0        0        0     1231 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Ploss_/Eval_/Trace.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.407468 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Ploss_/Eval_/Trace_/
--rw-rw-rw-   0        0        0     2126 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Ploss_/Eval_/Trace_/Frequency.py
--rw-rw-rw-   0        0        0     1892 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Ploss_/Eval_/Trace_/Gain.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Ploss_/Eval_/Trace_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Ploss_/Eval_/__init__.py
--rw-rw-rw-   0        0        0     2050 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Ploss_/Open.py
--rw-rw-rw-   0        0        0     2058 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Ploss_/Short.py
--rw-rw-rw-   0        0        0     1777 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Ploss_/State.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.414449 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Ploss_/State_/
--rw-rw-rw-   0        0        0     1163 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Ploss_/State_/All.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Ploss_/State_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Ploss_/__init__.py
--rw-rw-rw-   0        0        0     9109 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.477282 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/
--rw-rw-rw-   0        0        0     1453 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/AmplitudeProbDensity.py
--rw-rw-rw-   0        0        0     4831 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Average.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.485262 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Average_/
--rw-rw-rw-   0        0        0     1649 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Average_/Rms.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Average_/__init__.py
--rw-rw-rw-   0        0        0     2654 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/CumulativeDistribFnc.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.503215 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/CumulativeDistribFnc_/
--rw-rw-rw-   0        0        0     1977 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/CumulativeDistribFnc_/Power.py
--rw-rw-rw-   0        0        0     1641 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/CumulativeDistribFnc_/Probability.py
--rw-rw-rw-   0        0        0     1668 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/CumulativeDistribFnc_/Sample.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/CumulativeDistribFnc_/__init__.py
--rw-rw-rw-   0        0        0     5315 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Current.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.521165 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Current_/
--rw-rw-rw-   0        0        0     1685 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Current_/Maximum.py
--rw-rw-rw-   0        0        0     1685 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Current_/Minimum.py
--rw-rw-rw-   0        0        0     1649 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Current_/Rms.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Current_/__init__.py
--rw-rw-rw-   0        0        0     1194 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ElapsedStats.py
--rw-rw-rw-   0        0        0     3727 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/IqData.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.530141 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/IqData_/
--rw-rw-rw-   0        0        0     1995 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/IqData_/Bin.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/IqData_/__init__.py
--rw-rw-rw-   0        0        0     2179 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/IqInfo.py
--rw-rw-rw-   0        0        0     2217 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ListPy.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.568041 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ListPy_/
--rw-rw-rw-   0        0        0     3749 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ListPy_/Average.py
--rw-rw-rw-   0        0        0     4271 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ListPy_/Current.py
--rw-rw-rw-   0        0        0     1011 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ListPy_/Maximum.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.577016 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ListPy_/Maximum_/
--rw-rw-rw-   0        0        0     4348 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ListPy_/Maximum_/Current.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ListPy_/Maximum_/__init__.py
--rw-rw-rw-   0        0        0     1011 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ListPy_/Minimum.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.586990 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ListPy_/Minimum_/
--rw-rw-rw-   0        0        0     4348 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ListPy_/Minimum_/Current.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ListPy_/Minimum_/__init__.py
--rw-rw-rw-   0        0        0     1232 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ListPy_/Peak.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.598957 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ListPy_/Peak_/
--rw-rw-rw-   0        0        0     4321 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ListPy_/Peak_/Maximum.py
--rw-rw-rw-   0        0        0     4321 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ListPy_/Peak_/Minimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ListPy_/Peak_/__init__.py
--rw-rw-rw-   0        0        0     4313 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ListPy_/StandardDev.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ListPy_/__init__.py
--rw-rw-rw-   0        0        0     1251 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Maximum.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.612920 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Maximum_/
--rw-rw-rw-   0        0        0     4315 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Maximum_/Current.py
--rw-rw-rw-   0        0        0     1685 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Maximum_/Maximum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Maximum_/__init__.py
--rw-rw-rw-   0        0        0     1251 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Minimum.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.626882 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Minimum_/
--rw-rw-rw-   0        0        0     4315 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Minimum_/Current.py
--rw-rw-rw-   0        0        0     1685 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Minimum_/Minimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Minimum_/__init__.py
--rw-rw-rw-   0        0        0     1230 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Peak.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.639848 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Peak_/
--rw-rw-rw-   0        0        0     4288 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Peak_/Maximum.py
--rw-rw-rw-   0        0        0     4288 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Peak_/Minimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Peak_/__init__.py
--rw-rw-rw-   0        0        0     4302 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/StandardDev.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.647827 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/StandardDev_/
--rw-rw-rw-   0        0        0     1705 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/StandardDev_/Current.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/StandardDev_/__init__.py
--rw-rw-rw-   0        0        0     1789 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/State.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.655806 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/State_/
--rw-rw-rw-   0        0        0     1163 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/State_/All.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/State_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/__init__.py
--rw-rw-rw-   0        0        0     2518 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Route.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.662787 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Route_/
--rw-rw-rw-   0        0        0     6534 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Route_/Scenario.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.677748 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Route_/Scenario_/
--rw-rw-rw-   0        0        0     1115 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Route_/Scenario_/Catalog.py
--rw-rw-rw-   0        0        0     1183 2021-05-16 18:17:44.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Route_/Scenario_/MaProtocol.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Route_/Scenario_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Route_/__init__.py
--rw-rw-rw-   0        0        0     7785 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.718639 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/
--rw-rw-rw-   0        0        0     1735 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Average.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.741577 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Average_/
--rw-rw-rw-   0        0        0     2095 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Average_/Average.py
--rw-rw-rw-   0        0        0     2095 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Average_/Current.py
--rw-rw-rw-   0        0        0     2095 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Average_/Maximum.py
--rw-rw-rw-   0        0        0     2095 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Average_/Minimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Average_/__init__.py
--rw-rw-rw-   0        0        0     1806 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Marker.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.751551 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Marker_/
--rw-rw-rw-   0        0        0     2540 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Marker_/Npeak.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Marker_/__init__.py
--rw-rw-rw-   0        0        0     1735 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Maximum.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.774489 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Maximum_/
--rw-rw-rw-   0        0        0     1943 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Maximum_/Average.py
--rw-rw-rw-   0        0        0     1943 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Maximum_/Current.py
--rw-rw-rw-   0        0        0     1943 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Maximum_/Maximum.py
--rw-rw-rw-   0        0        0     1943 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Maximum_/Minimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Maximum_/__init__.py
--rw-rw-rw-   0        0        0     1735 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Minimum.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.796432 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Minimum_/
--rw-rw-rw-   0        0        0     1943 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Minimum_/Average.py
--rw-rw-rw-   0        0        0     1943 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Minimum_/Current.py
--rw-rw-rw-   0        0        0     1943 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Minimum_/Maximum.py
--rw-rw-rw-   0        0        0     1943 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Minimum_/Minimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Minimum_/__init__.py
--rw-rw-rw-   0        0        0     1275 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/ReferenceMarker.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.810395 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/ReferenceMarker_/
--rw-rw-rw-   0        0        0     2248 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/ReferenceMarker_/Npeak.py
--rw-rw-rw-   0        0        0     2220 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/ReferenceMarker_/Speak.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/ReferenceMarker_/__init__.py
--rw-rw-rw-   0        0        0     1699 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Rms.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.829342 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Rms_/
--rw-rw-rw-   0        0        0     1897 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Rms_/Average.py
--rw-rw-rw-   0        0        0     1897 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Rms_/Current.py
--rw-rw-rw-   0        0        0     1897 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Rms_/Maximum.py
--rw-rw-rw-   0        0        0     1897 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Rms_/Minimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Rms_/__init__.py
--rw-rw-rw-   0        0        0     1726 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Sample.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.850287 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Sample_/
--rw-rw-rw-   0        0        0     1921 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Sample_/Average.py
--rw-rw-rw-   0        0        0     1921 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Sample_/Current.py
--rw-rw-rw-   0        0        0     1921 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Sample_/Maximum.py
--rw-rw-rw-   0        0        0     1921 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Sample_/Minimum.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Sample_/__init__.py
--rw-rw-rw-   0        0        0     1798 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/State.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.860260 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/State_/
--rw-rw-rw-   0        0        0     1172 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/State_/All.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/State_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/__init__.py
--rw-rw-rw-   0        0        0     2016 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.887188 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/
--rw-rw-rw-   0        0        0    11384 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/FftSpecAn.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.895167 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/FftSpecAn_/
--rw-rw-rw-   0        0        0     1019 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/FftSpecAn_/Catalog.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/FftSpecAn_/__init__.py
--rw-rw-rw-   0        0        0     9051 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/IqRecorder.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.904143 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/IqRecorder_/
--rw-rw-rw-   0        0        0     1017 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/IqRecorder_/Catalog.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/IqRecorder_/__init__.py
--rw-rw-rw-   0        0        0     9429 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/IqVsSlot.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.913119 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/IqVsSlot_/
--rw-rw-rw-   0        0        0     1007 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/IqVsSlot_/Catalog.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/IqVsSlot_/__init__.py
--rw-rw-rw-   0        0        0     9727 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/Power.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.927082 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/Power_/
--rw-rw-rw-   0        0        0      997 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/Power_/Catalog.py
--rw-rw-rw-   0        0        0     1057 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/Power_/ParameterSetList.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.937057 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/Power_/ParameterSetList_/
--rw-rw-rw-   0        0        0     3016 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/Power_/ParameterSetList_/Offset.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/Power_/ParameterSetList_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/Power_/__init__.py
--rw-rw-rw-   0        0        0     8339 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/Spectrum.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:48.946031 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/Spectrum_/
--rw-rw-rw-   0        0        0     1009 2021-05-16 18:17:45.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/Spectrum_/Catalog.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/Spectrum_/__init__.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/__init__.py
--rw-rw-rw-   0        0        0        0 2019-11-18 07:28:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/__init__.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:49.076684 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/
--rw-rw-rw-   0        0        0      541 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/ArgLinkedEventArgs.py
--rw-rw-rw-   0        0        0     4003 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/ArgSingle.py
--rw-rw-rw-   0        0        0     1061 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/ArgSingleList.py
--rw-rw-rw-   0        0        0     1000 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/ArgSingleSuppressed.py
--rw-rw-rw-   0        0        0     9026 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/ArgStringComposer.py
--rw-rw-rw-   0        0        0     5624 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/ArgStruct.py
--rw-rw-rw-   0        0        0     3354 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/ArgStructList.py
--rw-rw-rw-   0        0        0     2446 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/ArgStructStringParser.py
--rw-rw-rw-   0        0        0     5176 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/CommandsGroup.py
--rw-rw-rw-   0        0        0    20227 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/Conversions.py
--rw-rw-rw-   0        0        0     3618 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/ConverterFromScpiString.py
--rw-rw-rw-   0        0        0     4409 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/ConverterToScpiString.py
--rw-rw-rw-   0        0        0    10299 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/Core.py
--rw-rw-rw-   0        0        0    38340 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/Instrument.py
--rw-rw-rw-   0        0        0     3918 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/InstrumentErrors.py
--rw-rw-rw-   0        0        0     2081 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/InstrumentOptions.py
--rw-rw-rw-   0        0        0     5101 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/InstrumentSettings.py
--rw-rw-rw-   0        0        0     3380 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/InternalLinker.py
--rw-rw-rw-   0        0        0     4331 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/IoTransferEventArgs.py
--rw-rw-rw-   0        0        0     3841 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/RepeatedCapability.py
--rw-rw-rw-   0        0        0     4719 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/StreamReader.py
--rw-rw-rw-   0        0        0     4938 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/StreamWriter.py
--rw-rw-rw-   0        0        0     1040 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/StructBase.py
--rw-rw-rw-   0        0        0     2893 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/Types.py
--rw-rw-rw-   0        0        0     4530 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/Utilities.py
--rw-rw-rw-   0        0        0     4850 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/VisaPluginSocketIo.py
--rw-rw-rw-   0        0        0    44232 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/VisaSession.py
--rw-rw-rw-   0        0        0     6999 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/VisaSessionSim.py
--rw-rw-rw-   0        0        0        0 2021-05-01 19:09:01.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/__init__.py
--rw-rw-rw-   0        0        0    10898 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/RsCmwGprfMeas.py
--rw-rw-rw-   0        0        0      847 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/__init__.py
--rw-rw-rw-   0        0        0     7614 2021-05-16 18:17:40.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/enums.py
--rw-rw-rw-   0        0        0     1078 2021-05-16 18:17:40.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/repcap.py
-drwxrwxrwx   0        0        0        0 2021-05-16 18:17:47.561255 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas.egg-info/
--rw-rw-rw-   0        0        0     3921 2021-05-16 18:17:47.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0    18899 2021-05-16 18:17:47.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        1 2021-05-16 18:17:47.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0        7 2021-05-16 18:17:47.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas.egg-info/requires.txt
--rw-rw-rw-   0        0        0       14 2021-05-16 18:17:47.000000 RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas.egg-info/top_level.txt
--rw-rw-rw-   0        0        0       42 2021-05-16 18:17:49.088653 RsCmwGprfMeas-3.7.30.31/setup.cfg
--rw-rw-rw-   0        0        0      865 2021-05-16 18:17:46.000000 RsCmwGprfMeas-3.7.30.31/setup.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.827238 RsCmwGprfMeas-4.0.140/
+-rw-rw-rw-   0        0        0     4362 2024-04-16 12:53:55.826240 RsCmwGprfMeas-4.0.140/PKG-INFO
+-rw-rw-rw-   0        0        0     2627 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/README.rst
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.084220 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.106163 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/CustomFiles/
+-rw-rw-rw-   0        0        0       90 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/CustomFiles/__init__.py
+-rw-rw-rw-   0        0        0     3725 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/CustomFiles/events.py
+-rw-rw-rw-   0        0        0     4916 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/CustomFiles/reliability.py
+-rw-rw-rw-   0        0        0    21854 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/CustomFiles/utilities.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.110152 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.112146 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Calibration/
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.117133 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Calibration/ExtPwrSensor/
+-rw-rw-rw-   0        0        0     2992 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Calibration/ExtPwrSensor/Zero.py
+-rw-rw-rw-   0        0        0     1036 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Calibration/ExtPwrSensor/__init__.py
+-rw-rw-rw-   0        0        0     1093 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Calibration/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.119129 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Canalyzer/
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.124115 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Canalyzer/State/
+-rw-rw-rw-   0        0        0     1785 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Canalyzer/State/All.py
+-rw-rw-rw-   0        0        0     2349 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Canalyzer/State/__init__.py
+-rw-rw-rw-   0        0        0     2136 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Canalyzer/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.127105 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.134088 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Canalyzer/
+-rw-rw-rw-   0        0        0     1247 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Canalyzer/IqFile.py
+-rw-rw-rw-   0        0        0     2176 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Canalyzer/Sall.py
+-rw-rw-rw-   0        0        0     3240 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Canalyzer/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.140071 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/ExtPwrSensor/
+-rw-rw-rw-   0        0        0     2415 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/ExtPwrSensor/Attenuation.py
+-rw-rw-rw-   0        0        0     8523 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/ExtPwrSensor/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.148052 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/FftSpecAn/
+-rw-rw-rw-   0        0        0     6303 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/FftSpecAn/PeakSearch.py
+-rw-rw-rw-   0        0        0    12207 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/FftSpecAn/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.158022 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/IqRecorder/
+-rw-rw-rw-   0        0        0     2634 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/IqRecorder/Capture.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.167996 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/IqRecorder/FilterPy/
+-rw-rw-rw-   0        0        0     1657 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/IqRecorder/FilterPy/Bandpass.py
+-rw-rw-rw-   0        0        0     1639 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/IqRecorder/FilterPy/Gauss.py
+-rw-rw-rw-   0        0        0     2451 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/IqRecorder/FilterPy/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.183955 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/IqRecorder/ListPy/
+-rw-rw-rw-   0        0        0     2651 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/IqRecorder/ListPy/EnvelopePower.py
+-rw-rw-rw-   0        0        0     2595 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/IqRecorder/ListPy/Frequency.py
+-rw-rw-rw-   0        0        0     2095 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/IqRecorder/ListPy/Sstop.py
+-rw-rw-rw-   0        0        0     5316 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/IqRecorder/ListPy/__init__.py
+-rw-rw-rw-   0        0        0     1428 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/IqRecorder/Trigger.py
+-rw-rw-rw-   0        0        0    12034 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/IqRecorder/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.189939 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/IqVsSlot/
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.206893 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/IqVsSlot/ListPy/
+-rw-rw-rw-   0        0        0     3741 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/IqVsSlot/ListPy/EnvelopePower.py
+-rw-rw-rw-   0        0        0     3017 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/IqVsSlot/ListPy/Frequency.py
+-rw-rw-rw-   0        0        0     3058 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/IqVsSlot/ListPy/Retrigger.py
+-rw-rw-rw-   0        0        0     2411 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/IqVsSlot/ListPy/Sstop.py
+-rw-rw-rw-   0        0        0     5599 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/IqVsSlot/ListPy/__init__.py
+-rw-rw-rw-   0        0        0     1412 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/IqVsSlot/Trigger.py
+-rw-rw-rw-   0        0        0    10647 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/IqVsSlot/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.209886 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Nrpm/
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.214872 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Nrpm/Sensor/
+-rw-rw-rw-   0        0        0     1827 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Nrpm/Sensor/Frequency.py
+-rw-rw-rw-   0        0        0     1883 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Nrpm/Sensor/__init__.py
+-rw-rw-rw-   0        0        0     3524 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Nrpm/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.219859 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Ploss/
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.224845 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Ploss/ListPy/
+-rw-rw-rw-   0        0        0     2626 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Ploss/ListPy/Frequency.py
+-rw-rw-rw-   0        0        0     1048 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Ploss/ListPy/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.227837 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Ploss/Mpath/
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.233821 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Ploss/Mpath/ListPy/
+-rw-rw-rw-   0        0        0     3026 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Ploss/Mpath/ListPy/Frequency.py
+-rw-rw-rw-   0        0        0     1050 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Ploss/Mpath/ListPy/__init__.py
+-rw-rw-rw-   0        0        0     1019 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Ploss/Mpath/__init__.py
+-rw-rw-rw-   0        0        0     1240 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Ploss/View.py
+-rw-rw-rw-   0        0        0     2256 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Ploss/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.242797 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/
+-rw-rw-rw-   0        0        0     1041 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/Catalog.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.249778 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/FilterPy/
+-rw-rw-rw-   0        0        0     1463 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/FilterPy/Bandpass.py
+-rw-rw-rw-   0        0        0     1439 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/FilterPy/Gauss.py
+-rw-rw-rw-   0        0        0     2781 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/FilterPy/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.268728 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ListPy/
+-rw-rw-rw-   0        0        0     3709 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ListPy/EnvelopePower.py
+-rw-rw-rw-   0        0        0     2985 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ListPy/Frequency.py
+-rw-rw-rw-   0        0        0     3350 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ListPy/IqData.py
+-rw-rw-rw-   0        0        0     3206 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ListPy/Irepetition.py
+-rw-rw-rw-   0        0        0     2818 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ListPy/ParameterSetList.py
+-rw-rw-rw-   0        0        0     3026 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ListPy/Retrigger.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.272718 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ListPy/SingleCmw/
+-rw-rw-rw-   0        0        0     2840 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ListPy/SingleCmw/Connector.py
+-rw-rw-rw-   0        0        0     2172 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ListPy/SingleCmw/__init__.py
+-rw-rw-rw-   0        0        0     2407 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ListPy/Sstop.py
+-rw-rw-rw-   0        0        0     8695 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ListPy/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.284686 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/
+-rw-rw-rw-   0        0        0     1092 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/Catalog.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.288675 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/FilterPy/
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.293661 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/FilterPy/Bandpass/
+-rw-rw-rw-   0        0        0     3257 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/FilterPy/Bandpass/Bandwidth.py
+-rw-rw-rw-   0        0        0     1062 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/FilterPy/Bandpass/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.299645 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/FilterPy/Gauss/
+-rw-rw-rw-   0        0        0     3281 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/FilterPy/Gauss/Bandwidth.py
+-rw-rw-rw-   0        0        0     1047 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/FilterPy/Gauss/__init__.py
+-rw-rw-rw-   0        0        0     4134 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/FilterPy/TypePy.py
+-rw-rw-rw-   0        0        0     1516 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/FilterPy/__init__.py
+-rw-rw-rw-   0        0        0     3347 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/Mlength.py
+-rw-rw-rw-   0        0        0     2419 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/PdefSet.py
+-rw-rw-rw-   0        0        0     3113 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/Slength.py
+-rw-rw-rw-   0        0        0     3373 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/__init__.py
+-rw-rw-rw-   0        0        0     1398 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/Trigger.py
+-rw-rw-rw-   0        0        0    11642 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.305629 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/RfSettings/
+-rw-rw-rw-   0        0        0     1251 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/RfSettings/LrStart.py
+-rw-rw-rw-   0        0        0    10953 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/RfSettings/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.307624 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Spectrum/
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.318595 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Spectrum/FreqSweep/
+-rw-rw-rw-   0        0        0     2644 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Spectrum/FreqSweep/Rbw.py
+-rw-rw-rw-   0        0        0     2540 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Spectrum/FreqSweep/Swt.py
+-rw-rw-rw-   0        0        0     2722 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Spectrum/FreqSweep/Vbw.py
+-rw-rw-rw-   0        0        0     1439 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Spectrum/FreqSweep/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.323582 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Spectrum/Frequency/
+-rw-rw-rw-   0        0        0     3127 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Spectrum/Frequency/Span.py
+-rw-rw-rw-   0        0        0     5339 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Spectrum/Frequency/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.358488 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Spectrum/ZeroSpan/
+-rw-rw-rw-   0        0        0     3805 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Spectrum/ZeroSpan/Rbw.py
+-rw-rw-rw-   0        0        0     2686 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Spectrum/ZeroSpan/Vbw.py
+-rw-rw-rw-   0        0        0     2209 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Spectrum/ZeroSpan/__init__.py
+-rw-rw-rw-   0        0        0     7749 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Spectrum/__init__.py
+-rw-rw-rw-   0        0        0     4786 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.361481 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/ExtPwrSensor/
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.367468 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/ExtPwrSensor/State/
+-rw-rw-rw-   0        0        0     2128 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/ExtPwrSensor/State/All.py
+-rw-rw-rw-   0        0        0     2656 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/ExtPwrSensor/State/__init__.py
+-rw-rw-rw-   0        0        0     5990 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/ExtPwrSensor/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.378438 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/FftSpecAn/
+-rw-rw-rw-   0        0        0     1893 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/FftSpecAn/Icomponent.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.385417 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/FftSpecAn/Peaks/
+-rw-rw-rw-   0        0        0     2608 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/FftSpecAn/Peaks/Average.py
+-rw-rw-rw-   0        0        0     2608 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/FftSpecAn/Peaks/Current.py
+-rw-rw-rw-   0        0        0     1269 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/FftSpecAn/Peaks/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.397384 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/FftSpecAn/Power/
+-rw-rw-rw-   0        0        0     2102 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/FftSpecAn/Power/Average.py
+-rw-rw-rw-   0        0        0     2102 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/FftSpecAn/Power/Current.py
+-rw-rw-rw-   0        0        0     2102 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/FftSpecAn/Power/Maximum.py
+-rw-rw-rw-   0        0        0     2102 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/FftSpecAn/Power/Minimum.py
+-rw-rw-rw-   0        0        0     1757 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/FftSpecAn/Power/__init__.py
+-rw-rw-rw-   0        0        0     1893 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/FftSpecAn/Qcomponent.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.402371 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/FftSpecAn/State/
+-rw-rw-rw-   0        0        0     2133 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/FftSpecAn/State/All.py
+-rw-rw-rw-   0        0        0     2661 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/FftSpecAn/State/__init__.py
+-rw-rw-rw-   0        0        0     4710 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/FftSpecAn/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.404366 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Initiate/
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.415336 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Initiate/Ploss/
+-rw-rw-rw-   0        0        0     2287 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Initiate/Ploss/Evaluate.py
+-rw-rw-rw-   0        0        0     2231 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Initiate/Ploss/Open.py
+-rw-rw-rw-   0        0        0     2245 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Initiate/Ploss/Short.py
+-rw-rw-rw-   0        0        0     1481 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Initiate/Ploss/__init__.py
+-rw-rw-rw-   0        0        0     1022 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Initiate/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.430297 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/IqRecorder/
+-rw-rw-rw-   0        0        0     1497 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/IqRecorder/Bin.py
+-rw-rw-rw-   0        0        0      931 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/IqRecorder/Reliability.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.436281 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/IqRecorder/State/
+-rw-rw-rw-   0        0        0     2130 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/IqRecorder/State/All.py
+-rw-rw-rw-   0        0        0     2658 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/IqRecorder/State/__init__.py
+-rw-rw-rw-   0        0        0      894 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/IqRecorder/SymbolRate.py
+-rw-rw-rw-   0        0        0     1690 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/IqRecorder/Talignment.py
+-rw-rw-rw-   0        0        0     7318 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/IqRecorder/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.453235 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/IqVsSlot/
+-rw-rw-rw-   0        0        0     1858 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/IqVsSlot/FreqError.py
+-rw-rw-rw-   0        0        0     1795 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/IqVsSlot/Icomponent.py
+-rw-rw-rw-   0        0        0     1776 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/IqVsSlot/Level.py
+-rw-rw-rw-   0        0        0     3128 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/IqVsSlot/OfError.py
+-rw-rw-rw-   0        0        0     1776 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/IqVsSlot/Phase.py
+-rw-rw-rw-   0        0        0     1795 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/IqVsSlot/Qcomponent.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.458222 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/IqVsSlot/State/
+-rw-rw-rw-   0        0        0     2122 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/IqVsSlot/State/All.py
+-rw-rw-rw-   0        0        0     2650 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/IqVsSlot/State/__init__.py
+-rw-rw-rw-   0        0        0     5176 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/IqVsSlot/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.460219 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Nrpm/
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.465204 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Nrpm/Sensor/
+-rw-rw-rw-   0        0        0     4255 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Nrpm/Sensor/Power.py
+-rw-rw-rw-   0        0        0     1847 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Nrpm/Sensor/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.469192 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Nrpm/State/
+-rw-rw-rw-   0        0        0     1770 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Nrpm/State/All.py
+-rw-rw-rw-   0        0        0     2334 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Nrpm/State/__init__.py
+-rw-rw-rw-   0        0        0     2302 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Nrpm/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.478168 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Ploss/
+-rw-rw-rw-   0        0        0     1202 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Ploss/Clear.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.488142 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Ploss/Eval/
+-rw-rw-rw-   0        0        0     1661 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Ploss/Eval/Frequency.py
+-rw-rw-rw-   0        0        0     1626 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Ploss/Eval/Gain.py
+-rw-rw-rw-   0        0        0     2396 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Ploss/Eval/State.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.497118 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Ploss/Eval/Trace/
+-rw-rw-rw-   0        0        0     1686 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Ploss/Eval/Trace/Frequency.py
+-rw-rw-rw-   0        0        0     1651 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Ploss/Eval/Trace/Gain.py
+-rw-rw-rw-   0        0        0     1263 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Ploss/Eval/Trace/__init__.py
+-rw-rw-rw-   0        0        0     1712 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Ploss/Eval/__init__.py
+-rw-rw-rw-   0        0        0     1707 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Ploss/Open.py
+-rw-rw-rw-   0        0        0     1714 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Ploss/Short.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.501108 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Ploss/State/
+-rw-rw-rw-   0        0        0     1773 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Ploss/State/All.py
+-rw-rw-rw-   0        0        0     2337 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Ploss/State/__init__.py
+-rw-rw-rw-   0        0        0     2610 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Ploss/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.512079 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/
+-rw-rw-rw-   0        0        0     1180 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/AmplitudeProbDensity.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.517065 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Average/
+-rw-rw-rw-   0        0        0     1656 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Average/Rms.py
+-rw-rw-rw-   0        0        0     4843 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Average/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.526042 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/CumulativeDistribFnc/
+-rw-rw-rw-   0        0        0     1779 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/CumulativeDistribFnc/Power.py
+-rw-rw-rw-   0        0        0     1369 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/CumulativeDistribFnc/Probability.py
+-rw-rw-rw-   0        0        0     1490 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/CumulativeDistribFnc/Sample.py
+-rw-rw-rw-   0        0        0     2350 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/CumulativeDistribFnc/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.535018 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Current/
+-rw-rw-rw-   0        0        0     1692 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Current/Maximum.py
+-rw-rw-rw-   0        0        0     1692 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Current/Minimum.py
+-rw-rw-rw-   0        0        0     1656 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Current/Rms.py
+-rw-rw-rw-   0        0        0     5331 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Current/__init__.py
+-rw-rw-rw-   0        0        0     1209 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/ElapsedStats.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.540004 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/IqData/
+-rw-rw-rw-   0        0        0     1528 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/IqData/Bin.py
+-rw-rw-rw-   0        0        0     3034 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/IqData/__init__.py
+-rw-rw-rw-   0        0        0     1967 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/IqInfo.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.549978 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/ListPy/
+-rw-rw-rw-   0        0        0     4483 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/ListPy/Average.py
+-rw-rw-rw-   0        0        0     4483 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/ListPy/Current.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.554964 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/ListPy/Maximum/
+-rw-rw-rw-   0        0        0     4561 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/ListPy/Maximum/Current.py
+-rw-rw-rw-   0        0        0     1037 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/ListPy/Maximum/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.561948 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/ListPy/Minimum/
+-rw-rw-rw-   0        0        0     4561 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/ListPy/Minimum/Current.py
+-rw-rw-rw-   0        0        0     1037 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/ListPy/Minimum/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.571919 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/ListPy/Peak/
+-rw-rw-rw-   0        0        0     4534 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/ListPy/Peak/Maximum.py
+-rw-rw-rw-   0        0        0     4534 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/ListPy/Peak/Minimum.py
+-rw-rw-rw-   0        0        0     1266 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/ListPy/Peak/__init__.py
+-rw-rw-rw-   0        0        0     4525 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/ListPy/StandardDev.py
+-rw-rw-rw-   0        0        0     2259 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/ListPy/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.580894 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Maximum/
+-rw-rw-rw-   0        0        0     4306 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Maximum/Current.py
+-rw-rw-rw-   0        0        0     1692 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Maximum/Maximum.py
+-rw-rw-rw-   0        0        0     1279 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Maximum/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.587876 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Minimum/
+-rw-rw-rw-   0        0        0     4306 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Minimum/Current.py
+-rw-rw-rw-   0        0        0     1692 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Minimum/Minimum.py
+-rw-rw-rw-   0        0        0     1279 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Minimum/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.596852 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Peak/
+-rw-rw-rw-   0        0        0     4279 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Peak/Maximum.py
+-rw-rw-rw-   0        0        0     4279 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Peak/Minimum.py
+-rw-rw-rw-   0        0        0     1264 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Peak/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.600841 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/StandardDev/
+-rw-rw-rw-   0        0        0     1712 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/StandardDev/Current.py
+-rw-rw-rw-   0        0        0     4925 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/StandardDev/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.606826 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/State/
+-rw-rw-rw-   0        0        0     2115 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/State/All.py
+-rw-rw-rw-   0        0        0     2643 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/State/__init__.py
+-rw-rw-rw-   0        0        0     6805 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.609818 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Route/
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.622784 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Route/Scenario/
+-rw-rw-rw-   0        0        0     1130 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Route/Scenario/Catalog.py
+-rw-rw-rw-   0        0        0     1241 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Route/Scenario/MaProtocol.py
+-rw-rw-rw-   0        0        0     2249 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Route/Scenario/Maiq.py
+-rw-rw-rw-   0        0        0     2605 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Route/Scenario/Salone.py
+-rw-rw-rw-   0        0        0     3801 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Route/Scenario/__init__.py
+-rw-rw-rw-   0        0        0     2579 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Route/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.624779 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.637744 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Average/
+-rw-rw-rw-   0        0        0     1942 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Average/Average.py
+-rw-rw-rw-   0        0        0     1942 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Average/Current.py
+-rw-rw-rw-   0        0        0     1942 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Average/Maximum.py
+-rw-rw-rw-   0        0        0     1942 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Average/Minimum.py
+-rw-rw-rw-   0        0        0     1767 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Average/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.641733 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Marker/
+-rw-rw-rw-   0        0        0     2618 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Marker/Npeak.py
+-rw-rw-rw-   0        0        0     1847 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Marker/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.653700 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Maximum/
+-rw-rw-rw-   0        0        0     1956 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Maximum/Average.py
+-rw-rw-rw-   0        0        0     1956 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Maximum/Current.py
+-rw-rw-rw-   0        0        0     1956 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Maximum/Maximum.py
+-rw-rw-rw-   0        0        0     1956 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Maximum/Minimum.py
+-rw-rw-rw-   0        0        0     1767 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Maximum/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.665670 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Minimum/
+-rw-rw-rw-   0        0        0     1956 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Minimum/Average.py
+-rw-rw-rw-   0        0        0     1956 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Minimum/Current.py
+-rw-rw-rw-   0        0        0     1956 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Minimum/Maximum.py
+-rw-rw-rw-   0        0        0     1956 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Minimum/Minimum.py
+-rw-rw-rw-   0        0        0     1767 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Minimum/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.673648 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/ReferenceMarker/
+-rw-rw-rw-   0        0        0     2332 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/ReferenceMarker/Npeak.py
+-rw-rw-rw-   0        0        0     2281 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/ReferenceMarker/Speak.py
+-rw-rw-rw-   0        0        0     1287 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/ReferenceMarker/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.686612 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Rms/
+-rw-rw-rw-   0        0        0     1910 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Rms/Average.py
+-rw-rw-rw-   0        0        0     1910 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Rms/Current.py
+-rw-rw-rw-   0        0        0     1910 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Rms/Maximum.py
+-rw-rw-rw-   0        0        0     1910 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Rms/Minimum.py
+-rw-rw-rw-   0        0        0     1747 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Rms/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.700575 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Sample/
+-rw-rw-rw-   0        0        0     1934 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Sample/Average.py
+-rw-rw-rw-   0        0        0     1934 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Sample/Current.py
+-rw-rw-rw-   0        0        0     1934 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Sample/Maximum.py
+-rw-rw-rw-   0        0        0     1934 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Sample/Minimum.py
+-rw-rw-rw-   0        0        0     1762 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Sample/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.705563 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/State/
+-rw-rw-rw-   0        0        0     2124 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/State/All.py
+-rw-rw-rw-   0        0        0     2652 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/State/__init__.py
+-rw-rw-rw-   0        0        0     5410 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.707558 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.715535 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/FftSpecAn/
+-rw-rw-rw-   0        0        0     1033 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/FftSpecAn/Catalog.py
+-rw-rw-rw-   0        0        0     2372 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/FftSpecAn/OsStop.py
+-rw-rw-rw-   0        0        0     9580 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/FftSpecAn/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.719524 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/IqRecorder/
+-rw-rw-rw-   0        0        0     1031 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/IqRecorder/Catalog.py
+-rw-rw-rw-   0        0        0    10576 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/IqRecorder/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.723515 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/IqVsSlot/
+-rw-rw-rw-   0        0        0     1021 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/IqVsSlot/Catalog.py
+-rw-rw-rw-   0        0        0     9447 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/IqVsSlot/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.729499 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/Power/
+-rw-rw-rw-   0        0        0     1011 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/Power/Catalog.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.734485 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/Power/ParameterSetList/
+-rw-rw-rw-   0        0        0     2973 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/Power/ParameterSetList/Offset.py
+-rw-rw-rw-   0        0        0     1074 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/Power/ParameterSetList/__init__.py
+-rw-rw-rw-   0        0        0     9714 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/Power/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.739472 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/Spectrum/
+-rw-rw-rw-   0        0        0     1023 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/Spectrum/Catalog.py
+-rw-rw-rw-   0        0        0     8329 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/Spectrum/__init__.py
+-rw-rw-rw-   0        0        0     2050 2024-04-16 12:53:51.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/__init__.py
+-rw-rw-rw-   0        0        0        0 2019-11-18 07:28:01.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.823248 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/
+-rw-rw-rw-   0        0        0      586 2024-02-28 16:27:53.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/ArgLinkedEventArgs.py
+-rw-rw-rw-   0        0        0     4165 2024-02-28 16:27:53.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/ArgSingle.py
+-rw-rw-rw-   0        0        0     1116 2024-02-28 16:27:53.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/ArgSingleList.py
+-rw-rw-rw-   0        0        0     1145 2024-02-28 16:27:53.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/ArgSingleSuppressed.py
+-rw-rw-rw-   0        0        0     9097 2024-02-28 16:27:53.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/ArgStringComposer.py
+-rw-rw-rw-   0        0        0     5751 2024-02-28 16:27:53.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/ArgStruct.py
+-rw-rw-rw-   0        0        0     3439 2024-02-28 16:27:53.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/ArgStructList.py
+-rw-rw-rw-   0        0        0     2546 2024-02-28 16:27:53.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/ArgStructStringParser.py
+-rw-rw-rw-   0        0        0     5238 2024-02-28 16:27:53.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/CommandsGroup.py
+-rw-rw-rw-   0        0        0    25419 2024-04-03 11:15:31.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/Conversions.py
+-rw-rw-rw-   0        0        0     3775 2024-02-28 16:27:53.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/ConverterFromScpiString.py
+-rw-rw-rw-   0        0        0     4768 2024-02-28 16:27:53.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/ConverterToScpiString.py
+-rw-rw-rw-   0        0        0    14213 2024-04-03 11:15:31.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/Core.py
+-rw-rw-rw-   0        0        0     1386 2024-02-28 16:27:53.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/GlobalData.py
+-rw-rw-rw-   0        0        0    60862 2024-04-03 11:15:31.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/Instrument.py
+-rw-rw-rw-   0        0        0     4785 2024-02-28 16:27:53.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/InstrumentErrors.py
+-rw-rw-rw-   0        0        0     2225 2024-02-28 16:27:53.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/InstrumentOptions.py
+-rw-rw-rw-   0        0        0    16156 2024-04-03 11:15:31.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/InstrumentSettings.py
+-rw-rw-rw-   0        0        0     3518 2024-02-28 16:27:53.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/InternalLinker.py
+-rw-rw-rw-   0        0        0     4390 2024-02-28 16:27:53.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/IoTransferEventArgs.py
+-rw-rw-rw-   0        0        0      387 2024-02-28 16:27:53.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/Properties.py
+-rw-rw-rw-   0        0        0     4289 2024-02-28 16:27:53.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/RepeatedCapability.py
+-rw-rw-rw-   0        0        0     4745 2024-02-28 16:27:53.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/ScpiEnums.py
+-rw-rw-rw-   0        0        0    35525 2024-02-28 16:27:53.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/ScpiLogger.py
+-rw-rw-rw-   0        0        0     5098 2024-02-28 16:27:53.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/StreamReader.py
+-rw-rw-rw-   0        0        0     5856 2024-02-28 16:27:53.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/StreamWriter.py
+-rw-rw-rw-   0        0        0     1114 2024-02-28 16:27:53.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/StructBase.py
+-rw-rw-rw-   0        0        0     3608 2024-02-28 16:27:53.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/Types.py
+-rw-rw-rw-   0        0        0     5498 2024-02-28 16:27:53.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/Utilities.py
+-rw-rw-rw-   0        0        0     5716 2024-02-28 16:27:53.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/VisaPluginSocketIo.py
+-rw-rw-rw-   0        0        0    51976 2024-04-03 11:15:31.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/VisaSession.py
+-rw-rw-rw-   0        0        0     7512 2024-02-28 16:27:53.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/VisaSessionSim.py
+-rw-rw-rw-   0        0        0       29 2024-02-28 16:27:53.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/__init__.py
+-rw-rw-rw-   0        0        0    15501 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/RsCmwGprfMeas.py
+-rw-rw-rw-   0        0        0      923 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/__init__.py
+-rw-rw-rw-   0        0        0     8012 2024-04-16 12:53:50.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/enums.py
+-rw-rw-rw-   0        0        0     1095 2024-04-16 12:53:49.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/repcap.py
+drwxrwxrwx   0        0        0        0 2024-04-16 12:53:55.097186 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas.egg-info/
+-rw-rw-rw-   0        0        0     4362 2024-04-16 12:53:54.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas.egg-info/PKG-INFO
+-rw-rw-rw-   0        0        0    15476 2024-04-16 12:53:54.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas.egg-info/SOURCES.txt
+-rw-rw-rw-   0        0        0        1 2024-04-16 12:53:54.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas.egg-info/dependency_links.txt
+-rw-rw-rw-   0        0        0       15 2024-04-16 12:53:54.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas.egg-info/requires.txt
+-rw-rw-rw-   0        0        0       14 2024-04-16 12:53:54.000000 RsCmwGprfMeas-4.0.140/RsCmwGprfMeas.egg-info/top_level.txt
+-rw-rw-rw-   0        0        0       42 2024-04-16 12:53:55.827238 RsCmwGprfMeas-4.0.140/setup.cfg
+-rw-rw-rw-   0        0        0     1478 2024-04-16 12:53:52.000000 RsCmwGprfMeas-4.0.140/setup.py
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/CustomFiles/events.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/CustomFiles/events.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,79 +1,89 @@
-from typing import Callable
-
-from ..Internal import Core
-
-
-class Events:
-	"""Common Events class.
-	Event-related methods common for all types of drivers."""
-	def __init__(self, core: Core):
-		self._core = core
-
-	@property
-	def io_events_include_data(self) -> bool:
-		"""Returns the current state of the io_events_include_data See the setter for more details."""
-		return self._core.io.io_events_include_data
-
-	@io_events_include_data.setter
-	def io_events_include_data(self, value: bool) -> None:
-		"""If True, the on_write and on_read events include also the sent/received data.
-		Default value is False, to avoid handling potentially big data."""
-		self._core.io.io_events_include_data = value
-
-	@property
-	def before_write_handler(self) -> Callable:
-		"""Returns the handler of before_write events. \n
-		:return: current before_write_handler"""
-		return self._core.io.before_write_handler
-
-	@before_write_handler.setter
-	def before_write_handler(self, handler: Callable) -> None:
-		"""Sets handler for before_write events.
-		The before_write event is invoked before each write operation (only once, not for every chunk)
-		Event prototype: handler(io: Instrument, cmd: str)
-		:param handler: new handler"""
-		self._core.io.before_write_handler = handler
-
-	@property
-	def on_write_handler(self) -> Callable:
-		"""Returns the handler of on_write events. \n
-		:return: current on_write_handler"""
-		return self._core.io.on_write_handler
-
-	@on_write_handler.setter
-	def on_write_handler(self, handler: Callable) -> None:
-		"""Sets handler for on_write events.
-		The on_write event is invoked every time the driver performs a write operation to the instrument (for each write chunk)
-		Event arguments type: IoTransferEventArgs
-		By default, the event_args do not contain the actual data sent. If you wish to receive them, set the driver.Events.io_events_include_data to True \n
-		:param handler: new handler for all write operations"""
-		self._core.io.on_write_handler = handler
-
-	@property
-	def on_read_handler(self) -> Callable:
-		"""Returns the handler of on_read events. \n
-		:return: current on_read_handler"""
-		return self._core.io.on_read_handler
-
-	@on_read_handler.setter
-	def on_read_handler(self, handler: Callable) -> None:
-		"""Sets handler for on_read events.
-		The on_read event is invoked every time the driver performs a read operation to the instrument.
-		Event arguments type: IoTransferEventArgs
-		By default, the event_args do not contain the actual data sent. If you wish to receive them, set the driver.Events.io_events_include_data to True \n
-		:param handler: new handler for all read operations"""
-		self._core.io.on_read_handler = handler
-
-	@property
-	def before_query_handler(self) -> Callable:
-		"""Returns the handler of before_query events. \n
-		:return: current before_query_handler"""
-		return self._core.io.before_query_handler
-
-	@before_query_handler.setter
-	def before_query_handler(self, handler: Callable) -> None:
-		"""Sets handler for before_query events.
-		The before_query event is invoked before each query operation (only once, not for every chunk)
-		Event prototype: handler(io: Instrument, query: str)
-		:param handler: new handler"""
-		self._core.io.before_query_handler = handler
+"""Event-related methods and properties. Here you can set all the event handlers."""
+
+from typing import Callable
+
+from ..Internal import Core
+
+
+class Events:
+	"""Common Events class.
+	Event-related methods and properties. Here you can set all the event handlers."""
+	def __init__(self, core: Core):
+		self._core = core
+
+	@property
+	def io_events_include_data(self) -> bool:
+		"""Returns the current state of the io_events_include_data See the setter for more details."""
+		return self._core.io.io_events_include_data
+
+	@io_events_include_data.setter
+	def io_events_include_data(self, value: bool) -> None:
+		"""If True, the on_write and on_read events include also the transferred data.
+		Default value is False, to avoid handling potentially big data."""
+		self._core.io.io_events_include_data = value
+
+	@property
+	def before_write_handler(self) -> Callable:
+		"""Returns the handler of before_write events. \n
+		:return: current ``before_write_handler``"""
+		return self._core.io.before_write_handler
+
+	@before_write_handler.setter
+	def before_write_handler(self, handler: Callable) -> None:
+		"""Sets handler for before_write events.
+		The before_write event is invoked before each write operation (only once, not for every chunk)
+		Event prototype: handler(io: Instrument, cmd: str)
+		:param handler: new handler"""
+		self._core.io.before_write_handler = handler
+
+	@property
+	def on_write_handler(self) -> Callable:
+		"""Returns the handler of on_write events. \n
+		:return: current ``on_write_handler``"""
+		return self._core.io.on_write_handler
+
+	@on_write_handler.setter
+	def on_write_handler(self, handler: Callable) -> None:
+		"""Sets handler for on_write events.
+		The on_write event is invoked every time the driver performs a write operation to the instrument (for each write chunk)
+		Event arguments type: IoTransferEventArgs
+		By default, the event_args do not contain the actual data sent. If you wish to receive them, set the driver.Events.io_events_include_data to True \n
+		:param handler: new handler for all write operations"""
+		self._core.io.on_write_handler = handler
+
+	@property
+	def on_read_handler(self) -> Callable:
+		"""Returns the handler of on_read events. \n
+		:return: current ``on_read_handler``"""
+		return self._core.io.on_read_handler
+
+	@on_read_handler.setter
+	def on_read_handler(self, handler: Callable) -> None:
+		"""Sets handler for on_read events.
+		The on_read event is invoked every time the driver performs a read operation to the instrument.
+		Event arguments type: IoTransferEventArgs
+		By default, the event_args do not contain the actual data sent. If you wish to receive them, set the driver.Events.io_events_include_data to True \n
+		:param handler: new handler for all read operations"""
+		self._core.io.on_read_handler = handler
+
+	@property
+	def before_query_handler(self) -> Callable:
+		"""Returns the handler of before_query events. \n
+		:return: current ``before_query_handler``"""
+		return self._core.io.before_query_handler
+
+	@before_query_handler.setter
+	def before_query_handler(self, handler: Callable) -> None:
+		"""Sets handler for before_query events.
+		The before_query event is invoked before each query operation (only once, not for every chunk)
+		Event prototype: handler(io: Instrument, query: str)
+		:param handler: new handler"""
+		self._core.io.before_query_handler = handler
+
+	def sync_from(self, source: 'Events') -> None:
+		"""Synchronises these Events with the source."""
+		self.before_query_handler = source.before_query_handler
+		self.before_write_handler = source.before_write_handler
+		self.io_events_include_data = source.io_events_include_data
+		self.on_read_handler = source.on_read_handler
+		self.on_write_handler = source.on_write_handler
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/CustomFiles/reliability.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/CustomFiles/reliability.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,7 +1,10 @@
+"""Class for R&S Mobile Radio Test instruments that use reliability indicators."""
+
+
 import time
 from typing import Callable
 
 from ..Internal import ArgLinkedEventArgs
 from ..Internal import Core
 
 codes_table = {
@@ -60,25 +63,25 @@
 		self.context = context
 
 
 class Reliability:
 	"""Reliability class that handles all the necessary tasks related to reliability indicator."""
 
 	def __init__(self, core: Core):
-		self._core = core
-		self._last_value = 0
-		self._last_context = ''
+		self._core: Core = core
+		self._last_value: int = 0
+		self._last_context: str = ''
 		self._last_timestamp = None
 		self._exception_on_error = False
 		# noinspection PyTypeChecker
 		self._on_update_handler: Callable = None
 		self._core.set_link_handler('Reliability', self._permanent_on_update_handler)
 
 	@property
-	def last_value(self):
+	def last_value(self) -> int:
 		"""Returns the last updated Reliability code."""
 		return self._last_value
 
 	@property
 	def last_context(self) -> str:
 		"""Returns the last updated Context of the reliability code - usually the SCPI query on which the instrument responded with the Reliability code."""
 		return self._last_context
@@ -94,36 +97,39 @@
 		if self._last_value in codes_table:
 			return codes_table[self._last_value]
 		else:
 			return f'Undefined reliability code {self._last_value}.'
 
 	@property
 	def exception_on_error(self) -> bool:
-		"""see the exception_on_error.setter."""
+		"""If True, (default is False) the object throws an exception if the updated reliability is not 0 (non-OK)."""
 		return self._exception_on_error
 
 	@exception_on_error.setter
 	def exception_on_error(self, value) -> None:
 		"""If True, (default is False) the object throws an exception if the updated reliability is not 0 (non-OK)."""
 		self._exception_on_error = value
 
 	def on_update_handler(self, handler: Callable) -> None:
 		"""Register the handler for on_update event.
 		This handler is invoked with each update of the reliability indicator.
 		Handler API: handler(event_args: ReliabilityEventArgs)"""
 		self._on_update_handler = handler
 
-	def _permanent_on_update_handler(self, event_args: ArgLinkedEventArgs):
+	def _permanent_on_update_handler(self, event_args: ArgLinkedEventArgs) -> None:
 		"""Permanent on_update handler. Takes care of updating all the 'last_xxx' values and calling a user-defined updated_handler."""
 		self._last_value = int(str(event_args.value))
 		self._last_context = event_args.context
 		self._last_timestamp = event_args.timestamp
-
 		if self._on_update_handler:
 			# Call the additional handler if registered
 			rel_events_args = ReliabilityEventArgs(self._last_timestamp, self._last_value, self.last_message, self._last_context)
 			self._on_update_handler(rel_events_args)
-
 		if self._exception_on_error and self._last_value != 0:
 			raise Exception(
 				f'Reliability indicator error. Time: {time.strftime("%H:%M:%S", time.localtime(self._last_timestamp))}, '
 				f'Context: {self._last_context}, Value {self._last_value}: {self.last_message}')
+
+	def sync_from(self, source: 'Reliability') -> None:
+		"""Synchronises this Reliability with the source."""
+		self.exception_on_error = source.exception_on_error
+		self.on_update_handler(source._on_update_handler)
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Calibration.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Calibration/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ..Internal.Core import Core
-from ..Internal.CommandsGroup import CommandsGroup
+from ...Internal.Core import Core
+from ...Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Calibration:
-	"""Calibration commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class CalibrationCls:
+	"""Calibration commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("calibration", core, parent)
+		self._cmd_group = CommandsGroup("calibration", core, parent)
 
 	@property
 	def extPwrSensor(self):
 		"""extPwrSensor commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_extPwrSensor'):
-			from .Calibration_.ExtPwrSensor import ExtPwrSensor
-			self._extPwrSensor = ExtPwrSensor(self._core, self._base)
+			from .ExtPwrSensor import ExtPwrSensorCls
+			self._extPwrSensor = ExtPwrSensorCls(self._core, self._cmd_group)
 		return self._extPwrSensor
 
-	def clone(self) -> 'Calibration':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CalibrationCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Calibration(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CalibrationCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Calibration_/ExtPwrSensor.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Calibration/ExtPwrSensor/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ExtPwrSensor:
-	"""ExtPwrSensor commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class ExtPwrSensorCls:
+	"""ExtPwrSensor commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extPwrSensor", core, parent)
+		self._cmd_group = CommandsGroup("extPwrSensor", core, parent)
 
 	@property
 	def zero(self):
 		"""zero commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_zero'):
-			from .ExtPwrSensor_.Zero import Zero
-			self._zero = Zero(self._core, self._base)
+			from .Zero import ZeroCls
+			self._zero = ZeroCls(self._core, self._cmd_group)
 		return self._zero
 
-	def clone(self) -> 'ExtPwrSensor':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ExtPwrSensorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ExtPwrSensor(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ExtPwrSensorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Calibration_/ExtPwrSensor_/Zero.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Calibration/ExtPwrSensor/Zero.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,39 +3,39 @@
 from ....Internal import Conversions
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Zero:
-	"""Zero commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ZeroCls:
+	"""Zero commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("zero", core, parent)
+		self._cmd_group = CommandsGroup("zero", core, parent)
 
 	def set(self) -> None:
 		"""SCPI: CALibration:GPRF:MEASurement<Instance>:EPSensor:ZERO \n
 		Snippet: driver.calibration.extPwrSensor.zero.set() \n
 		Initiates zeroing of the power sensor or reads the zeroing state. A running external power sensor measurement is
 		interrupted and restarted after the zeroing procedure has been completed. Zeroing takes a few seconds (3 to 10) . \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
 		"""
 		self._core.io.write(f'CALibration:GPRF:MEASurement<Instance>:EPSensor:ZERO')
 
-	def set_with_opc(self) -> None:
+	def set_with_opc(self, opc_timeout_ms: int = -1) -> None:
 		"""SCPI: CALibration:GPRF:MEASurement<Instance>:EPSensor:ZERO \n
 		Snippet: driver.calibration.extPwrSensor.zero.set_with_opc() \n
 		Initiates zeroing of the power sensor or reads the zeroing state. A running external power sensor measurement is
 		interrupted and restarted after the zeroing procedure has been completed. Zeroing takes a few seconds (3 to 10) . \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
 		Same as set, but waits for the operation to complete before continuing further. Use the RsCmwGprfMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'CALibration:GPRF:MEASurement<Instance>:EPSensor:ZERO')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'CALibration:GPRF:MEASurement<Instance>:EPSensor:ZERO', opc_timeout_ms)
 
 	# noinspection PyTypeChecker
 	def get(self) -> enums.ZeroingState:
 		"""SCPI: CALibration:GPRF:MEASurement<Instance>:EPSensor:ZERO \n
 		Snippet: value: enums.ZeroingState = driver.calibration.extPwrSensor.zero.get() \n
 		Initiates zeroing of the power sensor or reads the zeroing state. A running external power sensor measurement is
 		interrupted and restarted after the zeroing procedure has been completed. Zeroing takes a few seconds (3 to 10) . \n
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,93 +1,101 @@
-from ..Internal.Core import Core
-from ..Internal.CommandsGroup import CommandsGroup
-from ..Internal import Conversions
-from .. import enums
+from ...Internal.Core import Core
+from ...Internal.CommandsGroup import CommandsGroup
+from ...Internal import Conversions
+from ... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Configure:
-	"""Configure commands group definition. 144 total commands, 9 Sub-groups, 1 group commands"""
+class ConfigureCls:
+	"""Configure commands group definition. 152 total commands, 10 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("configure", core, parent)
+		self._cmd_group = CommandsGroup("configure", core, parent)
 
 	@property
 	def rfSettings(self):
-		"""rfSettings commands group. 0 Sub-classes, 6 commands."""
+		"""rfSettings commands group. 1 Sub-classes, 7 commands."""
 		if not hasattr(self, '_rfSettings'):
-			from .Configure_.RfSettings import RfSettings
-			self._rfSettings = RfSettings(self._core, self._base)
+			from .RfSettings import RfSettingsCls
+			self._rfSettings = RfSettingsCls(self._core, self._cmd_group)
 		return self._rfSettings
 
 	@property
 	def power(self):
 		"""power commands group. 5 Sub-classes, 7 commands."""
 		if not hasattr(self, '_power'):
-			from .Configure_.Power import Power
-			self._power = Power(self._core, self._base)
+			from .Power import PowerCls
+			self._power = PowerCls(self._core, self._cmd_group)
 		return self._power
 
 	@property
 	def iqVsSlot(self):
 		"""iqVsSlot commands group. 2 Sub-classes, 7 commands."""
 		if not hasattr(self, '_iqVsSlot'):
-			from .Configure_.IqVsSlot import IqVsSlot
-			self._iqVsSlot = IqVsSlot(self._core, self._base)
+			from .IqVsSlot import IqVsSlotCls
+			self._iqVsSlot = IqVsSlotCls(self._core, self._cmd_group)
 		return self._iqVsSlot
 
 	@property
 	def extPwrSensor(self):
 		"""extPwrSensor commands group. 1 Sub-classes, 5 commands."""
 		if not hasattr(self, '_extPwrSensor'):
-			from .Configure_.ExtPwrSensor import ExtPwrSensor
-			self._extPwrSensor = ExtPwrSensor(self._core, self._base)
+			from .ExtPwrSensor import ExtPwrSensorCls
+			self._extPwrSensor = ExtPwrSensorCls(self._core, self._cmd_group)
 		return self._extPwrSensor
 
 	@property
 	def nrpm(self):
 		"""nrpm commands group. 1 Sub-classes, 3 commands."""
 		if not hasattr(self, '_nrpm'):
-			from .Configure_.Nrpm import Nrpm
-			self._nrpm = Nrpm(self._core, self._base)
+			from .Nrpm import NrpmCls
+			self._nrpm = NrpmCls(self._core, self._cmd_group)
 		return self._nrpm
 
 	@property
 	def iqRecorder(self):
-		"""iqRecorder commands group. 3 Sub-classes, 9 commands."""
+		"""iqRecorder commands group. 4 Sub-classes, 8 commands."""
 		if not hasattr(self, '_iqRecorder'):
-			from .Configure_.IqRecorder import IqRecorder
-			self._iqRecorder = IqRecorder(self._core, self._base)
+			from .IqRecorder import IqRecorderCls
+			self._iqRecorder = IqRecorderCls(self._core, self._cmd_group)
 		return self._iqRecorder
 
 	@property
 	def spectrum(self):
 		"""spectrum commands group. 3 Sub-classes, 4 commands."""
 		if not hasattr(self, '_spectrum'):
-			from .Configure_.Spectrum import Spectrum
-			self._spectrum = Spectrum(self._core, self._base)
+			from .Spectrum import SpectrumCls
+			self._spectrum = SpectrumCls(self._core, self._cmd_group)
 		return self._spectrum
 
 	@property
 	def fftSpecAn(self):
 		"""fftSpecAn commands group. 1 Sub-classes, 8 commands."""
 		if not hasattr(self, '_fftSpecAn'):
-			from .Configure_.FftSpecAn import FftSpecAn
-			self._fftSpecAn = FftSpecAn(self._core, self._base)
+			from .FftSpecAn import FftSpecAnCls
+			self._fftSpecAn = FftSpecAnCls(self._core, self._cmd_group)
 		return self._fftSpecAn
 
 	@property
 	def ploss(self):
 		"""ploss commands group. 3 Sub-classes, 1 commands."""
 		if not hasattr(self, '_ploss'):
-			from .Configure_.Ploss import Ploss
-			self._ploss = Ploss(self._core, self._base)
+			from .Ploss import PlossCls
+			self._ploss = PlossCls(self._core, self._cmd_group)
 		return self._ploss
 
+	@property
+	def canalyzer(self):
+		"""canalyzer commands group. 2 Sub-classes, 3 commands."""
+		if not hasattr(self, '_canalyzer'):
+			from .Canalyzer import CanalyzerCls
+			self._canalyzer = CanalyzerCls(self._core, self._cmd_group)
+		return self._canalyzer
+
 	# noinspection PyTypeChecker
 	def get_display(self) -> enums.MeasTab:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:DISPlay \n
 		Snippet: value: enums.MeasTab = driver.configure.get_display() \n
 		Selects the displayed measurement tab. This command is useful, if you want to observe the GUI during remote control. The
 		GUI controls are disabled in that case, so that you cannot select a tab via the GUI. To display the GUI,
 		use SYSTem:DISPlay:UPDate ON. \n
@@ -103,14 +111,14 @@
 		GUI controls are disabled in that case, so that you cannot select a tab via the GUI. To display the GUI,
 		use SYSTem:DISPlay:UPDate ON. \n
 			:param meas_tab: POWer | SPECtrum | FFTSanalyzer | IQRecorder | IQVSlot | EPSensor
 		"""
 		param = Conversions.enum_scalar_to_str(meas_tab, enums.MeasTab)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:DISPlay {param}')
 
-	def clone(self) -> 'Configure':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ConfigureCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Configure(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ConfigureCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/ExtPwrSensor.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/ExtPwrSensor/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,98 +1,94 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ... import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ExtPwrSensor:
-	"""ExtPwrSensor commands group definition. 7 total commands, 1 Sub-groups, 5 group commands"""
+class ExtPwrSensorCls:
+	"""ExtPwrSensor commands group definition. 7 total commands, 1 Subgroups, 5 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("extPwrSensor", core, parent)
+		self._cmd_group = CommandsGroup("extPwrSensor", core, parent)
 
 	@property
 	def attenuation(self):
 		"""attenuation commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_attenuation'):
-			from .ExtPwrSensor_.Attenuation import Attenuation
-			self._attenuation = Attenuation(self._core, self._base)
+			from .Attenuation import AttenuationCls
+			self._attenuation = AttenuationCls(self._core, self._cmd_group)
 		return self._attenuation
 
 	def get_timeout(self) -> float:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:EPSensor:TOUT \n
 		Snippet: value: float = driver.configure.extPwrSensor.get_timeout() \n
 		Defines a timeout for the measurement. The timer is started when the measurement is initiated via a READ or INIT command.
-		It is not started if the measurement is initiated manually ([ON | OFF] key or [RESTART | STOP] key) .
-		When the measurement has completed the first measurement cycle (first single shot) , the statistical depth is reached and
-		the timer is reset. If the first measurement cycle has not been completed when the timer expires, the measurement is
-		stopped. The measurement state changes to RDY. The reliability indicator is set to 1, indicating that a measurement
-		timeout occurred. Still running READ, FETCh or CALCulate commands are completed, returning the available results.
-		At least for some results, there are no values at all or the statistical depth has not been reached. A timeout of 0 s
-		corresponds to an infinite measurement timeout. \n
-			:return: tcd_timeout: Unit: s
+		It is not started if the measurement is initiated manually. When the measurement has completed the first measurement
+		cycle (first single shot) , the statistical depth is reached and the timer is reset. If the first measurement cycle has
+		not been completed when the timer expires, the measurement is stopped. The measurement state changes to RDY.
+		The reliability indicator is set to 1, indicating that a measurement timeout occurred. Still running READ, FETCh or
+		CALCulate commands are completed, returning the available results. At least for some results, there are no values at all
+		or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite measurement timeout. \n
+			:return: tcd_timeout: numeric Unit: s
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:EPSensor:TOUT?')
 		return Conversions.str_to_float(response)
 
 	def set_timeout(self, tcd_timeout: float) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:EPSensor:TOUT \n
 		Snippet: driver.configure.extPwrSensor.set_timeout(tcd_timeout = 1.0) \n
 		Defines a timeout for the measurement. The timer is started when the measurement is initiated via a READ or INIT command.
-		It is not started if the measurement is initiated manually ([ON | OFF] key or [RESTART | STOP] key) .
-		When the measurement has completed the first measurement cycle (first single shot) , the statistical depth is reached and
-		the timer is reset. If the first measurement cycle has not been completed when the timer expires, the measurement is
-		stopped. The measurement state changes to RDY. The reliability indicator is set to 1, indicating that a measurement
-		timeout occurred. Still running READ, FETCh or CALCulate commands are completed, returning the available results.
-		At least for some results, there are no values at all or the statistical depth has not been reached. A timeout of 0 s
-		corresponds to an infinite measurement timeout. \n
-			:param tcd_timeout: Unit: s
+		It is not started if the measurement is initiated manually. When the measurement has completed the first measurement
+		cycle (first single shot) , the statistical depth is reached and the timer is reset. If the first measurement cycle has
+		not been completed when the timer expires, the measurement is stopped. The measurement state changes to RDY.
+		The reliability indicator is set to 1, indicating that a measurement timeout occurred. Still running READ, FETCh or
+		CALCulate commands are completed, returning the available results. At least for some results, there are no values at all
+		or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite measurement timeout. \n
+			:param tcd_timeout: numeric Unit: s
 		"""
 		param = Conversions.decimal_value_to_str(tcd_timeout)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:EPSensor:TOUT {param}')
 
 	# noinspection PyTypeChecker
 	def get_resolution(self) -> enums.PwrSensorResolution:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:EPSensor:RESolution \n
 		Snippet: value: enums.PwrSensorResolution = driver.configure.extPwrSensor.get_resolution() \n
-		Defines the number of digits of the power results in the measurement dialog. This command does not affect the remote
-		control results. \n
+		Defines the number of digits of the displayed power results. This command does not affect the remote control results. \n
 			:return: resolution: PD0 | PD1 | PD2 | PD3 PD0: 1 (results rounded to 1 dB) PD1: 0.1 PD2: 0.01 PD3: 0.001
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:EPSensor:RESolution?')
 		return Conversions.str_to_scalar_enum(response, enums.PwrSensorResolution)
 
 	def set_resolution(self, resolution: enums.PwrSensorResolution) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:EPSensor:RESolution \n
 		Snippet: driver.configure.extPwrSensor.set_resolution(resolution = enums.PwrSensorResolution.PD0) \n
-		Defines the number of digits of the power results in the measurement dialog. This command does not affect the remote
-		control results. \n
+		Defines the number of digits of the displayed power results. This command does not affect the remote control results. \n
 			:param resolution: PD0 | PD1 | PD2 | PD3 PD0: 1 (results rounded to 1 dB) PD1: 0.1 PD2: 0.01 PD3: 0.001
 		"""
 		param = Conversions.enum_scalar_to_str(resolution, enums.PwrSensorResolution)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:EPSensor:RESolution {param}')
 
 	def get_scount(self) -> int:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:EPSensor:SCOunt \n
 		Snippet: value: int = driver.configure.extPwrSensor.get_scount() \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. \n
-			:return: statistic_count: Number of measurement intervals, i.e. the number of measured power values from the external sensor. Range: 1 to 1000
+			:return: statistic_count: numeric Number of measurement intervals Range: 1 to 1000
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:EPSensor:SCOunt?')
 		return Conversions.str_to_int(response)
 
 	def set_scount(self, statistic_count: int) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:EPSensor:SCOunt \n
 		Snippet: driver.configure.extPwrSensor.set_scount(statistic_count = 1) \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. \n
-			:param statistic_count: Number of measurement intervals, i.e. the number of measured power values from the external sensor. Range: 1 to 1000
+			:param statistic_count: numeric Number of measurement intervals Range: 1 to 1000
 		"""
 		param = Conversions.decimal_value_to_str(statistic_count)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:EPSensor:SCOunt {param}')
 
 	# noinspection PyTypeChecker
 	def get_repetition(self) -> enums.Repeat:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:EPSensor:REPetition \n
@@ -116,28 +112,28 @@
 		param = Conversions.enum_scalar_to_str(repetition, enums.Repeat)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:EPSensor:REPetition {param}')
 
 	def get_frequency(self) -> float:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:EPSensor:FREQuency \n
 		Snippet: value: float = driver.configure.extPwrSensor.get_frequency() \n
 		Specifies the input frequency at the power sensor. \n
-			:return: correction_freq: Range: Depending on sensor model used , Unit: Hz
+			:return: correction_freq: numeric Range: Depends on sensor model , Unit: Hz
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:EPSensor:FREQuency?')
 		return Conversions.str_to_float(response)
 
 	def set_frequency(self, correction_freq: float) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:EPSensor:FREQuency \n
 		Snippet: driver.configure.extPwrSensor.set_frequency(correction_freq = 1.0) \n
 		Specifies the input frequency at the power sensor. \n
-			:param correction_freq: Range: Depending on sensor model used , Unit: Hz
+			:param correction_freq: numeric Range: Depends on sensor model , Unit: Hz
 		"""
 		param = Conversions.decimal_value_to_str(correction_freq)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:EPSensor:FREQuency {param}')
 
-	def clone(self) -> 'ExtPwrSensor':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ExtPwrSensorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ExtPwrSensor(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ExtPwrSensorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/ExtPwrSensor_/Attenuation.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/ExtPwrSensor/Attenuation.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,48 +1,48 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Attenuation:
-	"""Attenuation commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AttenuationCls:
+	"""Attenuation commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("attenuation", core, parent)
+		self._cmd_group = CommandsGroup("attenuation", core, parent)
 
 	def get_state(self) -> bool:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:EPSensor:ATTenuation:STATe \n
 		Snippet: value: bool = driver.configure.extPwrSensor.attenuation.get_state() \n
-		Enables or disables an external input attenuation at the sensor. \n
+		Enables or disables the result correction for an external input attenuation. \n
 			:return: attenuator_state: OFF | ON
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:EPSensor:ATTenuation:STATe?')
 		return Conversions.str_to_bool(response)
 
 	def set_state(self, attenuator_state: bool) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:EPSensor:ATTenuation:STATe \n
 		Snippet: driver.configure.extPwrSensor.attenuation.set_state(attenuator_state = False) \n
-		Enables or disables an external input attenuation at the sensor. \n
+		Enables or disables the result correction for an external input attenuation. \n
 			:param attenuator_state: OFF | ON
 		"""
 		param = Conversions.bool_to_str(attenuator_state)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:EPSensor:ATTenuation:STATe {param}')
 
 	def get_value(self) -> float:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:EPSensor:ATTenuation \n
 		Snippet: value: float = driver.configure.extPwrSensor.attenuation.get_value() \n
-		Specifies the external input attenuation factor to correct the power reading at the sensor. \n
-			:return: attenuation: Range: -50 dB to 50 dB, Unit: dB
+		Specifies an external input attenuation factor for correction of the power results. \n
+			:return: attenuation: numeric Range: -50 dB to 50 dB, Unit: dB
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:EPSensor:ATTenuation?')
 		return Conversions.str_to_float(response)
 
 	def set_value(self, attenuation: float) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:EPSensor:ATTenuation \n
 		Snippet: driver.configure.extPwrSensor.attenuation.set_value(attenuation = 1.0) \n
-		Specifies the external input attenuation factor to correct the power reading at the sensor. \n
-			:param attenuation: Range: -50 dB to 50 dB, Unit: dB
+		Specifies an external input attenuation factor for correction of the power results. \n
+			:param attenuation: numeric Range: -50 dB to 50 dB, Unit: dB
 		"""
 		param = Conversions.decimal_value_to_str(attenuation)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:EPSensor:ATTenuation {param}')
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/FftSpecAn.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/FftSpecAn/__init__.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,131 +1,129 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ... import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class FftSpecAn:
-	"""FftSpecAn commands group definition. 10 total commands, 1 Sub-groups, 8 group commands"""
+class FftSpecAnCls:
+	"""FftSpecAn commands group definition. 10 total commands, 1 Subgroups, 8 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("fftSpecAn", core, parent)
+		self._cmd_group = CommandsGroup("fftSpecAn", core, parent)
 
 	@property
 	def peakSearch(self):
 		"""peakSearch commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_peakSearch'):
-			from .FftSpecAn_.PeakSearch import PeakSearch
-			self._peakSearch = PeakSearch(self._core, self._base)
+			from .PeakSearch import PeakSearchCls
+			self._peakSearch = PeakSearchCls(self._core, self._cmd_group)
 		return self._peakSearch
 
 	def get_timeout(self) -> float:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:FFTSanalyzer:TOUT \n
 		Snippet: value: float = driver.configure.fftSpecAn.get_timeout() \n
 		Defines a timeout for the measurement. The timer is started when the measurement is initiated via a READ or INIT command.
-		It is not started if the measurement is initiated manually ([ON | OFF] key or [RESTART | STOP] key) .
-		When the measurement has completed the first measurement cycle (first single shot) , the statistical depth is reached and
-		the timer is reset. If the first measurement cycle has not been completed when the timer expires, the measurement is
-		stopped. The measurement state changes to RDY. The reliability indicator is set to 1, indicating that a measurement
-		timeout occurred. Still running READ, FETCh or CALCulate commands are completed, returning the available results.
-		At least for some results, there are no values at all or the statistical depth has not been reached. A timeout of 0 s
-		corresponds to an infinite measurement timeout. \n
-			:return: tcd_timeout: Unit: s
+		It is not started if the measurement is initiated manually. When the measurement has completed the first measurement
+		cycle (first single shot) , the statistical depth is reached and the timer is reset. If the first measurement cycle has
+		not been completed when the timer expires, the measurement is stopped. The measurement state changes to RDY.
+		The reliability indicator is set to 1, indicating that a measurement timeout occurred. Still running READ, FETCh or
+		CALCulate commands are completed, returning the available results. At least for some results, there are no values at all
+		or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite measurement timeout. \n
+			:return: tcd_timeout: numeric Unit: s
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:FFTSanalyzer:TOUT?')
 		return Conversions.str_to_float(response)
 
 	def set_timeout(self, tcd_timeout: float) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:FFTSanalyzer:TOUT \n
 		Snippet: driver.configure.fftSpecAn.set_timeout(tcd_timeout = 1.0) \n
 		Defines a timeout for the measurement. The timer is started when the measurement is initiated via a READ or INIT command.
-		It is not started if the measurement is initiated manually ([ON | OFF] key or [RESTART | STOP] key) .
-		When the measurement has completed the first measurement cycle (first single shot) , the statistical depth is reached and
-		the timer is reset. If the first measurement cycle has not been completed when the timer expires, the measurement is
-		stopped. The measurement state changes to RDY. The reliability indicator is set to 1, indicating that a measurement
-		timeout occurred. Still running READ, FETCh or CALCulate commands are completed, returning the available results.
-		At least for some results, there are no values at all or the statistical depth has not been reached. A timeout of 0 s
-		corresponds to an infinite measurement timeout. \n
-			:param tcd_timeout: Unit: s
+		It is not started if the measurement is initiated manually. When the measurement has completed the first measurement
+		cycle (first single shot) , the statistical depth is reached and the timer is reset. If the first measurement cycle has
+		not been completed when the timer expires, the measurement is stopped. The measurement state changes to RDY.
+		The reliability indicator is set to 1, indicating that a measurement timeout occurred. Still running READ, FETCh or
+		CALCulate commands are completed, returning the available results. At least for some results, there are no values at all
+		or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite measurement timeout. \n
+			:param tcd_timeout: numeric Unit: s
 		"""
 		param = Conversions.decimal_value_to_str(tcd_timeout)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:FFTSanalyzer:TOUT {param}')
 
 	# noinspection PyTypeChecker
 	def get_amode(self) -> enums.AveragingMode:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:FFTSanalyzer:AMODe \n
 		Snippet: value: enums.AveragingMode = driver.configure.fftSpecAn.get_amode() \n
-		Selects the averaging mode for the average FFT trace (see method RsCmwGprfMeas.FftSpecAn.Power.Average.read) . \n
-			:return: averaging_mode: LINear | LOGarithmic LINear: averaging of linear power values LOGarithmic: averaging of logarithmic (displayed) power values
+		Selects the averaging mode for the average spectrum trace. \n
+			:return: averaging_mode: LINear | LOGarithmic LINear: averaging of linear power values LOGarithmic: averaging of logarithmic power values
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:FFTSanalyzer:AMODe?')
 		return Conversions.str_to_scalar_enum(response, enums.AveragingMode)
 
 	def set_amode(self, averaging_mode: enums.AveragingMode) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:FFTSanalyzer:AMODe \n
 		Snippet: driver.configure.fftSpecAn.set_amode(averaging_mode = enums.AveragingMode.LINear) \n
-		Selects the averaging mode for the average FFT trace (see method RsCmwGprfMeas.FftSpecAn.Power.Average.read) . \n
-			:param averaging_mode: LINear | LOGarithmic LINear: averaging of linear power values LOGarithmic: averaging of logarithmic (displayed) power values
+		Selects the averaging mode for the average spectrum trace. \n
+			:param averaging_mode: LINear | LOGarithmic LINear: averaging of linear power values LOGarithmic: averaging of logarithmic power values
 		"""
 		param = Conversions.enum_scalar_to_str(averaging_mode, enums.AveragingMode)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:FFTSanalyzer:AMODe {param}')
 
 	# noinspection PyTypeChecker
 	def get_detector(self) -> enums.DetectorBasic:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:FFTSanalyzer:DETector \n
 		Snippet: value: enums.DetectorBasic = driver.configure.fftSpecAn.get_detector() \n
-		Selects the detector for the display of the FFT trace. \n
-			:return: detector: PEAK | RMS PEAK: Trace points are calculated from peak values of a set of adjacent raw calculated data. RMS: Trace points are calculated from RMS values.
+		Defines how the spectrum diagram is calculated from the frequency domain samples. \n
+			:return: detector: PEAK | RMS PEAK: The peak value of adjacent samples is used. RMS: The RMS value of adjacent samples is used.
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:FFTSanalyzer:DETector?')
 		return Conversions.str_to_scalar_enum(response, enums.DetectorBasic)
 
 	def set_detector(self, detector: enums.DetectorBasic) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:FFTSanalyzer:DETector \n
 		Snippet: driver.configure.fftSpecAn.set_detector(detector = enums.DetectorBasic.PEAK) \n
-		Selects the detector for the display of the FFT trace. \n
-			:param detector: PEAK | RMS PEAK: Trace points are calculated from peak values of a set of adjacent raw calculated data. RMS: Trace points are calculated from RMS values.
+		Defines how the spectrum diagram is calculated from the frequency domain samples. \n
+			:param detector: PEAK | RMS PEAK: The peak value of adjacent samples is used. RMS: The RMS value of adjacent samples is used.
 		"""
 		param = Conversions.enum_scalar_to_str(detector, enums.DetectorBasic)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:FFTSanalyzer:DETector {param}')
 
 	def get_fft_length(self) -> int:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:FFTSanalyzer:FFTLength \n
 		Snippet: value: int = driver.configure.fftSpecAn.get_fft_length() \n
-		Selects the number of samples (FFT length) that the R&S CMW uses for the FFT analysis. \n
-			:return: length: Range: 1024 | 2048 | 4096 | 8192 | 16384 (other values are rounded to the closest possible FFT length)
+		Selects the number of samples recorded per measurement interval. \n
+			:return: length: numeric Only the following values can be configured: 1024, 2048, 4096, 8192, 16384 Other values are rounded to the next allowed value. Range: 1024 to 16384
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:FFTSanalyzer:FFTLength?')
 		return Conversions.str_to_int(response)
 
 	def set_fft_length(self, length: int) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:FFTSanalyzer:FFTLength \n
 		Snippet: driver.configure.fftSpecAn.set_fft_length(length = 1) \n
-		Selects the number of samples (FFT length) that the R&S CMW uses for the FFT analysis. \n
-			:param length: Range: 1024 | 2048 | 4096 | 8192 | 16384 (other values are rounded to the closest possible FFT length)
+		Selects the number of samples recorded per measurement interval. \n
+			:param length: numeric Only the following values can be configured: 1024, 2048, 4096, 8192, 16384 Other values are rounded to the next allowed value. Range: 1024 to 16384
 		"""
 		param = Conversions.decimal_value_to_str(length)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:FFTSanalyzer:FFTLength {param}')
 
 	def get_fspan(self) -> float:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:FFTSanalyzer:FSPan \n
 		Snippet: value: float = driver.configure.fftSpecAn.get_fspan() \n
-		Selects the calculated and displayed frequency range (span) of the FFT spectrum analyzer. \n
-			:return: frequency_span: Range: 1.25 MHz | 2.5 MHz | 5 MHz | 10 MHz | 20 MHz | 40 MHz | 80 MHz | 160 MHz , Unit: Hz
+		Configures the frequency span of the FFT spectrum analyzer. \n
+			:return: frequency_span: numeric Only the following values can be configured, all values in MHz: 1.25, 2.5, 5, 10, 20, 40, 80, 160 Other values are rounded to the next allowed value. Unit: Hz
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:FFTSanalyzer:FSPan?')
 		return Conversions.str_to_float(response)
 
 	def set_fspan(self, frequency_span: float) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:FFTSanalyzer:FSPan \n
 		Snippet: driver.configure.fftSpecAn.set_fspan(frequency_span = 1.0) \n
-		Selects the calculated and displayed frequency range (span) of the FFT spectrum analyzer. \n
-			:param frequency_span: Range: 1.25 MHz | 2.5 MHz | 5 MHz | 10 MHz | 20 MHz | 40 MHz | 80 MHz | 160 MHz , Unit: Hz
+		Configures the frequency span of the FFT spectrum analyzer. \n
+			:param frequency_span: numeric Only the following values can be configured, all values in MHz: 1.25, 2.5, 5, 10, 20, 40, 80, 160 Other values are rounded to the next allowed value. Unit: Hz
 		"""
 		param = Conversions.decimal_value_to_str(frequency_span)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:FFTSanalyzer:FSPan {param}')
 
 	def get_mo_exception(self) -> bool:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:FFTSanalyzer:MOEXception \n
 		Snippet: value: bool = driver.configure.fftSpecAn.get_mo_exception() \n
@@ -168,29 +166,29 @@
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:FFTSanalyzer:REPetition {param}')
 
 	def get_scount(self) -> int:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:FFTSanalyzer:SCOunt \n
 		Snippet: value: int = driver.configure.fftSpecAn.get_scount() \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. \n
-			:return: statistic_count: Number of measurement intervals. A measurement interval comprises a single power/frequency step (list mode switched off) or a sweep (list mode switched on) . Range: 1 to 1000
+			:return: statistic_count: numeric Number of measurement intervals Range: 1 to 1000
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:FFTSanalyzer:SCOunt?')
 		return Conversions.str_to_int(response)
 
 	def set_scount(self, statistic_count: int) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:FFTSanalyzer:SCOunt \n
 		Snippet: driver.configure.fftSpecAn.set_scount(statistic_count = 1) \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. \n
-			:param statistic_count: Number of measurement intervals. A measurement interval comprises a single power/frequency step (list mode switched off) or a sweep (list mode switched on) . Range: 1 to 1000
+			:param statistic_count: numeric Number of measurement intervals Range: 1 to 1000
 		"""
 		param = Conversions.decimal_value_to_str(statistic_count)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:FFTSanalyzer:SCOunt {param}')
 
-	def clone(self) -> 'FftSpecAn':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'FftSpecAnCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = FftSpecAn(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = FftSpecAnCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqRecorder.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/IqRecorder/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,46 +1,52 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ...Internal.Utilities import trim_str_response
-from ...Internal.StructBase import StructBase
-from ...Internal.ArgStruct import ArgStruct
-from ... import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from ....Internal.Utilities import trim_str_response
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class IqRecorder:
-	"""IqRecorder commands group definition. 23 total commands, 3 Sub-groups, 9 group commands"""
+class IqRecorderCls:
+	"""IqRecorder commands group definition. 23 total commands, 4 Subgroups, 8 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("iqRecorder", core, parent)
+		self._cmd_group = CommandsGroup("iqRecorder", core, parent)
+
+	@property
+	def capture(self):
+		"""capture commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_capture'):
+			from .Capture import CaptureCls
+			self._capture = CaptureCls(self._core, self._cmd_group)
+		return self._capture
 
 	@property
 	def filterPy(self):
 		"""filterPy commands group. 2 Sub-classes, 1 commands."""
 		if not hasattr(self, '_filterPy'):
-			from .IqRecorder_.FilterPy import FilterPy
-			self._filterPy = FilterPy(self._core, self._base)
+			from .FilterPy import FilterPyCls
+			self._filterPy = FilterPyCls(self._core, self._cmd_group)
 		return self._filterPy
 
 	@property
 	def trigger(self):
 		"""trigger commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_trigger'):
-			from .IqRecorder_.Trigger import Trigger
-			self._trigger = Trigger(self._core, self._base)
+			from .Trigger import TriggerCls
+			self._trigger = TriggerCls(self._core, self._cmd_group)
 		return self._trigger
 
 	@property
 	def listPy(self):
-		"""listPy commands group. 2 Sub-classes, 6 commands."""
+		"""listPy commands group. 3 Sub-classes, 5 commands."""
 		if not hasattr(self, '_listPy'):
-			from .IqRecorder_.ListPy import ListPy
-			self._listPy = ListPy(self._core, self._base)
+			from .ListPy import ListPyCls
+			self._listPy = ListPyCls(self._core, self._cmd_group)
 		return self._listPy
 
 	# noinspection PyTypeChecker
 	def get_mode(self) -> enums.MeasurementMode:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:MODE \n
 		Snippet: value: enums.MeasurementMode = driver.configure.iqRecorder.get_mode() \n
 		No command help available \n
@@ -58,94 +64,94 @@
 		param = Conversions.enum_scalar_to_str(measurement_mode, enums.MeasurementMode)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQRecorder:MODE {param}')
 
 	def get_timeout(self) -> float:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:TOUT \n
 		Snippet: value: float = driver.configure.iqRecorder.get_timeout() \n
 		Defines a timeout for the measurement. The timer is started when the measurement is initiated via a READ or INIT command.
-		It is not started if the measurement is initiated manually ([ON | OFF] key or [RESTART | STOP] key) .
-		When the measurement has completed the first measurement cycle (first single shot) , the statistical depth is reached and
-		the timer is reset. If the first measurement cycle has not been completed when the timer expires, the measurement is
-		stopped. The measurement state changes to RDY. The reliability indicator is set to 1, indicating that a measurement
-		timeout occurred. Still running READ, FETCh or CALCulate commands are completed, returning the available results.
-		At least for some results, there are no values at all or the statistical depth has not been reached. A timeout of 0 s
-		corresponds to an infinite measurement timeout. \n
-			:return: tcd_timeout: Unit: s
+		It is not started if the measurement is initiated manually. When the measurement has completed the first measurement
+		cycle (first single shot) , the statistical depth is reached and the timer is reset. If the first measurement cycle has
+		not been completed when the timer expires, the measurement is stopped. The measurement state changes to RDY.
+		The reliability indicator is set to 1, indicating that a measurement timeout occurred. Still running READ, FETCh or
+		CALCulate commands are completed, returning the available results. At least for some results, there are no values at all
+		or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite measurement timeout. \n
+			:return: tcd_timeout: numeric Unit: s
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQRecorder:TOUT?')
 		return Conversions.str_to_float(response)
 
 	def set_timeout(self, tcd_timeout: float) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:TOUT \n
 		Snippet: driver.configure.iqRecorder.set_timeout(tcd_timeout = 1.0) \n
 		Defines a timeout for the measurement. The timer is started when the measurement is initiated via a READ or INIT command.
-		It is not started if the measurement is initiated manually ([ON | OFF] key or [RESTART | STOP] key) .
-		When the measurement has completed the first measurement cycle (first single shot) , the statistical depth is reached and
-		the timer is reset. If the first measurement cycle has not been completed when the timer expires, the measurement is
-		stopped. The measurement state changes to RDY. The reliability indicator is set to 1, indicating that a measurement
-		timeout occurred. Still running READ, FETCh or CALCulate commands are completed, returning the available results.
-		At least for some results, there are no values at all or the statistical depth has not been reached. A timeout of 0 s
-		corresponds to an infinite measurement timeout. \n
-			:param tcd_timeout: Unit: s
+		It is not started if the measurement is initiated manually. When the measurement has completed the first measurement
+		cycle (first single shot) , the statistical depth is reached and the timer is reset. If the first measurement cycle has
+		not been completed when the timer expires, the measurement is stopped. The measurement state changes to RDY.
+		The reliability indicator is set to 1, indicating that a measurement timeout occurred. Still running READ, FETCh or
+		CALCulate commands are completed, returning the available results. At least for some results, there are no values at all
+		or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite measurement timeout. \n
+			:param tcd_timeout: numeric Unit: s
 		"""
 		param = Conversions.decimal_value_to_str(tcd_timeout)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQRecorder:TOUT {param}')
 
 	def get_ratio(self) -> float:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:RATio \n
 		Snippet: value: float = driver.configure.iqRecorder.get_ratio() \n
-		Reduces the sampling rate (as defined by the filter settings) by a factor ≤1 and thus extends the total measurement time. \n
-			:return: ratio: Range: 0.1 to 1
+		Specifies a factor to reduce the sampling rate and to increase the measurement duration. The sampling rate resulting from
+		the filter settings is multiplied with the specified ratio. \n
+			:return: ratio: numeric
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQRecorder:RATio?')
 		return Conversions.str_to_float(response)
 
 	def set_ratio(self, ratio: float) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:RATio \n
 		Snippet: driver.configure.iqRecorder.set_ratio(ratio = 1.0) \n
-		Reduces the sampling rate (as defined by the filter settings) by a factor ≤1 and thus extends the total measurement time. \n
-			:param ratio: Range: 0.1 to 1
+		Specifies a factor to reduce the sampling rate and to increase the measurement duration. The sampling rate resulting from
+		the filter settings is multiplied with the specified ratio. \n
+			:param ratio: numeric
 		"""
 		param = Conversions.decimal_value_to_str(ratio)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQRecorder:RATio {param}')
 
 	# noinspection PyTypeChecker
 	def get_format_py(self) -> enums.IqFormat:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:FORMat \n
 		Snippet: value: enums.IqFormat = driver.configure.iqRecorder.get_format_py() \n
-		Selects the coordinates that are used to represent the I/Q recorder results. \n
-			:return: format_py: IQ | RPHI IQ: cartesian coordinates (I and Q axis) RPHI: polar coordinates (radius R and angle PHI) .
+		Selects the coordinate system for the I/Q recorder results. \n
+			:return: format_py: IQ | RPHI IQ: cartesian coordinates (I and Q axis) RPHI: polar coordinates (radius R and angle PHI)
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQRecorder:FORMat?')
 		return Conversions.str_to_scalar_enum(response, enums.IqFormat)
 
 	def set_format_py(self, format_py: enums.IqFormat) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:FORMat \n
 		Snippet: driver.configure.iqRecorder.set_format_py(format_py = enums.IqFormat.IQ) \n
-		Selects the coordinates that are used to represent the I/Q recorder results. \n
-			:param format_py: IQ | RPHI IQ: cartesian coordinates (I and Q axis) RPHI: polar coordinates (radius R and angle PHI) .
+		Selects the coordinate system for the I/Q recorder results. \n
+			:param format_py: IQ | RPHI IQ: cartesian coordinates (I and Q axis) RPHI: polar coordinates (radius R and angle PHI)
 		"""
 		param = Conversions.enum_scalar_to_str(format_py, enums.IqFormat)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQRecorder:FORMat {param}')
 
 	# noinspection PyTypeChecker
 	def get_munit(self) -> enums.MagnitudeUnit:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:MUNit \n
 		Snippet: value: enums.MagnitudeUnit = driver.configure.iqRecorder.get_munit() \n
 		Selects the magnitude unit for the measurement results. \n
-			:return: magnitude_unit: VOLT | RAW Voltage units or raw I/Q data relative to full scale
+			:return: magnitude_unit: VOLT | RAW Voltage units or raw I/Q data relative to full-scale.
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQRecorder:MUNit?')
 		return Conversions.str_to_scalar_enum(response, enums.MagnitudeUnit)
 
 	def set_munit(self, magnitude_unit: enums.MagnitudeUnit) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:MUNit \n
 		Snippet: driver.configure.iqRecorder.set_munit(magnitude_unit = enums.MagnitudeUnit.RAW) \n
 		Selects the magnitude unit for the measurement results. \n
-			:param magnitude_unit: VOLT | RAW Voltage units or raw I/Q data relative to full scale
+			:param magnitude_unit: VOLT | RAW Voltage units or raw I/Q data relative to full-scale.
 		"""
 		param = Conversions.enum_scalar_to_str(magnitude_unit, enums.MagnitudeUnit)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQRecorder:MUNit {param}')
 
 	# noinspection PyTypeChecker
 	def get_user(self) -> enums.UserDebugMode:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:USER \n
@@ -164,90 +170,50 @@
 		"""
 		param = Conversions.enum_scalar_to_str(user_mode, enums.UserDebugMode)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQRecorder:USER {param}')
 
 	def get_iq_file(self) -> str:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:IQFile \n
 		Snippet: value: str = driver.configure.iqRecorder.get_iq_file() \n
-		Selects the name and path of a file that is used to store the I/Q recorder results in binary format. To write the file,
-		the I/Q recorder measurement must be started using INITiate:GPRF:MEAS<i>:IQRecorder ON. \n
-			:return: iq_save_file: String parameter to specify the name and path of the I/Q file. The extension '*.iqw' is appended automatically.
+		Selects a file for storage of the I/Q recorder results in binary format. \n
+			:return: iq_save_file: string Name and path of the file. The extension '*.iqw' is appended automatically.
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQRecorder:IQFile?')
 		return trim_str_response(response)
 
 	def set_iq_file(self, iq_save_file: str) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:IQFile \n
-		Snippet: driver.configure.iqRecorder.set_iq_file(iq_save_file = '1') \n
-		Selects the name and path of a file that is used to store the I/Q recorder results in binary format. To write the file,
-		the I/Q recorder measurement must be started using INITiate:GPRF:MEAS<i>:IQRecorder ON. \n
-			:param iq_save_file: String parameter to specify the name and path of the I/Q file. The extension '*.iqw' is appended automatically.
+		Snippet: driver.configure.iqRecorder.set_iq_file(iq_save_file = 'abc') \n
+		Selects a file for storage of the I/Q recorder results in binary format. \n
+			:param iq_save_file: string Name and path of the file. The extension '*.iqw' is appended automatically.
 		"""
 		param = Conversions.value_to_quoted_str(iq_save_file)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQRecorder:IQFile {param}')
 
 	# noinspection PyTypeChecker
 	def get_wt_file(self) -> enums.FileSave:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:WTFile \n
 		Snippet: value: enums.FileSave = driver.configure.iqRecorder.get_wt_file() \n
-		Selects whether the results are written to an I/Q file, to the memory or both. For file selection, see method
-		RsCmwGprfMeas.Configure.IqRecorder.iqFile. \n
-			:return: write_to_iq_file: OFF | ON | ONLY OFF The results are only stored in the memory. ON The results are stored in the memory and in a file. ONLY The results are only stored in a file.
+		Selects whether the results are written to a file, to the memory or both. For file selection, see method RsCmwGprfMeas.
+		Configure.IqRecorder.iqFile. \n
+			:return: write_to_iq_file: OFF | ON | ONLY OFF: The results are only stored in the memory. ON: The results are stored in the memory and in a file. ONLY: The results are only stored in a file.
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQRecorder:WTFile?')
 		return Conversions.str_to_scalar_enum(response, enums.FileSave)
 
 	def set_wt_file(self, write_to_iq_file: enums.FileSave) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:WTFile \n
 		Snippet: driver.configure.iqRecorder.set_wt_file(write_to_iq_file = enums.FileSave.OFF) \n
-		Selects whether the results are written to an I/Q file, to the memory or both. For file selection, see method
-		RsCmwGprfMeas.Configure.IqRecorder.iqFile. \n
-			:param write_to_iq_file: OFF | ON | ONLY OFF The results are only stored in the memory. ON The results are stored in the memory and in a file. ONLY The results are only stored in a file.
+		Selects whether the results are written to a file, to the memory or both. For file selection, see method RsCmwGprfMeas.
+		Configure.IqRecorder.iqFile. \n
+			:param write_to_iq_file: OFF | ON | ONLY OFF: The results are only stored in the memory. ON: The results are stored in the memory and in a file. ONLY: The results are only stored in a file.
 		"""
 		param = Conversions.enum_scalar_to_str(write_to_iq_file, enums.FileSave)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQRecorder:WTFile {param}')
 
-	# noinspection PyTypeChecker
-	class CaptureStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Capt_Samp_Bef_Trig: int: Samples before trigger Range: 1 to 67108863
-			- Capt_Samp_Aft_Trig: int: Samples after trigger Range: 1 to 67108863"""
-		__meta_args_list = [
-			ArgStruct.scalar_int('Capt_Samp_Bef_Trig'),
-			ArgStruct.scalar_int('Capt_Samp_Aft_Trig')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Capt_Samp_Bef_Trig: int = None
-			self.Capt_Samp_Aft_Trig: int = None
-
-	def get_capture(self) -> CaptureStruct:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:CAPTure \n
-		Snippet: value: CaptureStruct = driver.configure.iqRecorder.get_capture() \n
-		Selects the total number of samples and their position relative to the trigger event. The total number of samples
-		corresponds to the sum of <CaptSampBefTrig> + <CaptSampAftTrig>.
-			INTRO_CMD_HELP: Configure the two settings so that the maximum supported total number of samples is not exceeded. The maximum allowed value depends on some factors: \n
-			- 4 MSamples (4194304 samples) can always be recorded.
-			- 64 MSamples (67108864 samples) can be recorded with an R&S CMW500/2xx with BB Meas if the results are not kept in the memory, only stored to a file. \n
-			:return: structure: for return value, see the help for CaptureStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:GPRF:MEASurement<Instance>:IQRecorder:CAPTure?', self.__class__.CaptureStruct())
-
-	def set_capture(self, value: CaptureStruct) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:CAPTure \n
-		Snippet: driver.configure.iqRecorder.set_capture(value = CaptureStruct()) \n
-		Selects the total number of samples and their position relative to the trigger event. The total number of samples
-		corresponds to the sum of <CaptSampBefTrig> + <CaptSampAftTrig>.
-			INTRO_CMD_HELP: Configure the two settings so that the maximum supported total number of samples is not exceeded. The maximum allowed value depends on some factors: \n
-			- 4 MSamples (4194304 samples) can always be recorded.
-			- 64 MSamples (67108864 samples) can be recorded with an R&S CMW500/2xx with BB Meas if the results are not kept in the memory, only stored to a file. \n
-			:param value: see the help for CaptureStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:GPRF:MEASurement<Instance>:IQRecorder:CAPTure', value)
-
-	def clone(self) -> 'IqRecorder':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'IqRecorderCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = IqRecorder(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = IqRecorderCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqRecorder_/FilterPy.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/IqRecorder/FilterPy/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,58 +1,56 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from .... import enums
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class FilterPy:
-	"""FilterPy commands group definition. 3 total commands, 2 Sub-groups, 1 group commands"""
+class FilterPyCls:
+	"""FilterPy commands group definition. 3 total commands, 2 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("filterPy", core, parent)
+		self._cmd_group = CommandsGroup("filterPy", core, parent)
 
 	@property
 	def bandpass(self):
 		"""bandpass commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_bandpass'):
-			from .FilterPy_.Bandpass import Bandpass
-			self._bandpass = Bandpass(self._core, self._base)
+			from .Bandpass import BandpassCls
+			self._bandpass = BandpassCls(self._core, self._cmd_group)
 		return self._bandpass
 
 	@property
 	def gauss(self):
 		"""gauss commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_gauss'):
-			from .FilterPy_.Gauss import Gauss
-			self._gauss = Gauss(self._core, self._base)
+			from .Gauss import GaussCls
+			self._gauss = GaussCls(self._core, self._cmd_group)
 		return self._gauss
 
 	# noinspection PyTypeChecker
 	def get_type_py(self) -> enums.RbwFilterType:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:FILTer:TYPE \n
 		Snippet: value: enums.RbwFilterType = driver.configure.iqRecorder.filterPy.get_type_py() \n
-		Selects the IF filter type. Gauss filters have shorter settling times and therefore larger sampling rates.
-		Bandpass filters have a flat passband and steeper edges. See also 'Filter Settings and Samples'. \n
-			:return: filter_type: BANDpass | GAUSs BANDpass: bandpass filter with variable bandwidth GAUSs: filter of Gaussian shape with variable bandwidth
+		Selects the IF filter type. \n
+			:return: filter_type: BANDpass | GAUSs BANDpass: bandpass filter GAUSs: filter of Gaussian shape
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQRecorder:FILTer:TYPE?')
 		return Conversions.str_to_scalar_enum(response, enums.RbwFilterType)
 
 	def set_type_py(self, filter_type: enums.RbwFilterType) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:FILTer:TYPE \n
 		Snippet: driver.configure.iqRecorder.filterPy.set_type_py(filter_type = enums.RbwFilterType.BANDpass) \n
-		Selects the IF filter type. Gauss filters have shorter settling times and therefore larger sampling rates.
-		Bandpass filters have a flat passband and steeper edges. See also 'Filter Settings and Samples'. \n
-			:param filter_type: BANDpass | GAUSs BANDpass: bandpass filter with variable bandwidth GAUSs: filter of Gaussian shape with variable bandwidth
+		Selects the IF filter type. \n
+			:param filter_type: BANDpass | GAUSs BANDpass: bandpass filter GAUSs: filter of Gaussian shape
 		"""
 		param = Conversions.enum_scalar_to_str(filter_type, enums.RbwFilterType)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQRecorder:FILTer:TYPE {param}')
 
-	def clone(self) -> 'FilterPy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'FilterPyCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = FilterPy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = FilterPyCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqRecorder_/FilterPy_/Bandpass.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/IqRecorder/FilterPy/Bandpass.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,30 +1,30 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Bandpass:
-	"""Bandpass commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class BandpassCls:
+	"""Bandpass commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("bandpass", core, parent)
+		self._cmd_group = CommandsGroup("bandpass", core, parent)
 
 	def get_bandwidth(self) -> float:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:FILTer:BANDpass:BWIDth \n
 		Snippet: value: float = driver.configure.iqRecorder.filterPy.bandpass.get_bandwidth() \n
 		Selects the bandwidth for a bandpass filter. \n
-			:return: bandpass_bw: 1 kHz | 10 kHz | 100 kHz | 1 MHz | 10 MHz | 40 MHz | 160 MHz Values in-between are rounded. Unit: Hz
+			:return: bandpass_bw: numeric Only the following values can be configured: 1, 10, 100 kHz; 1, 10, 40, 160 MHz Other values are rounded to the next allowed value. Unit: Hz
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQRecorder:FILTer:BANDpass:BWIDth?')
 		return Conversions.str_to_float(response)
 
 	def set_bandwidth(self, bandpass_bw: float) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:FILTer:BANDpass:BWIDth \n
 		Snippet: driver.configure.iqRecorder.filterPy.bandpass.set_bandwidth(bandpass_bw = 1.0) \n
 		Selects the bandwidth for a bandpass filter. \n
-			:param bandpass_bw: 1 kHz | 10 kHz | 100 kHz | 1 MHz | 10 MHz | 40 MHz | 160 MHz Values in-between are rounded. Unit: Hz
+			:param bandpass_bw: numeric Only the following values can be configured: 1, 10, 100 kHz; 1, 10, 40, 160 MHz Other values are rounded to the next allowed value. Unit: Hz
 		"""
 		param = Conversions.decimal_value_to_str(bandpass_bw)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQRecorder:FILTer:BANDpass:BWIDth {param}')
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqRecorder_/FilterPy_/Gauss.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/FilterPy/Gauss.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,30 +1,30 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Gauss:
-	"""Gauss commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class GaussCls:
+	"""Gauss commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("gauss", core, parent)
+		self._cmd_group = CommandsGroup("gauss", core, parent)
 
 	def get_bandwidth(self) -> float:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:FILTer:GAUSs:BWIDth \n
-		Snippet: value: float = driver.configure.iqRecorder.filterPy.gauss.get_bandwidth() \n
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:FILTer:GAUSs:BWIDth \n
+		Snippet: value: float = driver.configure.power.filterPy.gauss.get_bandwidth() \n
 		Selects the bandwidth for a filter of Gaussian shape. \n
-			:return: gauss_bw: Range: 1 kHz | 10 kHz | 100 kHz | 1 MHz | 10 MHz (values in-between are rounded) , Unit: Hz
+			:return: gauss_bw: numeric For allowed values, see Table 'Supported values'. Unit: Hz
 		"""
-		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQRecorder:FILTer:GAUSs:BWIDth?')
+		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:POWer:FILTer:GAUSs:BWIDth?')
 		return Conversions.str_to_float(response)
 
 	def set_bandwidth(self, gauss_bw: float) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:FILTer:GAUSs:BWIDth \n
-		Snippet: driver.configure.iqRecorder.filterPy.gauss.set_bandwidth(gauss_bw = 1.0) \n
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:FILTer:GAUSs:BWIDth \n
+		Snippet: driver.configure.power.filterPy.gauss.set_bandwidth(gauss_bw = 1.0) \n
 		Selects the bandwidth for a filter of Gaussian shape. \n
-			:param gauss_bw: Range: 1 kHz | 10 kHz | 100 kHz | 1 MHz | 10 MHz (values in-between are rounded) , Unit: Hz
+			:param gauss_bw: numeric For allowed values, see Table 'Supported values'. Unit: Hz
 		"""
 		param = Conversions.decimal_value_to_str(gauss_bw)
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQRecorder:FILTer:GAUSs:BWIDth {param}')
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:FILTer:GAUSs:BWIDth {param}')
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqRecorder_/ListPy.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Spectrum/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,156 +1,137 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ListPy:
-	"""ListPy commands group definition. 10 total commands, 2 Sub-groups, 6 group commands"""
+class SpectrumCls:
+	"""Spectrum commands group definition. 22 total commands, 3 Subgroups, 4 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("listPy", core, parent)
+		self._cmd_group = CommandsGroup("spectrum", core, parent)
+
+	@property
+	def zeroSpan(self):
+		"""zeroSpan commands group. 2 Sub-classes, 1 commands."""
+		if not hasattr(self, '_zeroSpan'):
+			from .ZeroSpan import ZeroSpanCls
+			self._zeroSpan = ZeroSpanCls(self._core, self._cmd_group)
+		return self._zeroSpan
 
 	@property
 	def frequency(self):
-		"""frequency commands group. 0 Sub-classes, 2 commands."""
+		"""frequency commands group. 1 Sub-classes, 4 commands."""
 		if not hasattr(self, '_frequency'):
-			from .ListPy_.Frequency import Frequency
-			self._frequency = Frequency(self._core, self._base)
+			from .Frequency import FrequencyCls
+			self._frequency = FrequencyCls(self._core, self._cmd_group)
 		return self._frequency
 
 	@property
-	def envelopePower(self):
-		"""envelopePower commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_envelopePower'):
-			from .ListPy_.EnvelopePower import EnvelopePower
-			self._envelopePower = EnvelopePower(self._core, self._base)
-		return self._envelopePower
-
-	def get_slength(self) -> float:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:LIST:SLENgth \n
-		Snippet: value: float = driver.configure.iqRecorder.listPy.get_slength() \n
-		Selects the time between the beginning of two consecutive measurement steps. \n
-			:return: step_length: Range: 100E-6 s to 0.1 s, Unit: s
-		"""
-		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQRecorder:LIST:SLENgth?')
-		return Conversions.str_to_float(response)
+	def freqSweep(self):
+		"""freqSweep commands group. 3 Sub-classes, 0 commands."""
+		if not hasattr(self, '_freqSweep'):
+			from .FreqSweep import FreqSweepCls
+			self._freqSweep = FreqSweepCls(self._core, self._cmd_group)
+		return self._freqSweep
 
-	def set_slength(self, step_length: float) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:LIST:SLENgth \n
-		Snippet: driver.configure.iqRecorder.listPy.set_slength(step_length = 1.0) \n
-		Selects the time between the beginning of two consecutive measurement steps. \n
-			:param step_length: Range: 100E-6 s to 0.1 s, Unit: s
-		"""
-		param = Conversions.decimal_value_to_str(step_length)
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQRecorder:LIST:SLENgth {param}')
-
-	def get_count(self) -> int:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:LIST:COUNt \n
-		Snippet: value: int = driver.configure.iqRecorder.listPy.get_count() \n
-		Queries the total number of results, given by <StopIndex> – <StartIndex> + 1 (see method RsCmwGprfMeas.Configure.
-		IqRecorder.ListPy.start and method RsCmwGprfMeas.Configure.IqRecorder.ListPy.stop) . \n
-			:return: result_count: Range: 1 to 2000
+	# noinspection PyTypeChecker
+	def get_amode(self) -> enums.AveragingMode:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:AMODe \n
+		Snippet: value: enums.AveragingMode = driver.configure.spectrum.get_amode() \n
+		Defines how the R&S CMW calculates the AVERage traces from the current results. \n
+			:return: averaging_mode: LINear | LOGarithmic
+		"""
+		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:SPECtrum:AMODe?')
+		return Conversions.str_to_scalar_enum(response, enums.AveragingMode)
+
+	def set_amode(self, averaging_mode: enums.AveragingMode) -> None:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:AMODe \n
+		Snippet: driver.configure.spectrum.set_amode(averaging_mode = enums.AveragingMode.LINear) \n
+		Defines how the R&S CMW calculates the AVERage traces from the current results. \n
+			:param averaging_mode: LINear | LOGarithmic
 		"""
-		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQRecorder:LIST:COUNt?')
-		return Conversions.str_to_int(response)
+		param = Conversions.enum_scalar_to_str(averaging_mode, enums.AveragingMode)
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:SPECtrum:AMODe {param}')
 
-	def get_start(self) -> int:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:LIST:STARt \n
-		Snippet: value: int = driver.configure.iqRecorder.listPy.get_start() \n
-		Start index, defines the first frequency/level step in the frequency/level list that is measured. The value must not
-		exceed the stop index defined by method RsCmwGprfMeas.Configure.IqRecorder.ListPy.stop. \n
-			:return: start_index: Range: 0 to 1999
+	# noinspection PyTypeChecker
+	def get_repetition(self) -> enums.Repeat:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:REPetition \n
+		Snippet: value: enums.Repeat = driver.configure.spectrum.get_repetition() \n
+		Specifies the repetition mode of the measurement. The repetition mode specifies whether the measurement is stopped after
+		a single shot or repeated continuously. Use CONFigure:..:MEAS<i>:...:SCOunt to determine the number of measurement
+		intervals per single shot. \n
+			:return: repetition: SINGleshot | CONTinuous SINGleshot: single-shot measurement CONTinuous: continuous measurement
+		"""
+		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:SPECtrum:REPetition?')
+		return Conversions.str_to_scalar_enum(response, enums.Repeat)
+
+	def set_repetition(self, repetition: enums.Repeat) -> None:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:REPetition \n
+		Snippet: driver.configure.spectrum.set_repetition(repetition = enums.Repeat.CONTinuous) \n
+		Specifies the repetition mode of the measurement. The repetition mode specifies whether the measurement is stopped after
+		a single shot or repeated continuously. Use CONFigure:..:MEAS<i>:...:SCOunt to determine the number of measurement
+		intervals per single shot. \n
+			:param repetition: SINGleshot | CONTinuous SINGleshot: single-shot measurement CONTinuous: continuous measurement
+		"""
+		param = Conversions.enum_scalar_to_str(repetition, enums.Repeat)
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:SPECtrum:REPetition {param}')
+
+	def get_timeout(self) -> float:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:TOUT \n
+		Snippet: value: float = driver.configure.spectrum.get_timeout() \n
+		Defines a timeout for the measurement. The timer is started when the measurement is initiated via a READ or INIT command.
+		It is not started if the measurement is initiated manually. When the measurement has completed the first measurement
+		cycle (first single shot) , the statistical depth is reached and the timer is reset. If the first measurement cycle has
+		not been completed when the timer expires, the measurement is stopped. The measurement state changes to RDY.
+		The reliability indicator is set to 1, indicating that a measurement timeout occurred. Still running READ, FETCh or
+		CALCulate commands are completed, returning the available results. At least for some results, there are no values at all
+		or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite measurement timeout. \n
+			:return: tcd_timeout: numeric Unit: s
 		"""
-		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQRecorder:LIST:STARt?')
-		return Conversions.str_to_int(response)
+		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:SPECtrum:TOUT?')
+		return Conversions.str_to_float(response)
 
-	def set_start(self, start_index: int) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:LIST:STARt \n
-		Snippet: driver.configure.iqRecorder.listPy.set_start(start_index = 1) \n
-		Start index, defines the first frequency/level step in the frequency/level list that is measured. The value must not
-		exceed the stop index defined by method RsCmwGprfMeas.Configure.IqRecorder.ListPy.stop. \n
-			:param start_index: Range: 0 to 1999
-		"""
-		param = Conversions.decimal_value_to_str(start_index)
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQRecorder:LIST:STARt {param}')
-
-	def get_stop(self) -> int:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:LIST:STOP \n
-		Snippet: value: int = driver.configure.iqRecorder.listPy.get_stop() \n
-		Stop index, defines the last frequency/level step in the frequency/level list that is measured. The value must not be
-		smaller than the start index defined by method RsCmwGprfMeas.Configure.IqRecorder.ListPy.start. \n
-			:return: stop_index: Range: 0 to 1999
+	def set_timeout(self, tcd_timeout: float) -> None:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:TOUT \n
+		Snippet: driver.configure.spectrum.set_timeout(tcd_timeout = 1.0) \n
+		Defines a timeout for the measurement. The timer is started when the measurement is initiated via a READ or INIT command.
+		It is not started if the measurement is initiated manually. When the measurement has completed the first measurement
+		cycle (first single shot) , the statistical depth is reached and the timer is reset. If the first measurement cycle has
+		not been completed when the timer expires, the measurement is stopped. The measurement state changes to RDY.
+		The reliability indicator is set to 1, indicating that a measurement timeout occurred. Still running READ, FETCh or
+		CALCulate commands are completed, returning the available results. At least for some results, there are no values at all
+		or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite measurement timeout. \n
+			:param tcd_timeout: numeric Unit: s
+		"""
+		param = Conversions.decimal_value_to_str(tcd_timeout)
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:SPECtrum:TOUT {param}')
+
+	def get_scount(self) -> int:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:SCOunt \n
+		Snippet: value: int = driver.configure.spectrum.get_scount() \n
+		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
+		single shot. \n
+			:return: statistic_count: numeric Number of measurement intervals Range: 1 to 1000
 		"""
-		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQRecorder:LIST:STOP?')
+		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:SPECtrum:SCOunt?')
 		return Conversions.str_to_int(response)
 
-	def set_stop(self, stop_index: int) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:LIST:STOP \n
-		Snippet: driver.configure.iqRecorder.listPy.set_stop(stop_index = 1) \n
-		Stop index, defines the last frequency/level step in the frequency/level list that is measured. The value must not be
-		smaller than the start index defined by method RsCmwGprfMeas.Configure.IqRecorder.ListPy.start. \n
-			:param stop_index: Range: 0 to 1999
-		"""
-		param = Conversions.decimal_value_to_str(stop_index)
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQRecorder:LIST:STOP {param}')
-
-	# noinspection PyTypeChecker
-	class SstopStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Start_Index: int: Range: 0 to 1999
-			- Stop_Index: int: Range: 0 to 1999"""
-		__meta_args_list = [
-			ArgStruct.scalar_int('Start_Index'),
-			ArgStruct.scalar_int('Stop_Index')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Start_Index: int = None
-			self.Stop_Index: int = None
-
-	def get_sstop(self) -> SstopStruct:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:LIST:SSTop \n
-		Snippet: value: SstopStruct = driver.configure.iqRecorder.listPy.get_sstop() \n
-		Start index and stop index, defines the first and last frequency/level step in the frequency/level list that is measured.
-		The start index must not exceed the stop index. \n
-			:return: structure: for return value, see the help for SstopStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:GPRF:MEASurement<Instance>:IQRecorder:LIST:SSTop?', self.__class__.SstopStruct())
-
-	def set_sstop(self, value: SstopStruct) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:LIST:SSTop \n
-		Snippet: driver.configure.iqRecorder.listPy.set_sstop(value = SstopStruct()) \n
-		Start index and stop index, defines the first and last frequency/level step in the frequency/level list that is measured.
-		The start index must not exceed the stop index. \n
-			:param value: see the help for SstopStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:GPRF:MEASurement<Instance>:IQRecorder:LIST:SSTop', value)
-
-	def get_value(self) -> bool:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:LIST \n
-		Snippet: value: bool = driver.configure.iqRecorder.listPy.get_value() \n
-		Enables or disables the list mode for the I/Q recorder. \n
-			:return: enable_list_mode: OFF | ON OFF: list mode off (single power step) ON: list mode on
-		"""
-		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQRecorder:LIST?')
-		return Conversions.str_to_bool(response)
-
-	def set_value(self, enable_list_mode: bool) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:LIST \n
-		Snippet: driver.configure.iqRecorder.listPy.set_value(enable_list_mode = False) \n
-		Enables or disables the list mode for the I/Q recorder. \n
-			:param enable_list_mode: OFF | ON OFF: list mode off (single power step) ON: list mode on
+	def set_scount(self, statistic_count: int) -> None:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:SCOunt \n
+		Snippet: driver.configure.spectrum.set_scount(statistic_count = 1) \n
+		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
+		single shot. \n
+			:param statistic_count: numeric Number of measurement intervals Range: 1 to 1000
 		"""
-		param = Conversions.bool_to_str(enable_list_mode)
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQRecorder:LIST {param}')
+		param = Conversions.decimal_value_to_str(statistic_count)
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:SPECtrum:SCOunt {param}')
 
-	def clone(self) -> 'ListPy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SpectrumCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ListPy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SpectrumCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqRecorder_/ListPy_/EnvelopePower.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/IqRecorder/ListPy/EnvelopePower.py`

 * *Files 20% similar despite different names*

```diff
@@ -5,51 +5,51 @@
 from .....Internal import Conversions
 from .....Internal.Types import DataType
 from .....Internal.ArgSingleList import ArgSingleList
 from .....Internal.ArgSingle import ArgSingle
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class EnvelopePower:
-	"""EnvelopePower commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class EnvelopePowerCls:
+	"""EnvelopePower commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("envelopePower", core, parent)
+		self._cmd_group = CommandsGroup("envelopePower", core, parent)
 
 	def set(self, index: int, exp_nom_power: float) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:LIST:ENPower \n
 		Snippet: driver.configure.iqRecorder.listPy.envelopePower.set(index = 1, exp_nom_power = 1.0) \n
-		Defines or queries the expected nominal power of a selected frequency/level step. \n
-			:param index: Number of the frequency/level step in the table Range: 0 to 1999
-			:param exp_nom_power: Expected nominal power of the frequency/level step Range: -55 dBm to 55 dBm, Unit: dBm
+		No command help available \n
+			:param index: No help available
+			:param exp_nom_power: No help available
 		"""
 		param = ArgSingleList().compose_cmd_string(ArgSingle('index', index, DataType.Integer), ArgSingle('exp_nom_power', exp_nom_power, DataType.Float))
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQRecorder:LIST:ENPower {param}'.rstrip())
 
 	def get(self, index: int) -> float:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:LIST:ENPower \n
 		Snippet: value: float = driver.configure.iqRecorder.listPy.envelopePower.get(index = 1) \n
-		Defines or queries the expected nominal power of a selected frequency/level step. \n
-			:param index: Number of the frequency/level step in the table Range: 0 to 1999
-			:return: exp_nom_power: Expected nominal power of the frequency/level step Range: -55 dBm to 55 dBm, Unit: dBm"""
+		No command help available \n
+			:param index: No help available
+			:return: exp_nom_power: No help available"""
 		param = Conversions.decimal_value_to_str(index)
 		response = self._core.io.query_str(f'CONFigure:GPRF:MEASurement<Instance>:IQRecorder:LIST:ENPower? {param}')
 		return Conversions.str_to_float(response)
 
 	def get_all(self) -> List[float]:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:LIST:ENPower:ALL \n
 		Snippet: value: List[float] = driver.configure.iqRecorder.listPy.envelopePower.get_all() \n
-		Defines the expected nominal power of all frequency/level steps. \n
-			:return: exp_nom_power: Comma-separated list of up to 2000 expected powers, one value per frequency/level step A query returns 2000 results (maximum number of steps) . Range: -55 dBm to 55 dBm, Unit: dBm
+		No command help available \n
+			:return: exp_nom_power: No help available
 		"""
 		response = self._core.io.query_bin_or_ascii_float_list('CONFigure:GPRF:MEASurement<Instance>:IQRecorder:LIST:ENPower:ALL?')
 		return response
 
 	def set_all(self, exp_nom_power: List[float]) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:LIST:ENPower:ALL \n
 		Snippet: driver.configure.iqRecorder.listPy.envelopePower.set_all(exp_nom_power = [1.1, 2.2, 3.3]) \n
-		Defines the expected nominal power of all frequency/level steps. \n
-			:param exp_nom_power: Comma-separated list of up to 2000 expected powers, one value per frequency/level step A query returns 2000 results (maximum number of steps) . Range: -55 dBm to 55 dBm, Unit: dBm
+		No command help available \n
+			:param exp_nom_power: No help available
 		"""
 		param = Conversions.list_to_csv_str(exp_nom_power)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQRecorder:LIST:ENPower:ALL {param}')
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqRecorder_/Trigger.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/IqVsSlot/Trigger.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,32 +1,32 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Trigger:
-	"""Trigger commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class TriggerCls:
+	"""Trigger commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("trigger", core, parent)
+		self._cmd_group = CommandsGroup("trigger", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_source(self) -> enums.TriggerSource:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:TRIGger:SOURce \n
-		Snippet: value: enums.TriggerSource = driver.configure.iqRecorder.trigger.get_source() \n
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:TRIGger:SOURce \n
+		Snippet: value: enums.TriggerSource = driver.configure.iqVsSlot.trigger.get_source() \n
 		No command help available \n
 			:return: source: No help available
 		"""
-		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQRecorder:TRIGger:SOURce?')
+		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQVSlot:TRIGger:SOURce?')
 		return Conversions.str_to_scalar_enum(response, enums.TriggerSource)
 
 	def set_source(self, source: enums.TriggerSource) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:TRIGger:SOURce \n
-		Snippet: driver.configure.iqRecorder.trigger.set_source(source = enums.TriggerSource.EXTernal) \n
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:TRIGger:SOURce \n
+		Snippet: driver.configure.iqVsSlot.trigger.set_source(source = enums.TriggerSource.EXTernal) \n
 		No command help available \n
 			:param source: No help available
 		"""
 		param = Conversions.enum_scalar_to_str(source, enums.TriggerSource)
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQRecorder:TRIGger:SOURce {param}')
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQVSlot:TRIGger:SOURce {param}')
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqVsSlot.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/RfSettings/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,189 +1,178 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ... import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class IqVsSlot:
-	"""IqVsSlot commands group definition. 19 total commands, 2 Sub-groups, 7 group commands"""
+class RfSettingsCls:
+	"""RfSettings commands group definition. 8 total commands, 1 Subgroups, 7 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("iqVsSlot", core, parent)
+		self._cmd_group = CommandsGroup("rfSettings", core, parent)
 
 	@property
-	def trigger(self):
-		"""trigger commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_trigger'):
-			from .IqVsSlot_.Trigger import Trigger
-			self._trigger = Trigger(self._core, self._base)
-		return self._trigger
+	def lrStart(self):
+		"""lrStart commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_lrStart'):
+			from .LrStart import LrStartCls
+			self._lrStart = LrStartCls(self._core, self._cmd_group)
+		return self._lrStart
+
+	def get_frequency(self) -> float:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:RFSettings:FREQuency \n
+		Snippet: value: float = driver.configure.rfSettings.get_frequency() \n
+		Selects the center frequency of the RF analyzer. This command is only relevant for the standalone scenario.
+		For the combined signal path scenario, use the corresponding ...:SIGN<i>:.. command. For the supported frequency range,
+		see 'Frequency ranges'. \n
+			:return: analyzer_freq: numeric Unit: Hz
+		"""
+		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:RFSettings:FREQuency?')
+		return Conversions.str_to_float(response)
 
-	@property
-	def listPy(self):
-		"""listPy commands group. 3 Sub-classes, 5 commands."""
-		if not hasattr(self, '_listPy'):
-			from .IqVsSlot_.ListPy import ListPy
-			self._listPy = ListPy(self._core, self._base)
-		return self._listPy
-
-	def get_timeout(self) -> float:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:TOUT \n
-		Snippet: value: float = driver.configure.iqVsSlot.get_timeout() \n
-		Defines a timeout for the measurement. The timer is started when the measurement is initiated via a READ or INIT command.
-		It is not started if the measurement is initiated manually ([ON | OFF] key or [RESTART | STOP] key) .
-		When the measurement has completed the first measurement cycle (first single shot) , the statistical depth is reached and
-		the timer is reset. If the first measurement cycle has not been completed when the timer expires, the measurement is
-		stopped. The measurement state changes to RDY. The reliability indicator is set to 1, indicating that a measurement
-		timeout occurred. Still running READ, FETCh or CALCulate commands are completed, returning the available results.
-		At least for some results, there are no values at all or the statistical depth has not been reached. A timeout of 0 s
-		corresponds to an infinite measurement timeout. \n
-			:return: tcd_timeout: Unit: s
-		"""
-		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQVSlot:TOUT?')
-		return Conversions.str_to_float(response)
-
-	def set_timeout(self, tcd_timeout: float) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:TOUT \n
-		Snippet: driver.configure.iqVsSlot.set_timeout(tcd_timeout = 1.0) \n
-		Defines a timeout for the measurement. The timer is started when the measurement is initiated via a READ or INIT command.
-		It is not started if the measurement is initiated manually ([ON | OFF] key or [RESTART | STOP] key) .
-		When the measurement has completed the first measurement cycle (first single shot) , the statistical depth is reached and
-		the timer is reset. If the first measurement cycle has not been completed when the timer expires, the measurement is
-		stopped. The measurement state changes to RDY. The reliability indicator is set to 1, indicating that a measurement
-		timeout occurred. Still running READ, FETCh or CALCulate commands are completed, returning the available results.
-		At least for some results, there are no values at all or the statistical depth has not been reached. A timeout of 0 s
-		corresponds to an infinite measurement timeout. \n
-			:param tcd_timeout: Unit: s
-		"""
-		param = Conversions.decimal_value_to_str(tcd_timeout)
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQVSlot:TOUT {param}')
-
-	# noinspection PyTypeChecker
-	def get_repetition(self) -> enums.Repeat:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:REPetition \n
-		Snippet: value: enums.Repeat = driver.configure.iqVsSlot.get_repetition() \n
-		Specifies the repetition mode of the measurement. The repetition mode specifies whether the measurement is stopped after
-		a single shot or repeated continuously. Use CONFigure:..:MEAS<i>:...:SCOunt to determine the number of measurement
-		intervals per single shot. \n
-			:return: repetition: SINGleshot | CONTinuous SINGleshot: single-shot measurement CONTinuous: continuous measurement
-		"""
-		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQVSlot:REPetition?')
-		return Conversions.str_to_scalar_enum(response, enums.Repeat)
-
-	def set_repetition(self, repetition: enums.Repeat) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:REPetition \n
-		Snippet: driver.configure.iqVsSlot.set_repetition(repetition = enums.Repeat.CONTinuous) \n
-		Specifies the repetition mode of the measurement. The repetition mode specifies whether the measurement is stopped after
-		a single shot or repeated continuously. Use CONFigure:..:MEAS<i>:...:SCOunt to determine the number of measurement
-		intervals per single shot. \n
-			:param repetition: SINGleshot | CONTinuous SINGleshot: single-shot measurement CONTinuous: continuous measurement
-		"""
-		param = Conversions.enum_scalar_to_str(repetition, enums.Repeat)
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQVSlot:REPetition {param}')
-
-	def get_scount(self) -> int:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:SCOunt \n
-		Snippet: value: int = driver.configure.iqVsSlot.get_scount() \n
-		Defines the number of measurement steps per subsweep. The total number of steps, i.e. the step count times the number of
-		subsweeps, must not exceed 3000 (see method RsCmwGprfMeas.Configure.IqVsSlot.ListPy.count) . \n
-			:return: step_count: Range: 1 to 3000
-		"""
-		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQVSlot:SCOunt?')
-		return Conversions.str_to_int(response)
-
-	def set_scount(self, step_count: int) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:SCOunt \n
-		Snippet: driver.configure.iqVsSlot.set_scount(step_count = 1) \n
-		Defines the number of measurement steps per subsweep. The total number of steps, i.e. the step count times the number of
-		subsweeps, must not exceed 3000 (see method RsCmwGprfMeas.Configure.IqVsSlot.ListPy.count) . \n
-			:param step_count: Range: 1 to 3000
-		"""
-		param = Conversions.decimal_value_to_str(step_count)
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQVSlot:SCOunt {param}')
-
-	def get_mlength(self) -> float:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:MLENgth \n
-		Snippet: value: float = driver.configure.iqVsSlot.get_mlength() \n
-		Selects the length of the averaging intervals that the R&S CMW uses to calculate the I/Q vs. slot results for each
-		measurement step. \n
-			:return: meas_length: Range: 10E-6 s to 1 ms, Unit: s
-		"""
-		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQVSlot:MLENgth?')
-		return Conversions.str_to_float(response)
-
-	def set_mlength(self, meas_length: float) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:MLENgth \n
-		Snippet: driver.configure.iqVsSlot.set_mlength(meas_length = 1.0) \n
-		Selects the length of the averaging intervals that the R&S CMW uses to calculate the I/Q vs. slot results for each
-		measurement step. \n
-			:param meas_length: Range: 10E-6 s to 1 ms, Unit: s
-		"""
-		param = Conversions.decimal_value_to_str(meas_length)
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQVSlot:MLENgth {param}')
-
-	def get_slength(self) -> float:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:SLENgth \n
-		Snippet: value: float = driver.configure.iqVsSlot.get_slength() \n
-		Selects the time between the beginning of two consecutive measurement steps. \n
-			:return: step_length: Range: 50E-6 s to 5E-3 s, Unit: s
-		"""
-		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQVSlot:SLENgth?')
-		return Conversions.str_to_float(response)
-
-	def set_slength(self, step_length: float) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:SLENgth \n
-		Snippet: driver.configure.iqVsSlot.set_slength(step_length = 1.0) \n
-		Selects the time between the beginning of two consecutive measurement steps. \n
-			:param step_length: Range: 50E-6 s to 5E-3 s, Unit: s
-		"""
-		param = Conversions.decimal_value_to_str(step_length)
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQVSlot:SLENgth {param}')
-
-	# noinspection PyTypeChecker
-	def get_ftype(self) -> enums.FilterType:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:FTYPe \n
-		Snippet: value: enums.FilterType = driver.configure.iqVsSlot.get_ftype() \n
-		Selects the IF filter type. \n
-			:return: filter_type: GAUSs | NYQuist | NY1Mhz GAUSs: filter of Gaussian shape, 100 kHz bandwidth NYQuist: Nyquist filter, 100 kHz bandwidth NY1Mhz: Nyquist filter, 1 MHz bandwidth
-		"""
-		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQVSlot:FTYPe?')
-		return Conversions.str_to_scalar_enum(response, enums.FilterType)
-
-	def set_ftype(self, filter_type: enums.FilterType) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:FTYPe \n
-		Snippet: driver.configure.iqVsSlot.set_ftype(filter_type = enums.FilterType.GAUSs) \n
-		Selects the IF filter type. \n
-			:param filter_type: GAUSs | NYQuist | NY1Mhz GAUSs: filter of Gaussian shape, 100 kHz bandwidth NYQuist: Nyquist filter, 100 kHz bandwidth NY1Mhz: Nyquist filter, 1 MHz bandwidth
-		"""
-		param = Conversions.enum_scalar_to_str(filter_type, enums.FilterType)
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQVSlot:FTYPe {param}')
-
-	def get_fe_limit(self) -> float:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:FELimit \n
-		Snippet: value: float = driver.configure.iqVsSlot.get_fe_limit() \n
-		Defines a minimum average signal level relative to the expected nominal power. The setting applies to all measurement
-		steps considered for the calculation of the average frequency per subsweep and the overall frequency error. \n
-			:return: limit: Range: -100 dB to -30 dB, Unit: dB
-		"""
-		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQVSlot:FELimit?')
-		return Conversions.str_to_float(response)
-
-	def set_fe_limit(self, limit: float) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:FELimit \n
-		Snippet: driver.configure.iqVsSlot.set_fe_limit(limit = 1.0) \n
-		Defines a minimum average signal level relative to the expected nominal power. The setting applies to all measurement
-		steps considered for the calculation of the average frequency per subsweep and the overall frequency error. \n
-			:param limit: Range: -100 dB to -30 dB, Unit: dB
+	def set_frequency(self, analyzer_freq: float) -> None:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:RFSettings:FREQuency \n
+		Snippet: driver.configure.rfSettings.set_frequency(analyzer_freq = 1.0) \n
+		Selects the center frequency of the RF analyzer. This command is only relevant for the standalone scenario.
+		For the combined signal path scenario, use the corresponding ...:SIGN<i>:.. command. For the supported frequency range,
+		see 'Frequency ranges'. \n
+			:param analyzer_freq: numeric Unit: Hz
+		"""
+		param = Conversions.decimal_value_to_str(analyzer_freq)
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:RFSettings:FREQuency {param}')
+
+	def get_envelope_power(self) -> float:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:RFSettings:ENPower \n
+		Snippet: value: float = driver.configure.rfSettings.get_envelope_power() \n
+		Sets the expected nominal power of the measured RF signal. This command is only relevant for the standalone scenario. For
+		the combined signal path scenario, use the corresponding ...:SIGN<i>:.. command. \n
+			:return: exp_nominal_power: numeric The range of the expected nominal power can be calculated as follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin The input power range is stated in the data sheet. Unit: dBm
+		"""
+		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:RFSettings:ENPower?')
+		return Conversions.str_to_float(response)
+
+	def set_envelope_power(self, exp_nominal_power: float) -> None:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:RFSettings:ENPower \n
+		Snippet: driver.configure.rfSettings.set_envelope_power(exp_nominal_power = 1.0) \n
+		Sets the expected nominal power of the measured RF signal. This command is only relevant for the standalone scenario. For
+		the combined signal path scenario, use the corresponding ...:SIGN<i>:.. command. \n
+			:param exp_nominal_power: numeric The range of the expected nominal power can be calculated as follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin The input power range is stated in the data sheet. Unit: dBm
+		"""
+		param = Conversions.decimal_value_to_str(exp_nominal_power)
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:RFSettings:ENPower {param}')
+
+	def get_eattenuation(self) -> float:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:RFSettings:EATTenuation \n
+		Snippet: value: float = driver.configure.rfSettings.get_eattenuation() \n
+		Defines an external attenuation (or gain, if the value is negative) , to be applied to the input connector. This command
+		is only relevant for the standalone scenario. For the combined signal path scenario, use the corresponding ...:SIGN<i>:..
+		command. \n
+			:return: rf_input_ext_att: numeric Range: -50 dB to 90 dB, Unit: dB
+		"""
+		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:RFSettings:EATTenuation?')
+		return Conversions.str_to_float(response)
+
+	def set_eattenuation(self, rf_input_ext_att: float) -> None:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:RFSettings:EATTenuation \n
+		Snippet: driver.configure.rfSettings.set_eattenuation(rf_input_ext_att = 1.0) \n
+		Defines an external attenuation (or gain, if the value is negative) , to be applied to the input connector. This command
+		is only relevant for the standalone scenario. For the combined signal path scenario, use the corresponding ...:SIGN<i>:..
+		command. \n
+			:param rf_input_ext_att: numeric Range: -50 dB to 90 dB, Unit: dB
+		"""
+		param = Conversions.decimal_value_to_str(rf_input_ext_att)
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:RFSettings:EATTenuation {param}')
+
+	def get_umargin(self) -> float:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:RFSettings:UMARgin \n
+		Snippet: value: float = driver.configure.rfSettings.get_umargin() \n
+		Sets the margin that the measurement adds to the expected nominal power to determine the reference power. The reference
+		power minus the external input attenuation must be within the power range of the selected input connector. Refer to the
+		data sheet. This command is only relevant for the standalone scenario. For the combined signal path scenario, use the
+		corresponding ...:SIGN<i>:.. command. \n
+			:return: user_margin: numeric Range: 0 dB to (55 dB + external attenuation - expected nominal power) , Unit: dB
+		"""
+		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:RFSettings:UMARgin?')
+		return Conversions.str_to_float(response)
+
+	def set_umargin(self, user_margin: float) -> None:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:RFSettings:UMARgin \n
+		Snippet: driver.configure.rfSettings.set_umargin(user_margin = 1.0) \n
+		Sets the margin that the measurement adds to the expected nominal power to determine the reference power. The reference
+		power minus the external input attenuation must be within the power range of the selected input connector. Refer to the
+		data sheet. This command is only relevant for the standalone scenario. For the combined signal path scenario, use the
+		corresponding ...:SIGN<i>:.. command. \n
+			:param user_margin: numeric Range: 0 dB to (55 dB + external attenuation - expected nominal power) , Unit: dB
+		"""
+		param = Conversions.decimal_value_to_str(user_margin)
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:RFSettings:UMARgin {param}')
+
+	def get_ml_offset(self) -> float:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:RFSettings:MLOFfset \n
+		Snippet: value: float = driver.configure.rfSettings.get_ml_offset() \n
+		Varies the input level of the mixer in the analyzer path. This command is only relevant for the standalone scenario. For
+		the combined signal path scenario, use the corresponding ...:SIGN<i>:.. command. \n
+			:return: mix_lev_offset: numeric Range: -10 dB to 16 dB, Unit: dB
+		"""
+		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:RFSettings:MLOFfset?')
+		return Conversions.str_to_float(response)
+
+	def set_ml_offset(self, mix_lev_offset: float) -> None:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:RFSettings:MLOFfset \n
+		Snippet: driver.configure.rfSettings.set_ml_offset(mix_lev_offset = 1.0) \n
+		Varies the input level of the mixer in the analyzer path. This command is only relevant for the standalone scenario. For
+		the combined signal path scenario, use the corresponding ...:SIGN<i>:.. command. \n
+			:param mix_lev_offset: numeric Range: -10 dB to 16 dB, Unit: dB
+		"""
+		param = Conversions.decimal_value_to_str(mix_lev_offset)
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:RFSettings:MLOFfset {param}')
+
+	def get_foffset(self) -> float:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:RFSettings:FOFFset \n
+		Snippet: value: float = driver.configure.rfSettings.get_foffset() \n
+		Specifies a positive or negative frequency offset to be added to the center frequency (see method RsCmwGprfMeas.Configure.
+		RfSettings.frequency) . This command does not apply to spectrum analysis in frequency sweep mode (see method
+		RsCmwGprfMeas.Configure.Spectrum.Frequency.Span.mode) . This command is only relevant for the standalone scenario.
+		For the combined signal path scenario, use the corresponding ...:SIGN<i>:.. command. \n
+			:return: freq_offset: numeric Range: -100 kHz to 100 kHz, Unit: Hz
+		"""
+		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:RFSettings:FOFFset?')
+		return Conversions.str_to_float(response)
+
+	def set_foffset(self, freq_offset: float) -> None:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:RFSettings:FOFFset \n
+		Snippet: driver.configure.rfSettings.set_foffset(freq_offset = 1.0) \n
+		Specifies a positive or negative frequency offset to be added to the center frequency (see method RsCmwGprfMeas.Configure.
+		RfSettings.frequency) . This command does not apply to spectrum analysis in frequency sweep mode (see method
+		RsCmwGprfMeas.Configure.Spectrum.Frequency.Span.mode) . This command is only relevant for the standalone scenario.
+		For the combined signal path scenario, use the corresponding ...:SIGN<i>:.. command. \n
+			:param freq_offset: numeric Range: -100 kHz to 100 kHz, Unit: Hz
+		"""
+		param = Conversions.decimal_value_to_str(freq_offset)
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:RFSettings:FOFFset {param}')
+
+	def get_lr_interval(self) -> float:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:RFSettings:LRINterval \n
+		Snippet: value: float = driver.configure.rfSettings.get_lr_interval() \n
+		No command help available \n
+			:return: lvl_rang_interval: No help available
+		"""
+		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:RFSettings:LRINterval?')
+		return Conversions.str_to_float(response)
+
+	def set_lr_interval(self, lvl_rang_interval: float) -> None:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:RFSettings:LRINterval \n
+		Snippet: driver.configure.rfSettings.set_lr_interval(lvl_rang_interval = 1.0) \n
+		No command help available \n
+			:param lvl_rang_interval: No help available
 		"""
-		param = Conversions.decimal_value_to_str(limit)
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQVSlot:FELimit {param}')
+		param = Conversions.decimal_value_to_str(lvl_rang_interval)
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:RFSettings:LRINterval {param}')
 
-	def clone(self) -> 'IqVsSlot':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'RfSettingsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = IqVsSlot(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = RfSettingsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqVsSlot_/ListPy.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/IqVsSlot/ListPy/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,140 +1,120 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ListPy:
-	"""ListPy commands group definition. 11 total commands, 3 Sub-groups, 5 group commands"""
+class ListPyCls:
+	"""ListPy commands group definition. 11 total commands, 4 Subgroups, 4 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("listPy", core, parent)
+		self._cmd_group = CommandsGroup("listPy", core, parent)
+
+	@property
+	def sstop(self):
+		"""sstop commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_sstop'):
+			from .Sstop import SstopCls
+			self._sstop = SstopCls(self._core, self._cmd_group)
+		return self._sstop
 
 	@property
 	def frequency(self):
 		"""frequency commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_frequency'):
-			from .ListPy_.Frequency import Frequency
-			self._frequency = Frequency(self._core, self._base)
+			from .Frequency import FrequencyCls
+			self._frequency = FrequencyCls(self._core, self._cmd_group)
 		return self._frequency
 
 	@property
 	def envelopePower(self):
 		"""envelopePower commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_envelopePower'):
-			from .ListPy_.EnvelopePower import EnvelopePower
-			self._envelopePower = EnvelopePower(self._core, self._base)
+			from .EnvelopePower import EnvelopePowerCls
+			self._envelopePower = EnvelopePowerCls(self._core, self._cmd_group)
 		return self._envelopePower
 
 	@property
 	def retrigger(self):
 		"""retrigger commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_retrigger'):
-			from .ListPy_.Retrigger import Retrigger
-			self._retrigger = Retrigger(self._core, self._base)
+			from .Retrigger import RetriggerCls
+			self._retrigger = RetriggerCls(self._core, self._cmd_group)
 		return self._retrigger
 
 	def get_start(self) -> int:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:LIST:STARt \n
 		Snippet: value: int = driver.configure.iqVsSlot.listPy.get_start() \n
-		Start index, defines the first frequency/level step in the frequency/level list that is measured. \n
-			:return: start_index: Range: 0 to 149
+		Selects the first subsweep to be measured. The <StartIndex> must not be greater than the <StopIndex>. The total number of
+		steps must not exceed 3000 (step count times number of subsweeps) . \n
+			:return: start_index: numeric Range: 0 to StopIndex
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQVSlot:LIST:STARt?')
 		return Conversions.str_to_int(response)
 
 	def set_start(self, start_index: int) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:LIST:STARt \n
 		Snippet: driver.configure.iqVsSlot.listPy.set_start(start_index = 1) \n
-		Start index, defines the first frequency/level step in the frequency/level list that is measured. \n
-			:param start_index: Range: 0 to 149
+		Selects the first subsweep to be measured. The <StartIndex> must not be greater than the <StopIndex>. The total number of
+		steps must not exceed 3000 (step count times number of subsweeps) . \n
+			:param start_index: numeric Range: 0 to StopIndex
 		"""
 		param = Conversions.decimal_value_to_str(start_index)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQVSlot:LIST:STARt {param}')
 
 	def get_stop(self) -> int:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:LIST:STOP \n
 		Snippet: value: int = driver.configure.iqVsSlot.listPy.get_stop() \n
-		Stop index, defines the last frequency/level step in the frequency/level list that is measured. \n
-			:return: stop_index: Range: 0 to 149
+		Selects the last subsweep to be measured. The <StopIndex> must not be smaller than the <StartIndex>. The total number of
+		steps must not exceed 3000 (step count times number of subsweeps) . \n
+			:return: stop_index: numeric Range: StartIndex to 199
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQVSlot:LIST:STOP?')
 		return Conversions.str_to_int(response)
 
 	def set_stop(self, stop_index: int) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:LIST:STOP \n
 		Snippet: driver.configure.iqVsSlot.listPy.set_stop(stop_index = 1) \n
-		Stop index, defines the last frequency/level step in the frequency/level list that is measured. \n
-			:param stop_index: Range: 0 to 149
+		Selects the last subsweep to be measured. The <StopIndex> must not be smaller than the <StartIndex>. The total number of
+		steps must not exceed 3000 (step count times number of subsweeps) . \n
+			:param stop_index: numeric Range: StartIndex to 199
 		"""
 		param = Conversions.decimal_value_to_str(stop_index)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQVSlot:LIST:STOP {param}')
 
-	# noinspection PyTypeChecker
-	class SstopStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Start_Index: int: Range: 0 to 149
-			- Stop_Index: int: Range: 0 to 149"""
-		__meta_args_list = [
-			ArgStruct.scalar_int('Start_Index'),
-			ArgStruct.scalar_int('Stop_Index')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Start_Index: int = None
-			self.Stop_Index: int = None
-
-	def get_sstop(self) -> SstopStruct:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:LIST:SSTop \n
-		Snippet: value: SstopStruct = driver.configure.iqVsSlot.listPy.get_sstop() \n
-		Start and stop index, defines the first and last frequency/level step in the frequency/level list that is measured. \n
-			:return: structure: for return value, see the help for SstopStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:GPRF:MEASurement<Instance>:IQVSlot:LIST:SSTop?', self.__class__.SstopStruct())
-
-	def set_sstop(self, value: SstopStruct) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:LIST:SSTop \n
-		Snippet: driver.configure.iqVsSlot.listPy.set_sstop(value = SstopStruct()) \n
-		Start and stop index, defines the first and last frequency/level step in the frequency/level list that is measured. \n
-			:param value: see the help for SstopStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:GPRF:MEASurement<Instance>:IQVSlot:LIST:SSTop', value)
-
 	def get_count(self) -> int:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:LIST:COUNt \n
 		Snippet: value: int = driver.configure.iqVsSlot.listPy.get_count() \n
-		Queries the number of subsweeps (<Stop Index> – <Start Index> + 1) . The total number of steps, i.e. the number of
-		subsweeps times the 'Step Count', must not exceed 3000 (see method RsCmwGprfMeas.Configure.IqVsSlot.scount) . \n
-			:return: sweep_count: Range: 1 to 150
+		Queries the number of subsweeps per sweep. The total number of steps must not exceed 3000 (step count times number of
+		subsweeps) . \n
+			:return: sweep_count: decimal Range: 1 to 200
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQVSlot:LIST:COUNt?')
 		return Conversions.str_to_int(response)
 
 	def get_value(self) -> bool:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:LIST \n
 		Snippet: value: bool = driver.configure.iqVsSlot.listPy.get_value() \n
-		Enables or disables the list mode for the I/Q vs. slot measurement. \n
-			:return: list_mode: OFF | ON OFF: list mode off (single power step) ON: list mode on
+		Enables or disables the list mode for the I/Q vs slot measurement. \n
+			:return: list_mode: OFF | ON OFF: list mode off ON: list mode on
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQVSlot:LIST?')
 		return Conversions.str_to_bool(response)
 
 	def set_value(self, list_mode: bool) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:LIST \n
 		Snippet: driver.configure.iqVsSlot.listPy.set_value(list_mode = False) \n
-		Enables or disables the list mode for the I/Q vs. slot measurement. \n
-			:param list_mode: OFF | ON OFF: list mode off (single power step) ON: list mode on
+		Enables or disables the list mode for the I/Q vs slot measurement. \n
+			:param list_mode: OFF | ON OFF: list mode off ON: list mode on
 		"""
 		param = Conversions.bool_to_str(list_mode)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQVSlot:LIST {param}')
 
-	def clone(self) -> 'ListPy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ListPyCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ListPy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ListPyCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqVsSlot_/ListPy_/EnvelopePower.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/IqVsSlot/ListPy/EnvelopePower.py`

 * *Files 21% similar despite different names*

```diff
@@ -5,51 +5,51 @@
 from .....Internal import Conversions
 from .....Internal.Types import DataType
 from .....Internal.ArgSingleList import ArgSingleList
 from .....Internal.ArgSingle import ArgSingle
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class EnvelopePower:
-	"""EnvelopePower commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class EnvelopePowerCls:
+	"""EnvelopePower commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("envelopePower", core, parent)
+		self._cmd_group = CommandsGroup("envelopePower", core, parent)
 
 	def set(self, index: int, exp_nom_power: float) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:LIST:ENPower \n
 		Snippet: driver.configure.iqVsSlot.listPy.envelopePower.set(index = 1, exp_nom_power = 1.0) \n
-		Defines or queries the expected nominal power of a selected frequency/level step. \n
-			:param index: Number of the frequency/level step in the table Range: 0 to 199
-			:param exp_nom_power: Range: -55 dBm to 55 dBm, Unit: dBm
+		Defines or queries the expected nominal power of subsweep <Index>. \n
+			:param index: integer Range: 0 to 199
+			:param exp_nom_power: numeric The range of the expected nominal power can be calculated as follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin The input power range is stated in the data sheet. Unit: dBm
 		"""
 		param = ArgSingleList().compose_cmd_string(ArgSingle('index', index, DataType.Integer), ArgSingle('exp_nom_power', exp_nom_power, DataType.Float))
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQVSlot:LIST:ENPower {param}'.rstrip())
 
 	def get(self, index: int) -> float:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:LIST:ENPower \n
 		Snippet: value: float = driver.configure.iqVsSlot.listPy.envelopePower.get(index = 1) \n
-		Defines or queries the expected nominal power of a selected frequency/level step. \n
-			:param index: Number of the frequency/level step in the table Range: 0 to 199
-			:return: exp_nom_power: Range: -55 dBm to 55 dBm, Unit: dBm"""
+		Defines or queries the expected nominal power of subsweep <Index>. \n
+			:param index: integer Range: 0 to 199
+			:return: exp_nom_power: numeric The range of the expected nominal power can be calculated as follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin The input power range is stated in the data sheet. Unit: dBm"""
 		param = Conversions.decimal_value_to_str(index)
 		response = self._core.io.query_str(f'CONFigure:GPRF:MEASurement<Instance>:IQVSlot:LIST:ENPower? {param}')
 		return Conversions.str_to_float(response)
 
 	def get_all(self) -> List[float]:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:LIST:ENPower:ALL \n
 		Snippet: value: List[float] = driver.configure.iqVsSlot.listPy.envelopePower.get_all() \n
-		Defines the expected nominal power of all frequency/level steps. \n
-			:return: exp_nom_power: Comma-separated list of up to 200 expected powers, one value per frequency/level step A query returns 200 results (maximum number of steps) . Range: -55 dBm to 55 dBm, Unit: dBm
+		Defines the expected nominal power for all subsweeps. \n
+			:return: exp_nom_power: numeric Comma-separated list of expected powers, one value per subsweep The range of the expected nominal power can be calculated as follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin The input power range is stated in the data sheet. Unit: dBm
 		"""
 		response = self._core.io.query_bin_or_ascii_float_list('CONFigure:GPRF:MEASurement<Instance>:IQVSlot:LIST:ENPower:ALL?')
 		return response
 
 	def set_all(self, exp_nom_power: List[float]) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:LIST:ENPower:ALL \n
 		Snippet: driver.configure.iqVsSlot.listPy.envelopePower.set_all(exp_nom_power = [1.1, 2.2, 3.3]) \n
-		Defines the expected nominal power of all frequency/level steps. \n
-			:param exp_nom_power: Comma-separated list of up to 200 expected powers, one value per frequency/level step A query returns 200 results (maximum number of steps) . Range: -55 dBm to 55 dBm, Unit: dBm
+		Defines the expected nominal power for all subsweeps. \n
+			:param exp_nom_power: numeric Comma-separated list of expected powers, one value per subsweep The range of the expected nominal power can be calculated as follows: Range (Expected Nominal Power) = Range (Input Power) + External Attenuation - User Margin The input power range is stated in the data sheet. Unit: dBm
 		"""
 		param = Conversions.list_to_csv_str(exp_nom_power)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQVSlot:LIST:ENPower:ALL {param}')
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/IqVsSlot_/Trigger.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/IqRecorder/Trigger.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,32 +1,32 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Trigger:
-	"""Trigger commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class TriggerCls:
+	"""Trigger commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("trigger", core, parent)
+		self._cmd_group = CommandsGroup("trigger", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_source(self) -> enums.TriggerSource:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:TRIGger:SOURce \n
-		Snippet: value: enums.TriggerSource = driver.configure.iqVsSlot.trigger.get_source() \n
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:TRIGger:SOURce \n
+		Snippet: value: enums.TriggerSource = driver.configure.iqRecorder.trigger.get_source() \n
 		No command help available \n
 			:return: source: No help available
 		"""
-		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQVSlot:TRIGger:SOURce?')
+		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQRecorder:TRIGger:SOURce?')
 		return Conversions.str_to_scalar_enum(response, enums.TriggerSource)
 
 	def set_source(self, source: enums.TriggerSource) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:TRIGger:SOURce \n
-		Snippet: driver.configure.iqVsSlot.trigger.set_source(source = enums.TriggerSource.EXTernal) \n
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQRecorder:TRIGger:SOURce \n
+		Snippet: driver.configure.iqRecorder.trigger.set_source(source = enums.TriggerSource.EXTernal) \n
 		No command help available \n
 			:param source: No help available
 		"""
 		param = Conversions.enum_scalar_to_str(source, enums.TriggerSource)
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQVSlot:TRIGger:SOURce {param}')
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQRecorder:TRIGger:SOURce {param}')
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Nrpm.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Nrpm/__init__.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ... import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Nrpm:
-	"""Nrpm commands group definition. 4 total commands, 1 Sub-groups, 3 group commands"""
+class NrpmCls:
+	"""Nrpm commands group definition. 4 total commands, 1 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("nrpm", core, parent)
+		self._cmd_group = CommandsGroup("nrpm", core, parent)
 
 	@property
 	def sensor(self):
 		"""sensor commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_sensor'):
-			from .Nrpm_.Sensor import Sensor
-			self._sensor = Sensor(self._core, self._base)
+			from .Sensor import SensorCls
+			self._sensor = SensorCls(self._core, self._cmd_group)
 		return self._sensor
 
 	def get_scount(self) -> int:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:NRPM:SCOunt \n
 		Snippet: value: int = driver.configure.nrpm.get_scount() \n
 		No command help available \n
 			:return: statistic_count: No help available
@@ -71,14 +71,14 @@
 		Snippet: driver.configure.nrpm.set_timeout(tcd_timeout = 1.0) \n
 		No command help available \n
 			:param tcd_timeout: No help available
 		"""
 		param = Conversions.decimal_value_to_str(tcd_timeout)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:NRPM:TOUT {param}')
 
-	def clone(self) -> 'Nrpm':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'NrpmCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Nrpm(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = NrpmCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Nrpm_/Sensor.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Nrpm/Sensor/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal.RepeatedCapability import RepeatedCapability
-from .... import repcap
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal.RepeatedCapability import RepeatedCapability
+from ..... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Sensor:
-	"""Sensor commands group definition. 1 total commands, 1 Sub-groups, 0 group commands
+class SensorCls:
+	"""Sensor commands group definition. 1 total commands, 1 Subgroups, 0 group commands
 	Repeated Capability: Sensor, default value after init: Sensor.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("sensor", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_sensor_get', 'repcap_sensor_set', repcap.Sensor.Nr1)
+		self._cmd_group = CommandsGroup("sensor", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_sensor_get', 'repcap_sensor_set', repcap.Sensor.Nr1)
 
-	def repcap_sensor_set(self, enum_value: repcap.Sensor) -> None:
+	def repcap_sensor_set(self, sensor: repcap.Sensor) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to Sensor.Default
 		Default value after init: Sensor.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(sensor)
 
 	def repcap_sensor_get(self) -> repcap.Sensor:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def frequency(self):
 		"""frequency commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_frequency'):
-			from .Sensor_.Frequency import Frequency
-			self._frequency = Frequency(self._core, self._base)
+			from .Frequency import FrequencyCls
+			self._frequency = FrequencyCls(self._core, self._cmd_group)
 		return self._frequency
 
-	def clone(self) -> 'Sensor':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SensorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Sensor(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SensorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Nrpm_/Sensor_/Frequency.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Nrpm/Sensor/Frequency.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,33 +1,34 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 from ..... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Frequency:
-	"""Frequency commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class FrequencyCls:
+	"""Frequency commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("frequency", core, parent)
+		self._cmd_group = CommandsGroup("frequency", core, parent)
 
 	def set(self, frequency: float, sensor=repcap.Sensor.Default) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:NRPM:SENSor<nr_NRPM>:FREQuency \n
 		Snippet: driver.configure.nrpm.sensor.frequency.set(frequency = 1.0, sensor = repcap.Sensor.Default) \n
 		No command help available \n
 			:param frequency: No help available
-			:param sensor: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Sensor')"""
+			:param sensor: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Sensor')
+		"""
 		param = Conversions.decimal_value_to_str(frequency)
-		sensor_cmd_val = self._base.get_repcap_cmd_value(sensor, repcap.Sensor)
+		sensor_cmd_val = self._cmd_group.get_repcap_cmd_value(sensor, repcap.Sensor)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:NRPM:SENSor{sensor_cmd_val}:FREQuency {param}')
 
 	def get(self, sensor=repcap.Sensor.Default) -> float:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:NRPM:SENSor<nr_NRPM>:FREQuency \n
 		Snippet: value: float = driver.configure.nrpm.sensor.frequency.get(sensor = repcap.Sensor.Default) \n
 		No command help available \n
 			:param sensor: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Sensor')
 			:return: frequency: No help available"""
-		sensor_cmd_val = self._base.get_repcap_cmd_value(sensor, repcap.Sensor)
+		sensor_cmd_val = self._cmd_group.get_repcap_cmd_value(sensor, repcap.Sensor)
 		response = self._core.io.query_str(f'CONFigure:GPRF:MEASurement<Instance>:NRPM:SENSor{sensor_cmd_val}:FREQuency?')
 		return Conversions.str_to_float(response)
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Ploss.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Spectrum/ZeroSpan/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,62 +1,54 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Ploss:
-	"""Ploss commands group definition. 4 total commands, 3 Sub-groups, 1 group commands"""
+class ZeroSpanCls:
+	"""ZeroSpan commands group definition. 6 total commands, 2 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ploss", core, parent)
+		self._cmd_group = CommandsGroup("zeroSpan", core, parent)
 
 	@property
-	def view(self):
-		"""view commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_view'):
-			from .Ploss_.View import View
-			self._view = View(self._core, self._base)
-		return self._view
+	def rbw(self):
+		"""rbw commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_rbw'):
+			from .Rbw import RbwCls
+			self._rbw = RbwCls(self._core, self._cmd_group)
+		return self._rbw
 
 	@property
-	def listPy(self):
-		"""listPy commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_listPy'):
-			from .Ploss_.ListPy import ListPy
-			self._listPy = ListPy(self._core, self._base)
-		return self._listPy
-
-	@property
-	def mpath(self):
-		"""mpath commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_mpath'):
-			from .Ploss_.Mpath import Mpath
-			self._mpath = Mpath(self._core, self._base)
-		return self._mpath
-
-	def get_trace(self) -> bool:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:PLOSs:TRACe \n
-		Snippet: value: bool = driver.configure.ploss.get_trace() \n
-		Selects whether a result diagram is provided. \n
-			:return: trace_mode: OFF | ON OFF: no result diagram, faster measurement ON: result diagram, slower measurement
+	def vbw(self):
+		"""vbw commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_vbw'):
+			from .Vbw import VbwCls
+			self._vbw = VbwCls(self._core, self._cmd_group)
+		return self._vbw
+
+	def get_swt(self) -> float:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:ZSPan:SWT \n
+		Snippet: value: float = driver.configure.spectrum.zeroSpan.get_swt() \n
+		Configures the duration of one measurement interval for the zero span mode. \n
+			:return: sweep_time: numeric Range: 0 s to 2000 s, Unit: s
 		"""
-		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:PLOSs:TRACe?')
-		return Conversions.str_to_bool(response)
+		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:SPECtrum:ZSPan:SWT?')
+		return Conversions.str_to_float(response)
 
-	def set_trace(self, trace_mode: bool) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:PLOSs:TRACe \n
-		Snippet: driver.configure.ploss.set_trace(trace_mode = False) \n
-		Selects whether a result diagram is provided. \n
-			:param trace_mode: OFF | ON OFF: no result diagram, faster measurement ON: result diagram, slower measurement
+	def set_swt(self, sweep_time: float) -> None:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:ZSPan:SWT \n
+		Snippet: driver.configure.spectrum.zeroSpan.set_swt(sweep_time = 1.0) \n
+		Configures the duration of one measurement interval for the zero span mode. \n
+			:param sweep_time: numeric Range: 0 s to 2000 s, Unit: s
 		"""
-		param = Conversions.bool_to_str(trace_mode)
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:PLOSs:TRACe {param}')
+		param = Conversions.decimal_value_to_str(sweep_time)
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:SPECtrum:ZSPan:SWT {param}')
 
-	def clone(self) -> 'Ploss':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ZeroSpanCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Ploss(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ZeroSpanCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Ploss_/ListPy.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Ploss/ListPy/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ListPy:
-	"""ListPy commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class ListPyCls:
+	"""ListPy commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("listPy", core, parent)
+		self._cmd_group = CommandsGroup("listPy", core, parent)
 
 	@property
 	def frequency(self):
 		"""frequency commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_frequency'):
-			from .ListPy_.Frequency import Frequency
-			self._frequency = Frequency(self._core, self._base)
+			from .Frequency import FrequencyCls
+			self._frequency = FrequencyCls(self._core, self._cmd_group)
 		return self._frequency
 
-	def clone(self) -> 'ListPy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ListPyCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ListPy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ListPyCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Ploss_/Mpath.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Ploss/Mpath/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Mpath:
-	"""Mpath commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class MpathCls:
+	"""Mpath commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("mpath", core, parent)
+		self._cmd_group = CommandsGroup("mpath", core, parent)
 
 	@property
 	def listPy(self):
 		"""listPy commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_listPy'):
-			from .Mpath_.ListPy import ListPy
-			self._listPy = ListPy(self._core, self._base)
+			from .ListPy import ListPyCls
+			self._listPy = ListPyCls(self._core, self._cmd_group)
 		return self._listPy
 
-	def clone(self) -> 'Mpath':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MpathCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Mpath(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MpathCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Ploss_/Mpath_/ListPy.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Ploss/Mpath/ListPy/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ListPy:
-	"""ListPy commands group definition. 1 total commands, 1 Sub-groups, 0 group commands"""
+class ListPyCls:
+	"""ListPy commands group definition. 1 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("listPy", core, parent)
+		self._cmd_group = CommandsGroup("listPy", core, parent)
 
 	@property
 	def frequency(self):
 		"""frequency commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_frequency'):
-			from .ListPy_.Frequency import Frequency
-			self._frequency = Frequency(self._core, self._base)
+			from .Frequency import FrequencyCls
+			self._frequency = FrequencyCls(self._core, self._cmd_group)
 		return self._frequency
 
-	def clone(self) -> 'ListPy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ListPyCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ListPy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ListPyCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Ploss_/View.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Canalyzer/IqFile.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,30 +1,30 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
+from ....Internal.Utilities import trim_str_response
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class View:
-	"""View commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class IqFileCls:
+	"""IqFile commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("view", core, parent)
+		self._cmd_group = CommandsGroup("iqFile", core, parent)
 
-	def get_aftaps(self) -> int:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:PLOSs:VIEW:AFTaps \n
-		Snippet: value: int = driver.configure.ploss.view.get_aftaps() \n
-		Configures the number of frequencies over which the gain results are averaged. \n
-			:return: avg_filter_taps: Range: 1 to 21
+	def set(self, filename: str) -> None:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:CANalyzer:IQFile \n
+		Snippet: driver.configure.canalyzer.iqFile.set(filename = 'abc') \n
+		No command help available \n
+			:param filename: No help available
 		"""
-		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:PLOSs:VIEW:AFTaps?')
-		return Conversions.str_to_int(response)
+		param = Conversions.value_to_quoted_str(filename)
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:CANalyzer:IQFile {param}')
 
-	def set_aftaps(self, avg_filter_taps: int) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:PLOSs:VIEW:AFTaps \n
-		Snippet: driver.configure.ploss.view.set_aftaps(avg_filter_taps = 1) \n
-		Configures the number of frequencies over which the gain results are averaged. \n
-			:param avg_filter_taps: Range: 1 to 21
-		"""
-		param = Conversions.decimal_value_to_str(avg_filter_taps)
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:PLOSs:VIEW:AFTaps {param}')
+	def get(self) -> str:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:CANalyzer:IQFile \n
+		Snippet: value: str = driver.configure.canalyzer.iqFile.get() \n
+		No command help available \n
+			:return: filename_return: No help available"""
+		response = self._core.io.query_str(f'CONFigure:GPRF:MEASurement<Instance>:CANalyzer:IQFile?')
+		return trim_str_response(response)
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,149 +1,145 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ...Internal.Utilities import trim_str_response
-from ... import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from ....Internal.Utilities import trim_str_response
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Power:
-	"""Power commands group definition. 48 total commands, 5 Sub-groups, 7 group commands"""
+class PowerCls:
+	"""Power commands group definition. 48 total commands, 5 Subgroups, 7 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("power", core, parent)
+		self._cmd_group = CommandsGroup("power", core, parent)
 
 	@property
 	def parameterSetList(self):
 		"""parameterSetList commands group. 5 Sub-classes, 1 commands."""
 		if not hasattr(self, '_parameterSetList'):
-			from .Power_.ParameterSetList import ParameterSetList
-			self._parameterSetList = ParameterSetList(self._core, self._base)
+			from .ParameterSetList import ParameterSetListCls
+			self._parameterSetList = ParameterSetListCls(self._core, self._cmd_group)
 		return self._parameterSetList
 
 	@property
 	def catalog(self):
 		"""catalog commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_catalog'):
-			from .Power_.Catalog import Catalog
-			self._catalog = Catalog(self._core, self._base)
+			from .Catalog import CatalogCls
+			self._catalog = CatalogCls(self._core, self._cmd_group)
 		return self._catalog
 
 	@property
 	def trigger(self):
 		"""trigger commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_trigger'):
-			from .Power_.Trigger import Trigger
-			self._trigger = Trigger(self._core, self._base)
+			from .Trigger import TriggerCls
+			self._trigger = TriggerCls(self._core, self._cmd_group)
 		return self._trigger
 
 	@property
 	def filterPy(self):
 		"""filterPy commands group. 2 Sub-classes, 1 commands."""
 		if not hasattr(self, '_filterPy'):
-			from .Power_.FilterPy import FilterPy
-			self._filterPy = FilterPy(self._core, self._base)
+			from .FilterPy import FilterPyCls
+			self._filterPy = FilterPyCls(self._core, self._cmd_group)
 		return self._filterPy
 
 	@property
 	def listPy(self):
-		"""listPy commands group. 7 Sub-classes, 7 commands."""
+		"""listPy commands group. 8 Sub-classes, 6 commands."""
 		if not hasattr(self, '_listPy'):
-			from .Power_.ListPy import ListPy
-			self._listPy = ListPy(self._core, self._base)
+			from .ListPy import ListPyCls
+			self._listPy = ListPyCls(self._core, self._cmd_group)
 		return self._listPy
 
 	# noinspection PyTypeChecker
 	def get_mode(self) -> enums.CcdfMode:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:MODE \n
 		Snippet: value: enums.CcdfMode = driver.configure.power.get_mode() \n
-		Sets/gets the result mode for the single-step power measurement. Note that the result mode has to be set before the power
-		measurement is started. \n
-			:return: ccdf_mode: POWer | STATistic POWer: power mode, only summary statistics calculated (minimum, maximum, average, standard deviation) STATistic: statistic mode, power distributions/densities calculated
+		Selects the measurement mode for measurements without list mode. Select the mode before starting the power measurement. \n
+			:return: ccdf_mode: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:POWer:MODE?')
 		return Conversions.str_to_scalar_enum(response, enums.CcdfMode)
 
 	def set_mode(self, ccdf_mode: enums.CcdfMode) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:MODE \n
 		Snippet: driver.configure.power.set_mode(ccdf_mode = enums.CcdfMode.POWer) \n
-		Sets/gets the result mode for the single-step power measurement. Note that the result mode has to be set before the power
-		measurement is started. \n
-			:param ccdf_mode: POWer | STATistic POWer: power mode, only summary statistics calculated (minimum, maximum, average, standard deviation) STATistic: statistic mode, power distributions/densities calculated
+		Selects the measurement mode for measurements without list mode. Select the mode before starting the power measurement. \n
+			:param ccdf_mode: POWer | STATistic POWer: 'Power' mode STATistic: 'Statistic' mode
 		"""
 		param = Conversions.enum_scalar_to_str(ccdf_mode, enums.CcdfMode)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:MODE {param}')
 
 	def get_timeout(self) -> float:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:TOUT \n
 		Snippet: value: float = driver.configure.power.get_timeout() \n
 		Defines a timeout for the measurement. The timer is started when the measurement is initiated via a READ or INIT command.
-		It is not started if the measurement is initiated manually ([ON | OFF] key or [RESTART | STOP] key) .
-		When the measurement has completed the first measurement cycle (first single shot) , the statistical depth is reached and
-		the timer is reset. If the first measurement cycle has not been completed when the timer expires, the measurement is
-		stopped. The measurement state changes to RDY. The reliability indicator is set to 1, indicating that a measurement
-		timeout occurred. Still running READ, FETCh or CALCulate commands are completed, returning the available results.
-		At least for some results, there are no values at all or the statistical depth has not been reached. A timeout of 0 s
-		corresponds to an infinite measurement timeout. \n
-			:return: tcd_timeout: Unit: s
+		It is not started if the measurement is initiated manually. When the measurement has completed the first measurement
+		cycle (first single shot) , the statistical depth is reached and the timer is reset. If the first measurement cycle has
+		not been completed when the timer expires, the measurement is stopped. The measurement state changes to RDY.
+		The reliability indicator is set to 1, indicating that a measurement timeout occurred. Still running READ, FETCh or
+		CALCulate commands are completed, returning the available results. At least for some results, there are no values at all
+		or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite measurement timeout. \n
+			:return: tcd_timeout: numeric Unit: s
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:POWer:TOUT?')
 		return Conversions.str_to_float(response)
 
 	def set_timeout(self, tcd_timeout: float) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:TOUT \n
 		Snippet: driver.configure.power.set_timeout(tcd_timeout = 1.0) \n
 		Defines a timeout for the measurement. The timer is started when the measurement is initiated via a READ or INIT command.
-		It is not started if the measurement is initiated manually ([ON | OFF] key or [RESTART | STOP] key) .
-		When the measurement has completed the first measurement cycle (first single shot) , the statistical depth is reached and
-		the timer is reset. If the first measurement cycle has not been completed when the timer expires, the measurement is
-		stopped. The measurement state changes to RDY. The reliability indicator is set to 1, indicating that a measurement
-		timeout occurred. Still running READ, FETCh or CALCulate commands are completed, returning the available results.
-		At least for some results, there are no values at all or the statistical depth has not been reached. A timeout of 0 s
-		corresponds to an infinite measurement timeout. \n
-			:param tcd_timeout: Unit: s
+		It is not started if the measurement is initiated manually. When the measurement has completed the first measurement
+		cycle (first single shot) , the statistical depth is reached and the timer is reset. If the first measurement cycle has
+		not been completed when the timer expires, the measurement is stopped. The measurement state changes to RDY.
+		The reliability indicator is set to 1, indicating that a measurement timeout occurred. Still running READ, FETCh or
+		CALCulate commands are completed, returning the available results. At least for some results, there are no values at all
+		or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite measurement timeout. \n
+			:param tcd_timeout: numeric Unit: s
 		"""
 		param = Conversions.decimal_value_to_str(tcd_timeout)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:TOUT {param}')
 
 	def get_slength(self) -> float:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:SLENgth \n
 		Snippet: value: float = driver.configure.power.get_slength() \n
-		Selects the time between the beginning of two consecutive measured power steps. \n
-			:return: step_length: Range: 50E-6 s to 1 s, Unit: s
+		Sets the time between the beginning of two consecutive measurement lengths. \n
+			:return: step_length: numeric Unit: s
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:POWer:SLENgth?')
 		return Conversions.str_to_float(response)
 
 	def set_slength(self, step_length: float) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:SLENgth \n
 		Snippet: driver.configure.power.set_slength(step_length = 1.0) \n
-		Selects the time between the beginning of two consecutive measured power steps. \n
-			:param step_length: Range: 50E-6 s to 1 s, Unit: s
+		Sets the time between the beginning of two consecutive measurement lengths. \n
+			:param step_length: numeric Unit: s
 		"""
 		param = Conversions.decimal_value_to_str(step_length)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:SLENgth {param}')
 
 	def get_mlength(self) -> float:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:MLENgth \n
 		Snippet: value: float = driver.configure.power.get_mlength() \n
-		Selects the length of the averaging intervals that the R&S CMW uses to calculate the power results for each measurement
-		step. The measurement length must not exceed the step length (method RsCmwGprfMeas.Configure.Power.slength) . \n
-			:return: meas_length: Range: 10E-6 s to 1 s, Unit: s
+		Sets the length of the evaluation interval used to measure a single set of current power results. The measurement length
+		cannot be greater than the step length. \n
+			:return: meas_length: numeric Unit: s
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:POWer:MLENgth?')
 		return Conversions.str_to_float(response)
 
 	def set_mlength(self, meas_length: float) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:MLENgth \n
 		Snippet: driver.configure.power.set_mlength(meas_length = 1.0) \n
-		Selects the length of the averaging intervals that the R&S CMW uses to calculate the power results for each measurement
-		step. The measurement length must not exceed the step length (method RsCmwGprfMeas.Configure.Power.slength) . \n
-			:param meas_length: Range: 10E-6 s to 1 s, Unit: s
+		Sets the length of the evaluation interval used to measure a single set of current power results. The measurement length
+		cannot be greater than the step length. \n
+			:param meas_length: numeric Unit: s
 		"""
 		param = Conversions.decimal_value_to_str(meas_length)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:MLENgth {param}')
 
 	# noinspection PyTypeChecker
 	def get_repetition(self) -> enums.Repeat:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:REPetition \n
@@ -168,51 +164,51 @@
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:REPetition {param}')
 
 	def get_scount(self) -> int:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:SCOunt \n
 		Snippet: value: int = driver.configure.power.get_scount() \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. \n
-			:return: statistic_count: Number of measurement intervals. A measurement interval comprises a single power/frequency step (list mode switched off) or a sweep (list mode switched on) . Range: 1 to 100E+3
+			:return: statistic_count: numeric Number of measurement intervals Range: 1 to 100E+3
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:POWer:SCOunt?')
 		return Conversions.str_to_int(response)
 
 	def set_scount(self, statistic_count: int) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:SCOunt \n
 		Snippet: driver.configure.power.set_scount(statistic_count = 1) \n
 		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
 		single shot. \n
-			:param statistic_count: Number of measurement intervals. A measurement interval comprises a single power/frequency step (list mode switched off) or a sweep (list mode switched on) . Range: 1 to 100E+3
+			:param statistic_count: numeric Number of measurement intervals Range: 1 to 100E+3
 		"""
 		param = Conversions.decimal_value_to_str(statistic_count)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:SCOunt {param}')
 
 	def get_pdef_set(self) -> str:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:PDEFset \n
 		Snippet: value: str = driver.configure.power.get_pdef_set() \n
 		This command is related to the global parameter set. A setting command loads a predefined set of parameters into the
 		global parameter set. A query returns the name of the predefined set assigned to the global parameter set. To get a list
 		of predefined-set strings, use method RsCmwGprfMeas.Configure.Power.ParameterSetList.Catalog.pdefSet. \n
-			:return: predefined_set: Predefined set as string
+			:return: predefined_set: string
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:POWer:PDEFset?')
 		return trim_str_response(response)
 
 	def set_pdef_set(self, predefined_set: str) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:PDEFset \n
-		Snippet: driver.configure.power.set_pdef_set(predefined_set = '1') \n
+		Snippet: driver.configure.power.set_pdef_set(predefined_set = 'abc') \n
 		This command is related to the global parameter set. A setting command loads a predefined set of parameters into the
 		global parameter set. A query returns the name of the predefined set assigned to the global parameter set. To get a list
 		of predefined-set strings, use method RsCmwGprfMeas.Configure.Power.ParameterSetList.Catalog.pdefSet. \n
-			:param predefined_set: Predefined set as string
+			:param predefined_set: string
 		"""
 		param = Conversions.value_to_quoted_str(predefined_set)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:PDEFset {param}')
 
-	def clone(self) -> 'Power':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PowerCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Power(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PowerCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/FilterPy.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/FilterPy/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,56 +1,56 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from .... import enums
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class FilterPy:
-	"""FilterPy commands group definition. 3 total commands, 2 Sub-groups, 1 group commands"""
+class FilterPyCls:
+	"""FilterPy commands group definition. 3 total commands, 2 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("filterPy", core, parent)
+		self._cmd_group = CommandsGroup("filterPy", core, parent)
 
 	@property
 	def bandpass(self):
 		"""bandpass commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_bandpass'):
-			from .FilterPy_.Bandpass import Bandpass
-			self._bandpass = Bandpass(self._core, self._base)
+			from .Bandpass import BandpassCls
+			self._bandpass = BandpassCls(self._core, self._cmd_group)
 		return self._bandpass
 
 	@property
 	def gauss(self):
 		"""gauss commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_gauss'):
-			from .FilterPy_.Gauss import Gauss
-			self._gauss = Gauss(self._core, self._base)
+			from .Gauss import GaussCls
+			self._gauss = GaussCls(self._core, self._cmd_group)
 		return self._gauss
 
 	# noinspection PyTypeChecker
 	def get_type_py(self) -> enums.DigitalFilterType:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:FILTer:TYPE \n
 		Snippet: value: enums.DigitalFilterType = driver.configure.power.filterPy.get_type_py() \n
 		Selects the IF filter type. \n
-			:return: filter_type: BANDpass | GAUSs | WCDMa | CDMA | TDSCdma BANDpass: Bandpass filter with selectable bandwidth GAUSs: Filter of Gaussian shape with selectable bandwidth WCDMA: 3.84 MHz RRC filter with a roll-off = 0.22 for WCDMA TX tests CDMA: 1.2288 MHz-wide channel filter for CDMA 2000 TX tests TDSCdma: 1.28 MHz RRC filter with a roll-off = 0.22 for TD-SCDMA TX tests
+			:return: filter_type: BANDpass | GAUSs | WCDMa | CDMA | TDSCdma BANDpass: bandpass filter GAUSs: Gaussian filter WCDMA: 3.84-MHz RRC filter for WCDMA TX tests CDMA: 1.2288-MHz channel filter for CDMA 2000 TX tests TDSCdma: 1.28-MHz RRC filter for TD-SCDMA TX tests
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:POWer:FILTer:TYPE?')
 		return Conversions.str_to_scalar_enum(response, enums.DigitalFilterType)
 
 	def set_type_py(self, filter_type: enums.DigitalFilterType) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:FILTer:TYPE \n
 		Snippet: driver.configure.power.filterPy.set_type_py(filter_type = enums.DigitalFilterType.BANDpass) \n
 		Selects the IF filter type. \n
-			:param filter_type: BANDpass | GAUSs | WCDMa | CDMA | TDSCdma BANDpass: Bandpass filter with selectable bandwidth GAUSs: Filter of Gaussian shape with selectable bandwidth WCDMA: 3.84 MHz RRC filter with a roll-off = 0.22 for WCDMA TX tests CDMA: 1.2288 MHz-wide channel filter for CDMA 2000 TX tests TDSCdma: 1.28 MHz RRC filter with a roll-off = 0.22 for TD-SCDMA TX tests
+			:param filter_type: BANDpass | GAUSs | WCDMa | CDMA | TDSCdma BANDpass: bandpass filter GAUSs: Gaussian filter WCDMA: 3.84-MHz RRC filter for WCDMA TX tests CDMA: 1.2288-MHz channel filter for CDMA 2000 TX tests TDSCdma: 1.28-MHz RRC filter for TD-SCDMA TX tests
 		"""
 		param = Conversions.enum_scalar_to_str(filter_type, enums.DigitalFilterType)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:FILTer:TYPE {param}')
 
-	def clone(self) -> 'FilterPy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'FilterPyCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = FilterPy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = FilterPyCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/FilterPy_/Bandpass.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/FilterPy/Bandpass.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,30 +1,30 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Bandpass:
-	"""Bandpass commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class BandpassCls:
+	"""Bandpass commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("bandpass", core, parent)
+		self._cmd_group = CommandsGroup("bandpass", core, parent)
 
 	def get_bandwidth(self) -> float:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:FILTer:BANDpass:BWIDth \n
 		Snippet: value: float = driver.configure.power.filterPy.bandpass.get_bandwidth() \n
 		Selects the bandwidth for a bandpass filter. \n
-			:return: bandpass_bw: Only the values listed in the table can be configured. Values in-between can be entered but are rounded to the listed values. Range: 1 kHz to 160 MHz, Unit: Hz
+			:return: bandpass_bw: numeric For allowed values, see Table 'Supported values'. Unit: Hz
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:POWer:FILTer:BANDpass:BWIDth?')
 		return Conversions.str_to_float(response)
 
 	def set_bandwidth(self, bandpass_bw: float) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:FILTer:BANDpass:BWIDth \n
 		Snippet: driver.configure.power.filterPy.bandpass.set_bandwidth(bandpass_bw = 1.0) \n
 		Selects the bandwidth for a bandpass filter. \n
-			:param bandpass_bw: Only the values listed in the table can be configured. Values in-between can be entered but are rounded to the listed values. Range: 1 kHz to 160 MHz, Unit: Hz
+			:param bandpass_bw: numeric For allowed values, see Table 'Supported values'. Unit: Hz
 		"""
 		param = Conversions.decimal_value_to_str(bandpass_bw)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:FILTer:BANDpass:BWIDth {param}')
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ListPy.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/Power/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,217 +1,180 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
-from ....Internal.StructBase import StructBase
-from ....Internal.ArgStruct import ArgStruct
+from ....Internal.Utilities import trim_str_response
 from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ListPy:
-	"""ListPy commands group definition. 23 total commands, 7 Sub-groups, 7 group commands"""
+class PowerCls:
+	"""Power commands group definition. 10 total commands, 2 Subgroups, 7 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("listPy", core, parent)
+		self._cmd_group = CommandsGroup("power", core, parent)
 
 	@property
-	def singleCmw(self):
-		"""singleCmw commands group. 1 Sub-classes, 1 commands."""
-		if not hasattr(self, '_singleCmw'):
-			from .ListPy_.SingleCmw import SingleCmw
-			self._singleCmw = SingleCmw(self._core, self._base)
-		return self._singleCmw
-
-	@property
-	def iqData(self):
-		"""iqData commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_iqData'):
-			from .ListPy_.IqData import IqData
-			self._iqData = IqData(self._core, self._base)
-		return self._iqData
-
-	@property
-	def frequency(self):
-		"""frequency commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_frequency'):
-			from .ListPy_.Frequency import Frequency
-			self._frequency = Frequency(self._core, self._base)
-		return self._frequency
-
-	@property
-	def envelopePower(self):
-		"""envelopePower commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_envelopePower'):
-			from .ListPy_.EnvelopePower import EnvelopePower
-			self._envelopePower = EnvelopePower(self._core, self._base)
-		return self._envelopePower
-
-	@property
-	def retrigger(self):
-		"""retrigger commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_retrigger'):
-			from .ListPy_.Retrigger import Retrigger
-			self._retrigger = Retrigger(self._core, self._base)
-		return self._retrigger
-
-	@property
-	def irepetition(self):
-		"""irepetition commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_irepetition'):
-			from .ListPy_.Irepetition import Irepetition
-			self._irepetition = Irepetition(self._core, self._base)
-		return self._irepetition
+	def catalog(self):
+		"""catalog commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_catalog'):
+			from .Catalog import CatalogCls
+			self._catalog = CatalogCls(self._core, self._cmd_group)
+		return self._catalog
 
 	@property
 	def parameterSetList(self):
-		"""parameterSetList commands group. 0 Sub-classes, 2 commands."""
+		"""parameterSetList commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_parameterSetList'):
-			from .ListPy_.ParameterSetList import ParameterSetList
-			self._parameterSetList = ParameterSetList(self._core, self._base)
+			from .ParameterSetList import ParameterSetListCls
+			self._parameterSetList = ParameterSetListCls(self._core, self._cmd_group)
 		return self._parameterSetList
 
-	# noinspection PyTypeChecker
-	def get_txi_timing(self) -> enums.Timing:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:TXITiming \n
-		Snippet: value: enums.Timing = driver.configure.power.listPy.get_txi_timing() \n
-		Specifies the timing of the generated 'GPRF Meas<i>:Power' trigger. \n
-			:return: timing: STEP | CENTered STEP: Trigger signals are generated at the step boundaries. CENTered: Trigger signals are generated in the middle of the gaps between subsequent measurement intervals.
-		"""
-		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:TXITiming?')
-		return Conversions.str_to_scalar_enum(response, enums.Timing)
-
-	def set_txi_timing(self, timing: enums.Timing) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:TXITiming \n
-		Snippet: driver.configure.power.listPy.set_txi_timing(timing = enums.Timing.CENTered) \n
-		Specifies the timing of the generated 'GPRF Meas<i>:Power' trigger. \n
-			:param timing: STEP | CENTered STEP: Trigger signals are generated at the step boundaries. CENTered: Trigger signals are generated in the middle of the gaps between subsequent measurement intervals.
+	def get_source(self) -> str:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:SOURce \n
+		Snippet: value: str = driver.trigger.power.get_source() \n
+		Selects the source of the trigger events. Some values are always available. They are listed below. Depending on the
+		installed options, additional values are available. You can query a list of all supported values via TRIGger:...
+		:CATalog:SOURce?. \n
+			:return: source: string 'IF Power': IF power trigger 'Free Run': free run (untriggered)
+		"""
+		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:POWer:SOURce?')
+		return trim_str_response(response)
+
+	def set_source(self, source: str) -> None:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:SOURce \n
+		Snippet: driver.trigger.power.set_source(source = 'abc') \n
+		Selects the source of the trigger events. Some values are always available. They are listed below. Depending on the
+		installed options, additional values are available. You can query a list of all supported values via TRIGger:...
+		:CATalog:SOURce?. \n
+			:param source: string 'IF Power': IF power trigger 'Free Run': free run (untriggered)
+		"""
+		param = Conversions.value_to_quoted_str(source)
+		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:POWer:SOURce {param}')
+
+	def get_mgap(self) -> float:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:MGAP \n
+		Snippet: value: float = driver.trigger.power.get_mgap() \n
+		Sets a minimum time during which the IF signal must be below the trigger threshold before the trigger is armed so that an
+		IF power trigger event can be generated. \n
+			:return: minimum_gap: numeric Range: 0 s to 0.01 s, Unit: s
+		"""
+		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:POWer:MGAP?')
+		return Conversions.str_to_float(response)
+
+	def set_mgap(self, minimum_gap: float) -> None:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:MGAP \n
+		Snippet: driver.trigger.power.set_mgap(minimum_gap = 1.0) \n
+		Sets a minimum time during which the IF signal must be below the trigger threshold before the trigger is armed so that an
+		IF power trigger event can be generated. \n
+			:param minimum_gap: numeric Range: 0 s to 0.01 s, Unit: s
+		"""
+		param = Conversions.decimal_value_to_str(minimum_gap)
+		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:POWer:MGAP {param}')
+
+	def get_timeout(self) -> float or bool:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:TOUT \n
+		Snippet: value: float or bool = driver.trigger.power.get_timeout() \n
+		Selects the maximum time that the measurement waits for a trigger event before it stops in remote control mode or
+		indicates a trigger timeout in manual operation mode. This setting has no influence on 'Free Run' measurements. \n
+			:return: timeout: (float or boolean) Range: 0.01 s to 300 s, Unit: s ON | OFF enables or disables the timeout check.
+		"""
+		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:POWer:TOUT?')
+		return Conversions.str_to_float_or_bool(response)
+
+	def set_timeout(self, timeout: float or bool) -> None:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:TOUT \n
+		Snippet: driver.trigger.power.set_timeout(timeout = 1.0) \n
+		Selects the maximum time that the measurement waits for a trigger event before it stops in remote control mode or
+		indicates a trigger timeout in manual operation mode. This setting has no influence on 'Free Run' measurements. \n
+			:param timeout: (float or boolean) Range: 0.01 s to 300 s, Unit: s ON | OFF enables or disables the timeout check.
+		"""
+		param = Conversions.decimal_or_bool_value_to_str(timeout)
+		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:POWer:TOUT {param}')
+
+	def get_offset(self) -> float:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:OFFSet \n
+		Snippet: value: float = driver.trigger.power.get_offset() \n
+		Defines a delay time for triggered measurements. The trigger offset delays the start of the measurement relative to the
+		trigger event. \n
+			:return: offset: numeric Range: 0 s to 1 s, Unit: s
+		"""
+		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:POWer:OFFSet?')
+		return Conversions.str_to_float(response)
+
+	def set_offset(self, offset: float) -> None:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:OFFSet \n
+		Snippet: driver.trigger.power.set_offset(offset = 1.0) \n
+		Defines a delay time for triggered measurements. The trigger offset delays the start of the measurement relative to the
+		trigger event. \n
+			:param offset: numeric Range: 0 s to 1 s, Unit: s
 		"""
-		param = Conversions.enum_scalar_to_str(timing, enums.Timing)
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:TXITiming {param}')
+		param = Conversions.decimal_value_to_str(offset)
+		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:POWer:OFFSet {param}')
 
 	# noinspection PyTypeChecker
-	def get_munit(self) -> enums.MagnitudeUnit:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:MUNit \n
-		Snippet: value: enums.MagnitudeUnit = driver.configure.power.listPy.get_munit() \n
-		Selects the magnitude unit for I/Q measurement results. \n
-			:return: magnitude_unit: VOLT | RAW Voltage units or raw I/Q data relative to full scale
-		"""
-		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:MUNit?')
-		return Conversions.str_to_scalar_enum(response, enums.MagnitudeUnit)
-
-	def set_munit(self, magnitude_unit: enums.MagnitudeUnit) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:MUNit \n
-		Snippet: driver.configure.power.listPy.set_munit(magnitude_unit = enums.MagnitudeUnit.RAW) \n
-		Selects the magnitude unit for I/Q measurement results. \n
-			:param magnitude_unit: VOLT | RAW Voltage units or raw I/Q data relative to full scale
-		"""
-		param = Conversions.enum_scalar_to_str(magnitude_unit, enums.MagnitudeUnit)
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:MUNit {param}')
-
-	def get_count(self) -> int:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:COUNt \n
-		Snippet: value: int = driver.configure.power.listPy.get_count() \n
-		Queries the total number of steps (results) in the selected list section. The total number of results (segments with
-		repetitions) is limited by 10000. \n
-			:return: result_count: Range: 1 to 10E+3
-		"""
-		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:COUNt?')
-		return Conversions.str_to_int(response)
-
-	def get_start(self) -> int:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:STARt \n
-		Snippet: value: int = driver.configure.power.listPy.get_start() \n
-		Start index, defines the first list segment to be measured. The total number of results (segments with repetitions) in
-		the selected list section must not be higher than 10000. \n
-			:return: start_index: Range: 0 to 1999
-		"""
-		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:STARt?')
-		return Conversions.str_to_int(response)
-
-	def set_start(self, start_index: int) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:STARt \n
-		Snippet: driver.configure.power.listPy.set_start(start_index = 1) \n
-		Start index, defines the first list segment to be measured. The total number of results (segments with repetitions) in
-		the selected list section must not be higher than 10000. \n
-			:param start_index: Range: 0 to 1999
-		"""
-		param = Conversions.decimal_value_to_str(start_index)
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:STARt {param}')
-
-	def get_stop(self) -> int:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:STOP \n
-		Snippet: value: int = driver.configure.power.listPy.get_stop() \n
-		Stop index, defines the last list segment to be measured. The total number of results (segments with repetitions) in the
-		selected list section must not be higher than 10000. \n
-			:return: stop_index: Range: 0 to 3999
-		"""
-		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:STOP?')
-		return Conversions.str_to_int(response)
-
-	def set_stop(self, stop_index: int) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:STOP \n
-		Snippet: driver.configure.power.listPy.set_stop(stop_index = 1) \n
-		Stop index, defines the last list segment to be measured. The total number of results (segments with repetitions) in the
-		selected list section must not be higher than 10000. \n
-			:param stop_index: Range: 0 to 3999
+	def get_mode(self) -> enums.TriggerPowerMode:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:MODE \n
+		Snippet: value: enums.TriggerPowerMode = driver.trigger.power.get_mode() \n
+		Selects the measurement sequence that is triggered by each single trigger event. This setting is not valid for free run
+		measurements. \n
+			:return: mode: ONCE | SWEep | ALL | PRESelect ONCE: 'Trigger Once' SWEep: 'Retrigger Sweep' ALL: 'Retrigger All' PRESelect: 'Retrigger Preselect'
+		"""
+		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:POWer:MODE?')
+		return Conversions.str_to_scalar_enum(response, enums.TriggerPowerMode)
+
+	def set_mode(self, mode: enums.TriggerPowerMode) -> None:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:MODE \n
+		Snippet: driver.trigger.power.set_mode(mode = enums.TriggerPowerMode.ALL) \n
+		Selects the measurement sequence that is triggered by each single trigger event. This setting is not valid for free run
+		measurements. \n
+			:param mode: ONCE | SWEep | ALL | PRESelect ONCE: 'Trigger Once' SWEep: 'Retrigger Sweep' ALL: 'Retrigger All' PRESelect: 'Retrigger Preselect'
+		"""
+		param = Conversions.enum_scalar_to_str(mode, enums.TriggerPowerMode)
+		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:POWer:MODE {param}')
+
+	def get_threshold(self) -> float:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:THReshold \n
+		Snippet: value: float = driver.trigger.power.get_threshold() \n
+		Defines the trigger threshold for power trigger sources. \n
+			:return: threshold: numeric Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
+		"""
+		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:POWer:THReshold?')
+		return Conversions.str_to_float(response)
+
+	def set_threshold(self, threshold: float) -> None:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:THReshold \n
+		Snippet: driver.trigger.power.set_threshold(threshold = 1.0) \n
+		Defines the trigger threshold for power trigger sources. \n
+			:param threshold: numeric Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
 		"""
-		param = Conversions.decimal_value_to_str(stop_index)
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:STOP {param}')
+		param = Conversions.decimal_value_to_str(threshold)
+		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:POWer:THReshold {param}')
 
 	# noinspection PyTypeChecker
-	class SstopStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Start_Index: int: Range: 0 to 3999
-			- Stop_Index: int: Range: 0 to 3999"""
-		__meta_args_list = [
-			ArgStruct.scalar_int('Start_Index'),
-			ArgStruct.scalar_int('Stop_Index')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Start_Index: int = None
-			self.Stop_Index: int = None
-
-	def get_sstop(self) -> SstopStruct:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:SSTop \n
-		Snippet: value: SstopStruct = driver.configure.power.listPy.get_sstop() \n
-		Start and stop index of the list section to be measured. The total number of results (segments with repetitions) in the
-		list section must not be higher than 10000. \n
-			:return: structure: for return value, see the help for SstopStruct structure arguments.
-		"""
-		return self._core.io.query_struct('CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:SSTop?', self.__class__.SstopStruct())
-
-	def set_sstop(self, value: SstopStruct) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:SSTop \n
-		Snippet: driver.configure.power.listPy.set_sstop(value = SstopStruct()) \n
-		Start and stop index of the list section to be measured. The total number of results (segments with repetitions) in the
-		list section must not be higher than 10000. \n
-			:param value: see the help for SstopStruct structure arguments.
-		"""
-		self._core.io.write_struct('CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:SSTop', value)
-
-	def get_value(self) -> bool:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST \n
-		Snippet: value: bool = driver.configure.power.listPy.get_value() \n
-		Enables or disables the list mode for the power measurement. \n
-			:return: enable_list_mode: OFF | ON OFF: list mode off (single power step) ON: list mode on
-		"""
-		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:POWer:LIST?')
-		return Conversions.str_to_bool(response)
-
-	def set_value(self, enable_list_mode: bool) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST \n
-		Snippet: driver.configure.power.listPy.set_value(enable_list_mode = False) \n
-		Enables or disables the list mode for the power measurement. \n
-			:param enable_list_mode: OFF | ON OFF: list mode off (single power step) ON: list mode on
+	def get_slope(self) -> enums.SignalSlopeExt:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:SLOPe \n
+		Snippet: value: enums.SignalSlopeExt = driver.trigger.power.get_slope() \n
+		Qualifies whether the trigger event is generated at the rising or at the falling edge of the trigger pulse (valid for
+		external and power trigger sources) . \n
+			:return: event: REDGe | FEDGe REDGe: rising edge FEDGe: falling edge
+		"""
+		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:POWer:SLOPe?')
+		return Conversions.str_to_scalar_enum(response, enums.SignalSlopeExt)
+
+	def set_slope(self, event: enums.SignalSlopeExt) -> None:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:SLOPe \n
+		Snippet: driver.trigger.power.set_slope(event = enums.SignalSlopeExt.FALLing) \n
+		Qualifies whether the trigger event is generated at the rising or at the falling edge of the trigger pulse (valid for
+		external and power trigger sources) . \n
+			:param event: REDGe | FEDGe REDGe: rising edge FEDGe: falling edge
 		"""
-		param = Conversions.bool_to_str(enable_list_mode)
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:LIST {param}')
+		param = Conversions.enum_scalar_to_str(event, enums.SignalSlopeExt)
+		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:POWer:SLOPe {param}')
 
-	def clone(self) -> 'ListPy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PowerCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ListPy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PowerCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ListPy_/EnvelopePower.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/Mlength.py`

 * *Files 26% similar despite different names*

```diff
@@ -5,51 +5,55 @@
 from .....Internal import Conversions
 from .....Internal.Types import DataType
 from .....Internal.ArgSingleList import ArgSingleList
 from .....Internal.ArgSingle import ArgSingle
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class EnvelopePower:
-	"""EnvelopePower commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MlengthCls:
+	"""Mlength commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("envelopePower", core, parent)
+		self._cmd_group = CommandsGroup("mlength", core, parent)
 
-	def set(self, index: int, exp_nom_power: float) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:ENPower \n
-		Snippet: driver.configure.power.listPy.envelopePower.set(index = 1, exp_nom_power = 1.0) \n
-		Defines or queries the expected nominal power of a selected frequency/level step. \n
-			:param index: Number of the frequency/level step in the table Range: 0 to 3999
-			:param exp_nom_power: Expected nominal power of the frequency/level step Range: -55 dBm to 55 dBm, Unit: dBm
+	def set(self, index: int, meas_length: float) -> None:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:MLENgth \n
+		Snippet: driver.configure.power.parameterSetList.mlength.set(index = 1, meas_length = 1.0) \n
+		Sets the length of the evaluation interval used to measure a single set of current power results for the parameter set
+		<Index>. The measurement length cannot be greater than the step length. \n
+			:param index: integer Range: 0 to 31
+			:param meas_length: numeric Unit: s
 		"""
-		param = ArgSingleList().compose_cmd_string(ArgSingle('index', index, DataType.Integer), ArgSingle('exp_nom_power', exp_nom_power, DataType.Float))
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:ENPower {param}'.rstrip())
+		param = ArgSingleList().compose_cmd_string(ArgSingle('index', index, DataType.Integer), ArgSingle('meas_length', meas_length, DataType.Float))
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:MLENgth {param}'.rstrip())
 
 	def get(self, index: int) -> float:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:ENPower \n
-		Snippet: value: float = driver.configure.power.listPy.envelopePower.get(index = 1) \n
-		Defines or queries the expected nominal power of a selected frequency/level step. \n
-			:param index: Number of the frequency/level step in the table Range: 0 to 3999
-			:return: exp_nom_power: Expected nominal power of the frequency/level step Range: -55 dBm to 55 dBm, Unit: dBm"""
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:MLENgth \n
+		Snippet: value: float = driver.configure.power.parameterSetList.mlength.get(index = 1) \n
+		Sets the length of the evaluation interval used to measure a single set of current power results for the parameter set
+		<Index>. The measurement length cannot be greater than the step length. \n
+			:param index: integer Range: 0 to 31
+			:return: meas_length: numeric Unit: s"""
 		param = Conversions.decimal_value_to_str(index)
-		response = self._core.io.query_str(f'CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:ENPower? {param}')
+		response = self._core.io.query_str(f'CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:MLENgth? {param}')
 		return Conversions.str_to_float(response)
 
 	def get_all(self) -> List[float]:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:ENPower:ALL \n
-		Snippet: value: List[float] = driver.configure.power.listPy.envelopePower.get_all() \n
-		Defines the expected nominal power of all frequency/level steps. \n
-			:return: exp_nom_power: Comma-separated list of up to 2000 expected powers, one value per frequency/level step A query returns 2000 values (maximum number of steps) . Range: -55 dBm to 55 dBm, Unit: dBm
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:MLENgth:ALL \n
+		Snippet: value: List[float] = driver.configure.power.parameterSetList.mlength.get_all() \n
+		Sets the length of the evaluation interval used to measure a single set of current power results, for all parameter sets.
+		The measurement length cannot be greater than the step length. \n
+			:return: meas_length: numeric Comma-separated list of 32 values, for parameter set 0 to 31 Unit: s
 		"""
-		response = self._core.io.query_bin_or_ascii_float_list('CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:ENPower:ALL?')
+		response = self._core.io.query_bin_or_ascii_float_list('CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:MLENgth:ALL?')
 		return response
 
-	def set_all(self, exp_nom_power: List[float]) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:ENPower:ALL \n
-		Snippet: driver.configure.power.listPy.envelopePower.set_all(exp_nom_power = [1.1, 2.2, 3.3]) \n
-		Defines the expected nominal power of all frequency/level steps. \n
-			:param exp_nom_power: Comma-separated list of up to 2000 expected powers, one value per frequency/level step A query returns 2000 values (maximum number of steps) . Range: -55 dBm to 55 dBm, Unit: dBm
+	def set_all(self, meas_length: List[float]) -> None:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:MLENgth:ALL \n
+		Snippet: driver.configure.power.parameterSetList.mlength.set_all(meas_length = [1.1, 2.2, 3.3]) \n
+		Sets the length of the evaluation interval used to measure a single set of current power results, for all parameter sets.
+		The measurement length cannot be greater than the step length. \n
+			:param meas_length: numeric Comma-separated list of 32 values, for parameter set 0 to 31 Unit: s
 		"""
-		param = Conversions.list_to_csv_str(exp_nom_power)
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:ENPower:ALL {param}')
+		param = Conversions.list_to_csv_str(meas_length)
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:MLENgth:ALL {param}')
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ListPy_/Irepetition.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ListPy/Irepetition.py`

 * *Files 22% similar despite different names*

```diff
@@ -5,51 +5,55 @@
 from .....Internal import Conversions
 from .....Internal.Types import DataType
 from .....Internal.ArgSingleList import ArgSingleList
 from .....Internal.ArgSingle import ArgSingle
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Irepetition:
-	"""Irepetition commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class IrepetitionCls:
+	"""Irepetition commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("irepetition", core, parent)
+		self._cmd_group = CommandsGroup("irepetition", core, parent)
 
 	def set(self, index: int, repetition: int) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:IREPetition \n
 		Snippet: driver.configure.power.listPy.irepetition.set(index = 1, repetition = 1) \n
-		Sets/gets the number of repetitions of a list segment. \n
-			:param index: Segment index Range: 0 to 3999
-			:param repetition: Repetition of the frequency/level step Range: 1 to 9981
+		Configures the number of repetitions of segment <Index>. The total number of repetitions over all measured segments must
+		not be higher than 10000. \n
+			:param index: integer Range: 0 to 3999
+			:param repetition: numeric Range: 1 to 10000
 		"""
 		param = ArgSingleList().compose_cmd_string(ArgSingle('index', index, DataType.Integer), ArgSingle('repetition', repetition, DataType.Integer))
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:IREPetition {param}'.rstrip())
 
 	def get(self, index: int) -> int:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:IREPetition \n
 		Snippet: value: int = driver.configure.power.listPy.irepetition.get(index = 1) \n
-		Sets/gets the number of repetitions of a list segment. \n
-			:param index: Segment index Range: 0 to 3999
-			:return: repetition: Repetition of the frequency/level step Range: 1 to 9981"""
+		Configures the number of repetitions of segment <Index>. The total number of repetitions over all measured segments must
+		not be higher than 10000. \n
+			:param index: integer Range: 0 to 3999
+			:return: repetition: numeric Range: 1 to 10000"""
 		param = Conversions.decimal_value_to_str(index)
 		response = self._core.io.query_str(f'CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:IREPetition? {param}')
 		return Conversions.str_to_int(response)
 
 	def get_all(self) -> List[int]:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:IREPetition:ALL \n
 		Snippet: value: List[int] = driver.configure.power.listPy.irepetition.get_all() \n
-		Sets/gets the individual number of repetitions of all list segments. \n
-			:return: repetition: List of n comma-separated values, one per list segment, where n ≤ 2000. The query returns 2000 results. Range: 1 to 10000
+		Configures the number of repetitions for all segments. The total number of repetitions over all measured segments must
+		not be higher than 10000. \n
+			:return: repetition: numeric Comma-separated list of repetitions, one value per segment Range: 1 to 10000
 		"""
 		response = self._core.io.query_bin_or_ascii_int_list('CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:IREPetition:ALL?')
 		return response
 
 	def set_all(self, repetition: List[int]) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:IREPetition:ALL \n
 		Snippet: driver.configure.power.listPy.irepetition.set_all(repetition = [1, 2, 3]) \n
-		Sets/gets the individual number of repetitions of all list segments. \n
-			:param repetition: List of n comma-separated values, one per list segment, where n ≤ 2000. The query returns 2000 results. Range: 1 to 10000
+		Configures the number of repetitions for all segments. The total number of repetitions over all measured segments must
+		not be higher than 10000. \n
+			:param repetition: numeric Comma-separated list of repetitions, one value per segment Range: 1 to 10000
 		"""
 		param = Conversions.list_to_csv_str(repetition)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:IREPetition:ALL {param}')
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ListPy_/ParameterSetList.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/FilterPy/Bandpass/Bandwidth.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,57 +1,55 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
-from .....Internal.Types import DataType
-from .....Internal.ArgSingleList import ArgSingleList
-from .....Internal.ArgSingle import ArgSingle
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
+from .......Internal import Conversions
+from .......Internal.Types import DataType
+from .......Internal.ArgSingleList import ArgSingleList
+from .......Internal.ArgSingle import ArgSingle
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ParameterSetList:
-	"""ParameterSetList commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class BandwidthCls:
+	"""Bandwidth commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("parameterSetList", core, parent)
+		self._cmd_group = CommandsGroup("bandwidth", core, parent)
 
-	def set(self, index: int, parameter_set: int) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:PSET \n
-		Snippet: driver.configure.power.listPy.parameterSetList.set(index = 1, parameter_set = 1) \n
-		Selects the parameter set for a particular frequency/level step <index>. The parameter sets are defined using ...
-		GPRF:MEAS<i>:POWER:PSET... commands; see 'Command Reference'. \n
-			:param index: Number of the frequency/level step in the table Range: 0 to 3999
-			:param parameter_set: Parameter set number Range: 0 to 31
+	def set(self, index: int, bandwidth: float) -> None:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:FILTer:BANDpass:BWIDth \n
+		Snippet: driver.configure.power.parameterSetList.filterPy.bandpass.bandwidth.set(index = 1, bandwidth = 1.0) \n
+		Selects the bandpass filter bandwidth for the parameter set <Index>. \n
+			:param index: integer Range: 0 to 31
+			:param bandwidth: numeric For supported values, see Table 'Supported values'. Unit: Hz
 		"""
-		param = ArgSingleList().compose_cmd_string(ArgSingle('index', index, DataType.Integer), ArgSingle('parameter_set', parameter_set, DataType.Integer))
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:PSET {param}'.rstrip())
+		param = ArgSingleList().compose_cmd_string(ArgSingle('index', index, DataType.Integer), ArgSingle('bandwidth', bandwidth, DataType.Float))
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:FILTer:BANDpass:BWIDth {param}'.rstrip())
 
-	def get(self, index: int) -> int:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:PSET \n
-		Snippet: value: int = driver.configure.power.listPy.parameterSetList.get(index = 1) \n
-		Selects the parameter set for a particular frequency/level step <index>. The parameter sets are defined using ...
-		GPRF:MEAS<i>:POWER:PSET... commands; see 'Command Reference'. \n
-			:param index: Number of the frequency/level step in the table Range: 0 to 3999
-			:return: parameter_set: Parameter set number Range: 0 to 31"""
+	def get(self, index: int) -> float:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:FILTer:BANDpass:BWIDth \n
+		Snippet: value: float = driver.configure.power.parameterSetList.filterPy.bandpass.bandwidth.get(index = 1) \n
+		Selects the bandpass filter bandwidth for the parameter set <Index>. \n
+			:param index: integer Range: 0 to 31
+			:return: bandwidth: numeric For supported values, see Table 'Supported values'. Unit: Hz"""
 		param = Conversions.decimal_value_to_str(index)
-		response = self._core.io.query_str(f'CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:PSET? {param}')
-		return Conversions.str_to_int(response)
+		response = self._core.io.query_str(f'CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:FILTer:BANDpass:BWIDth? {param}')
+		return Conversions.str_to_float(response)
 
-	def get_all(self) -> List[int]:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:PSET:ALL \n
-		Snippet: value: List[int] = driver.configure.power.listPy.parameterSetList.get_all() \n
-		Selects the parameter set for all frequency/level steps. To configure parameter sets, see 'Parameter Set List Settings'. \n
-			:return: parameter_set: Comma-separated list of up to 2000 parameter set indices, with one value per frequency/level step A query returns 2000 values (maximum number of steps) . Range: 0 to 31
+	def get_all(self) -> List[float]:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:FILTer:BANDpass:BWIDth:ALL \n
+		Snippet: value: List[float] = driver.configure.power.parameterSetList.filterPy.bandpass.bandwidth.get_all() \n
+		Selects the bandpass filter bandwidth for all parameter sets. \n
+			:return: bandwidth: numeric Comma-separated list of 32 values, for parameter set 0 to 31 For supported values, see Table 'Supported values'. Unit: Hz
 		"""
-		response = self._core.io.query_bin_or_ascii_int_list('CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:PSET:ALL?')
+		response = self._core.io.query_bin_or_ascii_float_list('CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:FILTer:BANDpass:BWIDth:ALL?')
 		return response
 
-	def set_all(self, parameter_set: List[int]) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:PSET:ALL \n
-		Snippet: driver.configure.power.listPy.parameterSetList.set_all(parameter_set = [1, 2, 3]) \n
-		Selects the parameter set for all frequency/level steps. To configure parameter sets, see 'Parameter Set List Settings'. \n
-			:param parameter_set: Comma-separated list of up to 2000 parameter set indices, with one value per frequency/level step A query returns 2000 values (maximum number of steps) . Range: 0 to 31
+	def set_all(self, bandwidth: List[float]) -> None:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:FILTer:BANDpass:BWIDth:ALL \n
+		Snippet: driver.configure.power.parameterSetList.filterPy.bandpass.bandwidth.set_all(bandwidth = [1.1, 2.2, 3.3]) \n
+		Selects the bandpass filter bandwidth for all parameter sets. \n
+			:param bandwidth: numeric Comma-separated list of 32 values, for parameter set 0 to 31 For supported values, see Table 'Supported values'. Unit: Hz
 		"""
-		param = Conversions.list_to_csv_str(parameter_set)
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:PSET:ALL {param}')
+		param = Conversions.list_to_csv_str(bandwidth)
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:FILTer:BANDpass:BWIDth:ALL {param}')
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ListPy_/Retrigger.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ListPy/Retrigger.py`

 * *Files 24% similar despite different names*

```diff
@@ -5,55 +5,53 @@
 from .....Internal import Conversions
 from .....Internal.Types import DataType
 from .....Internal.ArgSingleList import ArgSingleList
 from .....Internal.ArgSingle import ArgSingle
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Retrigger:
-	"""Retrigger commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class RetriggerCls:
+	"""Retrigger commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("retrigger", core, parent)
+		self._cmd_group = CommandsGroup("retrigger", core, parent)
 
 	def set(self, index: int, retrigger: bool) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:RETRigger \n
 		Snippet: driver.configure.power.listPy.retrigger.set(index = 1, retrigger = False) \n
-		Enables the retrigger mechanism for a selected list segment. The setting is relevant for trigger mode 'Retrigger
-		Preselect' (method RsCmwGprfMeas.Trigger.Power.mode PRESelect) . \n
-			:param index: List segment index Range: 0 to 3999
-			:param retrigger: OFF | ON Disables or enables retriggering for segment Index.
+		Configures the retrigger mechanism for segment <Index>. The setting is only relevant for trigger mode 'Retrigger
+		Preselect'. \n
+			:param index: integer Range: 0 to 3999
+			:param retrigger: OFF | ON
 		"""
 		param = ArgSingleList().compose_cmd_string(ArgSingle('index', index, DataType.Integer), ArgSingle('retrigger', retrigger, DataType.Boolean))
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:RETRigger {param}'.rstrip())
 
 	def get(self, index: int) -> bool:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:RETRigger \n
 		Snippet: value: bool = driver.configure.power.listPy.retrigger.get(index = 1) \n
-		Enables the retrigger mechanism for a selected list segment. The setting is relevant for trigger mode 'Retrigger
-		Preselect' (method RsCmwGprfMeas.Trigger.Power.mode PRESelect) . \n
-			:param index: List segment index Range: 0 to 3999
-			:return: retrigger: OFF | ON Disables or enables retriggering for segment Index."""
+		Configures the retrigger mechanism for segment <Index>. The setting is only relevant for trigger mode 'Retrigger
+		Preselect'. \n
+			:param index: integer Range: 0 to 3999
+			:return: retrigger: OFF | ON"""
 		param = Conversions.decimal_value_to_str(index)
 		response = self._core.io.query_str(f'CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:RETRigger? {param}')
 		return Conversions.str_to_bool(response)
 
 	def get_all(self) -> List[bool]:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:RETRigger:ALL \n
 		Snippet: value: List[bool] = driver.configure.power.listPy.retrigger.get_all() \n
-		Enables or disables the retrigger mechanism after the individual frequency/level steps. The setting is relevant for the
-		trigger mode 'Retrigger Preselect' (method RsCmwGprfMeas.Trigger.Power.modePRESelect) . \n
-			:return: retrigger: OFF | ON Comma-separated list of up to 2000 values, with one value per frequency/level step A query returns 2000 values (maximum number of steps) .
+		Configures the retrigger mechanism for all segments. The setting is only relevant for trigger mode 'Retrigger Preselect'. \n
+			:return: retrigger: OFF | ON Comma-separated list of values, one value per segment
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:RETRigger:ALL?')
 		return Conversions.str_to_bool_list(response)
 
 	def set_all(self, retrigger: List[bool]) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:RETRigger:ALL \n
 		Snippet: driver.configure.power.listPy.retrigger.set_all(retrigger = [True, False, True]) \n
-		Enables or disables the retrigger mechanism after the individual frequency/level steps. The setting is relevant for the
-		trigger mode 'Retrigger Preselect' (method RsCmwGprfMeas.Trigger.Power.modePRESelect) . \n
-			:param retrigger: OFF | ON Comma-separated list of up to 2000 values, with one value per frequency/level step A query returns 2000 values (maximum number of steps) .
+		Configures the retrigger mechanism for all segments. The setting is only relevant for trigger mode 'Retrigger Preselect'. \n
+			:param retrigger: OFF | ON Comma-separated list of values, one value per segment
 		"""
 		param = Conversions.list_to_csv_str(retrigger)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:RETRigger:ALL {param}')
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,84 +1,80 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from .... import enums
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ParameterSetList:
-	"""ParameterSetList commands group definition. 13 total commands, 5 Sub-groups, 1 group commands"""
+class ParameterSetListCls:
+	"""ParameterSetList commands group definition. 13 total commands, 5 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("parameterSetList", core, parent)
+		self._cmd_group = CommandsGroup("parameterSetList", core, parent)
 
 	@property
 	def slength(self):
 		"""slength commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_slength'):
-			from .ParameterSetList_.Slength import Slength
-			self._slength = Slength(self._core, self._base)
+			from .Slength import SlengthCls
+			self._slength = SlengthCls(self._core, self._cmd_group)
 		return self._slength
 
 	@property
 	def mlength(self):
 		"""mlength commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_mlength'):
-			from .ParameterSetList_.Mlength import Mlength
-			self._mlength = Mlength(self._core, self._base)
+			from .Mlength import MlengthCls
+			self._mlength = MlengthCls(self._core, self._cmd_group)
 		return self._mlength
 
 	@property
 	def filterPy(self):
 		"""filterPy commands group. 3 Sub-classes, 0 commands."""
 		if not hasattr(self, '_filterPy'):
-			from .ParameterSetList_.FilterPy import FilterPy
-			self._filterPy = FilterPy(self._core, self._base)
+			from .FilterPy import FilterPyCls
+			self._filterPy = FilterPyCls(self._core, self._cmd_group)
 		return self._filterPy
 
 	@property
 	def catalog(self):
 		"""catalog commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_catalog'):
-			from .ParameterSetList_.Catalog import Catalog
-			self._catalog = Catalog(self._core, self._base)
+			from .Catalog import CatalogCls
+			self._catalog = CatalogCls(self._core, self._cmd_group)
 		return self._catalog
 
 	@property
 	def pdefSet(self):
 		"""pdefSet commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_pdefSet'):
-			from .ParameterSetList_.PdefSet import PdefSet
-			self._pdefSet = PdefSet(self._core, self._base)
+			from .PdefSet import PdefSetCls
+			self._pdefSet = PdefSetCls(self._core, self._cmd_group)
 		return self._pdefSet
 
 	# noinspection PyTypeChecker
 	def get_value(self) -> enums.ParameterSetMode:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:PSET \n
 		Snippet: value: enums.ParameterSetMode = driver.configure.power.parameterSetList.get_value() \n
-		Selects the measurement control settings for the power measurement. The list settings require a 'Retrigger Preselect'
-		trigger mode (method RsCmwGprfMeas.Trigger.Power.mode PRESelect) . In this mode, the R&S CMW uses the parameter settings
-		defined via method RsCmwGprfMeas.Configure.Power.ListPy.ParameterSetList.set. \n
-			:return: parameter_set_mode: GLOBal | LIST GLOBal: Use global settings for all steps. LIST: Use step-specific settings.
+		Selects whether all segments use the same measurement control settings. \n
+			:return: parameter_set_mode: GLOBal | LIST GLOBal: Use global settings for all segments. LIST: Use segment-specific settings.
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:POWer:PSET?')
 		return Conversions.str_to_scalar_enum(response, enums.ParameterSetMode)
 
 	def set_value(self, parameter_set_mode: enums.ParameterSetMode) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:PSET \n
 		Snippet: driver.configure.power.parameterSetList.set_value(parameter_set_mode = enums.ParameterSetMode.GLOBal) \n
-		Selects the measurement control settings for the power measurement. The list settings require a 'Retrigger Preselect'
-		trigger mode (method RsCmwGprfMeas.Trigger.Power.mode PRESelect) . In this mode, the R&S CMW uses the parameter settings
-		defined via method RsCmwGprfMeas.Configure.Power.ListPy.ParameterSetList.set. \n
-			:param parameter_set_mode: GLOBal | LIST GLOBal: Use global settings for all steps. LIST: Use step-specific settings.
+		Selects whether all segments use the same measurement control settings. \n
+			:param parameter_set_mode: GLOBal | LIST GLOBal: Use global settings for all segments. LIST: Use segment-specific settings.
 		"""
 		param = Conversions.enum_scalar_to_str(parameter_set_mode, enums.ParameterSetMode)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:PSET {param}')
 
-	def clone(self) -> 'ParameterSetList':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ParameterSetListCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ParameterSetList(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ParameterSetListCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/Catalog.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/Catalog.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,25 +1,24 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Catalog:
-	"""Catalog commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CatalogCls:
+	"""Catalog commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("catalog", core, parent)
+		self._cmd_group = CommandsGroup("catalog", core, parent)
 
 	def get_pdef_set(self) -> List[str]:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:CATalog:PDEFset \n
-		Snippet: value: List[str] = driver.configure.power.parameterSetList.catalog.get_pdef_set() \n
-		Gets a comma-separated list of predefined parameter sets that can be loaded as parameter set in retriggered list mode
-		(see method RsCmwGprfMeas.Configure.Power.ParameterSetList.PdefSet.set) . See also 'Measurement Settings and Predefined
-		Parameter Sets' \n
-			:return: predefined_set: Examples for strings: 'GSM Power','WCDMA UE Power','WCDMA Off Power','LTE TX Power 20','LTE OFF Power 20','Customized'
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:CATalog:PDEFset \n
+		Snippet: value: List[str] = driver.configure.power.catalog.get_pdef_set() \n
+		Gets a comma/separated list of predefined parameter sets that can be loaded using method RsCmwGprfMeas.Configure.Power.
+		pdefSet. See also 'Predefined parameter sets'. \n
+			:return: predefined_set: string Comma-separated list of strings
 		"""
-		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:CATalog:PDEFset?')
+		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:POWer:CATalog:PDEFset?')
 		return Conversions.str_to_str_list(response)
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/FilterPy.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/__init__.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,43 +1,59 @@
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
+from ...Internal.Core import Core
+from ...Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class FilterPy:
-	"""FilterPy commands group definition. 6 total commands, 3 Sub-groups, 0 group commands"""
+class TriggerCls:
+	"""Trigger commands group definition. 43 total commands, 5 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("filterPy", core, parent)
+		self._cmd_group = CommandsGroup("trigger", core, parent)
 
 	@property
-	def typePy(self):
-		"""typePy commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_typePy'):
-			from .FilterPy_.TypePy import TypePy
-			self._typePy = TypePy(self._core, self._base)
-		return self._typePy
+	def power(self):
+		"""power commands group. 2 Sub-classes, 7 commands."""
+		if not hasattr(self, '_power'):
+			from .Power import PowerCls
+			self._power = PowerCls(self._core, self._cmd_group)
+		return self._power
 
 	@property
-	def bandpass(self):
-		"""bandpass commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_bandpass'):
-			from .FilterPy_.Bandpass import Bandpass
-			self._bandpass = Bandpass(self._core, self._base)
-		return self._bandpass
+	def iqVsSlot(self):
+		"""iqVsSlot commands group. 1 Sub-classes, 7 commands."""
+		if not hasattr(self, '_iqVsSlot'):
+			from .IqVsSlot import IqVsSlotCls
+			self._iqVsSlot = IqVsSlotCls(self._core, self._cmd_group)
+		return self._iqVsSlot
 
 	@property
-	def gauss(self):
-		"""gauss commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_gauss'):
-			from .FilterPy_.Gauss import Gauss
-			self._gauss = Gauss(self._core, self._base)
-		return self._gauss
+	def iqRecorder(self):
+		"""iqRecorder commands group. 1 Sub-classes, 8 commands."""
+		if not hasattr(self, '_iqRecorder'):
+			from .IqRecorder import IqRecorderCls
+			self._iqRecorder = IqRecorderCls(self._core, self._cmd_group)
+		return self._iqRecorder
 
-	def clone(self) -> 'FilterPy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def spectrum(self):
+		"""spectrum commands group. 1 Sub-classes, 6 commands."""
+		if not hasattr(self, '_spectrum'):
+			from .Spectrum import SpectrumCls
+			self._spectrum = SpectrumCls(self._core, self._cmd_group)
+		return self._spectrum
+
+	@property
+	def fftSpecAn(self):
+		"""fftSpecAn commands group. 2 Sub-classes, 7 commands."""
+		if not hasattr(self, '_fftSpecAn'):
+			from .FftSpecAn import FftSpecAnCls
+			self._fftSpecAn = FftSpecAnCls(self._core, self._cmd_group)
+		return self._fftSpecAn
+
+	def clone(self) -> 'TriggerCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = FilterPy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = TriggerCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/FilterPy_/Bandpass.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/FilterPy/Bandpass/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Bandpass:
-	"""Bandpass commands group definition. 2 total commands, 1 Sub-groups, 0 group commands"""
+class BandpassCls:
+	"""Bandpass commands group definition. 2 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("bandpass", core, parent)
+		self._cmd_group = CommandsGroup("bandpass", core, parent)
 
 	@property
 	def bandwidth(self):
 		"""bandwidth commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_bandwidth'):
-			from .Bandpass_.Bandwidth import Bandwidth
-			self._bandwidth = Bandwidth(self._core, self._base)
+			from .Bandwidth import BandwidthCls
+			self._bandwidth = BandwidthCls(self._core, self._cmd_group)
 		return self._bandwidth
 
-	def clone(self) -> 'Bandpass':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'BandpassCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Bandpass(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = BandpassCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/FilterPy_/Gauss.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/FilterPy/Gauss/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ......Internal.Core import Core
-from ......Internal.CommandsGroup import CommandsGroup
+from .......Internal.Core import Core
+from .......Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Gauss:
-	"""Gauss commands group definition. 2 total commands, 1 Sub-groups, 0 group commands"""
+class GaussCls:
+	"""Gauss commands group definition. 2 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("gauss", core, parent)
+		self._cmd_group = CommandsGroup("gauss", core, parent)
 
 	@property
 	def bandwidth(self):
 		"""bandwidth commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_bandwidth'):
-			from .Gauss_.Bandwidth import Bandwidth
-			self._bandwidth = Bandwidth(self._core, self._base)
+			from .Bandwidth import BandwidthCls
+			self._bandwidth = BandwidthCls(self._core, self._cmd_group)
 		return self._bandwidth
 
-	def clone(self) -> 'Gauss':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'GaussCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Gauss(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = GaussCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/FilterPy_/TypePy.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/FilterPy/TypePy.py`

 * *Files 25% similar despite different names*

```diff
@@ -6,53 +6,53 @@
 from ......Internal.Types import DataType
 from ......Internal.ArgSingleList import ArgSingleList
 from ......Internal.ArgSingle import ArgSingle
 from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class TypePy:
-	"""TypePy commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class TypePyCls:
+	"""TypePy commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("typePy", core, parent)
+		self._cmd_group = CommandsGroup("typePy", core, parent)
 
 	def set(self, index: int, filter_py: enums.DigitalFilterType) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:FILTer:TYPE \n
 		Snippet: driver.configure.power.parameterSetList.filterPy.typePy.set(index = 1, filter_py = enums.DigitalFilterType.BANDpass) \n
-		Selects the IF filter type for a particular parameter set <index>. \n
-			:param index: Number of the parameter set in the list Range: 0 to 31
-			:param filter_py: BANDpass | GAUSs | WCDMa | CDMA | TDSCdma BANDpass: bandpass filter with selectable bandwidth GAUSs: filter of Gaussian shape with selectable bandwidth WCDMA: 3.84 MHz RRC filter with a roll-off = 0.22 for WCDMA TX tests CDMA: 1.2288 MHz-wide channel filter for CDMA 2000 TX tests TDSCdma: 1.28 MHz RRC filter with a roll-off = 0.22 for TD-SCDMA TX tests
+		Selects the IF filter type for the parameter set <Index>. \n
+			:param index: integer Range: 0 to 31
+			:param filter_py: BANDpass | GAUSs | WCDMa | CDMA | TDSCdma BANDpass: bandpass filter GAUSs: Gaussian filter WCDMA: 3.84-MHz RRC filter for WCDMA TX tests CDMA: 1.2288-MHz channel filter for CDMA 2000 TX tests TDSCdma: 1.28-MHz RRC filter for TD-SCDMA TX tests
 		"""
-		param = ArgSingleList().compose_cmd_string(ArgSingle('index', index, DataType.Integer), ArgSingle('filter_py', filter_py, DataType.Enum))
+		param = ArgSingleList().compose_cmd_string(ArgSingle('index', index, DataType.Integer), ArgSingle('filter_py', filter_py, DataType.Enum, enums.DigitalFilterType))
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:FILTer:TYPE {param}'.rstrip())
 
 	# noinspection PyTypeChecker
 	def get(self, index: int) -> enums.DigitalFilterType:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:FILTer:TYPE \n
 		Snippet: value: enums.DigitalFilterType = driver.configure.power.parameterSetList.filterPy.typePy.get(index = 1) \n
-		Selects the IF filter type for a particular parameter set <index>. \n
-			:param index: Number of the parameter set in the list Range: 0 to 31
-			:return: filter_py: BANDpass | GAUSs | WCDMa | CDMA | TDSCdma BANDpass: bandpass filter with selectable bandwidth GAUSs: filter of Gaussian shape with selectable bandwidth WCDMA: 3.84 MHz RRC filter with a roll-off = 0.22 for WCDMA TX tests CDMA: 1.2288 MHz-wide channel filter for CDMA 2000 TX tests TDSCdma: 1.28 MHz RRC filter with a roll-off = 0.22 for TD-SCDMA TX tests"""
+		Selects the IF filter type for the parameter set <Index>. \n
+			:param index: integer Range: 0 to 31
+			:return: filter_py: BANDpass | GAUSs | WCDMa | CDMA | TDSCdma BANDpass: bandpass filter GAUSs: Gaussian filter WCDMA: 3.84-MHz RRC filter for WCDMA TX tests CDMA: 1.2288-MHz channel filter for CDMA 2000 TX tests TDSCdma: 1.28-MHz RRC filter for TD-SCDMA TX tests"""
 		param = Conversions.decimal_value_to_str(index)
 		response = self._core.io.query_str(f'CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:FILTer:TYPE? {param}')
 		return Conversions.str_to_scalar_enum(response, enums.DigitalFilterType)
 
 	# noinspection PyTypeChecker
 	def get_all(self) -> List[enums.DigitalFilterType]:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:FILTer:TYPE:ALL \n
 		Snippet: value: List[enums.DigitalFilterType] = driver.configure.power.parameterSetList.filterPy.typePy.get_all() \n
 		Selects the IF filter type for all parameter sets. \n
-			:return: filter_py: BANDpass | GAUSs | WCDMa | CDMA | TDSCdma Comma-separated list of 32 values, for parameter set no. 0 to 31 BANDpass: Bandpass filter with selectable bandwidth GAUSs: Filter of Gaussian shape with selectable bandwidth WCDMA: 3.84 MHz RRC filter with a roll-off = 0.22 for WCDMA TX tests CDMA: 1.2288 MHz-wide channel filter for CDMA 2000 TX tests TDSCdma: 1.28 MHz RRC filter with a roll-off = 0.22 for TD-SCDMA TX tests
+			:return: filter_py: BANDpass | GAUSs | WCDMa | CDMA | TDSCdma Comma-separated list of 32 values, for parameter set 0 to 31 BANDpass: bandpass filter GAUSs: Gaussian filter WCDMA: 3.84-MHz RRC filter for WCDMA TX tests CDMA: 1.2288-MHz channel filter for CDMA 2000 TX tests TDSCdma: 1.28-MHz RRC filter for TD-SCDMA TX tests
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:FILTer:TYPE:ALL?')
 		return Conversions.str_to_list_enum(response, enums.DigitalFilterType)
 
 	def set_all(self, filter_py: List[enums.DigitalFilterType]) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:FILTer:TYPE:ALL \n
 		Snippet: driver.configure.power.parameterSetList.filterPy.typePy.set_all(filter_py = [DigitalFilterType.BANDpass, DigitalFilterType.WCDMa]) \n
 		Selects the IF filter type for all parameter sets. \n
-			:param filter_py: BANDpass | GAUSs | WCDMa | CDMA | TDSCdma Comma-separated list of 32 values, for parameter set no. 0 to 31 BANDpass: Bandpass filter with selectable bandwidth GAUSs: Filter of Gaussian shape with selectable bandwidth WCDMA: 3.84 MHz RRC filter with a roll-off = 0.22 for WCDMA TX tests CDMA: 1.2288 MHz-wide channel filter for CDMA 2000 TX tests TDSCdma: 1.28 MHz RRC filter with a roll-off = 0.22 for TD-SCDMA TX tests
+			:param filter_py: BANDpass | GAUSs | WCDMa | CDMA | TDSCdma Comma-separated list of 32 values, for parameter set 0 to 31 BANDpass: bandpass filter GAUSs: Gaussian filter WCDMA: 3.84-MHz RRC filter for WCDMA TX tests CDMA: 1.2288-MHz channel filter for CDMA 2000 TX tests TDSCdma: 1.28-MHz RRC filter for TD-SCDMA TX tests
 		"""
 		param = Conversions.enum_list_to_str(filter_py, enums.DigitalFilterType)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:FILTer:TYPE:ALL {param}')
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/Mlength.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/Slength.py`

 * *Files 24% similar despite different names*

```diff
@@ -5,59 +5,51 @@
 from .....Internal import Conversions
 from .....Internal.Types import DataType
 from .....Internal.ArgSingleList import ArgSingleList
 from .....Internal.ArgSingle import ArgSingle
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Mlength:
-	"""Mlength commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class SlengthCls:
+	"""Slength commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("mlength", core, parent)
+		self._cmd_group = CommandsGroup("slength", core, parent)
 
-	def set(self, index: int, meas_length: float) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:MLENgth \n
-		Snippet: driver.configure.power.parameterSetList.mlength.set(index = 1, meas_length = 1.0) \n
-		Selects the length of the averaging intervals that the R&S CMW uses to calculate the 'Power' results for a particular
-		parameter set <Index>. The measurement length must not exceed the step length (method RsCmwGprfMeas.Configure.Power.
-		ParameterSetList.Slength.set) . \n
-			:param index: Number of the parameter set Range: 0 to 31
-			:param meas_length: Range: 10E-6 s to 1 s, Unit: s
+	def set(self, index: int, step_length: float) -> None:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:SLENgth \n
+		Snippet: driver.configure.power.parameterSetList.slength.set(index = 1, step_length = 1.0) \n
+		Selects the time between the beginning of two consecutive measurement lengths for the parameter set <Index>. \n
+			:param index: integer Range: 0 to 31
+			:param step_length: numeric Range: MeasLength to 1 s, Unit: s
 		"""
-		param = ArgSingleList().compose_cmd_string(ArgSingle('index', index, DataType.Integer), ArgSingle('meas_length', meas_length, DataType.Float))
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:MLENgth {param}'.rstrip())
+		param = ArgSingleList().compose_cmd_string(ArgSingle('index', index, DataType.Integer), ArgSingle('step_length', step_length, DataType.Float))
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:SLENgth {param}'.rstrip())
 
 	def get(self, index: int) -> float:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:MLENgth \n
-		Snippet: value: float = driver.configure.power.parameterSetList.mlength.get(index = 1) \n
-		Selects the length of the averaging intervals that the R&S CMW uses to calculate the 'Power' results for a particular
-		parameter set <Index>. The measurement length must not exceed the step length (method RsCmwGprfMeas.Configure.Power.
-		ParameterSetList.Slength.set) . \n
-			:param index: Number of the parameter set Range: 0 to 31
-			:return: meas_length: Range: 10E-6 s to 1 s, Unit: s"""
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:SLENgth \n
+		Snippet: value: float = driver.configure.power.parameterSetList.slength.get(index = 1) \n
+		Selects the time between the beginning of two consecutive measurement lengths for the parameter set <Index>. \n
+			:param index: integer Range: 0 to 31
+			:return: step_length: numeric Range: MeasLength to 1 s, Unit: s"""
 		param = Conversions.decimal_value_to_str(index)
-		response = self._core.io.query_str(f'CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:MLENgth? {param}')
+		response = self._core.io.query_str(f'CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:SLENgth? {param}')
 		return Conversions.str_to_float(response)
 
 	def get_all(self) -> List[float]:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:MLENgth:ALL \n
-		Snippet: value: List[float] = driver.configure.power.parameterSetList.mlength.get_all() \n
-		Selects the length of the averaging intervals that the R&S CMW uses to calculate the 'Power' results for all parameter
-		sets. The measurement length must not exceed the step length (method RsCmwGprfMeas.Configure.Power.ParameterSetList.
-		Slength.all) . \n
-			:return: meas_length: Comma-separated list of 32 values, for parameter set no. 0 to 31 Range: 10E-6 s to 1 s, Unit: s
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:SLENgth:ALL \n
+		Snippet: value: List[float] = driver.configure.power.parameterSetList.slength.get_all() \n
+		Selects the time between the beginning of two consecutive measurement lengths for all parameter sets. \n
+			:return: step_length: numeric Comma-separated list of 32 values, for parameter set 0 to 31 Range: MeasLength to 1 s, Unit: s
 		"""
-		response = self._core.io.query_bin_or_ascii_float_list('CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:MLENgth:ALL?')
+		response = self._core.io.query_bin_or_ascii_float_list('CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:SLENgth:ALL?')
 		return response
 
-	def set_all(self, meas_length: List[float]) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:MLENgth:ALL \n
-		Snippet: driver.configure.power.parameterSetList.mlength.set_all(meas_length = [1.1, 2.2, 3.3]) \n
-		Selects the length of the averaging intervals that the R&S CMW uses to calculate the 'Power' results for all parameter
-		sets. The measurement length must not exceed the step length (method RsCmwGprfMeas.Configure.Power.ParameterSetList.
-		Slength.all) . \n
-			:param meas_length: Comma-separated list of 32 values, for parameter set no. 0 to 31 Range: 10E-6 s to 1 s, Unit: s
+	def set_all(self, step_length: List[float]) -> None:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:SLENgth:ALL \n
+		Snippet: driver.configure.power.parameterSetList.slength.set_all(step_length = [1.1, 2.2, 3.3]) \n
+		Selects the time between the beginning of two consecutive measurement lengths for all parameter sets. \n
+			:param step_length: numeric Comma-separated list of 32 values, for parameter set 0 to 31 Range: MeasLength to 1 s, Unit: s
 		"""
-		param = Conversions.list_to_csv_str(meas_length)
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:MLENgth:ALL {param}')
+		param = Conversions.list_to_csv_str(step_length)
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:SLENgth:ALL {param}')
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/PdefSet.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/PdefSet.py`

 * *Files 9% similar despite different names*

```diff
@@ -4,39 +4,39 @@
 from .....Internal.Types import DataType
 from .....Internal.Utilities import trim_str_response
 from .....Internal.ArgSingleList import ArgSingleList
 from .....Internal.ArgSingle import ArgSingle
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class PdefSet:
-	"""PdefSet commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class PdefSetCls:
+	"""PdefSet commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("pdefSet", core, parent)
+		self._cmd_group = CommandsGroup("pdefSet", core, parent)
 
 	def set(self, index: int, predefined_set: str) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:PDEFset \n
-		Snippet: driver.configure.power.parameterSetList.pdefSet.set(index = 1, predefined_set = '1') \n
+		Snippet: driver.configure.power.parameterSetList.pdefSet.set(index = 1, predefined_set = 'abc') \n
 		This command is related to parameter sets in retriggered list mode. A setting command loads a predefined set of
 		parameters into the parameter set <Index>. A query returns the name of the predefined set assigned to the parameter set
-		<Index>. To get a list of predefined-set strings, use method RsCmwGprfMeas.Configure.Power.ParameterSetList.Catalog.
-		pdefSet. \n
-			:param index: Parameter set number Range: 0 to 31
-			:param predefined_set: Predefined set as string
+		<Index>. To get a list of allowed strings for <PredefinedSet>, use method RsCmwGprfMeas.Configure.Power.ParameterSetList.
+		Catalog.pdefSet. \n
+			:param index: integer Range: 0 to 31
+			:param predefined_set: string
 		"""
 		param = ArgSingleList().compose_cmd_string(ArgSingle('index', index, DataType.Integer), ArgSingle('predefined_set', predefined_set, DataType.String))
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:PDEFset {param}'.rstrip())
 
 	def get(self, index: int) -> str:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:PDEFset \n
 		Snippet: value: str = driver.configure.power.parameterSetList.pdefSet.get(index = 1) \n
 		This command is related to parameter sets in retriggered list mode. A setting command loads a predefined set of
 		parameters into the parameter set <Index>. A query returns the name of the predefined set assigned to the parameter set
-		<Index>. To get a list of predefined-set strings, use method RsCmwGprfMeas.Configure.Power.ParameterSetList.Catalog.
-		pdefSet. \n
-			:param index: Parameter set number Range: 0 to 31
-			:return: predefined_set: Predefined set as string"""
+		<Index>. To get a list of allowed strings for <PredefinedSet>, use method RsCmwGprfMeas.Configure.Power.ParameterSetList.
+		Catalog.pdefSet. \n
+			:param index: integer Range: 0 to 31
+			:return: predefined_set: string"""
 		param = Conversions.decimal_value_to_str(index)
 		response = self._core.io.query_str(f'CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:PDEFset? {param}')
 		return trim_str_response(response)
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/Slength.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/Power/ParameterSetList/Offset.py`

 * *Files 17% similar despite different names*

```diff
@@ -5,51 +5,51 @@
 from .....Internal import Conversions
 from .....Internal.Types import DataType
 from .....Internal.ArgSingleList import ArgSingleList
 from .....Internal.ArgSingle import ArgSingle
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Slength:
-	"""Slength commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class OffsetCls:
+	"""Offset commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("slength", core, parent)
+		self._cmd_group = CommandsGroup("offset", core, parent)
 
-	def set(self, index: int, step_length: float) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:SLENgth \n
-		Snippet: driver.configure.power.parameterSetList.slength.set(index = 1, step_length = 1.0) \n
-		Selects the time between the beginning of two consecutive measured power steps for a particular parameter set <Index>. \n
-			:param index: Number of the parameter set Range: 0 to 31
-			:param step_length: Range: 50E-6 s to 1 s, Unit: s
+	def set(self, index: int, trigger_offset: float) -> None:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:PSET:OFFSet \n
+		Snippet: driver.trigger.power.parameterSetList.offset.set(index = 1, trigger_offset = 1.0) \n
+		Defines a delay time relative to the trigger event for the parameter set <Index>. \n
+			:param index: integer Range: 0 to 31
+			:param trigger_offset: numeric Range: 0 s to 1 s, Unit: s
 		"""
-		param = ArgSingleList().compose_cmd_string(ArgSingle('index', index, DataType.Integer), ArgSingle('step_length', step_length, DataType.Float))
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:SLENgth {param}'.rstrip())
+		param = ArgSingleList().compose_cmd_string(ArgSingle('index', index, DataType.Integer), ArgSingle('trigger_offset', trigger_offset, DataType.Float))
+		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:POWer:PSET:OFFSet {param}'.rstrip())
 
 	def get(self, index: int) -> float:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:SLENgth \n
-		Snippet: value: float = driver.configure.power.parameterSetList.slength.get(index = 1) \n
-		Selects the time between the beginning of two consecutive measured power steps for a particular parameter set <Index>. \n
-			:param index: Number of the parameter set Range: 0 to 31
-			:return: step_length: Range: 50E-6 s to 1 s, Unit: s"""
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:PSET:OFFSet \n
+		Snippet: value: float = driver.trigger.power.parameterSetList.offset.get(index = 1) \n
+		Defines a delay time relative to the trigger event for the parameter set <Index>. \n
+			:param index: integer Range: 0 to 31
+			:return: trigger_offset: numeric Range: 0 s to 1 s, Unit: s"""
 		param = Conversions.decimal_value_to_str(index)
-		response = self._core.io.query_str(f'CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:SLENgth? {param}')
+		response = self._core.io.query_str(f'TRIGger:GPRF:MEASurement<Instance>:POWer:PSET:OFFSet? {param}')
 		return Conversions.str_to_float(response)
 
 	def get_all(self) -> List[float]:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:SLENgth:ALL \n
-		Snippet: value: List[float] = driver.configure.power.parameterSetList.slength.get_all() \n
-		Selects the time between the beginning of two consecutive measured power steps for all parameter sets. \n
-			:return: step_length: Comma-separated list of 32 values, for parameter set no. 0 to 31 Range: 50E-6 s to 1 s, Unit: s
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:PSET:OFFSet:ALL \n
+		Snippet: value: List[float] = driver.trigger.power.parameterSetList.offset.get_all() \n
+		Defines a delay time relative to the trigger event for all parameter sets. \n
+			:return: trigger_offset: numeric Comma-separated list of 32 offsets, for parameter set 0 to 31 Range: 0 s to 1 s, Unit: s
 		"""
-		response = self._core.io.query_bin_or_ascii_float_list('CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:SLENgth:ALL?')
+		response = self._core.io.query_bin_or_ascii_float_list('TRIGger:GPRF:MEASurement<Instance>:POWer:PSET:OFFSet:ALL?')
 		return response
 
-	def set_all(self, step_length: List[float]) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:SLENgth:ALL \n
-		Snippet: driver.configure.power.parameterSetList.slength.set_all(step_length = [1.1, 2.2, 3.3]) \n
-		Selects the time between the beginning of two consecutive measured power steps for all parameter sets. \n
-			:param step_length: Comma-separated list of 32 values, for parameter set no. 0 to 31 Range: 50E-6 s to 1 s, Unit: s
+	def set_all(self, trigger_offset: List[float]) -> None:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:PSET:OFFSet:ALL \n
+		Snippet: driver.trigger.power.parameterSetList.offset.set_all(trigger_offset = [1.1, 2.2, 3.3]) \n
+		Defines a delay time relative to the trigger event for all parameter sets. \n
+			:param trigger_offset: numeric Comma-separated list of 32 offsets, for parameter set 0 to 31 Range: 0 s to 1 s, Unit: s
 		"""
-		param = Conversions.list_to_csv_str(step_length)
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:PSET:SLENgth:ALL {param}')
+		param = Conversions.list_to_csv_str(trigger_offset)
+		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:POWer:PSET:OFFSet:ALL {param}')
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Power_/Trigger.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/Trigger.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Trigger:
-	"""Trigger commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class TriggerCls:
+	"""Trigger commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("trigger", core, parent)
+		self._cmd_group = CommandsGroup("trigger", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_source(self) -> enums.TriggerSource:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:TRIGger:SOURce \n
 		Snippet: value: enums.TriggerSource = driver.configure.power.trigger.get_source() \n
 		No command help available \n
 			:return: source: No help available
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Spectrum.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/IqVsSlot/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,139 +1,185 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ... import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Spectrum:
-	"""Spectrum commands group definition. 22 total commands, 3 Sub-groups, 4 group commands"""
+class IqVsSlotCls:
+	"""IqVsSlot commands group definition. 19 total commands, 2 Subgroups, 7 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("spectrum", core, parent)
+		self._cmd_group = CommandsGroup("iqVsSlot", core, parent)
 
 	@property
-	def zeroSpan(self):
-		"""zeroSpan commands group. 2 Sub-classes, 1 commands."""
-		if not hasattr(self, '_zeroSpan'):
-			from .Spectrum_.ZeroSpan import ZeroSpan
-			self._zeroSpan = ZeroSpan(self._core, self._base)
-		return self._zeroSpan
+	def trigger(self):
+		"""trigger commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_trigger'):
+			from .Trigger import TriggerCls
+			self._trigger = TriggerCls(self._core, self._cmd_group)
+		return self._trigger
 
 	@property
-	def frequency(self):
-		"""frequency commands group. 1 Sub-classes, 4 commands."""
-		if not hasattr(self, '_frequency'):
-			from .Spectrum_.Frequency import Frequency
-			self._frequency = Frequency(self._core, self._base)
-		return self._frequency
+	def listPy(self):
+		"""listPy commands group. 4 Sub-classes, 4 commands."""
+		if not hasattr(self, '_listPy'):
+			from .ListPy import ListPyCls
+			self._listPy = ListPyCls(self._core, self._cmd_group)
+		return self._listPy
 
-	@property
-	def freqSweep(self):
-		"""freqSweep commands group. 3 Sub-classes, 0 commands."""
-		if not hasattr(self, '_freqSweep'):
-			from .Spectrum_.FreqSweep import FreqSweep
-			self._freqSweep = FreqSweep(self._core, self._base)
-		return self._freqSweep
+	def get_timeout(self) -> float:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:TOUT \n
+		Snippet: value: float = driver.configure.iqVsSlot.get_timeout() \n
+		Defines a timeout for the measurement. The timer is started when the measurement is initiated via a READ or INIT command.
+		It is not started if the measurement is initiated manually. When the measurement has completed the first measurement
+		cycle (first single shot) , the statistical depth is reached and the timer is reset. If the first measurement cycle has
+		not been completed when the timer expires, the measurement is stopped. The measurement state changes to RDY.
+		The reliability indicator is set to 1, indicating that a measurement timeout occurred. Still running READ, FETCh or
+		CALCulate commands are completed, returning the available results. At least for some results, there are no values at all
+		or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite measurement timeout. \n
+			:return: tcd_timeout: numeric Unit: s
+		"""
+		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQVSlot:TOUT?')
+		return Conversions.str_to_float(response)
 
-	# noinspection PyTypeChecker
-	def get_amode(self) -> enums.AveragingMode:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:AMODe \n
-		Snippet: value: enums.AveragingMode = driver.configure.spectrum.get_amode() \n
-		Defines how the R&S CMW calculates the AVERage traces from the current results. \n
-			:return: averaging_mode: LINear | LOGarithmic
-		"""
-		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:SPECtrum:AMODe?')
-		return Conversions.str_to_scalar_enum(response, enums.AveragingMode)
-
-	def set_amode(self, averaging_mode: enums.AveragingMode) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:AMODe \n
-		Snippet: driver.configure.spectrum.set_amode(averaging_mode = enums.AveragingMode.LINear) \n
-		Defines how the R&S CMW calculates the AVERage traces from the current results. \n
-			:param averaging_mode: LINear | LOGarithmic
+	def set_timeout(self, tcd_timeout: float) -> None:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:TOUT \n
+		Snippet: driver.configure.iqVsSlot.set_timeout(tcd_timeout = 1.0) \n
+		Defines a timeout for the measurement. The timer is started when the measurement is initiated via a READ or INIT command.
+		It is not started if the measurement is initiated manually. When the measurement has completed the first measurement
+		cycle (first single shot) , the statistical depth is reached and the timer is reset. If the first measurement cycle has
+		not been completed when the timer expires, the measurement is stopped. The measurement state changes to RDY.
+		The reliability indicator is set to 1, indicating that a measurement timeout occurred. Still running READ, FETCh or
+		CALCulate commands are completed, returning the available results. At least for some results, there are no values at all
+		or the statistical depth has not been reached. A timeout of 0 s corresponds to an infinite measurement timeout. \n
+			:param tcd_timeout: numeric Unit: s
 		"""
-		param = Conversions.enum_scalar_to_str(averaging_mode, enums.AveragingMode)
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:SPECtrum:AMODe {param}')
+		param = Conversions.decimal_value_to_str(tcd_timeout)
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQVSlot:TOUT {param}')
 
 	# noinspection PyTypeChecker
 	def get_repetition(self) -> enums.Repeat:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:REPetition \n
-		Snippet: value: enums.Repeat = driver.configure.spectrum.get_repetition() \n
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:REPetition \n
+		Snippet: value: enums.Repeat = driver.configure.iqVsSlot.get_repetition() \n
 		Specifies the repetition mode of the measurement. The repetition mode specifies whether the measurement is stopped after
 		a single shot or repeated continuously. Use CONFigure:..:MEAS<i>:...:SCOunt to determine the number of measurement
 		intervals per single shot. \n
 			:return: repetition: SINGleshot | CONTinuous SINGleshot: single-shot measurement CONTinuous: continuous measurement
 		"""
-		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:SPECtrum:REPetition?')
+		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQVSlot:REPetition?')
 		return Conversions.str_to_scalar_enum(response, enums.Repeat)
 
 	def set_repetition(self, repetition: enums.Repeat) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:REPetition \n
-		Snippet: driver.configure.spectrum.set_repetition(repetition = enums.Repeat.CONTinuous) \n
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:REPetition \n
+		Snippet: driver.configure.iqVsSlot.set_repetition(repetition = enums.Repeat.CONTinuous) \n
 		Specifies the repetition mode of the measurement. The repetition mode specifies whether the measurement is stopped after
 		a single shot or repeated continuously. Use CONFigure:..:MEAS<i>:...:SCOunt to determine the number of measurement
 		intervals per single shot. \n
 			:param repetition: SINGleshot | CONTinuous SINGleshot: single-shot measurement CONTinuous: continuous measurement
 		"""
 		param = Conversions.enum_scalar_to_str(repetition, enums.Repeat)
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:SPECtrum:REPetition {param}')
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQVSlot:REPetition {param}')
 
-	def get_timeout(self) -> float:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:TOUT \n
-		Snippet: value: float = driver.configure.spectrum.get_timeout() \n
-		Defines a timeout for the measurement. The timer is started when the measurement is initiated via a READ or INIT command.
-		It is not started if the measurement is initiated manually ([ON | OFF] key or [RESTART | STOP] key) .
-		When the measurement has completed the first measurement cycle (first single shot) , the statistical depth is reached and
-		the timer is reset. If the first measurement cycle has not been completed when the timer expires, the measurement is
-		stopped. The measurement state changes to RDY. The reliability indicator is set to 1, indicating that a measurement
-		timeout occurred. Still running READ, FETCh or CALCulate commands are completed, returning the available results.
-		At least for some results, there are no values at all or the statistical depth has not been reached. A timeout of 0 s
-		corresponds to an infinite measurement timeout. \n
-			:return: tcd_timeout: Unit: s
+	def get_scount(self) -> int:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:SCOunt \n
+		Snippet: value: int = driver.configure.iqVsSlot.get_scount() \n
+		Defines the number of steps (measurement intervals) per subsweep. In list mode, the total number of steps must not exceed
+		3000 (step count times number of subsweeps) . \n
+			:return: step_count: integer Range: 1 to 3000
 		"""
-		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:SPECtrum:TOUT?')
+		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQVSlot:SCOunt?')
+		return Conversions.str_to_int(response)
+
+	def set_scount(self, step_count: int) -> None:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:SCOunt \n
+		Snippet: driver.configure.iqVsSlot.set_scount(step_count = 1) \n
+		Defines the number of steps (measurement intervals) per subsweep. In list mode, the total number of steps must not exceed
+		3000 (step count times number of subsweeps) . \n
+			:param step_count: integer Range: 1 to 3000
+		"""
+		param = Conversions.decimal_value_to_str(step_count)
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQVSlot:SCOunt {param}')
+
+	def get_mlength(self) -> float:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:MLENgth \n
+		Snippet: value: float = driver.configure.iqVsSlot.get_mlength() \n
+		Sets the length of the evaluation intervals used to calculate the I/Q vs slot results for one measurement step. \n
+			:return: meas_length: numeric Range: 10E-6 s to StepLength, Unit: s
+		"""
+		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQVSlot:MLENgth?')
 		return Conversions.str_to_float(response)
 
-	def set_timeout(self, tcd_timeout: float) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:TOUT \n
-		Snippet: driver.configure.spectrum.set_timeout(tcd_timeout = 1.0) \n
-		Defines a timeout for the measurement. The timer is started when the measurement is initiated via a READ or INIT command.
-		It is not started if the measurement is initiated manually ([ON | OFF] key or [RESTART | STOP] key) .
-		When the measurement has completed the first measurement cycle (first single shot) , the statistical depth is reached and
-		the timer is reset. If the first measurement cycle has not been completed when the timer expires, the measurement is
-		stopped. The measurement state changes to RDY. The reliability indicator is set to 1, indicating that a measurement
-		timeout occurred. Still running READ, FETCh or CALCulate commands are completed, returning the available results.
-		At least for some results, there are no values at all or the statistical depth has not been reached. A timeout of 0 s
-		corresponds to an infinite measurement timeout. \n
-			:param tcd_timeout: Unit: s
+	def set_mlength(self, meas_length: float) -> None:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:MLENgth \n
+		Snippet: driver.configure.iqVsSlot.set_mlength(meas_length = 1.0) \n
+		Sets the length of the evaluation intervals used to calculate the I/Q vs slot results for one measurement step. \n
+			:param meas_length: numeric Range: 10E-6 s to StepLength, Unit: s
+		"""
+		param = Conversions.decimal_value_to_str(meas_length)
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQVSlot:MLENgth {param}')
+
+	def get_slength(self) -> float:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:SLENgth \n
+		Snippet: value: float = driver.configure.iqVsSlot.get_slength() \n
+		Sets the time between the beginning of two consecutive measurement steps. \n
+			:return: step_length: numeric Range: MeasLength to 5E-3 s, Unit: s
 		"""
-		param = Conversions.decimal_value_to_str(tcd_timeout)
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:SPECtrum:TOUT {param}')
+		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQVSlot:SLENgth?')
+		return Conversions.str_to_float(response)
 
-	def get_scount(self) -> int:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:SCOunt \n
-		Snippet: value: int = driver.configure.spectrum.get_scount() \n
-		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
-		single shot. \n
-			:return: statistic_count: Number of measurement intervals. A measurement interval comprises a single frequency sweep. Range: 1 to 1000
+	def set_slength(self, step_length: float) -> None:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:SLENgth \n
+		Snippet: driver.configure.iqVsSlot.set_slength(step_length = 1.0) \n
+		Sets the time between the beginning of two consecutive measurement steps. \n
+			:param step_length: numeric Range: MeasLength to 5E-3 s, Unit: s
 		"""
-		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:SPECtrum:SCOunt?')
-		return Conversions.str_to_int(response)
+		param = Conversions.decimal_value_to_str(step_length)
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQVSlot:SLENgth {param}')
+
+	# noinspection PyTypeChecker
+	def get_ftype(self) -> enums.FilterType:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:FTYPe \n
+		Snippet: value: enums.FilterType = driver.configure.iqVsSlot.get_ftype() \n
+		Selects the IF filter type. \n
+			:return: filter_type: GAUSs | NYQuist | NY1Mhz GAUSs: Gaussian, 100-kHz BW NYQuist: Nyquist, 100-kHz BW NY1Mhz: Nyquist, 1-MHz BW
+		"""
+		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQVSlot:FTYPe?')
+		return Conversions.str_to_scalar_enum(response, enums.FilterType)
+
+	def set_ftype(self, filter_type: enums.FilterType) -> None:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:FTYPe \n
+		Snippet: driver.configure.iqVsSlot.set_ftype(filter_type = enums.FilterType.B10Mhz) \n
+		Selects the IF filter type. \n
+			:param filter_type: GAUSs | NYQuist | NY1Mhz GAUSs: Gaussian, 100-kHz BW NYQuist: Nyquist, 100-kHz BW NY1Mhz: Nyquist, 1-MHz BW
+		"""
+		param = Conversions.enum_scalar_to_str(filter_type, enums.FilterType)
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQVSlot:FTYPe {param}')
+
+	def get_fe_limit(self) -> float:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:FELimit \n
+		Snippet: value: float = driver.configure.iqVsSlot.get_fe_limit() \n
+		Defines the frequency estimation limit as signal level relative to the expected nominal power. Steps with a level below
+		this limit are not used for the frequency correction and do not contribute to the frequency results. \n
+			:return: limit: numeric Range: -100 dB to 0 dB, Unit: dB
+		"""
+		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:IQVSlot:FELimit?')
+		return Conversions.str_to_float(response)
 
-	def set_scount(self, statistic_count: int) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:SCOunt \n
-		Snippet: driver.configure.spectrum.set_scount(statistic_count = 1) \n
-		Specifies the statistic count of the measurement. The statistic count is equal to the number of measurement intervals per
-		single shot. \n
-			:param statistic_count: Number of measurement intervals. A measurement interval comprises a single frequency sweep. Range: 1 to 1000
+	def set_fe_limit(self, limit: float) -> None:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:IQVSlot:FELimit \n
+		Snippet: driver.configure.iqVsSlot.set_fe_limit(limit = 1.0) \n
+		Defines the frequency estimation limit as signal level relative to the expected nominal power. Steps with a level below
+		this limit are not used for the frequency correction and do not contribute to the frequency results. \n
+			:param limit: numeric Range: -100 dB to 0 dB, Unit: dB
 		"""
-		param = Conversions.decimal_value_to_str(statistic_count)
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:SPECtrum:SCOunt {param}')
+		param = Conversions.decimal_value_to_str(limit)
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:IQVSlot:FELimit {param}')
 
-	def clone(self) -> 'Spectrum':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'IqVsSlotCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Spectrum(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = IqVsSlotCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Spectrum_/FreqSweep.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Spectrum/FreqSweep/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class FreqSweep:
-	"""FreqSweep commands group definition. 6 total commands, 3 Sub-groups, 0 group commands"""
+class FreqSweepCls:
+	"""FreqSweep commands group definition. 6 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("freqSweep", core, parent)
+		self._cmd_group = CommandsGroup("freqSweep", core, parent)
 
 	@property
 	def rbw(self):
 		"""rbw commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_rbw'):
-			from .FreqSweep_.Rbw import Rbw
-			self._rbw = Rbw(self._core, self._base)
+			from .Rbw import RbwCls
+			self._rbw = RbwCls(self._core, self._cmd_group)
 		return self._rbw
 
 	@property
 	def vbw(self):
 		"""vbw commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_vbw'):
-			from .FreqSweep_.Vbw import Vbw
-			self._vbw = Vbw(self._core, self._base)
+			from .Vbw import VbwCls
+			self._vbw = VbwCls(self._core, self._cmd_group)
 		return self._vbw
 
 	@property
 	def swt(self):
 		"""swt commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_swt'):
-			from .FreqSweep_.Swt import Swt
-			self._swt = Swt(self._core, self._base)
+			from .Swt import SwtCls
+			self._swt = SwtCls(self._core, self._cmd_group)
 		return self._swt
 
-	def clone(self) -> 'FreqSweep':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'FreqSweepCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = FreqSweep(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = FreqSweepCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Spectrum_/FreqSweep_/Rbw.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Spectrum/FreqSweep/Rbw.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,50 +1,50 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Rbw:
-	"""Rbw commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class RbwCls:
+	"""Rbw commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbw", core, parent)
+		self._cmd_group = CommandsGroup("rbw", core, parent)
 
 	def get_auto(self) -> bool:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FSWeep:RBW:AUTO \n
 		Snippet: value: bool = driver.configure.spectrum.freqSweep.rbw.get_auto() \n
-		Sets or gets the state of the Auto-RBW selection for the frequency sweep mode. \n
+		Enables or disables the automatic mode for the RBW in frequency sweep mode. \n
 			:return: rbw_auto: OFF | ON
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FSWeep:RBW:AUTO?')
 		return Conversions.str_to_bool(response)
 
 	def set_auto(self, rbw_auto: bool) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FSWeep:RBW:AUTO \n
 		Snippet: driver.configure.spectrum.freqSweep.rbw.set_auto(rbw_auto = False) \n
-		Sets or gets the state of the Auto-RBW selection for the frequency sweep mode. \n
+		Enables or disables the automatic mode for the RBW in frequency sweep mode. \n
 			:param rbw_auto: OFF | ON
 		"""
 		param = Conversions.bool_to_str(rbw_auto)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FSWeep:RBW:AUTO {param}')
 
 	def get_value(self) -> float:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FSWeep:RBW \n
 		Snippet: value: float = driver.configure.spectrum.freqSweep.rbw.get_value() \n
-		Sets or gets the resolution bandwidth (RBW) for the frequency sweep mode. Setting this value is only possible if the
-		Auto-RBW selection for the sweep mode is switched OFF (see method RsCmwGprfMeas.Configure.Spectrum.FreqSweep.Rbw.auto) . \n
-			:return: rbw: Range: 100 Hz to 10 MHz, Unit: Hz
+		Configures the resolution bandwidth (RBW) for the frequency sweep mode. Setting this value is only possible if the
+		automatic mode is off. \n
+			:return: rbw: numeric Only certain values can be configured, see Table 'Supported values'. Other values are rounded to the next allowed value. Range: 100 Hz to 10 MHz, Unit: Hz
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FSWeep:RBW?')
 		return Conversions.str_to_float(response)
 
 	def set_value(self, rbw: float) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FSWeep:RBW \n
 		Snippet: driver.configure.spectrum.freqSweep.rbw.set_value(rbw = 1.0) \n
-		Sets or gets the resolution bandwidth (RBW) for the frequency sweep mode. Setting this value is only possible if the
-		Auto-RBW selection for the sweep mode is switched OFF (see method RsCmwGprfMeas.Configure.Spectrum.FreqSweep.Rbw.auto) . \n
-			:param rbw: Range: 100 Hz to 10 MHz, Unit: Hz
+		Configures the resolution bandwidth (RBW) for the frequency sweep mode. Setting this value is only possible if the
+		automatic mode is off. \n
+			:param rbw: numeric Only certain values can be configured, see Table 'Supported values'. Other values are rounded to the next allowed value. Range: 100 Hz to 10 MHz, Unit: Hz
 		"""
 		param = Conversions.decimal_value_to_str(rbw)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FSWeep:RBW {param}')
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Spectrum_/FreqSweep_/Swt.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Spectrum/FreqSweep/Swt.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,50 +1,50 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Swt:
-	"""Swt commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class SwtCls:
+	"""Swt commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("swt", core, parent)
+		self._cmd_group = CommandsGroup("swt", core, parent)
 
 	def get_auto(self) -> bool:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FSWeep:SWT:AUTO \n
 		Snippet: value: bool = driver.configure.spectrum.freqSweep.swt.get_auto() \n
-		Sets or gets the state of the Auto-SWT selection for the frequency sweep mode. \n
+		Enables or disables the automatic mode for the sweep time in frequency sweep mode. \n
 			:return: sweep_time_auto: OFF | ON
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FSWeep:SWT:AUTO?')
 		return Conversions.str_to_bool(response)
 
 	def set_auto(self, sweep_time_auto: bool) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FSWeep:SWT:AUTO \n
 		Snippet: driver.configure.spectrum.freqSweep.swt.set_auto(sweep_time_auto = False) \n
-		Sets or gets the state of the Auto-SWT selection for the frequency sweep mode. \n
+		Enables or disables the automatic mode for the sweep time in frequency sweep mode. \n
 			:param sweep_time_auto: OFF | ON
 		"""
 		param = Conversions.bool_to_str(sweep_time_auto)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FSWeep:SWT:AUTO {param}')
 
 	def get_value(self) -> float:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FSWeep:SWT \n
 		Snippet: value: float = driver.configure.spectrum.freqSweep.swt.get_value() \n
-		Sets or gets the sweep time (SWT) for the frequency sweep mode. Setting this value is only possible if the Auto-SWT
-		selection for the sweep mode is switched OFF (see method RsCmwGprfMeas.Configure.Spectrum.FreqSweep.Swt.auto) . \n
-			:return: sweep_time: Range: 0 s to 2000 s, Unit: s
+		Configures the sweep time for the frequency sweep mode. Setting this value is only possible if the automatic mode is off.
+		The minimum allowed value depends on the span. \n
+			:return: sweep_time: numeric Range: 0 s to 2000 s, Unit: s
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FSWeep:SWT?')
 		return Conversions.str_to_float(response)
 
 	def set_value(self, sweep_time: float) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FSWeep:SWT \n
 		Snippet: driver.configure.spectrum.freqSweep.swt.set_value(sweep_time = 1.0) \n
-		Sets or gets the sweep time (SWT) for the frequency sweep mode. Setting this value is only possible if the Auto-SWT
-		selection for the sweep mode is switched OFF (see method RsCmwGprfMeas.Configure.Spectrum.FreqSweep.Swt.auto) . \n
-			:param sweep_time: Range: 0 s to 2000 s, Unit: s
+		Configures the sweep time for the frequency sweep mode. Setting this value is only possible if the automatic mode is off.
+		The minimum allowed value depends on the span. \n
+			:param sweep_time: numeric Range: 0 s to 2000 s, Unit: s
 		"""
 		param = Conversions.decimal_value_to_str(sweep_time)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FSWeep:SWT {param}')
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Spectrum_/FreqSweep_/Vbw.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Spectrum/FreqSweep/Vbw.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,50 +1,50 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Vbw:
-	"""Vbw commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class VbwCls:
+	"""Vbw commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("vbw", core, parent)
+		self._cmd_group = CommandsGroup("vbw", core, parent)
 
 	def get_auto(self) -> bool:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FSWeep:VBW:AUTO \n
 		Snippet: value: bool = driver.configure.spectrum.freqSweep.vbw.get_auto() \n
-		Sets or gets the state of the Auto-VBW selection for the frequency sweep mode. \n
+		Enables or disables the automatic mode for the VBW in frequency sweep mode. \n
 			:return: vbw_auto: OFF | ON
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FSWeep:VBW:AUTO?')
 		return Conversions.str_to_bool(response)
 
 	def set_auto(self, vbw_auto: bool) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FSWeep:VBW:AUTO \n
 		Snippet: driver.configure.spectrum.freqSweep.vbw.set_auto(vbw_auto = False) \n
-		Sets or gets the state of the Auto-VBW selection for the frequency sweep mode. \n
+		Enables or disables the automatic mode for the VBW in frequency sweep mode. \n
 			:param vbw_auto: OFF | ON
 		"""
 		param = Conversions.bool_to_str(vbw_auto)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FSWeep:VBW:AUTO {param}')
 
 	def get_value(self) -> float or bool:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FSWeep:VBW \n
 		Snippet: value: float or bool = driver.configure.spectrum.freqSweep.vbw.get_value() \n
-		Sets or gets the video bandwidth (VBW) for the frequency sweep mode. Setting this value is only possible if the Auto-VBW
-		selection for the sweep mode is switched OFF (see method RsCmwGprfMeas.Configure.Spectrum.FreqSweep.Vbw.auto) . \n
-			:return: vbw: Range: 10 Hz to 10 MHz, Unit: Hz
+		Configures the video bandwidth (VBW) for the frequency sweep mode. Setting this value is only possible if the automatic
+		mode is off. \n
+			:return: vbw: (float or boolean) numeric | OFF Only certain values can be configured, see Table 'Supported values'. Other values are rounded to the next allowed value. Range: 10 Hz to 10 MHz, Unit: Hz
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FSWeep:VBW?')
 		return Conversions.str_to_float_or_bool(response)
 
 	def set_value(self, vbw: float or bool) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FSWeep:VBW \n
 		Snippet: driver.configure.spectrum.freqSweep.vbw.set_value(vbw = 1.0) \n
-		Sets or gets the video bandwidth (VBW) for the frequency sweep mode. Setting this value is only possible if the Auto-VBW
-		selection for the sweep mode is switched OFF (see method RsCmwGprfMeas.Configure.Spectrum.FreqSweep.Vbw.auto) . \n
-			:param vbw: Range: 10 Hz to 10 MHz, Unit: Hz
+		Configures the video bandwidth (VBW) for the frequency sweep mode. Setting this value is only possible if the automatic
+		mode is off. \n
+			:param vbw: (float or boolean) numeric | OFF Only certain values can be configured, see Table 'Supported values'. Other values are rounded to the next allowed value. Range: 10 Hz to 10 MHz, Unit: Hz
 		"""
 		param = Conversions.decimal_or_bool_value_to_str(vbw)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FSWeep:VBW {param}')
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Spectrum_/Frequency.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Spectrum/Frequency/__init__.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,120 +1,104 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Frequency:
-	"""Frequency commands group definition. 6 total commands, 1 Sub-groups, 4 group commands"""
+class FrequencyCls:
+	"""Frequency commands group definition. 6 total commands, 1 Subgroups, 4 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("frequency", core, parent)
+		self._cmd_group = CommandsGroup("frequency", core, parent)
 
 	@property
 	def span(self):
 		"""span commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_span'):
-			from .Frequency_.Span import Span
-			self._span = Span(self._core, self._base)
+			from .Span import SpanCls
+			self._span = SpanCls(self._core, self._cmd_group)
 		return self._span
 
 	def get_center(self) -> float:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FREQuency:CENTer \n
 		Snippet: value: float = driver.configure.spectrum.frequency.get_center() \n
-		Sets or gets the center frequency of the spectrum measurement.
-			INTRO_CMD_HELP: In frequency sweep mode (see method RsCmwGprfMeas.Configure.Spectrum.Frequency.Span.mode) , setting the center frequency adjusts the start and stop frequencies as follows: \n
-			- If the start frequency and stop frequency do not reach the minimum / maximum values, the frequency span is kept constant.
-			- If the start frequency or stop frequency reaches the minimum / maximum value, the frequency span is reduced automatically as far as required.
-		In zero span mode, setting the center frequency leaves the start frequency, stop frequency and span unchanged.
-		These values are adjusted according to the new center frequency and (appropriately reduced) span when the frequency sweep
-		mode is selected. This command is only relevant for the standalone scenario. For the combined signal path scenario, use
-		the corresponding ...:SIGN<i>:.. command. The supported frequency range depends on the instrument model and the available
-		options. The supported range can be smaller than stated here. Refer to the preface of your model-specific base unit
-		manual. \n
-			:return: center_frequency: Range: 70 MHz to 6 GHz, Unit: Hz
+		Configures the center frequency of the spectrum measurement. This command is only relevant for the standalone scenario.
+		For the combined signal path scenario, use the corresponding ...:SIGN<i>:.. command. For the supported frequency range,
+		see 'Frequency ranges'. \n
+			:return: center_frequency: numeric Unit: Hz
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FREQuency:CENTer?')
 		return Conversions.str_to_float(response)
 
 	def set_center(self, center_frequency: float) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FREQuency:CENTer \n
 		Snippet: driver.configure.spectrum.frequency.set_center(center_frequency = 1.0) \n
-		Sets or gets the center frequency of the spectrum measurement.
-			INTRO_CMD_HELP: In frequency sweep mode (see method RsCmwGprfMeas.Configure.Spectrum.Frequency.Span.mode) , setting the center frequency adjusts the start and stop frequencies as follows: \n
-			- If the start frequency and stop frequency do not reach the minimum / maximum values, the frequency span is kept constant.
-			- If the start frequency or stop frequency reaches the minimum / maximum value, the frequency span is reduced automatically as far as required.
-		In zero span mode, setting the center frequency leaves the start frequency, stop frequency and span unchanged.
-		These values are adjusted according to the new center frequency and (appropriately reduced) span when the frequency sweep
-		mode is selected. This command is only relevant for the standalone scenario. For the combined signal path scenario, use
-		the corresponding ...:SIGN<i>:.. command. The supported frequency range depends on the instrument model and the available
-		options. The supported range can be smaller than stated here. Refer to the preface of your model-specific base unit
-		manual. \n
-			:param center_frequency: Range: 70 MHz to 6 GHz, Unit: Hz
+		Configures the center frequency of the spectrum measurement. This command is only relevant for the standalone scenario.
+		For the combined signal path scenario, use the corresponding ...:SIGN<i>:.. command. For the supported frequency range,
+		see 'Frequency ranges'. \n
+			:param center_frequency: numeric Unit: Hz
 		"""
 		param = Conversions.decimal_value_to_str(center_frequency)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FREQuency:CENTer {param}')
 
 	def get_start(self) -> float:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FREQuency:STARt \n
 		Snippet: value: float = driver.configure.spectrum.frequency.get_start() \n
-		Sets or gets the start frequency of the frequency sweep. \n
-			:return: start_frequency: Range: 7E+7 Hz to 6 GHz , Unit: Hz
+		Configures the start frequency of the frequency sweep. For the supported frequency range, see 'Frequency ranges'. \n
+			:return: start_frequency: numeric Unit: Hz
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FREQuency:STARt?')
 		return Conversions.str_to_float(response)
 
 	def set_start(self, start_frequency: float) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FREQuency:STARt \n
 		Snippet: driver.configure.spectrum.frequency.set_start(start_frequency = 1.0) \n
-		Sets or gets the start frequency of the frequency sweep. \n
-			:param start_frequency: Range: 7E+7 Hz to 6 GHz , Unit: Hz
+		Configures the start frequency of the frequency sweep. For the supported frequency range, see 'Frequency ranges'. \n
+			:param start_frequency: numeric Unit: Hz
 		"""
 		param = Conversions.decimal_value_to_str(start_frequency)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FREQuency:STARt {param}')
 
 	def get_stop(self) -> float:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FREQuency:STOP \n
 		Snippet: value: float = driver.configure.spectrum.frequency.get_stop() \n
-		Sets or gets the stop frequency of the frequency sweep. \n
-			:return: stop_frequency: Range: 7E+7 Hz to 6 GHz , Unit: Hz
+		Configures the stop frequency of the frequency sweep. For the supported frequency range, see 'Frequency ranges'. \n
+			:return: stop_frequency: numeric Unit: Hz
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FREQuency:STOP?')
 		return Conversions.str_to_float(response)
 
 	def set_stop(self, stop_frequency: float) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FREQuency:STOP \n
 		Snippet: driver.configure.spectrum.frequency.set_stop(stop_frequency = 1.0) \n
-		Sets or gets the stop frequency of the frequency sweep. \n
-			:param stop_frequency: Range: 7E+7 Hz to 6 GHz , Unit: Hz
+		Configures the stop frequency of the frequency sweep. For the supported frequency range, see 'Frequency ranges'. \n
+			:param stop_frequency: numeric Unit: Hz
 		"""
 		param = Conversions.decimal_value_to_str(stop_frequency)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FREQuency:STOP {param}')
 
 	def get_laspan(self) -> float:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FREQuency:LASPan \n
 		Snippet: value: float = driver.configure.spectrum.frequency.get_laspan() \n
-		Sets the span for frequency sweep measurements to its previous value or queries the span's previous value (see method
-		RsCmwGprfMeas.Configure.Spectrum.Frequency.Span.value) . \n
-			:return: last_span: Range: 0 Hz to 6 GHz, Unit: Hz
+		No command help available \n
+			:return: last_span: No help available
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FREQuency:LASPan?')
 		return Conversions.str_to_float(response)
 
 	def set_laspan(self, last_span: float) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FREQuency:LASPan \n
 		Snippet: driver.configure.spectrum.frequency.set_laspan(last_span = 1.0) \n
-		Sets the span for frequency sweep measurements to its previous value or queries the span's previous value (see method
-		RsCmwGprfMeas.Configure.Spectrum.Frequency.Span.value) . \n
-			:param last_span: Range: 0 Hz to 6 GHz, Unit: Hz
+		No command help available \n
+			:param last_span: No help available
 		"""
 		param = Conversions.decimal_value_to_str(last_span)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:SPECtrum:FREQuency:LASPan {param}')
 
-	def clone(self) -> 'Frequency':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'FrequencyCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Frequency(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = FrequencyCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Spectrum_/ZeroSpan.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Nrpm/__init__.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,54 +1,56 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
+from ...Internal.Core import Core
+from ...Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ZeroSpan:
-	"""ZeroSpan commands group definition. 6 total commands, 2 Sub-groups, 1 group commands"""
+class NrpmCls:
+	"""Nrpm commands group definition. 8 total commands, 2 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("zeroSpan", core, parent)
+		self._cmd_group = CommandsGroup("nrpm", core, parent)
 
 	@property
-	def rbw(self):
-		"""rbw commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_rbw'):
-			from .ZeroSpan_.Rbw import Rbw
-			self._rbw = Rbw(self._core, self._base)
-		return self._rbw
+	def state(self):
+		"""state commands group. 1 Sub-classes, 1 commands."""
+		if not hasattr(self, '_state'):
+			from .State import StateCls
+			self._state = StateCls(self._core, self._cmd_group)
+		return self._state
 
 	@property
-	def vbw(self):
-		"""vbw commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_vbw'):
-			from .ZeroSpan_.Vbw import Vbw
-			self._vbw = Vbw(self._core, self._base)
-		return self._vbw
-
-	def get_swt(self) -> float:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:ZSPan:SWT \n
-		Snippet: value: float = driver.configure.spectrum.zeroSpan.get_swt() \n
-		Sets or gets the sweep time (SWT) for the zero span mode. \n
-			:return: sweep_time: Range: 0 s to 2000 s, Unit: s
-		"""
-		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:SPECtrum:ZSPan:SWT?')
-		return Conversions.str_to_float(response)
-
-	def set_swt(self, sweep_time: float) -> None:
-		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:ZSPan:SWT \n
-		Snippet: driver.configure.spectrum.zeroSpan.set_swt(sweep_time = 1.0) \n
-		Sets or gets the sweep time (SWT) for the zero span mode. \n
-			:param sweep_time: Range: 0 s to 2000 s, Unit: s
-		"""
-		param = Conversions.decimal_value_to_str(sweep_time)
-		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:SPECtrum:ZSPan:SWT {param}')
+	def sensor(self):
+		"""sensor commands group. 1 Sub-classes, 0 commands."""
+		if not hasattr(self, '_sensor'):
+			from .Sensor import SensorCls
+			self._sensor = SensorCls(self._core, self._cmd_group)
+		return self._sensor
+
+	def initiate(self, opc_timeout_ms: int = -1) -> None:
+		"""SCPI: INITiate:GPRF:MEASurement<Instance>:NRPM \n
+		Snippet: driver.nrpm.initiate() \n
+		No command help available \n
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'INITiate:GPRF:MEASurement<Instance>:NRPM', opc_timeout_ms)
+
+	def stop(self, opc_timeout_ms: int = -1) -> None:
+		"""SCPI: STOP:GPRF:MEASurement<Instance>:NRPM \n
+		Snippet: driver.nrpm.stop() \n
+		No command help available \n
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'STOP:GPRF:MEASurement<Instance>:NRPM', opc_timeout_ms)
+
+	def abort(self, opc_timeout_ms: int = -1) -> None:
+		"""SCPI: ABORt:GPRF:MEASurement<Instance>:NRPM \n
+		Snippet: driver.nrpm.abort() \n
+		No command help available \n
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'ABORt:GPRF:MEASurement<Instance>:NRPM', opc_timeout_ms)
 
-	def clone(self) -> 'ZeroSpan':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'NrpmCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ZeroSpan(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = NrpmCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Spectrum_/ZeroSpan_/Rbw.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Spectrum/ZeroSpan/Rbw.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,72 +1,68 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Rbw:
-	"""Rbw commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class RbwCls:
+	"""Rbw commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rbw", core, parent)
+		self._cmd_group = CommandsGroup("rbw", core, parent)
 
 	# noinspection PyTypeChecker
 	def get_type_py(self) -> enums.RbwFilterType:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:ZSPan:RBW:TYPE \n
 		Snippet: value: enums.RbwFilterType = driver.configure.spectrum.zeroSpan.rbw.get_type_py() \n
-		Sets/gets the type of the resolution filter to be used in zero span mode. \n
+		Configures the type of the resolution filter to be used in zero span mode. \n
 			:return: rbw_type: GAUSs | BANDpass
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:SPECtrum:ZSPan:RBW:TYPE?')
 		return Conversions.str_to_scalar_enum(response, enums.RbwFilterType)
 
 	def set_type_py(self, rbw_type: enums.RbwFilterType) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:ZSPan:RBW:TYPE \n
 		Snippet: driver.configure.spectrum.zeroSpan.rbw.set_type_py(rbw_type = enums.RbwFilterType.BANDpass) \n
-		Sets/gets the type of the resolution filter to be used in zero span mode. \n
+		Configures the type of the resolution filter to be used in zero span mode. \n
 			:param rbw_type: GAUSs | BANDpass
 		"""
 		param = Conversions.enum_scalar_to_str(rbw_type, enums.RbwFilterType)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:SPECtrum:ZSPan:RBW:TYPE {param}')
 
 	def get_bandpass(self) -> float:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:ZSPan:RBW:BANDpass \n
 		Snippet: value: float = driver.configure.spectrum.zeroSpan.rbw.get_bandpass() \n
-		Sets/gets the bandwidth of the bandpass resolution filter (see method RsCmwGprfMeas.Configure.Spectrum.ZeroSpan.Rbw.
-		typePy) . Note that currently only a filter bandwidth of 40 MHz is supported. \n
-			:return: rbw_bandpass: Range: 40 MHz to 40 MHz, Unit: Hz
+		Configures the bandwidth of the bandpass resolution filter. In the current software version, the value is fixed. \n
+			:return: rbw_bandpass: numeric Range: 40 MHz to 40 MHz, Unit: Hz
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:SPECtrum:ZSPan:RBW:BANDpass?')
 		return Conversions.str_to_float(response)
 
 	def set_bandpass(self, rbw_bandpass: float) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:ZSPan:RBW:BANDpass \n
 		Snippet: driver.configure.spectrum.zeroSpan.rbw.set_bandpass(rbw_bandpass = 1.0) \n
-		Sets/gets the bandwidth of the bandpass resolution filter (see method RsCmwGprfMeas.Configure.Spectrum.ZeroSpan.Rbw.
-		typePy) . Note that currently only a filter bandwidth of 40 MHz is supported. \n
-			:param rbw_bandpass: Range: 40 MHz to 40 MHz, Unit: Hz
+		Configures the bandwidth of the bandpass resolution filter. In the current software version, the value is fixed. \n
+			:param rbw_bandpass: numeric Range: 40 MHz to 40 MHz, Unit: Hz
 		"""
 		param = Conversions.decimal_value_to_str(rbw_bandpass)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:SPECtrum:ZSPan:RBW:BANDpass {param}')
 
 	def get_gauss(self) -> float:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:ZSPan:RBW:GAUSs \n
 		Snippet: value: float = driver.configure.spectrum.zeroSpan.rbw.get_gauss() \n
-		Sets/gets the bandwidth of the Gaussian resolution filter, see method RsCmwGprfMeas.Configure.Spectrum.ZeroSpan.Rbw.
-		typePy. \n
-			:return: rbw: Range: 100 Hz to 10 MHz, Unit: Hz
+		Configures the bandwidth of the Gaussian resolution filter. \n
+			:return: rbw: numeric Only certain values can be configured, see Table 'Supported values'. Other values are rounded to the next allowed value. Range: 100 Hz to 10 MHz, Unit: Hz
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:SPECtrum:ZSPan:RBW:GAUSs?')
 		return Conversions.str_to_float(response)
 
 	def set_gauss(self, rbw: float) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:ZSPan:RBW:GAUSs \n
 		Snippet: driver.configure.spectrum.zeroSpan.rbw.set_gauss(rbw = 1.0) \n
-		Sets/gets the bandwidth of the Gaussian resolution filter, see method RsCmwGprfMeas.Configure.Spectrum.ZeroSpan.Rbw.
-		typePy. \n
-			:param rbw: Range: 100 Hz to 10 MHz, Unit: Hz
+		Configures the bandwidth of the Gaussian resolution filter. \n
+			:param rbw: numeric Only certain values can be configured, see Table 'Supported values'. Other values are rounded to the next allowed value. Range: 100 Hz to 10 MHz, Unit: Hz
 		"""
 		param = Conversions.decimal_value_to_str(rbw)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:SPECtrum:ZSPan:RBW:GAUSs {param}')
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Configure_/Spectrum_/ZeroSpan_/Vbw.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Spectrum/ZeroSpan/Vbw.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,50 +1,50 @@
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Vbw:
-	"""Vbw commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class VbwCls:
+	"""Vbw commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("vbw", core, parent)
+		self._cmd_group = CommandsGroup("vbw", core, parent)
 
 	def get_auto(self) -> bool:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:ZSPan:VBW:AUTO \n
 		Snippet: value: bool = driver.configure.spectrum.zeroSpan.vbw.get_auto() \n
-		Sets or gets the state of the Auto-VBW selection for the zero span mode. \n
+		Enables or disables the automatic mode for the VBW in zero span mode. \n
 			:return: vbw_auto: OFF | ON
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:SPECtrum:ZSPan:VBW:AUTO?')
 		return Conversions.str_to_bool(response)
 
 	def set_auto(self, vbw_auto: bool) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:ZSPan:VBW:AUTO \n
 		Snippet: driver.configure.spectrum.zeroSpan.vbw.set_auto(vbw_auto = False) \n
-		Sets or gets the state of the Auto-VBW selection for the zero span mode. \n
+		Enables or disables the automatic mode for the VBW in zero span mode. \n
 			:param vbw_auto: OFF | ON
 		"""
 		param = Conversions.bool_to_str(vbw_auto)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:SPECtrum:ZSPan:VBW:AUTO {param}')
 
 	def get_value(self) -> float or bool:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:ZSPan:VBW \n
 		Snippet: value: float or bool = driver.configure.spectrum.zeroSpan.vbw.get_value() \n
-		Sets or gets the video bandwidth (VBW) for the zero span mode. Setting this value is only possible if the Auto-VBW
-		selection for the zero span mode is switched OFF (see method RsCmwGprfMeas.Configure.Spectrum.ZeroSpan.Vbw.auto) . \n
-			:return: vbw: Range: 10 Hz to 10 MHz, Unit: Hz
+		Configures the video bandwidth (VBW) for the zero span mode. Setting this value is only possible if the automatic mode is
+		off. \n
+			:return: vbw: (float or boolean) numeric | OFF Only certain values can be configured, see Table 'Supported values'. Other values are rounded to the next allowed value. Range: 10 Hz to 10 MHz, Unit: Hz
 		"""
 		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:SPECtrum:ZSPan:VBW?')
 		return Conversions.str_to_float_or_bool(response)
 
 	def set_value(self, vbw: float or bool) -> None:
 		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:SPECtrum:ZSPan:VBW \n
 		Snippet: driver.configure.spectrum.zeroSpan.vbw.set_value(vbw = 1.0) \n
-		Sets or gets the video bandwidth (VBW) for the zero span mode. Setting this value is only possible if the Auto-VBW
-		selection for the zero span mode is switched OFF (see method RsCmwGprfMeas.Configure.Spectrum.ZeroSpan.Vbw.auto) . \n
-			:param vbw: Range: 10 Hz to 10 MHz, Unit: Hz
+		Configures the video bandwidth (VBW) for the zero span mode. Setting this value is only possible if the automatic mode is
+		off. \n
+			:param vbw: (float or boolean) numeric | OFF Only certain values can be configured, see Table 'Supported values'. Other values are rounded to the next allowed value. Range: 10 Hz to 10 MHz, Unit: Hz
 		"""
 		param = Conversions.decimal_or_bool_value_to_str(vbw)
 		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:SPECtrum:ZSPan:VBW {param}')
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/ExtPwrSensor_/State.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ListPy/SingleCmw/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,39 +1,48 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ... import enums
+from ......Internal.Core import Core
+from ......Internal.CommandsGroup import CommandsGroup
+from ......Internal import Conversions
+from ...... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class State:
-	"""State commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class SingleCmwCls:
+	"""SingleCmw commands group definition. 3 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("state", core, parent)
+		self._cmd_group = CommandsGroup("singleCmw", core, parent)
 
 	@property
-	def all(self):
-		"""all commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_all'):
-			from .State_.All import All
-			self._all = All(self._core, self._base)
-		return self._all
+	def connector(self):
+		"""connector commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_connector'):
+			from .Connector import ConnectorCls
+			self._connector = ConnectorCls(self._core, self._cmd_group)
+		return self._connector
 
 	# noinspection PyTypeChecker
-	def fetch(self) -> enums.ResourceState:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:EPSensor:STATe \n
-		Snippet: value: enums.ResourceState = driver.extPwrSensor.state.fetch() \n
-		Queries the main measurement state. Use FETCh:...:STATe:ALL? to query the measurement state including the substates. Use
-		INITiate..., STOP..., ABORt...to change the measurement state. \n
-			:return: meas_state: OFF | RUN | RDY OFF: measurement off, no resources allocated, no results RUN: measurement running, synchronization pending or adjusted, resources active or queued RDY: measurement finished"""
-		response = self._core.io.query_str(f'FETCh:GPRF:MEASurement<Instance>:EPSensor:STATe?')
-		return Conversions.str_to_scalar_enum(response, enums.ResourceState)
+	def get_cmode(self) -> enums.ParameterSetMode:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:CMWS:CMODe \n
+		Snippet: value: enums.ParameterSetMode = driver.configure.power.listPy.singleCmw.get_cmode() \n
+		No command help available \n
+			:return: cmws_connector_mode: No help available
+		"""
+		response = self._core.io.query_str('CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:CMWS:CMODe?')
+		return Conversions.str_to_scalar_enum(response, enums.ParameterSetMode)
+
+	def set_cmode(self, cmws_connector_mode: enums.ParameterSetMode) -> None:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:CMWS:CMODe \n
+		Snippet: driver.configure.power.listPy.singleCmw.set_cmode(cmws_connector_mode = enums.ParameterSetMode.GLOBal) \n
+		No command help available \n
+			:param cmws_connector_mode: No help available
+		"""
+		param = Conversions.enum_scalar_to_str(cmws_connector_mode, enums.ParameterSetMode)
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:CMWS:CMODe {param}')
 
-	def clone(self) -> 'State':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SingleCmwCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = State(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SingleCmwCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/ExtPwrSensor_/State_/All.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Current/Minimum.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,26 +1,35 @@
 from typing import List
 
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from .... import enums
+from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class All:
-	"""All commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("all", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
-	# noinspection PyTypeChecker
-	def fetch(self) -> List[enums.ResourceState]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:EPSensor:STATe:ALL \n
-		Snippet: value: List[enums.ResourceState] = driver.extPwrSensor.state.all.fetch() \n
-		Queries the main measurement state and the measurement substates. Both measurement substates are relevant for running
-		measurements only. Use FETCh:...:STATe? to query the main measurement state only. Use INITiate..., STOP..., ABORt...
-		to change the measurement state. \n
-			:return: meas_state: No help available"""
-		response = self._core.io.query_str(f'FETCh:GPRF:MEASurement<Instance>:EPSensor:STATe:ALL?')
-		return Conversions.str_to_list_enum(response, enums.ResourceState)
+	def fetch(self) -> List[float]:
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:CURRent:MINimum \n
+		Snippet: value: List[float] = driver.power.current.minimum.fetch() \n
+		No command help available \n
+		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
+			:return: power_current_min: No help available"""
+		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:CURRent:MINimum?', suppressed)
+		return response
+
+	def read(self) -> List[float]:
+		"""SCPI: READ:GPRF:MEASurement<Instance>:POWer:CURRent:MINimum \n
+		Snippet: value: List[float] = driver.power.current.minimum.read() \n
+		No command help available \n
+		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
+			:return: power_current_min: No help available"""
+		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:POWer:CURRent:MINimum?', suppressed)
+		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/FftSpecAn_/Icomponent.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/FftSpecAn/Icomponent.py`

 * *Files 17% similar despite different names*

```diff
@@ -3,33 +3,33 @@
 from ...Internal.Core import Core
 from ...Internal.CommandsGroup import CommandsGroup
 from ...Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ...Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Icomponent:
-	"""Icomponent commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class IcomponentCls:
+	"""Icomponent commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("icomponent", core, parent)
+		self._cmd_group = CommandsGroup("icomponent", core, parent)
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:GPRF:MEASurement<Instance>:FFTSanalyzer:I \n
 		Snippet: value: List[float] = driver.fftSpecAn.icomponent.read() \n
 		Returns the measured normalized I and Q amplitudes in the time domain. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: idata: Comma-separated list of n normalized I or Q amplitudes, where n is given by the FFT length, see method RsCmwGprfMeas.Configure.FftSpecAn.fftLength. Range: -2 to 2"""
+			:return: idata: float Comma-separated list of N normalized I or Q amplitudes. N equals the configured FFT length."""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:FFTSanalyzer:I?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:GPRF:MEASurement<Instance>:FFTSanalyzer:I \n
 		Snippet: value: List[float] = driver.fftSpecAn.icomponent.fetch() \n
 		Returns the measured normalized I and Q amplitudes in the time domain. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: idata: Comma-separated list of n normalized I or Q amplitudes, where n is given by the FFT length, see method RsCmwGprfMeas.Configure.FftSpecAn.fftLength. Range: -2 to 2"""
+			:return: idata: float Comma-separated list of N normalized I or Q amplitudes. N equals the configured FFT length."""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:FFTSanalyzer:I?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/FftSpecAn_/Peaks.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/FftSpecAn/Peaks/__init__.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Peaks:
-	"""Peaks commands group definition. 4 total commands, 2 Sub-groups, 0 group commands"""
+class PeaksCls:
+	"""Peaks commands group definition. 4 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("peaks", core, parent)
+		self._cmd_group = CommandsGroup("peaks", core, parent)
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Peaks_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Peaks_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
-	def clone(self) -> 'Peaks':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PeaksCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Peaks(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PeaksCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/FftSpecAn_/Peaks_/Average.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/FftSpecAn/Peaks/Average.py`

 * *Files 18% similar despite different names*

```diff
@@ -4,46 +4,48 @@
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.Types import DataType
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: See 'Reliability Indicator'
-			- Frequency: List[float]: The range depends on the search range settings, see [CMDLINK: CONFigure:GPRF:MEASi:FFTSanalyzer:PSEarch CMDLINK]. Unit: Hz
-			- Level: List[float]: Range: -100 dBm to 57 dBm, Unit: dBm"""
+			- Reliability: int: decimal See 'Reliability indicator'
+			- Frequency: List[float]: float Frequency of the detected peak Unit: Hz
+			- Level: List[float]: float Level of the detected peak Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Frequency', DataType.FloatList, None, False, True, 1),
 			ArgStruct('Level', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Frequency: List[float] = None
 			self.Level: List[float] = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:GPRF:MEASurement<Instance>:FFTSanalyzer:PEAKs:AVERage \n
 		Snippet: value: ResultData = driver.fftSpecAn.peaks.average.read() \n
-		Returns the results of the peak search. Separate commands retrieve current and average values. There are results for
-		search range no. 0 to 4: <Reliability>, <Frequency0>, <Power0>, ..., <Frequency4>, <Power4> \n
+		Returns the results of the peak search in the spectrum diagram. Separate commands retrieve results for the current trace
+		and for the average trace. The results are returned in the following order: <Reliability>, {<Frequency>, <Level>}marker 0,
+		..., {<Frequency>, <Level>}marker 4 \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:GPRF:MEASurement<Instance>:FFTSanalyzer:PEAKs:AVERage?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:GPRF:MEASurement<Instance>:FFTSanalyzer:PEAKs:AVERage \n
 		Snippet: value: ResultData = driver.fftSpecAn.peaks.average.fetch() \n
-		Returns the results of the peak search. Separate commands retrieve current and average values. There are results for
-		search range no. 0 to 4: <Reliability>, <Frequency0>, <Power0>, ..., <Frequency4>, <Power4> \n
+		Returns the results of the peak search in the spectrum diagram. Separate commands retrieve results for the current trace
+		and for the average trace. The results are returned in the following order: <Reliability>, {<Frequency>, <Level>}marker 0,
+		..., {<Frequency>, <Level>}marker 4 \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:GPRF:MEASurement<Instance>:FFTSanalyzer:PEAKs:AVERage?', self.__class__.ResultData())
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/FftSpecAn_/Peaks_/Current.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/FftSpecAn/Peaks/Current.py`

 * *Files 21% similar despite different names*

```diff
@@ -4,46 +4,48 @@
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.Types import DataType
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: See 'Reliability Indicator'
-			- Frequency: List[float]: The range depends on the search range settings, see [CMDLINK: CONFigure:GPRF:MEASi:FFTSanalyzer:PSEarch CMDLINK]. Unit: Hz
-			- Level: List[float]: Range: -100 dBm to 57 dBm, Unit: dBm"""
+			- Reliability: int: decimal See 'Reliability indicator'
+			- Frequency: List[float]: float Frequency of the detected peak Unit: Hz
+			- Level: List[float]: float Level of the detected peak Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct('Frequency', DataType.FloatList, None, False, True, 1),
 			ArgStruct('Level', DataType.FloatList, None, False, True, 1)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Frequency: List[float] = None
 			self.Level: List[float] = None
 
 	def read(self) -> ResultData:
 		"""SCPI: READ:GPRF:MEASurement<Instance>:FFTSanalyzer:PEAKs:CURRent \n
 		Snippet: value: ResultData = driver.fftSpecAn.peaks.current.read() \n
-		Returns the results of the peak search. Separate commands retrieve current and average values. There are results for
-		search range no. 0 to 4: <Reliability>, <Frequency0>, <Power0>, ..., <Frequency4>, <Power4> \n
+		Returns the results of the peak search in the spectrum diagram. Separate commands retrieve results for the current trace
+		and for the average trace. The results are returned in the following order: <Reliability>, {<Frequency>, <Level>}marker 0,
+		..., {<Frequency>, <Level>}marker 4 \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'READ:GPRF:MEASurement<Instance>:FFTSanalyzer:PEAKs:CURRent?', self.__class__.ResultData())
 
 	def fetch(self) -> ResultData:
 		"""SCPI: FETCh:GPRF:MEASurement<Instance>:FFTSanalyzer:PEAKs:CURRent \n
 		Snippet: value: ResultData = driver.fftSpecAn.peaks.current.fetch() \n
-		Returns the results of the peak search. Separate commands retrieve current and average values. There are results for
-		search range no. 0 to 4: <Reliability>, <Frequency0>, <Power0>, ..., <Frequency4>, <Power4> \n
+		Returns the results of the peak search in the spectrum diagram. Separate commands retrieve results for the current trace
+		and for the average trace. The results are returned in the following order: <Reliability>, {<Frequency>, <Level>}marker 0,
+		..., {<Frequency>, <Level>}marker 4 \n
 			:return: structure: for return value, see the help for ResultData structure arguments."""
 		return self._core.io.query_struct(f'FETCh:GPRF:MEASurement<Instance>:FFTSanalyzer:PEAKs:CURRent?', self.__class__.ResultData())
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/FftSpecAn_/Power.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Sample/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Power:
-	"""Power commands group definition. 8 total commands, 4 Sub-groups, 0 group commands"""
+class SampleCls:
+	"""Sample commands group definition. 8 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("power", core, parent)
+		self._cmd_group = CommandsGroup("sample", core, parent)
+
+	@property
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
+
+	@property
+	def minimum(self):
+		"""minimum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_minimum'):
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
+		return self._minimum
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Power_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Power_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
-	@property
-	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_minimum'):
-			from .Power_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
-
-	@property
-	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_maximum'):
-			from .Power_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
-
-	def clone(self) -> 'Power':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SampleCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Power(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SampleCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/FftSpecAn_/Power_/Average.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/FftSpecAn/Power/Minimum.py`

 * *Files 18% similar despite different names*

```diff
@@ -3,35 +3,35 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:FFTSanalyzer:POWer:AVERage \n
-		Snippet: value: List[float] = driver.fftSpecAn.power.average.fetch() \n
-		Returns the FFT spectrum analyzer traces across the selected frequency span (see method RsCmwGprfMeas.Configure.FftSpecAn.
-		fspan) . The results of the current, average, minimum and maximum traces can be retrieved. \n
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:FFTSanalyzer:POWer:MINimum \n
+		Snippet: value: List[float] = driver.fftSpecAn.power.minimum.fetch() \n
+		Returns the traces of the spectrum diagram. The current, average, minimum and maximum traces can be retrieved. Each trace
+		contains 801 power values and covers the configured frequency span. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: Frequency-dependent power values. Each of the traces contains 801 values, irrespective of the frequency span. Range: -100.0 dBm to 57.0 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 801 power values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:FFTSanalyzer:POWer:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:FFTSanalyzer:POWer:MINimum?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:GPRF:MEASurement<Instance>:FFTSanalyzer:POWer:AVERage \n
-		Snippet: value: List[float] = driver.fftSpecAn.power.average.read() \n
-		Returns the FFT spectrum analyzer traces across the selected frequency span (see method RsCmwGprfMeas.Configure.FftSpecAn.
-		fspan) . The results of the current, average, minimum and maximum traces can be retrieved. \n
+		"""SCPI: READ:GPRF:MEASurement<Instance>:FFTSanalyzer:POWer:MINimum \n
+		Snippet: value: List[float] = driver.fftSpecAn.power.minimum.read() \n
+		Returns the traces of the spectrum diagram. The current, average, minimum and maximum traces can be retrieved. Each trace
+		contains 801 power values and covers the configured frequency span. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: Frequency-dependent power values. Each of the traces contains 801 values, irrespective of the frequency span. Range: -100.0 dBm to 57.0 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 801 power values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:FFTSanalyzer:POWer:AVERage?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:FFTSanalyzer:POWer:MINimum?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/FftSpecAn_/Power_/Current.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/FftSpecAn/Power/Maximum.py`

 * *Files 15% similar despite different names*

```diff
@@ -3,35 +3,35 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:FFTSanalyzer:POWer:CURRent \n
-		Snippet: value: List[float] = driver.fftSpecAn.power.current.fetch() \n
-		Returns the FFT spectrum analyzer traces across the selected frequency span (see method RsCmwGprfMeas.Configure.FftSpecAn.
-		fspan) . The results of the current, average, minimum and maximum traces can be retrieved. \n
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:FFTSanalyzer:POWer:MAXimum \n
+		Snippet: value: List[float] = driver.fftSpecAn.power.maximum.fetch() \n
+		Returns the traces of the spectrum diagram. The current, average, minimum and maximum traces can be retrieved. Each trace
+		contains 801 power values and covers the configured frequency span. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: Frequency-dependent power values. Each of the traces contains 801 values, irrespective of the frequency span. Range: -100.0 dBm to 57.0 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 801 power values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:FFTSanalyzer:POWer:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:FFTSanalyzer:POWer:MAXimum?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:GPRF:MEASurement<Instance>:FFTSanalyzer:POWer:CURRent \n
-		Snippet: value: List[float] = driver.fftSpecAn.power.current.read() \n
-		Returns the FFT spectrum analyzer traces across the selected frequency span (see method RsCmwGprfMeas.Configure.FftSpecAn.
-		fspan) . The results of the current, average, minimum and maximum traces can be retrieved. \n
+		"""SCPI: READ:GPRF:MEASurement<Instance>:FFTSanalyzer:POWer:MAXimum \n
+		Snippet: value: List[float] = driver.fftSpecAn.power.maximum.read() \n
+		Returns the traces of the spectrum diagram. The current, average, minimum and maximum traces can be retrieved. Each trace
+		contains 801 power values and covers the configured frequency span. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: Frequency-dependent power values. Each of the traces contains 801 values, irrespective of the frequency span. Range: -100.0 dBm to 57.0 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 801 power values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:FFTSanalyzer:POWer:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:FFTSanalyzer:POWer:MAXimum?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/FftSpecAn_/Power_/Maximum.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Sample/Average.py`

 * *Files 24% similar despite different names*

```diff
@@ -3,35 +3,33 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:FFTSanalyzer:POWer:MAXimum \n
-		Snippet: value: List[float] = driver.fftSpecAn.power.maximum.fetch() \n
-		Returns the FFT spectrum analyzer traces across the selected frequency span (see method RsCmwGprfMeas.Configure.FftSpecAn.
-		fspan) . The results of the current, average, minimum and maximum traces can be retrieved. \n
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:SAMPle:AVERage \n
+		Snippet: value: List[float] = driver.spectrum.sample.average.fetch() \n
+		Returns the traces calculated with the sample detector. Current, average, maximum and minimum traces can be retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: Frequency-dependent power values. Each of the traces contains 801 values, irrespective of the frequency span. Range: -100.0 dBm to 57.0 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:FFTSanalyzer:POWer:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:SAMPle:AVERage?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:GPRF:MEASurement<Instance>:FFTSanalyzer:POWer:MAXimum \n
-		Snippet: value: List[float] = driver.fftSpecAn.power.maximum.read() \n
-		Returns the FFT spectrum analyzer traces across the selected frequency span (see method RsCmwGprfMeas.Configure.FftSpecAn.
-		fspan) . The results of the current, average, minimum and maximum traces can be retrieved. \n
+		"""SCPI: READ:GPRF:MEASurement<Instance>:SPECtrum:SAMPle:AVERage \n
+		Snippet: value: List[float] = driver.spectrum.sample.average.read() \n
+		Returns the traces calculated with the sample detector. Current, average, maximum and minimum traces can be retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: Frequency-dependent power values. Each of the traces contains 801 values, irrespective of the frequency span. Range: -100.0 dBm to 57.0 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:FFTSanalyzer:POWer:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:SPECtrum:SAMPle:AVERage?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/FftSpecAn_/Qcomponent.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/IqVsSlot/Icomponent.py`

 * *Files 18% similar despite different names*

```diff
@@ -3,33 +3,33 @@
 from ...Internal.Core import Core
 from ...Internal.CommandsGroup import CommandsGroup
 from ...Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ...Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Qcomponent:
-	"""Qcomponent commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class IcomponentCls:
+	"""Icomponent commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("qcomponent", core, parent)
+		self._cmd_group = CommandsGroup("icomponent", core, parent)
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:GPRF:MEASurement<Instance>:FFTSanalyzer:Q \n
-		Snippet: value: List[float] = driver.fftSpecAn.qcomponent.read() \n
-		Returns the measured normalized I and Q amplitudes in the time domain. \n
+		"""SCPI: READ:GPRF:MEASurement<Instance>:IQVSlot:I \n
+		Snippet: value: List[float] = driver.iqVsSlot.icomponent.read() \n
+		Returns the contents of the I and Q result diagrams. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: qdata: Comma-separated list of n normalized I or Q amplitudes, where n is given by the FFT length, see method RsCmwGprfMeas.Configure.FftSpecAn.fftLength. Range: -2 to 2"""
+			:return: idata: float Comma-separated list of amplitudes, one value per measured step Unit: V"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:FFTSanalyzer:Q?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:IQVSlot:I?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:FFTSanalyzer:Q \n
-		Snippet: value: List[float] = driver.fftSpecAn.qcomponent.fetch() \n
-		Returns the measured normalized I and Q amplitudes in the time domain. \n
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:IQVSlot:I \n
+		Snippet: value: List[float] = driver.iqVsSlot.icomponent.fetch() \n
+		Returns the contents of the I and Q result diagrams. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: qdata: Comma-separated list of n normalized I or Q amplitudes, where n is given by the FFT length, see method RsCmwGprfMeas.Configure.FftSpecAn.fftLength. Range: -2 to 2"""
+			:return: idata: float Comma-separated list of amplitudes, one value per measured step Unit: V"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:FFTSanalyzer:Q?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:IQVSlot:I?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/FftSpecAn_/State_/All.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/StandardDev/Current.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,26 +1,35 @@
 from typing import List
 
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from .... import enums
+from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class All:
-	"""All commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("all", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
-	# noinspection PyTypeChecker
-	def fetch(self) -> List[enums.ResourceState]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:FFTSanalyzer:STATe:ALL \n
-		Snippet: value: List[enums.ResourceState] = driver.fftSpecAn.state.all.fetch() \n
-		Queries the main measurement state and the measurement substates. Both measurement substates are relevant for running
-		measurements only. Use FETCh:...:STATe? to query the main measurement state only. Use INITiate..., STOP..., ABORt...
-		to change the measurement state. \n
-			:return: meas_state: No help available"""
-		response = self._core.io.query_str(f'FETCh:GPRF:MEASurement<Instance>:FFTSanalyzer:STATe:ALL?')
-		return Conversions.str_to_list_enum(response, enums.ResourceState)
+	def fetch(self) -> List[float]:
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:SDEViation:CURRent \n
+		Snippet: value: List[float] = driver.power.standardDev.current.fetch() \n
+		No command help available \n
+		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
+			:return: power_std_dev_cur: No help available"""
+		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:SDEViation:CURRent?', suppressed)
+		return response
+
+	def read(self) -> List[float]:
+		"""SCPI: READ:GPRF:MEASurement<Instance>:POWer:SDEViation:CURRent \n
+		Snippet: value: List[float] = driver.power.standardDev.current.read() \n
+		No command help available \n
+		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
+			:return: power_std_dev_cur: No help available"""
+		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:POWer:SDEViation:CURRent?', suppressed)
+		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Initiate.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Initiate/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ..Internal.Core import Core
-from ..Internal.CommandsGroup import CommandsGroup
+from ...Internal.Core import Core
+from ...Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Initiate:
-	"""Initiate commands group definition. 3 total commands, 1 Sub-groups, 0 group commands"""
+class InitiateCls:
+	"""Initiate commands group definition. 3 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("initiate", core, parent)
+		self._cmd_group = CommandsGroup("initiate", core, parent)
 
 	@property
 	def ploss(self):
-		"""ploss commands group. 0 Sub-classes, 3 commands."""
+		"""ploss commands group. 3 Sub-classes, 0 commands."""
 		if not hasattr(self, '_ploss'):
-			from .Initiate_.Ploss import Ploss
-			self._ploss = Ploss(self._core, self._base)
+			from .Ploss import PlossCls
+			self._ploss = PlossCls(self._core, self._cmd_group)
 		return self._ploss
 
-	def clone(self) -> 'Initiate':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'InitiateCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Initiate(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = InitiateCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqRecorder_/Bin.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/IqRecorder/Bin.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,31 +1,31 @@
 from typing import List
 
 from ...Internal.Core import Core
 from ...Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Bin:
-	"""Bin commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class BinCls:
+	"""Bin commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("bin", core, parent)
+		self._cmd_group = CommandsGroup("bin", core, parent)
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:GPRF:MEASurement<Instance>:IQRecorder:BIN \n
 		Snippet: value: List[float] = driver.iqRecorder.bin.read() \n
-		Retrieve IQ recorder results in binary format. The number n of sample values is set via method RsCmwGprfMeas.Configure.
-		IqRecorder.capture. \n
-			:return: iq_samples: dblock Binary block data. For a detailed description, see 'ASCII and Binary Data Formats'."""
+		Returns I/Q recorder results in binary format. For the number of values n, see method RsCmwGprfMeas.Configure.IqRecorder.
+		Capture.set. \n
+			:return: iq_samples: block Binary block data. For a detailed description, see 'ASCII and binary data formats'."""
 		response = self._core.io.query_bin_or_ascii_float_list(f'READ:GPRF:MEASurement<Instance>:IQRecorder:BIN?')
 		return response
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:GPRF:MEASurement<Instance>:IQRecorder:BIN \n
 		Snippet: value: List[float] = driver.iqRecorder.bin.fetch() \n
-		Retrieve IQ recorder results in binary format. The number n of sample values is set via method RsCmwGprfMeas.Configure.
-		IqRecorder.capture. \n
-			:return: iq_samples: dblock Binary block data. For a detailed description, see 'ASCII and Binary Data Formats'."""
+		Returns I/Q recorder results in binary format. For the number of values n, see method RsCmwGprfMeas.Configure.IqRecorder.
+		Capture.set. \n
+			:return: iq_samples: block Binary block data. For a detailed description, see 'ASCII and binary data formats'."""
 		response = self._core.io.query_bin_or_ascii_float_list(f'FETCh:GPRF:MEASurement<Instance>:IQRecorder:BIN?')
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqRecorder_/Reliability.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/IqRecorder/Reliability.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from ...Internal.Core import Core
 from ...Internal.CommandsGroup import CommandsGroup
 from ...Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Reliability:
-	"""Reliability commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ReliabilityCls:
+	"""Reliability commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("reliability", core, parent)
+		self._cmd_group = CommandsGroup("reliability", core, parent)
 
 	def fetch(self) -> int:
 		"""SCPI: FETCh:GPRF:MEASurement<Instance>:IQRecorder:RELiability \n
 		Snippet: value: int = driver.iqRecorder.reliability.fetch() \n
-		Queries the reliability indicator for the I/Q recorder measurement, see 'Reliability Indicator'. \n
-			:return: reliability_flag: Two equal values, separated by a comma (e.g. 0,0 for 'OK')"""
+		Queries the reliability indicator for the I/Q recorder, see 'Reliability indicator'. \n
+			:return: reliability_flag: decimal Two equal values, separated by a comma (e.g. 0,0 for 'OK')"""
 		response = self._core.io.query_str(f'FETCh:GPRF:MEASurement<Instance>:IQRecorder:RELiability?')
 		return Conversions.str_to_int(response)
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqRecorder_/State.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/CumulativeDistribFnc/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,39 +1,57 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ... import enums
+from typing import List
+
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class State:
-	"""State commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class CumulativeDistribFncCls:
+	"""CumulativeDistribFnc commands group definition. 4 total commands, 3 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("state", core, parent)
+		self._cmd_group = CommandsGroup("cumulativeDistribFnc", core, parent)
+
+	@property
+	def power(self):
+		"""power commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_power'):
+			from .Power import PowerCls
+			self._power = PowerCls(self._core, self._cmd_group)
+		return self._power
+
+	@property
+	def sample(self):
+		"""sample commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_sample'):
+			from .Sample import SampleCls
+			self._sample = SampleCls(self._core, self._cmd_group)
+		return self._sample
 
 	@property
-	def all(self):
-		"""all commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_all'):
-			from .State_.All import All
-			self._all = All(self._core, self._base)
-		return self._all
-
-	# noinspection PyTypeChecker
-	def fetch(self) -> enums.ResourceState:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:IQRecorder:STATe \n
-		Snippet: value: enums.ResourceState = driver.iqRecorder.state.fetch() \n
-		Queries the main measurement state. Use FETCh:...:STATe:ALL? to query the measurement state including the substates. Use
-		INITiate..., STOP..., ABORt...to change the measurement state. \n
-			:return: meas_state: OFF | RUN | RDY OFF: measurement off, no resources allocated, no results RUN: measurement running, synchronization pending or adjusted, resources active or queued RDY: measurement finished"""
-		response = self._core.io.query_str(f'FETCh:GPRF:MEASurement<Instance>:IQRecorder:STATe?')
-		return Conversions.str_to_scalar_enum(response, enums.ResourceState)
+	def probability(self):
+		"""probability commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_probability'):
+			from .Probability import ProbabilityCls
+			self._probability = ProbabilityCls(self._core, self._cmd_group)
+		return self._probability
+
+	def fetch(self) -> List[float]:
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:CCDF \n
+		Snippet: value: List[float] = driver.power.cumulativeDistribFnc.fetch() \n
+		Returns the CCDF diagram contents. \n
+		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
+			:return: results: float 4096 results, each representing a 0.047-dB interval ('bin') Unit: %"""
+		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:CCDF?', suppressed)
+		return response
 
-	def clone(self) -> 'State':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CumulativeDistribFncCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = State(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CumulativeDistribFncCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqRecorder_/SymbolRate.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/IqRecorder/SymbolRate.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,21 +1,20 @@
 from ...Internal.Core import Core
 from ...Internal.CommandsGroup import CommandsGroup
 from ...Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class SymbolRate:
-	"""SymbolRate commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SymbolRateCls:
+	"""SymbolRate commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("symbolRate", core, parent)
+		self._cmd_group = CommandsGroup("symbolRate", core, parent)
 
 	def fetch(self) -> float:
 		"""SCPI: FETCh:GPRF:MEASurement<Instance>:IQRecorder:SRATe \n
 		Snippet: value: float = driver.iqRecorder.symbolRate.fetch() \n
-		Returns the sampling rate of the I/Q recorder measurement, depending on the filter settings, see 'Filter Settings and
-		Samples'. \n
-			:return: sample_rate: Range: 0 Hz to 100 MHz, Unit: Hz"""
+		Returns the sampling rate of the I/Q recorder, resulting from the filter settings and the configured sample ratio. \n
+			:return: sample_rate: float Unit: Hz"""
 		response = self._core.io.query_str(f'FETCh:GPRF:MEASurement<Instance>:IQRecorder:SRATe?')
 		return Conversions.str_to_float(response)
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqRecorder_/Talignment.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/IqRecorder/Talignment.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,20 +2,20 @@
 from ...Internal.CommandsGroup import CommandsGroup
 from ...Internal import Conversions
 from ...Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ...Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Talignment:
-	"""Talignment commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class TalignmentCls:
+	"""Talignment commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("talignment", core, parent)
+		self._cmd_group = CommandsGroup("talignment", core, parent)
 
 	def fetch(self) -> float:
 		"""SCPI: FETCh:GPRF:MEASurement<Instance>:IQRecorder:TALignment \n
 		Snippet: value: float = driver.iqRecorder.talignment.fetch() \n
 		No command help available \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
 			:return: time_alignment: No help available"""
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqVsSlot_/FreqError.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/IqVsSlot/FreqError.py`

 * *Files 22% similar despite different names*

```diff
@@ -3,33 +3,33 @@
 from ...Internal.Core import Core
 from ...Internal.CommandsGroup import CommandsGroup
 from ...Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ...Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class FreqError:
-	"""FreqError commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class FreqErrorCls:
+	"""FreqError commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("freqError", core, parent)
+		self._cmd_group = CommandsGroup("freqError", core, parent)
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:GPRF:MEASurement<Instance>:IQVSlot:FERRor \n
 		Snippet: value: List[float] = driver.iqVsSlot.freqError.read() \n
-		Returns the frequency errors, see 'Measurement Results'. \n
+		Returns the contents of the frequency error result diagram. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: frequency_error: Frequency error for each measurement step. The total number n of results is equal to the total number of steps (see method RsCmwGprfMeas.Configure.IqVsSlot.scount) . Range: -500 kHz to 500 kHz, Unit: Hz"""
+			:return: frequency_error: float Comma-separated list of frequency errors, one value per measured step Unit: Hz"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:IQVSlot:FERRor?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:GPRF:MEASurement<Instance>:IQVSlot:FERRor \n
 		Snippet: value: List[float] = driver.iqVsSlot.freqError.fetch() \n
-		Returns the frequency errors, see 'Measurement Results'. \n
+		Returns the contents of the frequency error result diagram. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: frequency_error: Frequency error for each measurement step. The total number n of results is equal to the total number of steps (see method RsCmwGprfMeas.Configure.IqVsSlot.scount) . Range: -500 kHz to 500 kHz, Unit: Hz"""
+			:return: frequency_error: float Comma-separated list of frequency errors, one value per measured step Unit: Hz"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:IQVSlot:FERRor?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqVsSlot_/Icomponent.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/IqVsSlot/Qcomponent.py`

 * *Files 18% similar despite different names*

```diff
@@ -3,33 +3,33 @@
 from ...Internal.Core import Core
 from ...Internal.CommandsGroup import CommandsGroup
 from ...Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ...Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Icomponent:
-	"""Icomponent commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class QcomponentCls:
+	"""Qcomponent commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("icomponent", core, parent)
+		self._cmd_group = CommandsGroup("qcomponent", core, parent)
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:GPRF:MEASurement<Instance>:IQVSlot:I \n
-		Snippet: value: List[float] = driver.iqVsSlot.icomponent.read() \n
-		Returns the averaged I and Q amplitudes, see 'Measurement Results'. \n
+		"""SCPI: READ:GPRF:MEASurement<Instance>:IQVSlot:Q \n
+		Snippet: value: List[float] = driver.iqVsSlot.qcomponent.read() \n
+		Returns the contents of the I and Q result diagrams. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: idata: Average I or Q amplitude for each measurement step. The total number n of results is equal to the total number of steps (see method RsCmwGprfMeas.Configure.IqVsSlot.scount) . Range: -150 V to 150 V, Unit: V"""
+			:return: qdata: float Comma-separated list of amplitudes, one value per measured step Unit: V"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:IQVSlot:I?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:IQVSlot:Q?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:IQVSlot:I \n
-		Snippet: value: List[float] = driver.iqVsSlot.icomponent.fetch() \n
-		Returns the averaged I and Q amplitudes, see 'Measurement Results'. \n
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:IQVSlot:Q \n
+		Snippet: value: List[float] = driver.iqVsSlot.qcomponent.fetch() \n
+		Returns the contents of the I and Q result diagrams. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: idata: Average I or Q amplitude for each measurement step. The total number n of results is equal to the total number of steps (see method RsCmwGprfMeas.Configure.IqVsSlot.scount) . Range: -150 V to 150 V, Unit: V"""
+			:return: qdata: float Comma-separated list of amplitudes, one value per measured step Unit: V"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:IQVSlot:I?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:IQVSlot:Q?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqVsSlot_/Level.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/IqVsSlot/Phase.py`

 * *Files 18% similar despite different names*

```diff
@@ -3,33 +3,33 @@
 from ...Internal.Core import Core
 from ...Internal.CommandsGroup import CommandsGroup
 from ...Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ...Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Level:
-	"""Level commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class PhaseCls:
+	"""Phase commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("level", core, parent)
+		self._cmd_group = CommandsGroup("phase", core, parent)
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:GPRF:MEASurement<Instance>:IQVSlot:LEVel \n
-		Snippet: value: List[float] = driver.iqVsSlot.level.read() \n
-		Returns the averaged signal levels, see 'Measurement Results'. \n
+		"""SCPI: READ:GPRF:MEASurement<Instance>:IQVSlot:PHASe \n
+		Snippet: value: List[float] = driver.iqVsSlot.phase.read() \n
+		Returns the contents of the phase result diagram. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: level: Average level for each measurement step. The total number n of results is equal to the total number of steps (see method RsCmwGprfMeas.Configure.IqVsSlot.scount) . Range: -150 dBm to 60 dBm, Unit: dBm"""
+			:return: phase: float Comma-separated list of phases, one value per measured step Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:IQVSlot:LEVel?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:IQVSlot:PHASe?', suppressed)
 		return response
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:IQVSlot:LEVel \n
-		Snippet: value: List[float] = driver.iqVsSlot.level.fetch() \n
-		Returns the averaged signal levels, see 'Measurement Results'. \n
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:IQVSlot:PHASe \n
+		Snippet: value: List[float] = driver.iqVsSlot.phase.fetch() \n
+		Returns the contents of the phase result diagram. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: level: Average level for each measurement step. The total number n of results is equal to the total number of steps (see method RsCmwGprfMeas.Configure.IqVsSlot.scount) . Range: -150 dBm to 60 dBm, Unit: dBm"""
+			:return: phase: float Comma-separated list of phases, one value per measured step Unit: deg"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:IQVSlot:LEVel?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:IQVSlot:PHASe?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqVsSlot_/OfError.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/IqVsSlot/OfError.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,47 +1,49 @@
 from ...Internal.Core import Core
 from ...Internal.CommandsGroup import CommandsGroup
 from ...Internal import Conversions
 from ...Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ...Internal.Types import DataType
+from ... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class OfError:
-	"""OfError commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class OfErrorCls:
+	"""OfError commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ofError", core, parent)
+		self._cmd_group = CommandsGroup("ofError", core, parent)
 
-	def calculate(self) -> float:
+	# noinspection PyTypeChecker
+	def calculate(self) -> enums.ResultStatus2:
 		"""SCPI: CALCulate:GPRF:MEASurement<Instance>:IQVSlot:OFERror \n
-		Snippet: value: float = driver.iqVsSlot.ofError.calculate() \n
-		Returns the frequency errors, see 'Measurement Results'. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return a single-value error code for each result listed below. \n
+		Snippet: value: enums.ResultStatus2 = driver.iqVsSlot.ofError.calculate() \n
+		Returns the overall frequency error. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return error codes instead, one value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: frequency_error: Overall frequency error, the arithmetic mean value of the frequency errors for each measurement step (see method RsCmwGprfMeas.IqVsSlot.FreqError.read) . Range: -50 kHz to 50 kHz, Unit: Hz"""
+			:return: frequency_error: float Overall frequency error, the arithmetic mean value of the frequency errors of all considered steps. Unit: Hz"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'CALCulate:GPRF:MEASurement<Instance>:IQVSlot:OFERror?', suppressed)
-		return Conversions.str_to_float(response)
+		return Conversions.str_to_scalar_enum(response, enums.ResultStatus2)
 
 	def read(self) -> float:
 		"""SCPI: READ:GPRF:MEASurement<Instance>:IQVSlot:OFERror \n
 		Snippet: value: float = driver.iqVsSlot.ofError.read() \n
-		Returns the frequency errors, see 'Measurement Results'. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return a single-value error code for each result listed below. \n
+		Returns the overall frequency error. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return error codes instead, one value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: frequency_error: Overall frequency error, the arithmetic mean value of the frequency errors for each measurement step (see method RsCmwGprfMeas.IqVsSlot.FreqError.read) . Range: -50 kHz to 50 kHz, Unit: Hz"""
+			:return: frequency_error: float Overall frequency error, the arithmetic mean value of the frequency errors of all considered steps. Unit: Hz"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'READ:GPRF:MEASurement<Instance>:IQVSlot:OFERror?', suppressed)
 		return Conversions.str_to_float(response)
 
 	def fetch(self) -> float:
 		"""SCPI: FETCh:GPRF:MEASurement<Instance>:IQVSlot:OFERror \n
 		Snippet: value: float = driver.iqVsSlot.ofError.fetch() \n
-		Returns the frequency errors, see 'Measurement Results'. The values described below are returned by FETCh and READ
-		commands. CALCulate commands return a single-value error code for each result listed below. \n
+		Returns the overall frequency error. The values described below are returned by FETCh and READ commands.
+		CALCulate commands return error codes instead, one value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: frequency_error: Overall frequency error, the arithmetic mean value of the frequency errors for each measurement step (see method RsCmwGprfMeas.IqVsSlot.FreqError.read) . Range: -50 kHz to 50 kHz, Unit: Hz"""
+			:return: frequency_error: float Overall frequency error, the arithmetic mean value of the frequency errors of all considered steps. Unit: Hz"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'FETCh:GPRF:MEASurement<Instance>:IQVSlot:OFERror?', suppressed)
 		return Conversions.str_to_float(response)
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqVsSlot_/Phase.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Current/Rms.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,35 +1,35 @@
 from typing import List
 
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ...Internal.Types import DataType
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Phase:
-	"""Phase commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class RmsCls:
+	"""Rms commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("phase", core, parent)
+		self._cmd_group = CommandsGroup("rms", core, parent)
 
-	def read(self) -> List[float]:
-		"""SCPI: READ:GPRF:MEASurement<Instance>:IQVSlot:PHASe \n
-		Snippet: value: List[float] = driver.iqVsSlot.phase.read() \n
-		Returns the averaged phase values, see 'Measurement Results'. \n
+	def fetch(self) -> List[float]:
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:CURRent:RMS \n
+		Snippet: value: List[float] = driver.power.current.rms.fetch() \n
+		No command help available \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: phase: Average phase for each measurement step. The total number n of results is equal to the total number of steps (see method RsCmwGprfMeas.Configure.IqVsSlot.scount) . Range: -180 deg to 180 deg, Unit: deg"""
+			:return: power_current_rms: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:IQVSlot:PHASe?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:CURRent:RMS?', suppressed)
 		return response
 
-	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:IQVSlot:PHASe \n
-		Snippet: value: List[float] = driver.iqVsSlot.phase.fetch() \n
-		Returns the averaged phase values, see 'Measurement Results'. \n
+	def read(self) -> List[float]:
+		"""SCPI: READ:GPRF:MEASurement<Instance>:POWer:CURRent:RMS \n
+		Snippet: value: List[float] = driver.power.current.rms.read() \n
+		No command help available \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: phase: Average phase for each measurement step. The total number n of results is equal to the total number of steps (see method RsCmwGprfMeas.Configure.IqVsSlot.scount) . Range: -180 deg to 180 deg, Unit: deg"""
+			:return: power_current_rms: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:IQVSlot:PHASe?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:POWer:CURRent:RMS?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqVsSlot_/Qcomponent.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Current/Maximum.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,35 +1,35 @@
 from typing import List
 
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ...Internal.Types import DataType
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Qcomponent:
-	"""Qcomponent commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("qcomponent", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
-	def read(self) -> List[float]:
-		"""SCPI: READ:GPRF:MEASurement<Instance>:IQVSlot:Q \n
-		Snippet: value: List[float] = driver.iqVsSlot.qcomponent.read() \n
-		Returns the averaged I and Q amplitudes, see 'Measurement Results'. \n
+	def fetch(self) -> List[float]:
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:CURRent:MAXimum \n
+		Snippet: value: List[float] = driver.power.current.maximum.fetch() \n
+		No command help available \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: qdata: Average I or Q amplitude for each measurement step. The total number n of results is equal to the total number of steps (see method RsCmwGprfMeas.Configure.IqVsSlot.scount) . Range: -150 V to 150 V, Unit: V"""
+			:return: power_current_max: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:IQVSlot:Q?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:CURRent:MAXimum?', suppressed)
 		return response
 
-	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:IQVSlot:Q \n
-		Snippet: value: List[float] = driver.iqVsSlot.qcomponent.fetch() \n
-		Returns the averaged I and Q amplitudes, see 'Measurement Results'. \n
+	def read(self) -> List[float]:
+		"""SCPI: READ:GPRF:MEASurement<Instance>:POWer:CURRent:MAXimum \n
+		Snippet: value: List[float] = driver.power.current.maximum.read() \n
+		No command help available \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: qdata: Average I or Q amplitude for each measurement step. The total number n of results is equal to the total number of steps (see method RsCmwGprfMeas.Configure.IqVsSlot.scount) . Range: -150 V to 150 V, Unit: V"""
+			:return: power_current_max: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:IQVSlot:Q?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:POWer:CURRent:MAXimum?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/IqVsSlot_/State_/All.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/IqRecorder/Catalog.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,26 +1,23 @@
 from typing import List
 
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
-from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class All:
-	"""All commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CatalogCls:
+	"""Catalog commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("all", core, parent)
+		self._cmd_group = CommandsGroup("catalog", core, parent)
 
-	# noinspection PyTypeChecker
-	def fetch(self) -> List[enums.ResourceState]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:IQVSlot:STATe:ALL \n
-		Snippet: value: List[enums.ResourceState] = driver.iqVsSlot.state.all.fetch() \n
-		Queries the main measurement state and the measurement substates. Both measurement substates are relevant for running
-		measurements only. Use FETCh:...:STATe? to query the main measurement state only. Use INITiate..., STOP..., ABORt...
-		to change the measurement state. \n
-			:return: meas_state: No help available"""
-		response = self._core.io.query_str(f'FETCh:GPRF:MEASurement<Instance>:IQVSlot:STATe:ALL?')
-		return Conversions.str_to_list_enum(response, enums.ResourceState)
+	def get_source(self) -> List[str]:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:IQRecorder:CATalog:SOURce \n
+		Snippet: value: List[str] = driver.trigger.iqRecorder.catalog.get_source() \n
+		Lists all trigger source values that can be set using method RsCmwGprfMeas.Trigger.IqRecorder.source. \n
+			:return: trigger_sources: string Comma-separated list of all supported values. Each value is represented as a string.
+		"""
+		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:IQRecorder:CATalog:SOURce?')
+		return Conversions.str_to_str_list(response)
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Nrpm_/Sensor.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Nrpm/Sensor/__init__.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal.RepeatedCapability import RepeatedCapability
-from ... import repcap
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal.RepeatedCapability import RepeatedCapability
+from .... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Sensor:
-	"""Sensor commands group definition. 3 total commands, 1 Sub-groups, 0 group commands
+class SensorCls:
+	"""Sensor commands group definition. 3 total commands, 1 Subgroups, 0 group commands
 	Repeated Capability: Sensor, default value after init: Sensor.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("sensor", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_sensor_get', 'repcap_sensor_set', repcap.Sensor.Nr1)
+		self._cmd_group = CommandsGroup("sensor", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_sensor_get', 'repcap_sensor_set', repcap.Sensor.Nr1)
 
-	def repcap_sensor_set(self, enum_value: repcap.Sensor) -> None:
+	def repcap_sensor_set(self, sensor: repcap.Sensor) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to Sensor.Default
 		Default value after init: Sensor.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(sensor)
 
 	def repcap_sensor_get(self) -> repcap.Sensor:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def power(self):
 		"""power commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_power'):
-			from .Sensor_.Power import Power
-			self._power = Power(self._core, self._base)
+			from .Power import PowerCls
+			self._power = PowerCls(self._core, self._cmd_group)
 		return self._power
 
-	def clone(self) -> 'Sensor':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SensorCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Sensor(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SensorCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Nrpm_/Sensor_/Power.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Nrpm/Sensor/Power.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 from .... import enums
 from .... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Power:
-	"""Power commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class PowerCls:
+	"""Power commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("power", core, parent)
+		self._cmd_group = CommandsGroup("power", core, parent)
 
 	# noinspection PyTypeChecker
 	class ResultData(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
 			- Power_Antenna_1: float: No parameter help available
 			- Power_Antenna_2: float: No parameter help available
@@ -36,47 +36,47 @@
 
 	def read(self, sensor=repcap.Sensor.Default) -> ResultData:
 		"""SCPI: READ:GPRF:MEASurement<Instance>:NRPM:SENSor<nr_NRPM>:POWer \n
 		Snippet: value: ResultData = driver.nrpm.sensor.power.read(sensor = repcap.Sensor.Default) \n
 		No command help available \n
 			:param sensor: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Sensor')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		sensor_cmd_val = self._base.get_repcap_cmd_value(sensor, repcap.Sensor)
+		sensor_cmd_val = self._cmd_group.get_repcap_cmd_value(sensor, repcap.Sensor)
 		return self._core.io.query_struct(f'READ:GPRF:MEASurement<Instance>:NRPM:SENSor{sensor_cmd_val}:POWer?', self.__class__.ResultData())
 
 	def fetch(self, sensor=repcap.Sensor.Default) -> ResultData:
 		"""SCPI: FETCh:GPRF:MEASurement<Instance>:NRPM:SENSor<nr_NRPM>:POWer \n
 		Snippet: value: ResultData = driver.nrpm.sensor.power.fetch(sensor = repcap.Sensor.Default) \n
 		No command help available \n
 			:param sensor: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Sensor')
 			:return: structure: for return value, see the help for ResultData structure arguments."""
-		sensor_cmd_val = self._base.get_repcap_cmd_value(sensor, repcap.Sensor)
+		sensor_cmd_val = self._cmd_group.get_repcap_cmd_value(sensor, repcap.Sensor)
 		return self._core.io.query_struct(f'FETCh:GPRF:MEASurement<Instance>:NRPM:SENSor{sensor_cmd_val}:POWer?', self.__class__.ResultData())
 
 	# noinspection PyTypeChecker
 	class CalculateStruct(StructBase):
 		"""Response structure. Fields: \n
 			- Reliability: int: No parameter help available
-			- State_Antenna_1: float: No parameter help available
+			- State_Antenna_1: enums.ResultStatus2: No parameter help available
 			- State_Antenna_2: enums.ResultStatus2: No parameter help available
 			- State_Antenna_3: enums.ResultStatus2: No parameter help available"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('State_Antenna_1'),
+			ArgStruct.scalar_enum('State_Antenna_1', enums.ResultStatus2),
 			ArgStruct.scalar_enum('State_Antenna_2', enums.ResultStatus2),
 			ArgStruct.scalar_enum('State_Antenna_3', enums.ResultStatus2)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.State_Antenna_1: float = None
+			self.State_Antenna_1: enums.ResultStatus2 = None
 			self.State_Antenna_2: enums.ResultStatus2 = None
 			self.State_Antenna_3: enums.ResultStatus2 = None
 
 	def calculate(self, sensor=repcap.Sensor.Default) -> CalculateStruct:
 		"""SCPI: CALCulate:GPRF:MEASurement<Instance>:NRPM:SENSor<nr_NRPM>:POWer \n
 		Snippet: value: CalculateStruct = driver.nrpm.sensor.power.calculate(sensor = repcap.Sensor.Default) \n
 		No command help available \n
 			:param sensor: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Sensor')
 			:return: structure: for return value, see the help for CalculateStruct structure arguments."""
-		sensor_cmd_val = self._base.get_repcap_cmd_value(sensor, repcap.Sensor)
+		sensor_cmd_val = self._cmd_group.get_repcap_cmd_value(sensor, repcap.Sensor)
 		return self._core.io.query_struct(f'CALCulate:GPRF:MEASurement<Instance>:NRPM:SENSor{sensor_cmd_val}:POWer?', self.__class__.CalculateStruct())
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Nrpm_/State.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Nrpm/State/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,38 +1,45 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ... import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from ....Internal.Types import DataType
+from ....Internal.ArgSingleList import ArgSingleList
+from ....Internal.ArgSingle import ArgSingle
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class State:
-	"""State commands group definition. 2 total commands, 1 Sub-groups, 1 group commands"""
+class StateCls:
+	"""State commands group definition. 2 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("state", core, parent)
+		self._cmd_group = CommandsGroup("state", core, parent)
 
 	@property
 	def all(self):
 		"""all commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_all'):
-			from .State_.All import All
-			self._all = All(self._core, self._base)
+			from .All import AllCls
+			self._all = AllCls(self._core, self._cmd_group)
 		return self._all
 
 	# noinspection PyTypeChecker
-	def fetch(self) -> enums.ResourceState:
+	def fetch(self, timeout: float = None, target_main_state: enums.TargetMainState = None, target_sync_state: enums.TargetSyncState = None) -> enums.ResourceState:
 		"""SCPI: FETCh:GPRF:MEASurement<Instance>:NRPM:STATe \n
-		Snippet: value: enums.ResourceState = driver.nrpm.state.fetch() \n
+		Snippet: value: enums.ResourceState = driver.nrpm.state.fetch(timeout = 1.0, target_main_state = enums.TargetMainState.OFF, target_sync_state = enums.TargetSyncState.ADJusted) \n
 		No command help available \n
+			:param timeout: No help available
+			:param target_main_state: No help available
+			:param target_sync_state: No help available
 			:return: meas_state: No help available"""
-		response = self._core.io.query_str(f'FETCh:GPRF:MEASurement<Instance>:NRPM:STATe?')
+		param = ArgSingleList().compose_cmd_string(ArgSingle('timeout', timeout, DataType.Float, None, is_optional=True), ArgSingle('target_main_state', target_main_state, DataType.Enum, enums.TargetMainState, is_optional=True), ArgSingle('target_sync_state', target_sync_state, DataType.Enum, enums.TargetSyncState, is_optional=True))
+		response = self._core.io.query_str(f'FETCh:GPRF:MEASurement<Instance>:NRPM:STATe? {param}'.rstrip())
 		return Conversions.str_to_scalar_enum(response, enums.ResourceState)
 
-	def clone(self) -> 'State':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'StateCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = State(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = StateCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Nrpm_/State_/All.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Nrpm/State/All.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,24 +1,31 @@
 from typing import List
 
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
+from ....Internal.Types import DataType
+from ....Internal.ArgSingleList import ArgSingleList
+from ....Internal.ArgSingle import ArgSingle
 from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class All:
-	"""All commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AllCls:
+	"""All commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("all", core, parent)
+		self._cmd_group = CommandsGroup("all", core, parent)
 
 	# noinspection PyTypeChecker
-	def fetch(self) -> List[enums.ResourceState]:
+	def fetch(self, timeout: float = None, target_main_state: enums.TargetMainState = None, target_sync_state: enums.TargetSyncState = None) -> List[enums.ResourceState]:
 		"""SCPI: FETCh:GPRF:MEASurement<Instance>:NRPM:STATe:ALL \n
-		Snippet: value: List[enums.ResourceState] = driver.nrpm.state.all.fetch() \n
+		Snippet: value: List[enums.ResourceState] = driver.nrpm.state.all.fetch(timeout = 1.0, target_main_state = enums.TargetMainState.OFF, target_sync_state = enums.TargetSyncState.ADJusted) \n
 		No command help available \n
+			:param timeout: No help available
+			:param target_main_state: No help available
+			:param target_sync_state: No help available
 			:return: meas_state: No help available"""
-		response = self._core.io.query_str(f'FETCh:GPRF:MEASurement<Instance>:NRPM:STATe:ALL?')
+		param = ArgSingleList().compose_cmd_string(ArgSingle('timeout', timeout, DataType.Float, None, is_optional=True), ArgSingle('target_main_state', target_main_state, DataType.Enum, enums.TargetMainState, is_optional=True), ArgSingle('target_sync_state', target_sync_state, DataType.Enum, enums.TargetSyncState, is_optional=True))
+		response = self._core.io.query_str(f'FETCh:GPRF:MEASurement<Instance>:NRPM:STATe:ALL? {param}'.rstrip())
 		return Conversions.str_to_list_enum(response, enums.ResourceState)
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Ploss.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/FftSpecAn/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,101 +1,92 @@
-from ..Internal.Core import Core
-from ..Internal.CommandsGroup import CommandsGroup
+from ...Internal.Core import Core
+from ...Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Ploss:
-	"""Ploss commands group definition. 12 total commands, 5 Sub-groups, 2 group commands"""
+class FftSpecAnCls:
+	"""FftSpecAn commands group definition. 21 total commands, 5 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("ploss", core, parent)
+		self._cmd_group = CommandsGroup("fftSpecAn", core, parent)
 
 	@property
 	def state(self):
 		"""state commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_state'):
-			from .Ploss_.State import State
-			self._state = State(self._core, self._base)
+			from .State import StateCls
+			self._state = StateCls(self._core, self._cmd_group)
 		return self._state
 
 	@property
-	def clear(self):
-		"""clear commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_clear'):
-			from .Ploss_.Clear import Clear
-			self._clear = Clear(self._core, self._base)
-		return self._clear
+	def peaks(self):
+		"""peaks commands group. 2 Sub-classes, 0 commands."""
+		if not hasattr(self, '_peaks'):
+			from .Peaks import PeaksCls
+			self._peaks = PeaksCls(self._core, self._cmd_group)
+		return self._peaks
 
 	@property
-	def open(self):
-		"""open commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_open'):
-			from .Ploss_.Open import Open
-			self._open = Open(self._core, self._base)
-		return self._open
+	def power(self):
+		"""power commands group. 4 Sub-classes, 0 commands."""
+		if not hasattr(self, '_power'):
+			from .Power import PowerCls
+			self._power = PowerCls(self._core, self._cmd_group)
+		return self._power
 
 	@property
-	def short(self):
-		"""short commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_short'):
-			from .Ploss_.Short import Short
-			self._short = Short(self._core, self._base)
-		return self._short
+	def qcomponent(self):
+		"""qcomponent commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_qcomponent'):
+			from .Qcomponent import QcomponentCls
+			self._qcomponent = QcomponentCls(self._core, self._cmd_group)
+		return self._qcomponent
 
 	@property
-	def eval(self):
-		"""eval commands group. 4 Sub-classes, 0 commands."""
-		if not hasattr(self, '_eval'):
-			from .Ploss_.Eval import Eval
-			self._eval = Eval(self._core, self._base)
-		return self._eval
-
-	def stop(self) -> None:
-		"""SCPI: STOP:GPRF:MEASurement<Instance>:PLOSs \n
-		Snippet: driver.ploss.stop() \n
-		Halts the measurement immediately. Results that have been available before this measurement are kept.
-			INTRO_CMD_HELP: Stops or aborts the measurement: \n
-			- STOP...: The measurement enters the 'RDY' state. The resources remain allocated to the measurement.
-			- ABORt...: The measurement enters the 'OFF' state. Allocated resources are released. \n
-		"""
-		self._core.io.write(f'STOP:GPRF:MEASurement<Instance>:PLOSs')
-
-	def stop_with_opc(self) -> None:
-		"""SCPI: STOP:GPRF:MEASurement<Instance>:PLOSs \n
-		Snippet: driver.ploss.stop_with_opc() \n
-		Halts the measurement immediately. Results that have been available before this measurement are kept.
-			INTRO_CMD_HELP: Stops or aborts the measurement: \n
-			- STOP...: The measurement enters the 'RDY' state. The resources remain allocated to the measurement.
-			- ABORt...: The measurement enters the 'OFF' state. Allocated resources are released. \n
-		Same as stop, but waits for the operation to complete before continuing further. Use the RsCmwGprfMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'STOP:GPRF:MEASurement<Instance>:PLOSs')
-
-	def abort(self) -> None:
-		"""SCPI: ABORt:GPRF:MEASurement<Instance>:PLOSs \n
-		Snippet: driver.ploss.abort() \n
-		Halts the measurement immediately. Results that have been available before this measurement are kept.
-			INTRO_CMD_HELP: Stops or aborts the measurement: \n
-			- STOP...: The measurement enters the 'RDY' state. The resources remain allocated to the measurement.
-			- ABORt...: The measurement enters the 'OFF' state. Allocated resources are released. \n
-		"""
-		self._core.io.write(f'ABORt:GPRF:MEASurement<Instance>:PLOSs')
-
-	def abort_with_opc(self) -> None:
-		"""SCPI: ABORt:GPRF:MEASurement<Instance>:PLOSs \n
-		Snippet: driver.ploss.abort_with_opc() \n
-		Halts the measurement immediately. Results that have been available before this measurement are kept.
-			INTRO_CMD_HELP: Stops or aborts the measurement: \n
-			- STOP...: The measurement enters the 'RDY' state. The resources remain allocated to the measurement.
-			- ABORt...: The measurement enters the 'OFF' state. Allocated resources are released. \n
-		Same as abort, but waits for the operation to complete before continuing further. Use the RsCmwGprfMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'ABORt:GPRF:MEASurement<Instance>:PLOSs')
+	def icomponent(self):
+		"""icomponent commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_icomponent'):
+			from .Icomponent import IcomponentCls
+			self._icomponent = IcomponentCls(self._core, self._cmd_group)
+		return self._icomponent
+
+	def initiate(self, opc_timeout_ms: int = -1) -> None:
+		"""SCPI: INITiate:GPRF:MEASurement<Instance>:FFTSanalyzer \n
+		Snippet: driver.fftSpecAn.initiate() \n
+			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
+			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
+			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
+			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
+		Use FETCh...STATe? to query the current measurement state. \n
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'INITiate:GPRF:MEASurement<Instance>:FFTSanalyzer', opc_timeout_ms)
+
+	def stop(self, opc_timeout_ms: int = -1) -> None:
+		"""SCPI: STOP:GPRF:MEASurement<Instance>:FFTSanalyzer \n
+		Snippet: driver.fftSpecAn.stop() \n
+			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
+			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
+			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
+			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
+		Use FETCh...STATe? to query the current measurement state. \n
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'STOP:GPRF:MEASurement<Instance>:FFTSanalyzer', opc_timeout_ms)
+
+	def abort(self, opc_timeout_ms: int = -1) -> None:
+		"""SCPI: ABORt:GPRF:MEASurement<Instance>:FFTSanalyzer \n
+		Snippet: driver.fftSpecAn.abort() \n
+			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
+			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
+			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
+			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
+		Use FETCh...STATe? to query the current measurement state. \n
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'ABORt:GPRF:MEASurement<Instance>:FFTSanalyzer', opc_timeout_ms)
 
-	def clone(self) -> 'Ploss':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'FftSpecAnCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Ploss(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = FftSpecAnCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Ploss_/Clear.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Ploss/Clear.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from ...Internal.Core import Core
 from ...Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Clear:
-	"""Clear commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ClearCls:
+	"""Clear commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("clear", core, parent)
+		self._cmd_group = CommandsGroup("clear", core, parent)
 
 	def initiate(self) -> None:
 		"""SCPI: INITiate:GPRF:MEASurement<Instance>:PLOSs:CLEar \n
 		Snippet: driver.ploss.clear.initiate() \n
-		Discards all measurement results. \n
+		No command help available \n
 		"""
 		self._core.io.write(f'INITiate:GPRF:MEASurement<Instance>:PLOSs:CLEar')
 
-	def initiate_with_opc(self) -> None:
+	def initiate_with_opc(self, opc_timeout_ms: int = -1) -> None:
 		"""SCPI: INITiate:GPRF:MEASurement<Instance>:PLOSs:CLEar \n
 		Snippet: driver.ploss.clear.initiate_with_opc() \n
-		Discards all measurement results. \n
+		No command help available \n
 		Same as initiate, but waits for the operation to complete before continuing further. Use the RsCmwGprfMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'INITiate:GPRF:MEASurement<Instance>:PLOSs:CLEar')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'INITiate:GPRF:MEASurement<Instance>:PLOSs:CLEar', opc_timeout_ms)
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Ploss_/Eval.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Ploss/Eval/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Eval:
-	"""Eval commands group definition. 5 total commands, 4 Sub-groups, 0 group commands"""
+class EvalCls:
+	"""Eval commands group definition. 5 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("eval", core, parent)
+		self._cmd_group = CommandsGroup("eval", core, parent)
 
 	@property
 	def trace(self):
 		"""trace commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_trace'):
-			from .Eval_.Trace import Trace
-			self._trace = Trace(self._core, self._base)
+			from .Trace import TraceCls
+			self._trace = TraceCls(self._core, self._cmd_group)
 		return self._trace
 
 	@property
 	def state(self):
 		"""state commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_state'):
-			from .Eval_.State import State
-			self._state = State(self._core, self._base)
+			from .State import StateCls
+			self._state = StateCls(self._core, self._cmd_group)
 		return self._state
 
 	@property
 	def gain(self):
 		"""gain commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_gain'):
-			from .Eval_.Gain import Gain
-			self._gain = Gain(self._core, self._base)
+			from .Gain import GainCls
+			self._gain = GainCls(self._core, self._cmd_group)
 		return self._gain
 
 	@property
 	def frequency(self):
 		"""frequency commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_frequency'):
-			from .Eval_.Frequency import Frequency
-			self._frequency = Frequency(self._core, self._base)
+			from .Frequency import FrequencyCls
+			self._frequency = FrequencyCls(self._core, self._cmd_group)
 		return self._frequency
 
-	def clone(self) -> 'Eval':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'EvalCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Eval(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = EvalCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Ploss_/Eval_/Frequency.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/IqData/Bin.py`

 * *Files 24% similar despite different names*

```diff
@@ -2,32 +2,29 @@
 
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 from ....Internal.ArgSingleList import ArgSingleList
 from ....Internal.ArgSingle import ArgSingle
-from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Frequency:
-	"""Frequency commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class BinCls:
+	"""Bin commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("frequency", core, parent)
+		self._cmd_group = CommandsGroup("bin", core, parent)
 
-	def fetch(self, connector: enums.CmwsConnector, path_index: enums.PathIndex = None) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:PLOSs:EVAL:FREQuency \n
-		Snippet: value: List[float] = driver.ploss.eval.frequency.fetch(connector = enums.CmwsConnector.R11, path_index = enums.PathIndex.P1) \n
-		Returns the frequency values of the result table for a selected path of a selected connector. The order of the list
-		entries is the same as in the command method RsCmwGprfMeas.Ploss.Eval.Gain.fetch. Use this command to check at which
-		frequencies the gain values have been measured. For possible connector values, see 'Values for RF Path Selection'. \n
+	def fetch(self, list_index: int, result_index: int = None) -> List[float]:
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:IQData:BIN \n
+		Snippet: value: List[float] = driver.power.iqData.bin.fetch(list_index = 1, result_index = 1) \n
+		No command help available \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:param connector: RF connector for which results are queried
-			:param path_index: P1 | P2 | P3 | P4 | P5 | P6 | P7 | P8 Path index, default value P1 Skip the parameter if you have only one path at the connector.
-			:return: frequency: Comma-separated list of frequency values Unit: Hz"""
-		param = ArgSingleList().compose_cmd_string(ArgSingle('connector', connector, DataType.Enum), ArgSingle('path_index', path_index, DataType.Enum, True))
+			:param list_index: No help available
+			:param result_index: No help available
+			:return: iq_data: No help available"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('list_index', list_index, DataType.Integer), ArgSingle('result_index', result_index, DataType.Integer, None, is_optional=True))
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:PLOSs:EVAL:FREQuency? {param}'.rstrip(), suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:IQData:BIN? {param}'.rstrip(), suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Ploss_/Eval_/Gain.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Rms/Minimum.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,32 +1,35 @@
 from typing import List
 
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
-from ....Internal.ArgSingleList import ArgSingleList
-from ....Internal.ArgSingle import ArgSingle
-from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Gain:
-	"""Gain commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("gain", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
-	def fetch(self, connector: enums.CmwsConnector, path_index: enums.PathIndex = None) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:PLOSs:EVAL:GAIN \n
-		Snippet: value: List[float] = driver.ploss.eval.gain.fetch(connector = enums.CmwsConnector.R11, path_index = enums.PathIndex.P1) \n
-		Returns the gain values of the result table for a selected path of a selected connector. For possible connector values,
-		see 'Values for RF Path Selection'. \n
+	def fetch(self) -> List[float]:
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:RMS:MINimum \n
+		Snippet: value: List[float] = driver.spectrum.rms.minimum.fetch() \n
+		Returns the traces calculated with the RMS detector. Current, average, maximum and minimum traces can be retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:param connector: RF connector for which results are queried
-			:param path_index: P1 | P2 | P3 | P4 | P5 | P6 | P7 | P8 Path index, default value P1 Skip the parameter if you have only one path at the connector.
-			:return: gain: Comma-separated list of gain values Unit: dB"""
-		param = ArgSingleList().compose_cmd_string(ArgSingle('connector', connector, DataType.Enum), ArgSingle('path_index', path_index, DataType.Enum, True))
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:PLOSs:EVAL:GAIN? {param}'.rstrip(), suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:RMS:MINimum?', suppressed)
+		return response
+
+	def read(self) -> List[float]:
+		"""SCPI: READ:GPRF:MEASurement<Instance>:SPECtrum:RMS:MINimum \n
+		Snippet: value: List[float] = driver.spectrum.rms.minimum.read() \n
+		Returns the traces calculated with the RMS detector. Current, average, maximum and minimum traces can be retrieved. \n
+		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
+		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:SPECtrum:RMS:MINimum?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Ploss_/Eval_/State.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Initiate/Ploss/Evaluate.py`

 * *Files 20% similar despite different names*

```diff
@@ -5,44 +5,44 @@
 from ....Internal.ArgStruct import ArgStruct
 from ....Internal.ArgSingleList import ArgSingleList
 from ....Internal.ArgSingle import ArgSingle
 from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class State:
-	"""State commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class EvaluateCls:
+	"""Evaluate commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("state", core, parent)
+		self._cmd_group = CommandsGroup("evaluate", core, parent)
+
+	def set(self, connector: enums.CmwsConnector, path_index: enums.PathIndex = None) -> None:
+		"""SCPI: INITiate:GPRF:MEASurement<Instance>:PLOSs:EVALuate \n
+		Snippet: driver.initiate.ploss.evaluate.set(connector = enums.CmwsConnector.R11, path_index = enums.PathIndex.P1) \n
+		No command help available \n
+			:param connector: No help available
+			:param path_index: No help available
+		"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('connector', connector, DataType.Enum, enums.CmwsConnector), ArgSingle('path_index', path_index, DataType.Enum, enums.PathIndex, is_optional=True))
+		self._core.io.write(f'INITiate:GPRF:MEASurement<Instance>:PLOSs:EVALuate {param}'.rstrip())
 
 	# noinspection PyTypeChecker
-	class FetchStruct(StructBase):
+	class EvaluateStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: See 'Reliability Indicator'
-			- Result_State_Open: enums.PathLossState: NCAP | PEND | RDY Result state for measurement mode 'Open' NCAP: no measurement results available PEND: measurement running RDY: measurement complete, results available
-			- Result_State_Short: enums.PathLossState: NCAP | PEND | RDY Result state for measurement mode 'Short'
-			- Result_State_Eval: enums.PathLossState: NCAP | PEND | RDY Result state for measurement mode 'Eval'"""
+			- Connector: enums.CmwsConnector: No parameter help available
+			- Path_Index: enums.PathIndex: No parameter help available"""
 		__meta_args_list = [
-			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_enum('Result_State_Open', enums.PathLossState),
-			ArgStruct.scalar_enum('Result_State_Short', enums.PathLossState),
-			ArgStruct.scalar_enum('Result_State_Eval', enums.PathLossState)]
+			ArgStruct.scalar_enum('Connector', enums.CmwsConnector),
+			ArgStruct.scalar_enum('Path_Index', enums.PathIndex)]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
-			self.Reliability: int = None
-			self.Result_State_Open: enums.PathLossState = None
-			self.Result_State_Short: enums.PathLossState = None
-			self.Result_State_Eval: enums.PathLossState = None
-
-	def fetch(self, connector: enums.CmwsConnector, path_index: enums.PathIndex = None) -> FetchStruct:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:PLOSs:EVAL:STATe \n
-		Snippet: value: FetchStruct = driver.ploss.eval.state.fetch(connector = enums.CmwsConnector.R11, path_index = enums.PathIndex.P1) \n
-		Queries the result state for all measurement modes and a selected path of a selected connector. For possible connector
-		values, see 'Values for RF Path Selection'. \n
-			:param connector: RF connector for which the result state is queried
-			:param path_index: P1 | P2 | P3 | P4 | P5 | P6 | P7 | P8 Path index, default value P1 Skip the parameter if you have only one path at the connector.
-			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		param = ArgSingleList().compose_cmd_string(ArgSingle('connector', connector, DataType.Enum), ArgSingle('path_index', path_index, DataType.Enum, True))
-		return self._core.io.query_struct(f'FETCh:GPRF:MEASurement<Instance>:PLOSs:EVAL:STATe? {param}'.rstrip(), self.__class__.FetchStruct())
+			self.Connector: enums.CmwsConnector = None
+			self.Path_Index: enums.PathIndex = None
+
+	def get(self) -> EvaluateStruct:
+		"""SCPI: INITiate:GPRF:MEASurement<Instance>:PLOSs:EVALuate \n
+		Snippet: value: EvaluateStruct = driver.initiate.ploss.evaluate.get() \n
+		No command help available \n
+			:return: structure: for return value, see the help for EvaluateStruct structure arguments."""
+		return self._core.io.query_struct(f'INITiate:GPRF:MEASurement<Instance>:PLOSs:EVALuate?', self.__class__.EvaluateStruct())
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Ploss_/Eval_/Trace_/Frequency.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/FftSpecAn/Qcomponent.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,33 +1,35 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
-from .....Internal.ArgSingleList import ArgSingleList
-from .....Internal.ArgSingle import ArgSingle
-from ..... import enums
+from ...Internal.Core import Core
+from ...Internal.CommandsGroup import CommandsGroup
+from ...Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ...Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Frequency:
-	"""Frequency commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class QcomponentCls:
+	"""Qcomponent commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("frequency", core, parent)
+		self._cmd_group = CommandsGroup("qcomponent", core, parent)
 
-	def fetch(self, connector: enums.CmwsConnector, path_index: enums.PathIndex = None) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:PLOSs:EVAL:TRACe:FREQuency \n
-		Snippet: value: List[float] = driver.ploss.eval.trace.frequency.fetch(connector = enums.CmwsConnector.R11, path_index = enums.PathIndex.P1) \n
-		Returns the frequency values of the result diagram for a selected path of a selected connector. The order of the values
-		is the same as in the command method RsCmwGprfMeas.Ploss.Eval.Trace.Gain.fetch. Use this command to check at which
-		frequencies the gain values have been measured. For possible connector values, see 'Values for RF Path Selection'. \n
+	def read(self) -> List[float]:
+		"""SCPI: READ:GPRF:MEASurement<Instance>:FFTSanalyzer:Q \n
+		Snippet: value: List[float] = driver.fftSpecAn.qcomponent.read() \n
+		Returns the measured normalized I and Q amplitudes in the time domain. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:param connector: RF connector for which results are queried
-			:param path_index: P1 | P2 | P3 | P4 | P5 | P6 | P7 | P8 Path index, default value P1 Skip the parameter if you have only one path at the connector.
-			:return: frequency: Comma-separated list of frequency values Unit: Hz"""
-		param = ArgSingleList().compose_cmd_string(ArgSingle('connector', connector, DataType.Enum), ArgSingle('path_index', path_index, DataType.Enum, True))
+			:return: qdata: float Comma-separated list of N normalized I or Q amplitudes. N equals the configured FFT length."""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:PLOSs:EVAL:TRACe:FREQuency? {param}'.rstrip(), suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:FFTSanalyzer:Q?', suppressed)
+		return response
+
+	def fetch(self) -> List[float]:
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:FFTSanalyzer:Q \n
+		Snippet: value: List[float] = driver.fftSpecAn.qcomponent.fetch() \n
+		Returns the measured normalized I and Q amplitudes in the time domain. \n
+		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
+			:return: qdata: float Comma-separated list of N normalized I or Q amplitudes. N equals the configured FFT length."""
+		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:FFTSanalyzer:Q?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Ploss_/Eval_/Trace_/Gain.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Ploss/Eval/Trace/Gain.py`

 * *Files 21% similar despite different names*

```diff
@@ -6,27 +6,26 @@
 from .....Internal.Types import DataType
 from .....Internal.ArgSingleList import ArgSingleList
 from .....Internal.ArgSingle import ArgSingle
 from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Gain:
-	"""Gain commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class GainCls:
+	"""Gain commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("gain", core, parent)
+		self._cmd_group = CommandsGroup("gain", core, parent)
 
 	def fetch(self, connector: enums.CmwsConnector, path_index: enums.PathIndex = None) -> List[float]:
 		"""SCPI: FETCh:GPRF:MEASurement<Instance>:PLOSs:EVAL:TRACe:GAIN \n
 		Snippet: value: List[float] = driver.ploss.eval.trace.gain.fetch(connector = enums.CmwsConnector.R11, path_index = enums.PathIndex.P1) \n
-		Returns the gain values of the result diagram for a selected path of a selected connector. For possible connector values,
-		see 'Values for RF Path Selection'. \n
+		No command help available \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:param connector: RF connector for which results are queried
-			:param path_index: P1 | P2 | P3 | P4 | P5 | P6 | P7 | P8 Path index, default value P1 Skip the parameter if you have only one path at the connector.
-			:return: gain: Comma-separated list of gain values Unit: dB"""
-		param = ArgSingleList().compose_cmd_string(ArgSingle('connector', connector, DataType.Enum), ArgSingle('path_index', path_index, DataType.Enum, True))
+			:param connector: No help available
+			:param path_index: No help available
+			:return: gain: No help available"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('connector', connector, DataType.Enum, enums.CmwsConnector), ArgSingle('path_index', path_index, DataType.Enum, enums.PathIndex, is_optional=True))
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:PLOSs:EVAL:TRACe:GAIN? {param}'.rstrip(), suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Ploss_/Open.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Minimum/Minimum.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,32 +1,37 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ...Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ...Internal.Types import DataType
-from ...Internal.ArgSingleList import ArgSingleList
-from ...Internal.ArgSingle import ArgSingle
-from ... import enums
+from typing import List
+
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Open:
-	"""Open commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("open", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
+
+	def fetch(self) -> List[float]:
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:MINimum:MINimum \n
+		Snippet: value: List[float] = driver.spectrum.minimum.minimum.fetch() \n
+		Returns the traces calculated with the minimum peak detector. Current, average, maximum and minimum traces can be
+		retrieved. \n
+		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
+		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:MINimum:MINimum?', suppressed)
+		return response
 
-	# noinspection PyTypeChecker
-	def fetch(self, connector: enums.CmwsConnector, path_index: enums.PathIndex = None) -> enums.PathLossState:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:PLOSs:OPEN \n
-		Snippet: value: enums.PathLossState = driver.ploss.open.fetch(connector = enums.CmwsConnector.R11, path_index = enums.PathIndex.P1) \n
-		Queries the result state for the measurement mode 'Open' and a selected path of a selected connector.
-		For possible connector values, see 'Values for RF Path Selection'. \n
+	def read(self) -> List[float]:
+		"""SCPI: READ:GPRF:MEASurement<Instance>:SPECtrum:MINimum:MINimum \n
+		Snippet: value: List[float] = driver.spectrum.minimum.minimum.read() \n
+		Returns the traces calculated with the minimum peak detector. Current, average, maximum and minimum traces can be
+		retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:param connector: RF connector for which the result state is queried
-			:param path_index: P1 | P2 | P3 | P4 | P5 | P6 | P7 | P8 Path index, default value P1 Skip the parameter if you have only one path at the connector.
-			:return: result_state_open: NCAP | PEND | RDY NCAP: no measurement results available PEND: measurement running RDY: measurement complete, results available"""
-		param = ArgSingleList().compose_cmd_string(ArgSingle('connector', connector, DataType.Enum), ArgSingle('path_index', path_index, DataType.Enum, True))
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_str_suppressed(f'FETCh:GPRF:MEASurement<Instance>:PLOSs:OPEN? {param}'.rstrip(), suppressed)
-		return Conversions.str_to_scalar_enum(response, enums.PathLossState)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:SPECtrum:MINimum:MINimum?', suppressed)
+		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Ploss_/Short.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Ploss/Short.py`

 * *Files 23% similar despite different names*

```diff
@@ -5,28 +5,27 @@
 from ...Internal.Types import DataType
 from ...Internal.ArgSingleList import ArgSingleList
 from ...Internal.ArgSingle import ArgSingle
 from ... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Short:
-	"""Short commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ShortCls:
+	"""Short commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("short", core, parent)
+		self._cmd_group = CommandsGroup("short", core, parent)
 
 	# noinspection PyTypeChecker
 	def fetch(self, connector: enums.CmwsConnector, path_index: enums.PathIndex = None) -> enums.PathLossState:
 		"""SCPI: FETCh:GPRF:MEASurement<Instance>:PLOSs:SHORt \n
 		Snippet: value: enums.PathLossState = driver.ploss.short.fetch(connector = enums.CmwsConnector.R11, path_index = enums.PathIndex.P1) \n
-		Queries the result state for the measurement mode 'Short' and a selected path of a selected connector. For possible
-		connector values, see 'Values for RF Path Selection'. \n
+		No command help available \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:param connector: RF connector for which the result state is queried
-			:param path_index: P1 | P2 | P3 | P4 | P5 | P6 | P7 | P8 Path index, default value P1 Skip the parameter if you have only one path at the connector.
-			:return: result_state_short: NCAP | PEND | RDY NCAP: no measurement results available PEND: measurement running RDY: measurement complete, results available"""
-		param = ArgSingleList().compose_cmd_string(ArgSingle('connector', connector, DataType.Enum), ArgSingle('path_index', path_index, DataType.Enum, True))
+			:param connector: No help available
+			:param path_index: No help available
+			:return: result_state_short: No help available"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('connector', connector, DataType.Enum, enums.CmwsConnector), ArgSingle('path_index', path_index, DataType.Enum, enums.PathIndex, is_optional=True))
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'FETCh:GPRF:MEASurement<Instance>:PLOSs:SHORt? {param}'.rstrip(), suppressed)
 		return Conversions.str_to_scalar_enum(response, enums.PathLossState)
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,192 +1,156 @@
-from ..Internal.Core import Core
-from ..Internal.CommandsGroup import CommandsGroup
+from ...Internal.Core import Core
+from ...Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Power:
-	"""Power commands group definition. 71 total commands, 13 Sub-groups, 3 group commands"""
+class PowerCls:
+	"""Power commands group definition. 71 total commands, 13 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("power", core, parent)
+		self._cmd_group = CommandsGroup("power", core, parent)
 
 	@property
 	def state(self):
 		"""state commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_state'):
-			from .Power_.State import State
-			self._state = State(self._core, self._base)
+			from .State import StateCls
+			self._state = StateCls(self._core, self._cmd_group)
 		return self._state
 
 	@property
 	def current(self):
 		"""current commands group. 3 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .Power_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 1 Sub-classes, 3 commands."""
 		if not hasattr(self, '_average'):
-			from .Power_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def minimum(self):
 		"""minimum commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Power_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Power_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
 	@property
 	def standardDev(self):
 		"""standardDev commands group. 1 Sub-classes, 3 commands."""
 		if not hasattr(self, '_standardDev'):
-			from .Power_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
+			from .StandardDev import StandardDevCls
+			self._standardDev = StandardDevCls(self._core, self._cmd_group)
 		return self._standardDev
 
 	@property
 	def cumulativeDistribFnc(self):
 		"""cumulativeDistribFnc commands group. 3 Sub-classes, 1 commands."""
 		if not hasattr(self, '_cumulativeDistribFnc'):
-			from .Power_.CumulativeDistribFnc import CumulativeDistribFnc
-			self._cumulativeDistribFnc = CumulativeDistribFnc(self._core, self._base)
+			from .CumulativeDistribFnc import CumulativeDistribFncCls
+			self._cumulativeDistribFnc = CumulativeDistribFncCls(self._core, self._cmd_group)
 		return self._cumulativeDistribFnc
 
 	@property
 	def amplitudeProbDensity(self):
 		"""amplitudeProbDensity commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_amplitudeProbDensity'):
-			from .Power_.AmplitudeProbDensity import AmplitudeProbDensity
-			self._amplitudeProbDensity = AmplitudeProbDensity(self._core, self._base)
+			from .AmplitudeProbDensity import AmplitudeProbDensityCls
+			self._amplitudeProbDensity = AmplitudeProbDensityCls(self._core, self._cmd_group)
 		return self._amplitudeProbDensity
 
 	@property
 	def elapsedStats(self):
 		"""elapsedStats commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_elapsedStats'):
-			from .Power_.ElapsedStats import ElapsedStats
-			self._elapsedStats = ElapsedStats(self._core, self._base)
+			from .ElapsedStats import ElapsedStatsCls
+			self._elapsedStats = ElapsedStatsCls(self._core, self._cmd_group)
 		return self._elapsedStats
 
 	@property
 	def listPy(self):
 		"""listPy commands group. 6 Sub-classes, 0 commands."""
 		if not hasattr(self, '_listPy'):
-			from .Power_.ListPy import ListPy
-			self._listPy = ListPy(self._core, self._base)
+			from .ListPy import ListPyCls
+			self._listPy = ListPyCls(self._core, self._cmd_group)
 		return self._listPy
 
 	@property
 	def peak(self):
 		"""peak commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_peak'):
-			from .Power_.Peak import Peak
-			self._peak = Peak(self._core, self._base)
+			from .Peak import PeakCls
+			self._peak = PeakCls(self._core, self._cmd_group)
 		return self._peak
 
 	@property
 	def iqData(self):
 		"""iqData commands group. 1 Sub-classes, 2 commands."""
 		if not hasattr(self, '_iqData'):
-			from .Power_.IqData import IqData
-			self._iqData = IqData(self._core, self._base)
+			from .IqData import IqDataCls
+			self._iqData = IqDataCls(self._core, self._cmd_group)
 		return self._iqData
 
 	@property
 	def iqInfo(self):
 		"""iqInfo commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_iqInfo'):
-			from .Power_.IqInfo import IqInfo
-			self._iqInfo = IqInfo(self._core, self._base)
+			from .IqInfo import IqInfoCls
+			self._iqInfo = IqInfoCls(self._core, self._cmd_group)
 		return self._iqInfo
 
-	def initiate(self) -> None:
+	def initiate(self, opc_timeout_ms: int = -1) -> None:
 		"""SCPI: INITiate:GPRF:MEASurement<Instance>:POWer \n
 		Snippet: driver.power.initiate() \n
 			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
 			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
 			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
 			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
-		"""
-		self._core.io.write(f'INITiate:GPRF:MEASurement<Instance>:POWer')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'INITiate:GPRF:MEASurement<Instance>:POWer', opc_timeout_ms)
 
-	def initiate_with_opc(self) -> None:
-		"""SCPI: INITiate:GPRF:MEASurement<Instance>:POWer \n
-		Snippet: driver.power.initiate_with_opc() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
-		Use FETCh...STATe? to query the current measurement state. \n
-		Same as initiate, but waits for the operation to complete before continuing further. Use the RsCmwGprfMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'INITiate:GPRF:MEASurement<Instance>:POWer')
-
-	def stop(self) -> None:
+	def stop(self, opc_timeout_ms: int = -1) -> None:
 		"""SCPI: STOP:GPRF:MEASurement<Instance>:POWer \n
 		Snippet: driver.power.stop() \n
 			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
 			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
 			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
 			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
-		"""
-		self._core.io.write(f'STOP:GPRF:MEASurement<Instance>:POWer')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'STOP:GPRF:MEASurement<Instance>:POWer', opc_timeout_ms)
 
-	def stop_with_opc(self) -> None:
-		"""SCPI: STOP:GPRF:MEASurement<Instance>:POWer \n
-		Snippet: driver.power.stop_with_opc() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
-		Use FETCh...STATe? to query the current measurement state. \n
-		Same as stop, but waits for the operation to complete before continuing further. Use the RsCmwGprfMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'STOP:GPRF:MEASurement<Instance>:POWer')
-
-	def abort(self) -> None:
+	def abort(self, opc_timeout_ms: int = -1) -> None:
 		"""SCPI: ABORt:GPRF:MEASurement<Instance>:POWer \n
 		Snippet: driver.power.abort() \n
 			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
 			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
 			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
 			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
-		"""
-		self._core.io.write(f'ABORt:GPRF:MEASurement<Instance>:POWer')
-
-	def abort_with_opc(self) -> None:
-		"""SCPI: ABORt:GPRF:MEASurement<Instance>:POWer \n
-		Snippet: driver.power.abort_with_opc() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
-		Use FETCh...STATe? to query the current measurement state. \n
-		Same as abort, but waits for the operation to complete before continuing further. Use the RsCmwGprfMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'ABORt:GPRF:MEASurement<Instance>:POWer')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'ABORt:GPRF:MEASurement<Instance>:POWer', opc_timeout_ms)
 
-	def clone(self) -> 'Power':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PowerCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Power(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PowerCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/AmplitudeProbDensity.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/AmplitudeProbDensity.py`

 * *Files 27% similar despite different names*

```diff
@@ -3,24 +3,23 @@
 from ...Internal.Core import Core
 from ...Internal.CommandsGroup import CommandsGroup
 from ...Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ...Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class AmplitudeProbDensity:
-	"""AmplitudeProbDensity commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class AmplitudeProbDensityCls:
+	"""AmplitudeProbDensity commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("amplitudeProbDensity", core, parent)
+		self._cmd_group = CommandsGroup("amplitudeProbDensity", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:APD \n
 		Snippet: value: List[float] = driver.power.amplitudeProbDensity.fetch() \n
-		Returns the trace points of the amplitude probability density (APD) . This result is only available in statistic
-		evaluation mode (see method RsCmwGprfMeas.Configure.Power.mode) . \n
+		Returns the APD diagram contents. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: results: 4096 results, each representing a 0.047dB interval ('bin') . The position of the average power 'bin' can be retrieved via method RsCmwGprfMeas.Power.CumulativeDistribFnc.Power.fetch. Range: 10E-9 % to 100 %"""
+			:return: results: float 4096 results, each representing a 0.047-dB interval ('bin') Unit: %"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:APD?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Average.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Average/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,82 +1,94 @@
 from typing import List
 
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ...Internal.Types import DataType
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ....Internal.Types import DataType
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 5 total commands, 1 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 5 total commands, 1 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	@property
 	def rms(self):
 		"""rms commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_rms'):
-			from .Average_.Rms import Rms
-			self._rms = Rms(self._core, self._base)
+			from .Rms import RmsCls
+			self._rms = RmsCls(self._core, self._cmd_group)
 		return self._rms
 
-	def calculate(self) -> List[float]:
+	# noinspection PyTypeChecker
+	def calculate(self) -> List[enums.ResultStatus2]:
 		"""SCPI: CALCulate:GPRF:MEASurement<Instance>:POWer:AVERage \n
-		Snippet: value: List[float] = driver.power.average.calculate() \n
-		Returns RF power results, see 'Measurement Results'.
+		Snippet: value: List[enums.ResultStatus2] = driver.power.average.calculate() \n
+		Returns power results for all segments, see 'Results in list mode'.
 			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:POWer:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)  \n
+			- 'Current RMS' (...:POWer:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_average_rms: If list mode is switched off, a single value is returned. In list mode, n is equal to the step count (method RsCmwGprfMeas.Configure.Power.ListPy.count) . CALCulate commands return error indicators for each measured power step. FETCh/READ commands return RF power values for each measured power step. Range: -100 dBm to 57 dBm, Unit: dBm"""
+			:return: power_average_rms: float Comma-separated list of power values, one value per measured segment Unit: dBm (SDEViation: dB)"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:GPRF:MEASurement<Instance>:POWer:AVERage?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:GPRF:MEASurement<Instance>:POWer:AVERage?', suppressed)
+		return Conversions.str_to_list_enum(response, enums.ResultStatus2)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:AVERage \n
 		Snippet: value: List[float] = driver.power.average.fetch() \n
-		Returns RF power results, see 'Measurement Results'.
+		Returns power results for all segments, see 'Results in list mode'.
 			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:POWer:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)  \n
+			- 'Current RMS' (...:POWer:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_average_rms: If list mode is switched off, a single value is returned. In list mode, n is equal to the step count (method RsCmwGprfMeas.Configure.Power.ListPy.count) . CALCulate commands return error indicators for each measured power step. FETCh/READ commands return RF power values for each measured power step. Range: -100 dBm to 57 dBm, Unit: dBm"""
+			:return: power_average_rms: float Comma-separated list of power values, one value per measured segment Unit: dBm (SDEViation: dB)"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:AVERage?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:GPRF:MEASurement<Instance>:POWer:AVERage \n
 		Snippet: value: List[float] = driver.power.average.read() \n
-		Returns RF power results, see 'Measurement Results'.
+		Returns power results for all segments, see 'Results in list mode'.
 			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:POWer:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)  \n
+			- 'Current RMS' (...:POWer:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_average_rms: If list mode is switched off, a single value is returned. In list mode, n is equal to the step count (method RsCmwGprfMeas.Configure.Power.ListPy.count) . CALCulate commands return error indicators for each measured power step. FETCh/READ commands return RF power values for each measured power step. Range: -100 dBm to 57 dBm, Unit: dBm"""
+			:return: power_average_rms: float Comma-separated list of power values, one value per measured segment Unit: dBm (SDEViation: dB)"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:POWer:AVERage?', suppressed)
 		return response
 
-	def clone(self) -> 'Average':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'AverageCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Average(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AverageCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Average_/Rms.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Average/Rms.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Rms:
-	"""Rms commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class RmsCls:
+	"""Rms commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rms", core, parent)
+		self._cmd_group = CommandsGroup("rms", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:AVERage:RMS \n
 		Snippet: value: List[float] = driver.power.average.rms.fetch() \n
 		No command help available \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
 			:return: power_average_rms: No help available"""
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/CumulativeDistribFnc_/Power.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/CumulativeDistribFnc/Sample.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,44 +1,37 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Power:
-	"""Power commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SampleCls:
+	"""Sample commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("power", core, parent)
+		self._cmd_group = CommandsGroup("sample", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: See 'Reliability Indicator'
-			- Avg: float: Average power Range: -150 dBm to 50 dBm
-			- Max: float: Maximum power Range: -150 dBm to 50 dBm
-			- Par: float: Peak to average ratio Range: 0 dB to 50 dB
-			- Index_Avg_Power: int: Index of the average power 'bin' in the CCDF result (see [CMDLINK: FETCh:GPRF:MEASi:POWer:CCDF CMDLINK]) Range: 0 to n"""
+			- Reliability: int: decimal See 'Reliability indicator'
+			- Count: int: decimal Total sample count
+			- Time: float: float Total sample time Unit: s"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
-			ArgStruct.scalar_float('Avg'),
-			ArgStruct.scalar_float('Max'),
-			ArgStruct.scalar_float('Par'),
-			ArgStruct.scalar_int('Index_Avg_Power')]
+			ArgStruct.scalar_int('Count'),
+			ArgStruct.scalar_float('Time')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
-			self.Avg: float = None
-			self.Max: float = None
-			self.Par: float = None
-			self.Index_Avg_Power: int = None
+			self.Count: int = None
+			self.Time: float = None
 
 	def fetch(self) -> FetchStruct:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:CCDF:POWer \n
-		Snippet: value: FetchStruct = driver.power.cumulativeDistribFnc.power.fetch() \n
-		Returns the power results in statistic evaluation mode (see method RsCmwGprfMeas.Configure.Power.mode) . The statistic
-		evaluation mode is only available for single-step measurements (list mode OFF) . \n
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:CCDF:SAMPle \n
+		Snippet: value: FetchStruct = driver.power.cumulativeDistribFnc.sample.fetch() \n
+		Returns the sample counters for the APD and CCDF results. \n
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		return self._core.io.query_struct(f'FETCh:GPRF:MEASurement<Instance>:POWer:CCDF:POWer?', self.__class__.FetchStruct())
+		return self._core.io.query_struct(f'FETCh:GPRF:MEASurement<Instance>:POWer:CCDF:SAMPle?', self.__class__.FetchStruct())
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Current.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Current/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,98 +1,110 @@
 from typing import List
 
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ...Internal.Types import DataType
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ....Internal.Types import DataType
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 9 total commands, 3 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 9 total commands, 3 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	@property
 	def rms(self):
 		"""rms commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_rms'):
-			from .Current_.Rms import Rms
-			self._rms = Rms(self._core, self._base)
+			from .Rms import RmsCls
+			self._rms = RmsCls(self._core, self._cmd_group)
 		return self._rms
 
 	@property
 	def minimum(self):
 		"""minimum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Current_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Current_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	def calculate(self) -> List[float]:
+	# noinspection PyTypeChecker
+	def calculate(self) -> List[enums.ResultStatus2]:
 		"""SCPI: CALCulate:GPRF:MEASurement<Instance>:POWer:CURRent \n
-		Snippet: value: List[float] = driver.power.current.calculate() \n
-		Returns RF power results, see 'Measurement Results'.
+		Snippet: value: List[enums.ResultStatus2] = driver.power.current.calculate() \n
+		Returns power results for all segments, see 'Results in list mode'.
 			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:POWer:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)  \n
+			- 'Current RMS' (...:POWer:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_current_rms: If list mode is switched off, a single value is returned. In list mode, n is equal to the step count (method RsCmwGprfMeas.Configure.Power.ListPy.count) . CALCulate commands return error indicators for each measured power step. FETCh/READ commands return RF power values for each measured power step. Range: -100 dBm to 57 dBm, Unit: dBm"""
+			:return: power_current_rms: float Comma-separated list of power values, one value per measured segment Unit: dBm (SDEViation: dB)"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:GPRF:MEASurement<Instance>:POWer:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:GPRF:MEASurement<Instance>:POWer:CURRent?', suppressed)
+		return Conversions.str_to_list_enum(response, enums.ResultStatus2)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:CURRent \n
 		Snippet: value: List[float] = driver.power.current.fetch() \n
-		Returns RF power results, see 'Measurement Results'.
+		Returns power results for all segments, see 'Results in list mode'.
 			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:POWer:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)  \n
+			- 'Current RMS' (...:POWer:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_current_rms: If list mode is switched off, a single value is returned. In list mode, n is equal to the step count (method RsCmwGprfMeas.Configure.Power.ListPy.count) . CALCulate commands return error indicators for each measured power step. FETCh/READ commands return RF power values for each measured power step. Range: -100 dBm to 57 dBm, Unit: dBm"""
+			:return: power_current_rms: float Comma-separated list of power values, one value per measured segment Unit: dBm (SDEViation: dB)"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:CURRent?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:GPRF:MEASurement<Instance>:POWer:CURRent \n
 		Snippet: value: List[float] = driver.power.current.read() \n
-		Returns RF power results, see 'Measurement Results'.
+		Returns power results for all segments, see 'Results in list mode'.
 			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:POWer:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)  \n
+			- 'Current RMS' (...:POWer:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_current_rms: If list mode is switched off, a single value is returned. In list mode, n is equal to the step count (method RsCmwGprfMeas.Configure.Power.ListPy.count) . CALCulate commands return error indicators for each measured power step. FETCh/READ commands return RF power values for each measured power step. Range: -100 dBm to 57 dBm, Unit: dBm"""
+			:return: power_current_rms: float Comma-separated list of power values, one value per measured segment Unit: dBm (SDEViation: dB)"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:POWer:CURRent?', suppressed)
 		return response
 
-	def clone(self) -> 'Current':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'CurrentCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Current(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = CurrentCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Current_/Maximum.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Average/Maximum.py`

 * *Files 22% similar despite different names*

```diff
@@ -3,33 +3,33 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:CURRent:MAXimum \n
-		Snippet: value: List[float] = driver.power.current.maximum.fetch() \n
-		No command help available \n
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:AVERage:MAXimum \n
+		Snippet: value: List[float] = driver.spectrum.average.maximum.fetch() \n
+		Returns the traces calculated with the average detector. Current, average, maximum and minimum traces can be retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_current_max: No help available"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:CURRent:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:AVERage:MAXimum?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:GPRF:MEASurement<Instance>:POWer:CURRent:MAXimum \n
-		Snippet: value: List[float] = driver.power.current.maximum.read() \n
-		No command help available \n
+		"""SCPI: READ:GPRF:MEASurement<Instance>:SPECtrum:AVERage:MAXimum \n
+		Snippet: value: List[float] = driver.spectrum.average.maximum.read() \n
+		Returns the traces calculated with the average detector. Current, average, maximum and minimum traces can be retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_current_max: No help available"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:POWer:CURRent:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:SPECtrum:AVERage:MAXimum?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Current_/Minimum.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Minimum/Minimum.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,33 +3,33 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:CURRent:MINimum \n
-		Snippet: value: List[float] = driver.power.current.minimum.fetch() \n
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:MINimum:MINimum \n
+		Snippet: value: List[float] = driver.power.minimum.minimum.fetch() \n
 		No command help available \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_current_min: No help available"""
+			:return: power_minimum_min: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:CURRent:MINimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:MINimum:MINimum?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:GPRF:MEASurement<Instance>:POWer:CURRent:MINimum \n
-		Snippet: value: List[float] = driver.power.current.minimum.read() \n
+		"""SCPI: READ:GPRF:MEASurement<Instance>:POWer:MINimum:MINimum \n
+		Snippet: value: List[float] = driver.power.minimum.minimum.read() \n
 		No command help available \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_current_min: No help available"""
+			:return: power_minimum_min: No help available"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:POWer:CURRent:MINimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:POWer:MINimum:MINimum?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Current_/Rms.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Sample/Current.py`

 * *Files 16% similar despite different names*

```diff
@@ -3,33 +3,33 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Rms:
-	"""Rms commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("rms", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:CURRent:RMS \n
-		Snippet: value: List[float] = driver.power.current.rms.fetch() \n
-		No command help available \n
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:SAMPle:CURRent \n
+		Snippet: value: List[float] = driver.spectrum.sample.current.fetch() \n
+		Returns the traces calculated with the sample detector. Current, average, maximum and minimum traces can be retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_current_rms: No help available"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:CURRent:RMS?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:SAMPle:CURRent?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:GPRF:MEASurement<Instance>:POWer:CURRent:RMS \n
-		Snippet: value: List[float] = driver.power.current.rms.read() \n
-		No command help available \n
+		"""SCPI: READ:GPRF:MEASurement<Instance>:SPECtrum:SAMPle:CURRent \n
+		Snippet: value: List[float] = driver.spectrum.sample.current.read() \n
+		Returns the traces calculated with the sample detector. Current, average, maximum and minimum traces can be retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_current_rms: No help available"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:POWer:CURRent:RMS?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:SPECtrum:SAMPle:CURRent?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ElapsedStats.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/ElapsedStats.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,23 +2,23 @@
 from ...Internal.CommandsGroup import CommandsGroup
 from ...Internal import Conversions
 from ...Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ...Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ElapsedStats:
-	"""ElapsedStats commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ElapsedStatsCls:
+	"""ElapsedStats commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("elapsedStats", core, parent)
+		self._cmd_group = CommandsGroup("elapsedStats", core, parent)
 
 	def fetch(self) -> int:
 		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:ESTatistics \n
 		Snippet: value: int = driver.power.elapsedStats.fetch() \n
 		Returns the reliability indicator and the number of elapsed measurement intervals. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: stat_count: Number of elapsed measurement intervals. Range: 0 to 100E+3"""
+			:return: stat_count: decimal Number of elapsed measurement intervals. Range: 0 to 100E+3"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_str_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:ESTatistics?', suppressed)
 		return Conversions.str_to_int(response)
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/IqData.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/IqData/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,61 +1,59 @@
 from typing import List
 
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ...Internal.Types import DataType
-from ...Internal.ArgSingleList import ArgSingleList
-from ...Internal.ArgSingle import ArgSingle
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ....Internal.Types import DataType
+from ....Internal.ArgSingleList import ArgSingleList
+from ....Internal.ArgSingle import ArgSingle
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class IqData:
-	"""IqData commands group definition. 3 total commands, 1 Sub-groups, 2 group commands"""
+class IqDataCls:
+	"""IqData commands group definition. 3 total commands, 1 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("iqData", core, parent)
+		self._cmd_group = CommandsGroup("iqData", core, parent)
 
 	@property
 	def bin(self):
 		"""bin commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_bin'):
-			from .IqData_.Bin import Bin
-			self._bin = Bin(self._core, self._base)
+			from .Bin import BinCls
+			self._bin = BinCls(self._core, self._cmd_group)
 		return self._bin
 
 	def fetch(self, list_index: int, result_index: int = None) -> List[float]:
 		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:IQData \n
 		Snippet: value: List[float] = driver.power.iqData.fetch(list_index = 1, result_index = 1) \n
-		Returns the results of the I/Q data measurement in a particular frequency/level step <index> in ASCII format. With the
-		optional <ResultIndex> parameter, it is also possible to get results for a particular list index repetition. \n
+		No command help available \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:param list_index: Range: 0 to 3999
-			:param result_index: Range: 0 to #repetitions of ListIndex
-			:return: iq_data: I and Q amplitudes in alternating order. The values depend on the selected magnitude unit (method RsCmwGprfMeas.Configure.Power.ListPy.munit. Range: -160 V to 160 V , Unit: V"""
-		param = ArgSingleList().compose_cmd_string(ArgSingle('list_index', list_index, DataType.Integer), ArgSingle('result_index', result_index, DataType.Integer, True))
+			:param list_index: No help available
+			:param result_index: No help available
+			:return: iq_data: No help available"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('list_index', list_index, DataType.Integer), ArgSingle('result_index', result_index, DataType.Integer, None, is_optional=True))
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:IQData? {param}'.rstrip(), suppressed)
 		return response
 
 	def read(self, list_index: int, result_index: int = None) -> List[float]:
 		"""SCPI: READ:GPRF:MEASurement<Instance>:POWer:IQData \n
 		Snippet: value: List[float] = driver.power.iqData.read(list_index = 1, result_index = 1) \n
-		Returns the results of the I/Q data measurement in a particular frequency/level step <index> in ASCII format. With the
-		optional <ResultIndex> parameter, it is also possible to get results for a particular list index repetition. \n
+		No command help available \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:param list_index: Range: 0 to 3999
-			:param result_index: Range: 0 to #repetitions of ListIndex
-			:return: iq_data: I and Q amplitudes in alternating order. The values depend on the selected magnitude unit (method RsCmwGprfMeas.Configure.Power.ListPy.munit. Range: -160 V to 160 V , Unit: V"""
-		param = ArgSingleList().compose_cmd_string(ArgSingle('list_index', list_index, DataType.Integer), ArgSingle('result_index', result_index, DataType.Integer, True))
+			:param list_index: No help available
+			:param result_index: No help available
+			:return: iq_data: No help available"""
+		param = ArgSingleList().compose_cmd_string(ArgSingle('list_index', list_index, DataType.Integer), ArgSingle('result_index', result_index, DataType.Integer, None, is_optional=True))
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:POWer:IQData? {param}'.rstrip(), suppressed)
 		return response
 
-	def clone(self) -> 'IqData':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'IqDataCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = IqData(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = IqDataCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ListPy.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Initiate/Ploss/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,67 +1,43 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ListPy:
-	"""ListPy commands group definition. 21 total commands, 6 Sub-groups, 0 group commands"""
+class PlossCls:
+	"""Ploss commands group definition. 3 total commands, 3 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("listPy", core, parent)
+		self._cmd_group = CommandsGroup("ploss", core, parent)
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_current'):
-			from .ListPy_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
+	def open(self):
+		"""open commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_open'):
+			from .Open import OpenCls
+			self._open = OpenCls(self._core, self._cmd_group)
+		return self._open
+
+	@property
+	def short(self):
+		"""short commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_short'):
+			from .Short import ShortCls
+			self._short = ShortCls(self._core, self._cmd_group)
+		return self._short
+
+	@property
+	def evaluate(self):
+		"""evaluate commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_evaluate'):
+			from .Evaluate import EvaluateCls
+			self._evaluate = EvaluateCls(self._core, self._cmd_group)
+		return self._evaluate
 
-	@property
-	def minimum(self):
-		"""minimum commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_minimum'):
-			from .ListPy_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
-
-	@property
-	def maximum(self):
-		"""maximum commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_maximum'):
-			from .ListPy_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
-
-	@property
-	def average(self):
-		"""average commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_average'):
-			from .ListPy_.Average import Average
-			self._average = Average(self._core, self._base)
-		return self._average
-
-	@property
-	def peak(self):
-		"""peak commands group. 2 Sub-classes, 0 commands."""
-		if not hasattr(self, '_peak'):
-			from .ListPy_.Peak import Peak
-			self._peak = Peak(self._core, self._base)
-		return self._peak
-
-	@property
-	def standardDev(self):
-		"""standardDev commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_standardDev'):
-			from .ListPy_.StandardDev import StandardDev
-			self._standardDev = StandardDev(self._core, self._base)
-		return self._standardDev
-
-	def clone(self) -> 'ListPy':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'PlossCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ListPy(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PlossCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ListPy_/Average.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/ListPy/Average.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,70 +1,84 @@
 from typing import List
 
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class AverageCls:
+	"""Average commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
-	def calculate(self, list_index: int) -> List[float]:
+	# noinspection PyTypeChecker
+	def calculate(self, list_index: int) -> List[enums.ResultStatus2]:
 		"""SCPI: CALCulate:GPRF:MEASurement<Instance>:POWer:LIST:AVERage \n
-		Snippet: value: List[float] = driver.power.listPy.average.calculate(list_index = 1) \n
-		Returns power results in list mode, see 'List Mode: Diagram View'.
-			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:LIST:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)
-		The values described below are returned by FETCh and READ commands. CALCulate commands return a single-value error code
-		for each result listed below. \n
+		Snippet: value: List[enums.ResultStatus2] = driver.power.listPy.average.calculate(list_index = 1) \n
+		Returns power results for segment <ListIndex>, see 'Results in list mode'.
+			INTRO_CMD_HELP: The following powers can be retrieved: \n
+			- 'Current RMS' (...:LIST:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:param list_index: No help available
+			:param list_index: integer Index of the segment
 			:return: power_average_rms: No help available"""
 		param = Conversions.decimal_value_to_str(list_index)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:GPRF:MEASurement<Instance>:POWer:LIST:AVERage? {param}', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:GPRF:MEASurement<Instance>:POWer:LIST:AVERage? {param}', suppressed)
+		return Conversions.str_to_list_enum(response, enums.ResultStatus2)
 
 	def fetch(self, list_index: int) -> List[float]:
 		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:LIST:AVERage \n
 		Snippet: value: List[float] = driver.power.listPy.average.fetch(list_index = 1) \n
-		No command help available \n
+		Returns power results for segment <ListIndex>, see 'Results in list mode'.
+			INTRO_CMD_HELP: The following powers can be retrieved: \n
+			- 'Current RMS' (...:LIST:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:param list_index: No help available
+			:param list_index: integer Index of the segment
 			:return: power_average_rms: No help available"""
 		param = Conversions.decimal_value_to_str(list_index)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:LIST:AVERage? {param}', suppressed)
 		return response
 
 	def read(self, list_index: int) -> List[float]:
 		"""SCPI: READ:GPRF:MEASurement<Instance>:POWer:LIST:AVERage \n
 		Snippet: value: List[float] = driver.power.listPy.average.read(list_index = 1) \n
-		Returns power results in list mode, see 'List Mode: Diagram View'.
-			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:LIST:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)
-		The values described below are returned by FETCh and READ commands. CALCulate commands return a single-value error code
-		for each result listed below. \n
+		Returns power results for segment <ListIndex>, see 'Results in list mode'.
+			INTRO_CMD_HELP: The following powers can be retrieved: \n
+			- 'Current RMS' (...:LIST:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:param list_index: No help available
+			:param list_index: integer Index of the segment
 			:return: power_average_rms: No help available"""
 		param = Conversions.decimal_value_to_str(list_index)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:POWer:LIST:AVERage? {param}', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ListPy_/Current.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Minimum/Current.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,79 +1,78 @@
 from typing import List
 
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
-	def calculate(self, list_index: int) -> List[float]:
-		"""SCPI: CALCulate:GPRF:MEASurement<Instance>:POWer:LIST:CURRent \n
-		Snippet: value: List[float] = driver.power.listPy.current.calculate(list_index = 1) \n
-		Returns power results in list mode, see 'List Mode: Diagram View'.
+	# noinspection PyTypeChecker
+	def calculate(self) -> List[enums.ResultStatus2]:
+		"""SCPI: CALCulate:GPRF:MEASurement<Instance>:POWer:MINimum:CURRent \n
+		Snippet: value: List[enums.ResultStatus2] = driver.power.minimum.current.calculate() \n
+		Returns power results for all segments, see 'Results in list mode'.
 			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:LIST:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)
-		The values described below are returned by FETCh and READ commands. CALCulate commands return a single-value error code
-		for each result listed below. \n
+			- 'Current RMS' (...:POWer:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:param list_index: No help available
-			:return: power_current_rms: No help available"""
-		param = Conversions.decimal_value_to_str(list_index)
+			:return: power_current_min: float Comma-separated list of power values, one value per measured segment Unit: dBm (SDEViation: dB)"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:GPRF:MEASurement<Instance>:POWer:LIST:CURRent? {param}', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:GPRF:MEASurement<Instance>:POWer:MINimum:CURRent?', suppressed)
+		return Conversions.str_to_list_enum(response, enums.ResultStatus2)
 
-	def fetch(self, list_index: int) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:LIST:CURRent \n
-		Snippet: value: List[float] = driver.power.listPy.current.fetch(list_index = 1) \n
-		Returns power results in list mode, see 'List Mode: Diagram View'.
+	def fetch(self) -> List[float]:
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:MINimum:CURRent \n
+		Snippet: value: List[float] = driver.power.minimum.current.fetch() \n
+		Returns power results for all segments, see 'Results in list mode'.
 			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:LIST:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)
-		The values described below are returned by FETCh and READ commands. CALCulate commands return a single-value error code
-		for each result listed below. \n
+			- 'Current RMS' (...:POWer:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:param list_index: No help available
-			:return: power_current_rms: No help available"""
-		param = Conversions.decimal_value_to_str(list_index)
+			:return: power_current_min: float Comma-separated list of power values, one value per measured segment Unit: dBm (SDEViation: dB)"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:LIST:CURRent? {param}', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:MINimum:CURRent?', suppressed)
 		return response
 
-	def read(self, list_index: int) -> List[float]:
-		"""SCPI: READ:GPRF:MEASurement<Instance>:POWer:LIST:CURRent \n
-		Snippet: value: List[float] = driver.power.listPy.current.read(list_index = 1) \n
-		Returns power results in list mode, see 'List Mode: Diagram View'.
+	def read(self) -> List[float]:
+		"""SCPI: READ:GPRF:MEASurement<Instance>:POWer:MINimum:CURRent \n
+		Snippet: value: List[float] = driver.power.minimum.current.read() \n
+		Returns power results for all segments, see 'Results in list mode'.
 			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:LIST:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)
-		The values described below are returned by FETCh and READ commands. CALCulate commands return a single-value error code
-		for each result listed below. \n
+			- 'Current RMS' (...:POWer:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:param list_index: No help available
-			:return: power_current_rms: No help available"""
-		param = Conversions.decimal_value_to_str(list_index)
+			:return: power_current_min: float Comma-separated list of power values, one value per measured segment Unit: dBm (SDEViation: dB)"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:POWer:LIST:CURRent? {param}', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:POWer:MINimum:CURRent?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ListPy_/Maximum.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/ListPy/Peak/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,27 +1,35 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 1 Sub-groups, 0 group commands"""
+class PeakCls:
+	"""Peak commands group definition. 6 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("peak", core, parent)
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_current'):
-			from .Maximum_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
+	def minimum(self):
+		"""minimum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_minimum'):
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
+		return self._minimum
 
-	def clone(self) -> 'Maximum':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
+
+	def clone(self) -> 'PeakCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Maximum(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PeakCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ListPy_/Maximum_/Current.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/ListPy/Maximum/Current.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,79 +1,84 @@
 from typing import List
 
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
-	def calculate(self, list_index: int) -> List[float]:
+	# noinspection PyTypeChecker
+	def calculate(self, list_index: int) -> List[enums.ResultStatus2]:
 		"""SCPI: CALCulate:GPRF:MEASurement<Instance>:POWer:LIST:MAXimum:CURRent \n
-		Snippet: value: List[float] = driver.power.listPy.maximum.current.calculate(list_index = 1) \n
-		Returns power results in list mode, see 'List Mode: Diagram View'.
-			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:LIST:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)
-		The values described below are returned by FETCh and READ commands. CALCulate commands return a single-value error code
-		for each result listed below. \n
+		Snippet: value: List[enums.ResultStatus2] = driver.power.listPy.maximum.current.calculate(list_index = 1) \n
+		Returns power results for segment <ListIndex>, see 'Results in list mode'.
+			INTRO_CMD_HELP: The following powers can be retrieved: \n
+			- 'Current RMS' (...:LIST:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:param list_index: No help available
+			:param list_index: integer Index of the segment
 			:return: power_current_max: No help available"""
 		param = Conversions.decimal_value_to_str(list_index)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:GPRF:MEASurement<Instance>:POWer:LIST:MAXimum:CURRent? {param}', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:GPRF:MEASurement<Instance>:POWer:LIST:MAXimum:CURRent? {param}', suppressed)
+		return Conversions.str_to_list_enum(response, enums.ResultStatus2)
 
 	def fetch(self, list_index: int) -> List[float]:
 		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:LIST:MAXimum:CURRent \n
 		Snippet: value: List[float] = driver.power.listPy.maximum.current.fetch(list_index = 1) \n
-		Returns power results in list mode, see 'List Mode: Diagram View'.
-			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:LIST:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)
-		The values described below are returned by FETCh and READ commands. CALCulate commands return a single-value error code
-		for each result listed below. \n
+		Returns power results for segment <ListIndex>, see 'Results in list mode'.
+			INTRO_CMD_HELP: The following powers can be retrieved: \n
+			- 'Current RMS' (...:LIST:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:param list_index: No help available
+			:param list_index: integer Index of the segment
 			:return: power_current_max: No help available"""
 		param = Conversions.decimal_value_to_str(list_index)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:LIST:MAXimum:CURRent? {param}', suppressed)
 		return response
 
 	def read(self, list_index: int) -> List[float]:
 		"""SCPI: READ:GPRF:MEASurement<Instance>:POWer:LIST:MAXimum:CURRent \n
 		Snippet: value: List[float] = driver.power.listPy.maximum.current.read(list_index = 1) \n
-		Returns power results in list mode, see 'List Mode: Diagram View'.
-			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:LIST:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)
-		The values described below are returned by FETCh and READ commands. CALCulate commands return a single-value error code
-		for each result listed below. \n
+		Returns power results for segment <ListIndex>, see 'Results in list mode'.
+			INTRO_CMD_HELP: The following powers can be retrieved: \n
+			- 'Current RMS' (...:LIST:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:param list_index: No help available
+			:param list_index: integer Index of the segment
 			:return: power_current_max: No help available"""
 		param = Conversions.decimal_value_to_str(list_index)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:POWer:LIST:MAXimum:CURRent? {param}', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ListPy_/Minimum.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Peak/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,27 +1,35 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 3 total commands, 1 Sub-groups, 0 group commands"""
+class PeakCls:
+	"""Peak commands group definition. 6 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("peak", core, parent)
 
 	@property
-	def current(self):
-		"""current commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_current'):
-			from .Minimum_.Current import Current
-			self._current = Current(self._core, self._base)
-		return self._current
+	def minimum(self):
+		"""minimum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_minimum'):
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
+		return self._minimum
 
-	def clone(self) -> 'Minimum':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
+
+	def clone(self) -> 'PeakCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Minimum(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = PeakCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ListPy_/Minimum_/Current.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/ListPy/Peak/Maximum.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,79 +1,84 @@
 from typing import List
 
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
-	def calculate(self, list_index: int) -> List[float]:
-		"""SCPI: CALCulate:GPRF:MEASurement<Instance>:POWer:LIST:MINimum:CURRent \n
-		Snippet: value: List[float] = driver.power.listPy.minimum.current.calculate(list_index = 1) \n
-		Returns power results in list mode, see 'List Mode: Diagram View'.
-			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:LIST:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)
-		The values described below are returned by FETCh and READ commands. CALCulate commands return a single-value error code
-		for each result listed below. \n
+	# noinspection PyTypeChecker
+	def calculate(self, list_index: int) -> List[enums.ResultStatus2]:
+		"""SCPI: CALCulate:GPRF:MEASurement<Instance>:POWer:LIST:PEAK:MAXimum \n
+		Snippet: value: List[enums.ResultStatus2] = driver.power.listPy.peak.maximum.calculate(list_index = 1) \n
+		Returns power results for segment <ListIndex>, see 'Results in list mode'.
+			INTRO_CMD_HELP: The following powers can be retrieved: \n
+			- 'Current RMS' (...:LIST:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:param list_index: No help available
-			:return: power_current_min: No help available"""
+			:param list_index: integer Index of the segment
+			:return: power_maximum_max: No help available"""
 		param = Conversions.decimal_value_to_str(list_index)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:GPRF:MEASurement<Instance>:POWer:LIST:MINimum:CURRent? {param}', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:GPRF:MEASurement<Instance>:POWer:LIST:PEAK:MAXimum? {param}', suppressed)
+		return Conversions.str_to_list_enum(response, enums.ResultStatus2)
 
 	def fetch(self, list_index: int) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:LIST:MINimum:CURRent \n
-		Snippet: value: List[float] = driver.power.listPy.minimum.current.fetch(list_index = 1) \n
-		Returns power results in list mode, see 'List Mode: Diagram View'.
-			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:LIST:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)
-		The values described below are returned by FETCh and READ commands. CALCulate commands return a single-value error code
-		for each result listed below. \n
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:LIST:PEAK:MAXimum \n
+		Snippet: value: List[float] = driver.power.listPy.peak.maximum.fetch(list_index = 1) \n
+		Returns power results for segment <ListIndex>, see 'Results in list mode'.
+			INTRO_CMD_HELP: The following powers can be retrieved: \n
+			- 'Current RMS' (...:LIST:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:param list_index: No help available
-			:return: power_current_min: No help available"""
+			:param list_index: integer Index of the segment
+			:return: power_maximum_max: No help available"""
 		param = Conversions.decimal_value_to_str(list_index)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:LIST:MINimum:CURRent? {param}', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:LIST:PEAK:MAXimum? {param}', suppressed)
 		return response
 
 	def read(self, list_index: int) -> List[float]:
-		"""SCPI: READ:GPRF:MEASurement<Instance>:POWer:LIST:MINimum:CURRent \n
-		Snippet: value: List[float] = driver.power.listPy.minimum.current.read(list_index = 1) \n
-		Returns power results in list mode, see 'List Mode: Diagram View'.
-			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:LIST:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)
-		The values described below are returned by FETCh and READ commands. CALCulate commands return a single-value error code
-		for each result listed below. \n
+		"""SCPI: READ:GPRF:MEASurement<Instance>:POWer:LIST:PEAK:MAXimum \n
+		Snippet: value: List[float] = driver.power.listPy.peak.maximum.read(list_index = 1) \n
+		Returns power results for segment <ListIndex>, see 'Results in list mode'.
+			INTRO_CMD_HELP: The following powers can be retrieved: \n
+			- 'Current RMS' (...:LIST:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:param list_index: No help available
-			:return: power_current_min: No help available"""
+			:param list_index: integer Index of the segment
+			:return: power_maximum_max: No help available"""
 		param = Conversions.decimal_value_to_str(list_index)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:POWer:LIST:MINimum:CURRent? {param}', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:POWer:LIST:PEAK:MAXimum? {param}', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ListPy_/Peak.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Maximum/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,35 +1,35 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Peak:
-	"""Peak commands group definition. 6 total commands, 2 Sub-groups, 0 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 5 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("peak", core, parent)
-
-	@property
-	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_minimum'):
-			from .Peak_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	@property
 	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 3 commands."""
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Peak_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
-	def clone(self) -> 'Peak':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	@property
+	def current(self):
+		"""current commands group. 0 Sub-classes, 3 commands."""
+		if not hasattr(self, '_current'):
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
+		return self._current
+
+	def clone(self) -> 'MaximumCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Peak(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MaximumCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ListPy_/Peak_/Maximum.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/ListPy/Peak/Minimum.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,79 +1,84 @@
 from typing import List
 
 from .....Internal.Core import Core
 from .....Internal.CommandsGroup import CommandsGroup
 from .....Internal import Conversions
 from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from .....Internal.Types import DataType
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
-	def calculate(self, list_index: int) -> List[float]:
-		"""SCPI: CALCulate:GPRF:MEASurement<Instance>:POWer:LIST:PEAK:MAXimum \n
-		Snippet: value: List[float] = driver.power.listPy.peak.maximum.calculate(list_index = 1) \n
-		Returns power results in list mode, see 'List Mode: Diagram View'.
-			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:LIST:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)
-		The values described below are returned by FETCh and READ commands. CALCulate commands return a single-value error code
-		for each result listed below. \n
+	# noinspection PyTypeChecker
+	def calculate(self, list_index: int) -> List[enums.ResultStatus2]:
+		"""SCPI: CALCulate:GPRF:MEASurement<Instance>:POWer:LIST:PEAK:MINimum \n
+		Snippet: value: List[enums.ResultStatus2] = driver.power.listPy.peak.minimum.calculate(list_index = 1) \n
+		Returns power results for segment <ListIndex>, see 'Results in list mode'.
+			INTRO_CMD_HELP: The following powers can be retrieved: \n
+			- 'Current RMS' (...:LIST:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:param list_index: No help available
-			:return: power_maximum_max: No help available"""
+			:param list_index: integer Index of the segment
+			:return: power_minimum_min: No help available"""
 		param = Conversions.decimal_value_to_str(list_index)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:GPRF:MEASurement<Instance>:POWer:LIST:PEAK:MAXimum? {param}', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:GPRF:MEASurement<Instance>:POWer:LIST:PEAK:MINimum? {param}', suppressed)
+		return Conversions.str_to_list_enum(response, enums.ResultStatus2)
 
 	def fetch(self, list_index: int) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:LIST:PEAK:MAXimum \n
-		Snippet: value: List[float] = driver.power.listPy.peak.maximum.fetch(list_index = 1) \n
-		Returns power results in list mode, see 'List Mode: Diagram View'.
-			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:LIST:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)
-		The values described below are returned by FETCh and READ commands. CALCulate commands return a single-value error code
-		for each result listed below. \n
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:LIST:PEAK:MINimum \n
+		Snippet: value: List[float] = driver.power.listPy.peak.minimum.fetch(list_index = 1) \n
+		Returns power results for segment <ListIndex>, see 'Results in list mode'.
+			INTRO_CMD_HELP: The following powers can be retrieved: \n
+			- 'Current RMS' (...:LIST:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:param list_index: No help available
-			:return: power_maximum_max: No help available"""
+			:param list_index: integer Index of the segment
+			:return: power_minimum_min: No help available"""
 		param = Conversions.decimal_value_to_str(list_index)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:LIST:PEAK:MAXimum? {param}', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:LIST:PEAK:MINimum? {param}', suppressed)
 		return response
 
 	def read(self, list_index: int) -> List[float]:
-		"""SCPI: READ:GPRF:MEASurement<Instance>:POWer:LIST:PEAK:MAXimum \n
-		Snippet: value: List[float] = driver.power.listPy.peak.maximum.read(list_index = 1) \n
-		Returns power results in list mode, see 'List Mode: Diagram View'.
-			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:LIST:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)
-		The values described below are returned by FETCh and READ commands. CALCulate commands return a single-value error code
-		for each result listed below. \n
+		"""SCPI: READ:GPRF:MEASurement<Instance>:POWer:LIST:PEAK:MINimum \n
+		Snippet: value: List[float] = driver.power.listPy.peak.minimum.read(list_index = 1) \n
+		Returns power results for segment <ListIndex>, see 'Results in list mode'.
+			INTRO_CMD_HELP: The following powers can be retrieved: \n
+			- 'Current RMS' (...:LIST:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:param list_index: No help available
-			:return: power_maximum_max: No help available"""
+			:param list_index: integer Index of the segment
+			:return: power_minimum_min: No help available"""
 		param = Conversions.decimal_value_to_str(list_index)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:POWer:LIST:PEAK:MAXimum? {param}', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:POWer:LIST:PEAK:MINimum? {param}', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ListPy_/Peak_/Minimum.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Peak/Maximum.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,79 +1,78 @@
 from typing import List
 
-from .....Internal.Core import Core
-from .....Internal.CommandsGroup import CommandsGroup
-from .....Internal import Conversions
-from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from .....Internal.Types import DataType
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ....Internal.Types import DataType
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
-	def calculate(self, list_index: int) -> List[float]:
-		"""SCPI: CALCulate:GPRF:MEASurement<Instance>:POWer:LIST:PEAK:MINimum \n
-		Snippet: value: List[float] = driver.power.listPy.peak.minimum.calculate(list_index = 1) \n
-		Returns power results in list mode, see 'List Mode: Diagram View'.
+	# noinspection PyTypeChecker
+	def calculate(self) -> List[enums.ResultStatus2]:
+		"""SCPI: CALCulate:GPRF:MEASurement<Instance>:POWer:PEAK:MAXimum \n
+		Snippet: value: List[enums.ResultStatus2] = driver.power.peak.maximum.calculate() \n
+		Returns power results for all segments, see 'Results in list mode'.
 			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:LIST:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)
-		The values described below are returned by FETCh and READ commands. CALCulate commands return a single-value error code
-		for each result listed below. \n
+			- 'Current RMS' (...:POWer:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:param list_index: No help available
-			:return: power_minimum_min: No help available"""
-		param = Conversions.decimal_value_to_str(list_index)
+			:return: power_maximum_max: float Comma-separated list of power values, one value per measured segment Unit: dBm (SDEViation: dB)"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:GPRF:MEASurement<Instance>:POWer:LIST:PEAK:MINimum? {param}', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:GPRF:MEASurement<Instance>:POWer:PEAK:MAXimum?', suppressed)
+		return Conversions.str_to_list_enum(response, enums.ResultStatus2)
 
-	def fetch(self, list_index: int) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:LIST:PEAK:MINimum \n
-		Snippet: value: List[float] = driver.power.listPy.peak.minimum.fetch(list_index = 1) \n
-		Returns power results in list mode, see 'List Mode: Diagram View'.
+	def fetch(self) -> List[float]:
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:PEAK:MAXimum \n
+		Snippet: value: List[float] = driver.power.peak.maximum.fetch() \n
+		Returns power results for all segments, see 'Results in list mode'.
 			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:LIST:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)
-		The values described below are returned by FETCh and READ commands. CALCulate commands return a single-value error code
-		for each result listed below. \n
+			- 'Current RMS' (...:POWer:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:param list_index: No help available
-			:return: power_minimum_min: No help available"""
-		param = Conversions.decimal_value_to_str(list_index)
+			:return: power_maximum_max: float Comma-separated list of power values, one value per measured segment Unit: dBm (SDEViation: dB)"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:LIST:PEAK:MINimum? {param}', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:PEAK:MAXimum?', suppressed)
 		return response
 
-	def read(self, list_index: int) -> List[float]:
-		"""SCPI: READ:GPRF:MEASurement<Instance>:POWer:LIST:PEAK:MINimum \n
-		Snippet: value: List[float] = driver.power.listPy.peak.minimum.read(list_index = 1) \n
-		Returns power results in list mode, see 'List Mode: Diagram View'.
+	def read(self) -> List[float]:
+		"""SCPI: READ:GPRF:MEASurement<Instance>:POWer:PEAK:MAXimum \n
+		Snippet: value: List[float] = driver.power.peak.maximum.read() \n
+		Returns power results for all segments, see 'Results in list mode'.
 			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:LIST:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)
-		The values described below are returned by FETCh and READ commands. CALCulate commands return a single-value error code
-		for each result listed below. \n
+			- 'Current RMS' (...:POWer:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:param list_index: No help available
-			:return: power_minimum_min: No help available"""
-		param = Conversions.decimal_value_to_str(list_index)
+			:return: power_maximum_max: float Comma-separated list of power values, one value per measured segment Unit: dBm (SDEViation: dB)"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:POWer:LIST:PEAK:MINimum? {param}', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:POWer:PEAK:MAXimum?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/ListPy_/StandardDev.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/ListPy/Minimum/Current.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,79 +1,84 @@
 from typing import List
 
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
-from ....Internal.Types import DataType
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
+from .....Internal import Conversions
+from .....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from .....Internal.Types import DataType
+from ..... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class StandardDev:
-	"""StandardDev commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("standardDev", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
-	def calculate(self, list_index: int) -> List[float]:
-		"""SCPI: CALCulate:GPRF:MEASurement<Instance>:POWer:LIST:SDEViation \n
-		Snippet: value: List[float] = driver.power.listPy.standardDev.calculate(list_index = 1) \n
-		Returns power results in list mode, see 'List Mode: Diagram View'.
-			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:LIST:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)
-		The values described below are returned by FETCh and READ commands. CALCulate commands return a single-value error code
-		for each result listed below. \n
+	# noinspection PyTypeChecker
+	def calculate(self, list_index: int) -> List[enums.ResultStatus2]:
+		"""SCPI: CALCulate:GPRF:MEASurement<Instance>:POWer:LIST:MINimum:CURRent \n
+		Snippet: value: List[enums.ResultStatus2] = driver.power.listPy.minimum.current.calculate(list_index = 1) \n
+		Returns power results for segment <ListIndex>, see 'Results in list mode'.
+			INTRO_CMD_HELP: The following powers can be retrieved: \n
+			- 'Current RMS' (...:LIST:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:param list_index: No help available
-			:return: power_std_dev_cur: No help available"""
+			:param list_index: integer Index of the segment
+			:return: power_current_min: No help available"""
 		param = Conversions.decimal_value_to_str(list_index)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:GPRF:MEASurement<Instance>:POWer:LIST:SDEViation? {param}', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:GPRF:MEASurement<Instance>:POWer:LIST:MINimum:CURRent? {param}', suppressed)
+		return Conversions.str_to_list_enum(response, enums.ResultStatus2)
 
 	def fetch(self, list_index: int) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:LIST:SDEViation \n
-		Snippet: value: List[float] = driver.power.listPy.standardDev.fetch(list_index = 1) \n
-		Returns power results in list mode, see 'List Mode: Diagram View'.
-			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:LIST:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)
-		The values described below are returned by FETCh and READ commands. CALCulate commands return a single-value error code
-		for each result listed below. \n
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:LIST:MINimum:CURRent \n
+		Snippet: value: List[float] = driver.power.listPy.minimum.current.fetch(list_index = 1) \n
+		Returns power results for segment <ListIndex>, see 'Results in list mode'.
+			INTRO_CMD_HELP: The following powers can be retrieved: \n
+			- 'Current RMS' (...:LIST:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:param list_index: No help available
-			:return: power_std_dev_cur: No help available"""
+			:param list_index: integer Index of the segment
+			:return: power_current_min: No help available"""
 		param = Conversions.decimal_value_to_str(list_index)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:LIST:SDEViation? {param}', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:LIST:MINimum:CURRent? {param}', suppressed)
 		return response
 
 	def read(self, list_index: int) -> List[float]:
-		"""SCPI: READ:GPRF:MEASurement<Instance>:POWer:LIST:SDEViation \n
-		Snippet: value: List[float] = driver.power.listPy.standardDev.read(list_index = 1) \n
-		Returns power results in list mode, see 'List Mode: Diagram View'.
-			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:LIST:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)
-		The values described below are returned by FETCh and READ commands. CALCulate commands return a single-value error code
-		for each result listed below. \n
+		"""SCPI: READ:GPRF:MEASurement<Instance>:POWer:LIST:MINimum:CURRent \n
+		Snippet: value: List[float] = driver.power.listPy.minimum.current.read(list_index = 1) \n
+		Returns power results for segment <ListIndex>, see 'Results in list mode'.
+			INTRO_CMD_HELP: The following powers can be retrieved: \n
+			- 'Current RMS' (...:LIST:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:param list_index: No help available
-			:return: power_std_dev_cur: No help available"""
+			:param list_index: integer Index of the segment
+			:return: power_current_min: No help available"""
 		param = Conversions.decimal_value_to_str(list_index)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:POWer:LIST:SDEViation? {param}', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:POWer:LIST:MINimum:CURRent? {param}', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Maximum.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Minimum/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 5 total commands, 2 Sub-groups, 0 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 5 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	@property
-	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_maximum'):
-			from .Maximum_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
+	def minimum(self):
+		"""minimum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_minimum'):
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
+		return self._minimum
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .Maximum_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
-	def clone(self) -> 'Maximum':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MinimumCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Maximum(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MinimumCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Maximum_/Current.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Peak/Minimum.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,66 +1,78 @@
 from typing import List
 
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:GPRF:MEASurement<Instance>:POWer:MAXimum:CURRent \n
-		Snippet: value: List[float] = driver.power.maximum.current.calculate() \n
-		Returns RF power results, see 'Measurement Results'.
+	# noinspection PyTypeChecker
+	def calculate(self) -> List[enums.ResultStatus2]:
+		"""SCPI: CALCulate:GPRF:MEASurement<Instance>:POWer:PEAK:MINimum \n
+		Snippet: value: List[enums.ResultStatus2] = driver.power.peak.minimum.calculate() \n
+		Returns power results for all segments, see 'Results in list mode'.
 			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:POWer:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)  \n
+			- 'Current RMS' (...:POWer:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_current_max: If list mode is switched off, a single value is returned. In list mode, n is equal to the step count (method RsCmwGprfMeas.Configure.Power.ListPy.count) . CALCulate commands return error indicators for each measured power step. FETCh/READ commands return RF power values for each measured power step. Range: -100 dBm to 57 dBm, Unit: dBm"""
+			:return: power_minimum_min: float Comma-separated list of power values, one value per measured segment Unit: dBm (SDEViation: dB)"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:GPRF:MEASurement<Instance>:POWer:MAXimum:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:GPRF:MEASurement<Instance>:POWer:PEAK:MINimum?', suppressed)
+		return Conversions.str_to_list_enum(response, enums.ResultStatus2)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:MAXimum:CURRent \n
-		Snippet: value: List[float] = driver.power.maximum.current.fetch() \n
-		Returns RF power results, see 'Measurement Results'.
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:PEAK:MINimum \n
+		Snippet: value: List[float] = driver.power.peak.minimum.fetch() \n
+		Returns power results for all segments, see 'Results in list mode'.
 			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:POWer:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)  \n
+			- 'Current RMS' (...:POWer:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_current_max: If list mode is switched off, a single value is returned. In list mode, n is equal to the step count (method RsCmwGprfMeas.Configure.Power.ListPy.count) . CALCulate commands return error indicators for each measured power step. FETCh/READ commands return RF power values for each measured power step. Range: -100 dBm to 57 dBm, Unit: dBm"""
+			:return: power_minimum_min: float Comma-separated list of power values, one value per measured segment Unit: dBm (SDEViation: dB)"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:MAXimum:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:PEAK:MINimum?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:GPRF:MEASurement<Instance>:POWer:MAXimum:CURRent \n
-		Snippet: value: List[float] = driver.power.maximum.current.read() \n
-		Returns RF power results, see 'Measurement Results'.
+		"""SCPI: READ:GPRF:MEASurement<Instance>:POWer:PEAK:MINimum \n
+		Snippet: value: List[float] = driver.power.peak.minimum.read() \n
+		Returns power results for all segments, see 'Results in list mode'.
 			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:POWer:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)  \n
+			- 'Current RMS' (...:POWer:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_current_max: If list mode is switched off, a single value is returned. In list mode, n is equal to the step count (method RsCmwGprfMeas.Configure.Power.ListPy.count) . CALCulate commands return error indicators for each measured power step. FETCh/READ commands return RF power values for each measured power step. Range: -100 dBm to 57 dBm, Unit: dBm"""
+			:return: power_minimum_min: float Comma-separated list of power values, one value per measured segment Unit: dBm (SDEViation: dB)"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:POWer:MAXimum:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:POWer:PEAK:MINimum?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Maximum_/Maximum.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/Maximum/Maximum.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:MAXimum:MAXimum \n
 		Snippet: value: List[float] = driver.power.maximum.maximum.fetch() \n
 		No command help available \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
 			:return: power_maximum_max: No help available"""
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Minimum.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/ListPy/Minimum/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,35 +1,27 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 5 total commands, 2 Sub-groups, 0 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 3 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
-
-	@property
-	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_minimum'):
-			from .Minimum_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 3 commands."""
 		if not hasattr(self, '_current'):
-			from .Minimum_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
-	def clone(self) -> 'Minimum':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MinimumCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Minimum(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MinimumCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Minimum_/Current.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/StandardDev/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,66 +1,94 @@
 from typing import List
 
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class StandardDevCls:
+	"""StandardDev commands group definition. 5 total commands, 1 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("standardDev", core, parent)
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:GPRF:MEASurement<Instance>:POWer:MINimum:CURRent \n
-		Snippet: value: List[float] = driver.power.minimum.current.calculate() \n
-		Returns RF power results, see 'Measurement Results'.
+	@property
+	def current(self):
+		"""current commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_current'):
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
+		return self._current
+
+	# noinspection PyTypeChecker
+	def calculate(self) -> List[enums.ResultStatus2]:
+		"""SCPI: CALCulate:GPRF:MEASurement<Instance>:POWer:SDEViation \n
+		Snippet: value: List[enums.ResultStatus2] = driver.power.standardDev.calculate() \n
+		Returns power results for all segments, see 'Results in list mode'.
 			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:POWer:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)  \n
+			- 'Current RMS' (...:POWer:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_current_min: If list mode is switched off, a single value is returned. In list mode, n is equal to the step count (method RsCmwGprfMeas.Configure.Power.ListPy.count) . CALCulate commands return error indicators for each measured power step. FETCh/READ commands return RF power values for each measured power step. Range: -100 dBm to 57 dBm, Unit: dBm"""
+			:return: power_std_dev_cur: float Comma-separated list of power values, one value per measured segment Unit: dBm (SDEViation: dB)"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:GPRF:MEASurement<Instance>:POWer:MINimum:CURRent?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:GPRF:MEASurement<Instance>:POWer:SDEViation?', suppressed)
+		return Conversions.str_to_list_enum(response, enums.ResultStatus2)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:MINimum:CURRent \n
-		Snippet: value: List[float] = driver.power.minimum.current.fetch() \n
-		Returns RF power results, see 'Measurement Results'.
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:SDEViation \n
+		Snippet: value: List[float] = driver.power.standardDev.fetch() \n
+		Returns power results for all segments, see 'Results in list mode'.
 			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:POWer:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)  \n
+			- 'Current RMS' (...:POWer:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_current_min: If list mode is switched off, a single value is returned. In list mode, n is equal to the step count (method RsCmwGprfMeas.Configure.Power.ListPy.count) . CALCulate commands return error indicators for each measured power step. FETCh/READ commands return RF power values for each measured power step. Range: -100 dBm to 57 dBm, Unit: dBm"""
+			:return: power_std_dev_cur: float Comma-separated list of power values, one value per measured segment Unit: dBm (SDEViation: dB)"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:MINimum:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:SDEViation?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:GPRF:MEASurement<Instance>:POWer:MINimum:CURRent \n
-		Snippet: value: List[float] = driver.power.minimum.current.read() \n
-		Returns RF power results, see 'Measurement Results'.
+		"""SCPI: READ:GPRF:MEASurement<Instance>:POWer:SDEViation \n
+		Snippet: value: List[float] = driver.power.standardDev.read() \n
+		Returns power results for all segments, see 'Results in list mode'.
 			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:POWer:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)  \n
+			- 'Current RMS' (...:POWer:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_current_min: If list mode is switched off, a single value is returned. In list mode, n is equal to the step count (method RsCmwGprfMeas.Configure.Power.ListPy.count) . CALCulate commands return error indicators for each measured power step. FETCh/READ commands return RF power values for each measured power step. Range: -100 dBm to 57 dBm, Unit: dBm"""
+			:return: power_std_dev_cur: float Comma-separated list of power values, one value per measured segment Unit: dBm (SDEViation: dB)"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:POWer:MINimum:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:POWer:SDEViation?', suppressed)
 		return response
+
+	def clone(self) -> 'StandardDevCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
+		Also copies all the existing default Repeated Capabilities setting,
+		which you can change independently without affecting the original group"""
+		new_group = StandardDevCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
+		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Minimum_/Minimum.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Sample/Minimum.py`

 * *Files 22% similar despite different names*

```diff
@@ -3,33 +3,33 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:MINimum:MINimum \n
-		Snippet: value: List[float] = driver.power.minimum.minimum.fetch() \n
-		No command help available \n
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:SAMPle:MINimum \n
+		Snippet: value: List[float] = driver.spectrum.sample.minimum.fetch() \n
+		Returns the traces calculated with the sample detector. Current, average, maximum and minimum traces can be retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_minimum_min: No help available"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:MINimum:MINimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:SAMPle:MINimum?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:GPRF:MEASurement<Instance>:POWer:MINimum:MINimum \n
-		Snippet: value: List[float] = driver.power.minimum.minimum.read() \n
-		No command help available \n
+		"""SCPI: READ:GPRF:MEASurement<Instance>:SPECtrum:SAMPle:MINimum \n
+		Snippet: value: List[float] = driver.spectrum.sample.minimum.read() \n
+		Returns the traces calculated with the sample detector. Current, average, maximum and minimum traces can be retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_minimum_min: No help available"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:POWer:MINimum:MINimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:SPECtrum:SAMPle:MINimum?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Peak.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/ReferenceMarker/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Peak:
-	"""Peak commands group definition. 6 total commands, 2 Sub-groups, 0 group commands"""
+class ReferenceMarkerCls:
+	"""ReferenceMarker commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("peak", core, parent)
+		self._cmd_group = CommandsGroup("referenceMarker", core, parent)
 
 	@property
-	def minimum(self):
-		"""minimum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_minimum'):
-			from .Peak_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
-		return self._minimum
+	def speak(self):
+		"""speak commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_speak'):
+			from .Speak import SpeakCls
+			self._speak = SpeakCls(self._core, self._cmd_group)
+		return self._speak
 
 	@property
-	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 3 commands."""
-		if not hasattr(self, '_maximum'):
-			from .Peak_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
+	def npeak(self):
+		"""npeak commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_npeak'):
+			from .Npeak import NpeakCls
+			self._npeak = NpeakCls(self._core, self._cmd_group)
+		return self._npeak
 
-	def clone(self) -> 'Peak':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ReferenceMarkerCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Peak(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ReferenceMarkerCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/Peak_/Maximum.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/ListPy/Current.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,66 +1,84 @@
 from typing import List
 
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 3 total commands, 0 Sub-groups, 3 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 3 total commands, 0 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
-	def calculate(self) -> List[float]:
-		"""SCPI: CALCulate:GPRF:MEASurement<Instance>:POWer:PEAK:MAXimum \n
-		Snippet: value: List[float] = driver.power.peak.maximum.calculate() \n
-		Returns RF power results, see 'Measurement Results'.
-			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:POWer:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)  \n
+	# noinspection PyTypeChecker
+	def calculate(self, list_index: int) -> List[enums.ResultStatus2]:
+		"""SCPI: CALCulate:GPRF:MEASurement<Instance>:POWer:LIST:CURRent \n
+		Snippet: value: List[enums.ResultStatus2] = driver.power.listPy.current.calculate(list_index = 1) \n
+		Returns power results for segment <ListIndex>, see 'Results in list mode'.
+			INTRO_CMD_HELP: The following powers can be retrieved: \n
+			- 'Current RMS' (...:LIST:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_maximum_max: If list mode is switched off, a single value is returned. In list mode, n is equal to the step count (method RsCmwGprfMeas.Configure.Power.ListPy.count) . CALCulate commands return error indicators for each measured power step. FETCh/READ commands return RF power values for each measured power step. Range: -100 dBm to 57 dBm, Unit: dBm"""
+			:param list_index: integer Index of the segment
+			:return: power_current_rms: No help available"""
+		param = Conversions.decimal_value_to_str(list_index)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'CALCulate:GPRF:MEASurement<Instance>:POWer:PEAK:MAXimum?', suppressed)
-		return response
+		response = self._core.io.query_str_suppressed(f'CALCulate:GPRF:MEASurement<Instance>:POWer:LIST:CURRent? {param}', suppressed)
+		return Conversions.str_to_list_enum(response, enums.ResultStatus2)
 
-	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:PEAK:MAXimum \n
-		Snippet: value: List[float] = driver.power.peak.maximum.fetch() \n
-		Returns RF power results, see 'Measurement Results'.
-			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:POWer:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)  \n
+	def fetch(self, list_index: int) -> List[float]:
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:LIST:CURRent \n
+		Snippet: value: List[float] = driver.power.listPy.current.fetch(list_index = 1) \n
+		Returns power results for segment <ListIndex>, see 'Results in list mode'.
+			INTRO_CMD_HELP: The following powers can be retrieved: \n
+			- 'Current RMS' (...:LIST:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_maximum_max: If list mode is switched off, a single value is returned. In list mode, n is equal to the step count (method RsCmwGprfMeas.Configure.Power.ListPy.count) . CALCulate commands return error indicators for each measured power step. FETCh/READ commands return RF power values for each measured power step. Range: -100 dBm to 57 dBm, Unit: dBm"""
+			:param list_index: integer Index of the segment
+			:return: power_current_rms: No help available"""
+		param = Conversions.decimal_value_to_str(list_index)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:PEAK:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:LIST:CURRent? {param}', suppressed)
 		return response
 
-	def read(self) -> List[float]:
-		"""SCPI: READ:GPRF:MEASurement<Instance>:POWer:PEAK:MAXimum \n
-		Snippet: value: List[float] = driver.power.peak.maximum.read() \n
-		Returns RF power results, see 'Measurement Results'.
-			INTRO_CMD_HELP: The following results can be retrieved: \n
-			- 'Power Current RMS' (...:POWer:CURRent?)
-			- 'Power Current Min.' (...:MINimum:CURRent?)
-			- 'Power Current Max.' (...:MAXimum:CURRent?)
-			- 'Power Average RMS' (...:AVERage?)
-			- 'Power Minimum' (...:PEAK:MINimum?)
-			- 'Power Maximum' (...:PEAK:MAXimum?)  \n
+	def read(self, list_index: int) -> List[float]:
+		"""SCPI: READ:GPRF:MEASurement<Instance>:POWer:LIST:CURRent \n
+		Snippet: value: List[float] = driver.power.listPy.current.read(list_index = 1) \n
+		Returns power results for segment <ListIndex>, see 'Results in list mode'.
+			INTRO_CMD_HELP: The following powers can be retrieved: \n
+			- 'Current RMS' (...:LIST:CURRent?)
+			- 'Current Min.' (...:MINimum:CURRent?)
+			- 'Current Max.' (...:MAXimum:CURRent?)
+			- 'Average RMS' (...:AVERage?)
+			- 'Minimum' (...:PEAK:MINimum?)
+			- 'Maximum' (...:PEAK:MAXimum?)
+			- 'Standard Deviation' (...:SDEViation?)
+		The values described below are returned by FETCh and READ commands. CALCulate commands return error codes instead, one
+		value for each result listed below. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_maximum_max: If list mode is switched off, a single value is returned. In list mode, n is equal to the step count (method RsCmwGprfMeas.Configure.Power.ListPy.count) . CALCulate commands return error indicators for each measured power step. FETCh/READ commands return RF power values for each measured power step. Range: -100 dBm to 57 dBm, Unit: dBm"""
+			:param list_index: integer Index of the segment
+			:return: power_current_rms: No help available"""
+		param = Conversions.decimal_value_to_str(list_index)
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:POWer:PEAK:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:POWer:LIST:CURRent? {param}', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/StandardDev_/Current.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Average/Minimum.py`

 * *Files 20% similar despite different names*

```diff
@@ -3,33 +3,33 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:SDEViation:CURRent \n
-		Snippet: value: List[float] = driver.power.standardDev.current.fetch() \n
-		No command help available \n
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:AVERage:MINimum \n
+		Snippet: value: List[float] = driver.spectrum.average.minimum.fetch() \n
+		Returns the traces calculated with the average detector. Current, average, maximum and minimum traces can be retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_std_dev_cur: No help available"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:SDEViation:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:AVERage:MINimum?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:GPRF:MEASurement<Instance>:POWer:SDEViation:CURRent \n
-		Snippet: value: List[float] = driver.power.standardDev.current.read() \n
-		No command help available \n
+		"""SCPI: READ:GPRF:MEASurement<Instance>:SPECtrum:AVERage:MINimum \n
+		Snippet: value: List[float] = driver.spectrum.average.minimum.read() \n
+		Returns the traces calculated with the average detector. Current, average, maximum and minimum traces can be retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power_std_dev_cur: No help available"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:POWer:SDEViation:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:SPECtrum:AVERage:MINimum?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Power_/State_/All.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Route/Scenario/Catalog.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,26 +1,24 @@
 from typing import List
 
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
-from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class All:
-	"""All commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CatalogCls:
+	"""Catalog commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("all", core, parent)
+		self._cmd_group = CommandsGroup("catalog", core, parent)
 
-	# noinspection PyTypeChecker
-	def fetch(self) -> List[enums.ResourceState]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:STATe:ALL \n
-		Snippet: value: List[enums.ResourceState] = driver.power.state.all.fetch() \n
-		Queries the main measurement state and the measurement substates. Both measurement substates are relevant for running
-		measurements only. Use FETCh:...:STATe? to query the main measurement state only. Use INITiate..., STOP..., ABORt...
-		to change the measurement state. \n
-			:return: meas_state: No help available"""
-		response = self._core.io.query_str(f'FETCh:GPRF:MEASurement<Instance>:POWer:STATe:ALL?')
-		return Conversions.str_to_list_enum(response, enums.ResourceState)
+	def get_cspath(self) -> List[str]:
+		"""SCPI: ROUTe:GPRF:MEASurement<Instance>:SCENario:CATalog:CSPath \n
+		Snippet: value: List[str] = driver.route.scenario.catalog.get_cspath() \n
+		Queries the possible controlling firmware applications for a combined signal path scenario. The returned list contains
+		all installed signaling applications. \n
+			:return: csp_masters: string Comma-separated list of string parameters For example 'LTE Sig1', 'GSM Sig2' 'No Connection' means that no signaling application is installed.
+		"""
+		response = self._core.io.query_str('ROUTe:GPRF:MEASurement<Instance>:SCENario:CATalog:CSPath?')
+		return Conversions.str_to_str_list(response)
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Route.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Route/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ..Internal.Core import Core
-from ..Internal.CommandsGroup import CommandsGroup
-from ..Internal.StructBase import StructBase
-from ..Internal.ArgStruct import ArgStruct
-from .. import enums
+from ...Internal.Core import Core
+from ...Internal.CommandsGroup import CommandsGroup
+from ...Internal.StructBase import StructBase
+from ...Internal.ArgStruct import ArgStruct
+from ... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Route:
-	"""Route commands group definition. 7 total commands, 1 Sub-groups, 1 group commands"""
+class RouteCls:
+	"""Route commands group definition. 7 total commands, 1 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("route", core, parent)
+		self._cmd_group = CommandsGroup("route", core, parent)
 
 	@property
 	def scenario(self):
-		"""scenario commands group. 2 Sub-classes, 4 commands."""
+		"""scenario commands group. 4 Sub-classes, 2 commands."""
 		if not hasattr(self, '_scenario'):
-			from .Route_.Scenario import Scenario
-			self._scenario = Scenario(self._core, self._base)
+			from .Scenario import ScenarioCls
+			self._scenario = ScenarioCls(self._core, self._cmd_group)
 		return self._scenario
 
 	# noinspection PyTypeChecker
-	class ValueStruct(StructBase):
+	class ValueStruct(StructBase):  # From ReadStructDefinition CmdPropertyTemplate.xml
 		"""Structure for reading output parameters. Fields: \n
 			- Scenario: enums.Scenario: SALone | CSPath SALone: standalone (non-signaling) scenario CSPath: combined signal path scenario
-			- Master: str: Controlling application for scenario CSPath
+			- Master: str: string Controlling application for scenario CSPath
 			- Rf_Connector: enums.RfConnector: RF connector for the input path
 			- Rf_Converter: enums.RxConverter: RX module for the input path"""
 		__meta_args_list = [
 			ArgStruct.scalar_enum('Scenario', enums.Scenario),
 			ArgStruct.scalar_str('Master'),
 			ArgStruct.scalar_enum('Rf_Connector', enums.RfConnector),
 			ArgStruct.scalar_enum('Rf_Converter', enums.RxConverter)]
@@ -37,23 +37,22 @@
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Scenario: enums.Scenario = None
 			self.Master: str = None
 			self.Rf_Connector: enums.RfConnector = None
 			self.Rf_Converter: enums.RxConverter = None
 
-	# noinspection PyTypeChecker
 	def get_value(self) -> ValueStruct:
 		"""SCPI: ROUTe:GPRF:MEASurement<Instance> \n
 		Snippet: value: ValueStruct = driver.route.get_value() \n
-		Returns the configured routing settings. For possible connector and converter values, see 'Values for RF Path Selection'. \n
+		Returns the configured routing settings. For possible connector and converter values, see 'Values for RF path selection'. \n
 			:return: structure: for return value, see the help for ValueStruct structure arguments.
 		"""
 		return self._core.io.query_struct('ROUTe:GPRF:MEASurement<Instance>?', self.__class__.ValueStruct())
 
-	def clone(self) -> 'Route':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'RouteCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Route(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = RouteCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Route_/Scenario_/Catalog.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/Spectrum/Catalog.py`

 * *Files 27% similar despite different names*

```diff
@@ -2,23 +2,22 @@
 
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Catalog:
-	"""Catalog commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CatalogCls:
+	"""Catalog commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("catalog", core, parent)
+		self._cmd_group = CommandsGroup("catalog", core, parent)
 
-	def get_cspath(self) -> List[str]:
-		"""SCPI: ROUTe:GPRF:MEASurement<Instance>:SCENario:CATalog:CSPath \n
-		Snippet: value: List[str] = driver.route.scenario.catalog.get_cspath() \n
-		Queries the possible master firmware applications for a combined signal path scenario. The returned list contains all
-		installed signaling applications. \n
-			:return: csp_masters: Comma-separated list of string parameters For example '1xEV-DO Sig1', 'GSM Sig2' 'No Connection' means that no signaling application is installed.
+	def get_source(self) -> List[str]:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:SPECtrum:CATalog:SOURce \n
+		Snippet: value: List[str] = driver.trigger.spectrum.catalog.get_source() \n
+		Lists all trigger source values that can be set using method RsCmwGprfMeas.Trigger.Spectrum.source. \n
+			:return: trigger_sources: string Comma-separated list of all supported values. Each value is represented as a string.
 		"""
-		response = self._core.io.query_str('ROUTe:GPRF:MEASurement<Instance>:SCENario:CATalog:CSPath?')
+		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:SPECtrum:CATalog:SOURce?')
 		return Conversions.str_to_str_list(response)
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Route_/Scenario_/MaProtocol.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Route/Scenario/MaProtocol.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,23 +3,23 @@
 from ....Internal.Types import DataType
 from ....Internal.ArgSingleList import ArgSingleList
 from ....Internal.ArgSingle import ArgSingle
 from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class MaProtocol:
-	"""MaProtocol commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class MaProtocolCls:
+	"""MaProtocol commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maProtocol", core, parent)
+		self._cmd_group = CommandsGroup("maProtocol", core, parent)
 
 	def set(self, controler: str = None, converter: enums.RxConverter = None) -> None:
 		"""SCPI: ROUTe:GPRF:MEASurement<Instance>:SCENario:MAPRotocol \n
-		Snippet: driver.route.scenario.maProtocol.set(controler = '1', converter = enums.RxConverter.IRX1) \n
+		Snippet: driver.route.scenario.maProtocol.set(controler = 'abc', converter = enums.RxConverter.IRX1) \n
 		No command help available \n
 			:param controler: No help available
 			:param converter: No help available
 		"""
-		param = ArgSingleList().compose_cmd_string(ArgSingle('controler', controler, DataType.String, True), ArgSingle('converter', converter, DataType.Enum, True))
+		param = ArgSingleList().compose_cmd_string(ArgSingle('controler', controler, DataType.String, None, is_optional=True), ArgSingle('converter', converter, DataType.Enum, enums.RxConverter, is_optional=True))
 		self._core.io.write(f'ROUTe:GPRF:MEASurement<Instance>:SCENario:MAPRotocol {param}'.rstrip())
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,152 +1,116 @@
-from ..Internal.Core import Core
-from ..Internal.CommandsGroup import CommandsGroup
+from ...Internal.Core import Core
+from ...Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Spectrum:
-	"""Spectrum commands group definition. 48 total commands, 8 Sub-groups, 3 group commands"""
+class SpectrumCls:
+	"""Spectrum commands group definition. 48 total commands, 8 Subgroups, 3 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("spectrum", core, parent)
+		self._cmd_group = CommandsGroup("spectrum", core, parent)
 
 	@property
 	def state(self):
 		"""state commands group. 1 Sub-classes, 1 commands."""
 		if not hasattr(self, '_state'):
-			from .Spectrum_.State import State
-			self._state = State(self._core, self._base)
+			from .State import StateCls
+			self._state = StateCls(self._core, self._cmd_group)
 		return self._state
 
 	@property
 	def referenceMarker(self):
 		"""referenceMarker commands group. 2 Sub-classes, 0 commands."""
 		if not hasattr(self, '_referenceMarker'):
-			from .Spectrum_.ReferenceMarker import ReferenceMarker
-			self._referenceMarker = ReferenceMarker(self._core, self._base)
+			from .ReferenceMarker import ReferenceMarkerCls
+			self._referenceMarker = ReferenceMarkerCls(self._core, self._cmd_group)
 		return self._referenceMarker
 
 	@property
 	def marker(self):
 		"""marker commands group. 1 Sub-classes, 0 commands."""
 		if not hasattr(self, '_marker'):
-			from .Spectrum_.Marker import Marker
-			self._marker = Marker(self._core, self._base)
+			from .Marker import MarkerCls
+			self._marker = MarkerCls(self._core, self._cmd_group)
 		return self._marker
 
 	@property
 	def sample(self):
 		"""sample commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_sample'):
-			from .Spectrum_.Sample import Sample
-			self._sample = Sample(self._core, self._base)
+			from .Sample import SampleCls
+			self._sample = SampleCls(self._core, self._cmd_group)
 		return self._sample
 
 	@property
 	def rms(self):
 		"""rms commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_rms'):
-			from .Spectrum_.Rms import Rms
-			self._rms = Rms(self._core, self._base)
+			from .Rms import RmsCls
+			self._rms = RmsCls(self._core, self._cmd_group)
 		return self._rms
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Spectrum_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
 	@property
 	def minimum(self):
 		"""minimum commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Spectrum_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	@property
 	def average(self):
 		"""average commands group. 4 Sub-classes, 0 commands."""
 		if not hasattr(self, '_average'):
-			from .Spectrum_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
-	def initiate(self) -> None:
+	def initiate(self, opc_timeout_ms: int = -1) -> None:
 		"""SCPI: INITiate:GPRF:MEASurement<Instance>:SPECtrum \n
 		Snippet: driver.spectrum.initiate() \n
 			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
 			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
 			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
 			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
-		"""
-		self._core.io.write(f'INITiate:GPRF:MEASurement<Instance>:SPECtrum')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'INITiate:GPRF:MEASurement<Instance>:SPECtrum', opc_timeout_ms)
 
-	def initiate_with_opc(self) -> None:
-		"""SCPI: INITiate:GPRF:MEASurement<Instance>:SPECtrum \n
-		Snippet: driver.spectrum.initiate_with_opc() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
-		Use FETCh...STATe? to query the current measurement state. \n
-		Same as initiate, but waits for the operation to complete before continuing further. Use the RsCmwGprfMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'INITiate:GPRF:MEASurement<Instance>:SPECtrum')
-
-	def stop(self) -> None:
+	def stop(self, opc_timeout_ms: int = -1) -> None:
 		"""SCPI: STOP:GPRF:MEASurement<Instance>:SPECtrum \n
 		Snippet: driver.spectrum.stop() \n
 			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
 			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
 			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
 			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
-		"""
-		self._core.io.write(f'STOP:GPRF:MEASurement<Instance>:SPECtrum')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'STOP:GPRF:MEASurement<Instance>:SPECtrum', opc_timeout_ms)
 
-	def stop_with_opc(self) -> None:
-		"""SCPI: STOP:GPRF:MEASurement<Instance>:SPECtrum \n
-		Snippet: driver.spectrum.stop_with_opc() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
-		Use FETCh...STATe? to query the current measurement state. \n
-		Same as stop, but waits for the operation to complete before continuing further. Use the RsCmwGprfMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'STOP:GPRF:MEASurement<Instance>:SPECtrum')
-
-	def abort(self) -> None:
+	def abort(self, opc_timeout_ms: int = -1) -> None:
 		"""SCPI: ABORt:GPRF:MEASurement<Instance>:SPECtrum \n
 		Snippet: driver.spectrum.abort() \n
 			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
 			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
 			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
 			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
 		Use FETCh...STATe? to query the current measurement state. \n
-		"""
-		self._core.io.write(f'ABORt:GPRF:MEASurement<Instance>:SPECtrum')
-
-	def abort_with_opc(self) -> None:
-		"""SCPI: ABORt:GPRF:MEASurement<Instance>:SPECtrum \n
-		Snippet: driver.spectrum.abort_with_opc() \n
-			INTRO_CMD_HELP: Starts, stops, or aborts the measurement: \n
-			- INITiate... starts or restarts the measurement. The measurement enters the 'RUN' state.
-			- STOP... halts the measurement immediately. The measurement enters the 'RDY' state. Measurement results are kept. The resources remain allocated to the measurement.
-			- ABORt... halts the measurement immediately. The measurement enters the 'OFF' state. All measurement values are set to NAV. Allocated resources are released.
-		Use FETCh...STATe? to query the current measurement state. \n
-		Same as abort, but waits for the operation to complete before continuing further. Use the RsCmwGprfMeas.utilities.opc_timeout_set() to set the timeout value. \n
-		"""
-		self._core.io.write_with_opc(f'ABORt:GPRF:MEASurement<Instance>:SPECtrum')
+			:param opc_timeout_ms: Maximum time to wait in milliseconds, valid only for this call."""
+		self._core.io.write_with_opc(f'ABORt:GPRF:MEASurement<Instance>:SPECtrum', opc_timeout_ms)
 
-	def clone(self) -> 'Spectrum':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SpectrumCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Spectrum(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SpectrumCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Average.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Average/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 8 total commands, 4 Sub-groups, 0 group commands"""
+class AverageCls:
+	"""Average commands group definition. 8 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	@property
 	def minimum(self):
 		"""minimum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Average_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Average_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Average_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Average_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
-	def clone(self) -> 'Average':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'AverageCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Average(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = AverageCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Average_/Average.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Average/Average.py`

 * *Files 16% similar despite different names*

```diff
@@ -3,35 +3,33 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:AVERage:AVERage \n
 		Snippet: value: List[float] = driver.spectrum.average.average.fetch() \n
-		Returns the traces calculated with the average detector. Current, average, maximum and minimum traces can be retrieved.
-		The averaging mode is defined via method RsCmwGprfMeas.Configure.Spectrum.amode. \n
+		Returns the traces calculated with the average detector. Current, average, maximum and minimum traces can be retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 1001 values Range: -150 dBm to 50 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:AVERage:AVERage?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:GPRF:MEASurement<Instance>:SPECtrum:AVERage:AVERage \n
 		Snippet: value: List[float] = driver.spectrum.average.average.read() \n
-		Returns the traces calculated with the average detector. Current, average, maximum and minimum traces can be retrieved.
-		The averaging mode is defined via method RsCmwGprfMeas.Configure.Spectrum.amode. \n
+		Returns the traces calculated with the average detector. Current, average, maximum and minimum traces can be retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 1001 values Range: -150 dBm to 50 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:SPECtrum:AVERage:AVERage?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Average_/Minimum.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Maximum/Minimum.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,35 +3,35 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MinimumCls:
+	"""Minimum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("minimum", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:AVERage:MINimum \n
-		Snippet: value: List[float] = driver.spectrum.average.minimum.fetch() \n
-		Returns the traces calculated with the average detector. Current, average, maximum and minimum traces can be retrieved.
-		The averaging mode is defined via method RsCmwGprfMeas.Configure.Spectrum.amode. \n
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:MAXimum:MINimum \n
+		Snippet: value: List[float] = driver.spectrum.maximum.minimum.fetch() \n
+		Returns the traces calculated with the maximum peak detector. Current, average, maximum and minimum traces can be
+		retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 1001 values Range: -150 dBm to 50 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:AVERage:MINimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:MAXimum:MINimum?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:GPRF:MEASurement<Instance>:SPECtrum:AVERage:MINimum \n
-		Snippet: value: List[float] = driver.spectrum.average.minimum.read() \n
-		Returns the traces calculated with the average detector. Current, average, maximum and minimum traces can be retrieved.
-		The averaging mode is defined via method RsCmwGprfMeas.Configure.Spectrum.amode. \n
+		"""SCPI: READ:GPRF:MEASurement<Instance>:SPECtrum:MAXimum:MINimum \n
+		Snippet: value: List[float] = driver.spectrum.maximum.minimum.read() \n
+		Returns the traces calculated with the maximum peak detector. Current, average, maximum and minimum traces can be
+		retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 1001 values Range: -150 dBm to 50 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:SPECtrum:AVERage:MINimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:SPECtrum:MAXimum:MINimum?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Marker.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Marker/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal.RepeatedCapability import RepeatedCapability
-from ... import repcap
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal.RepeatedCapability import RepeatedCapability
+from .... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Marker:
-	"""Marker commands group definition. 1 total commands, 1 Sub-groups, 0 group commands
+class MarkerCls:
+	"""Marker commands group definition. 1 total commands, 1 Subgroups, 0 group commands
 	Repeated Capability: Marker, default value after init: Marker.Nr1"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("marker", core, parent)
-		self._base.rep_cap = RepeatedCapability(self._base.group_name, 'repcap_marker_get', 'repcap_marker_set', repcap.Marker.Nr1)
+		self._cmd_group = CommandsGroup("marker", core, parent)
+		self._cmd_group.rep_cap = RepeatedCapability(self._cmd_group.group_name, 'repcap_marker_get', 'repcap_marker_set', repcap.Marker.Nr1)
 
-	def repcap_marker_set(self, enum_value: repcap.Marker) -> None:
+	def repcap_marker_set(self, marker: repcap.Marker) -> None:
 		"""Repeated Capability default value numeric suffix.
 		This value is used, if you do not explicitely set it in the child set/get methods, or if you leave it to Marker.Default
 		Default value after init: Marker.Nr1"""
-		self._base.set_repcap_enum_value(enum_value)
+		self._cmd_group.set_repcap_enum_value(marker)
 
 	def repcap_marker_get(self) -> repcap.Marker:
 		"""Returns the current default repeated capability for the child set/get methods"""
 		# noinspection PyTypeChecker
-		return self._base.get_repcap_enum_value()
+		return self._cmd_group.get_repcap_enum_value()
 
 	@property
 	def npeak(self):
 		"""npeak commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_npeak'):
-			from .Marker_.Npeak import Npeak
-			self._npeak = Npeak(self._core, self._base)
+			from .Npeak import NpeakCls
+			self._npeak = NpeakCls(self._core, self._cmd_group)
 		return self._npeak
 
-	def clone(self) -> 'Marker':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MarkerCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Marker(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MarkerCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Marker_/Npeak.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/ReferenceMarker/Npeak.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,47 +2,44 @@
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.Types import DataType
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 from ....Internal.ArgSingleList import ArgSingleList
 from ....Internal.ArgSingle import ArgSingle
 from .... import enums
-from .... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Npeak:
-	"""Npeak commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class NpeakCls:
+	"""Npeak commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("npeak", core, parent)
+		self._cmd_group = CommandsGroup("npeak", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: See 'Reliability Indicator'
-			- Xvalue: float: X value
-			- Yvalue: float: Y value Unit: dBm"""
+			- Reliability: int: decimal See 'Reliability indicator'
+			- Xvalue: float: float X value
+			- Yvalue: float: float Y value Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Xvalue'),
 			ArgStruct.scalar_float('Yvalue')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Xvalue: float = None
 			self.Yvalue: float = None
 
-	def fetch(self, detector: enums.Detector, statistic: enums.Statistic, marker=repcap.Marker.Default) -> FetchStruct:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:MARKer<MarkerNo>:NPEak \n
-		Snippet: value: FetchStruct = driver.spectrum.marker.npeak.fetch(detector = enums.Detector.AUTopeak, statistic = enums.Statistic.AVERage, marker = repcap.Marker.Default) \n
-		Moves marker <MarkerNo> to the next lower (or equal) peak, relative to the current marker position. Returns the X and Y
-		value of the new marker position. The trace is selected by <Detector> and <Statistic>. \n
+	def fetch(self, detector: enums.Detector, statistic: enums.Statistic) -> FetchStruct:
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:REFMarker:NPEak \n
+		Snippet: value: FetchStruct = driver.spectrum.referenceMarker.npeak.fetch(detector = enums.Detector.AUTopeak, statistic = enums.Statistic.AVERage) \n
+		Moves the reference marker to the next lower (or equal) peak, relative to the current marker position. Returns the X and
+		Y value of the new marker position. The trace is selected by <Detector> and <Statistic>. \n
 			:param detector: AVERage | RMS | SAMPle | MINPeak | MAXPeak | AUTopeak Selects the detector type, see 'Detector hotkey'.
-			:param statistic: CURRent | AVERage | MAXimum | MINimum Trace type
-			:param marker: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Marker')
+			:param statistic: CURRent | AVERage | MAXimum | MINimum Selects the trace type.
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		param = ArgSingleList().compose_cmd_string(ArgSingle('detector', detector, DataType.Enum), ArgSingle('statistic', statistic, DataType.Enum))
-		marker_cmd_val = self._base.get_repcap_cmd_value(marker, repcap.Marker)
-		return self._core.io.query_struct(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:MARKer{marker_cmd_val}:NPEak? {param}'.rstrip(), self.__class__.FetchStruct())
+		param = ArgSingleList().compose_cmd_string(ArgSingle('detector', detector, DataType.Enum, enums.Detector), ArgSingle('statistic', statistic, DataType.Enum, enums.Statistic))
+		return self._core.io.query_struct(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:REFMarker:NPEak? {param}'.rstrip(), self.__class__.FetchStruct())
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Maximum_/Average.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Maximum/Average.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,35 +3,35 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:MAXimum:AVERage \n
 		Snippet: value: List[float] = driver.spectrum.maximum.average.fetch() \n
 		Returns the traces calculated with the maximum peak detector. Current, average, maximum and minimum traces can be
 		retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 1001 values Range: -150 dBm to 50 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:MAXimum:AVERage?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:GPRF:MEASurement<Instance>:SPECtrum:MAXimum:AVERage \n
 		Snippet: value: List[float] = driver.spectrum.maximum.average.read() \n
 		Returns the traces calculated with the maximum peak detector. Current, average, maximum and minimum traces can be
 		retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 1001 values Range: -150 dBm to 50 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:SPECtrum:MAXimum:AVERage?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Maximum_/Current.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Minimum/Maximum.py`

 * *Files 13% similar despite different names*

```diff
@@ -3,35 +3,35 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:MAXimum:CURRent \n
-		Snippet: value: List[float] = driver.spectrum.maximum.current.fetch() \n
-		Returns the traces calculated with the maximum peak detector. Current, average, maximum and minimum traces can be
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:MINimum:MAXimum \n
+		Snippet: value: List[float] = driver.spectrum.minimum.maximum.fetch() \n
+		Returns the traces calculated with the minimum peak detector. Current, average, maximum and minimum traces can be
 		retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 1001 values Range: -150 dBm to 50 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:MAXimum:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:MINimum:MAXimum?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:GPRF:MEASurement<Instance>:SPECtrum:MAXimum:CURRent \n
-		Snippet: value: List[float] = driver.spectrum.maximum.current.read() \n
-		Returns the traces calculated with the maximum peak detector. Current, average, maximum and minimum traces can be
+		"""SCPI: READ:GPRF:MEASurement<Instance>:SPECtrum:MINimum:MAXimum \n
+		Snippet: value: List[float] = driver.spectrum.minimum.maximum.read() \n
+		Returns the traces calculated with the minimum peak detector. Current, average, maximum and minimum traces can be
 		retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 1001 values Range: -150 dBm to 50 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:SPECtrum:MAXimum:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:SPECtrum:MINimum:MAXimum?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Maximum_/Maximum.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Maximum/Maximum.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,35 +3,35 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:MAXimum:MAXimum \n
 		Snippet: value: List[float] = driver.spectrum.maximum.maximum.fetch() \n
 		Returns the traces calculated with the maximum peak detector. Current, average, maximum and minimum traces can be
 		retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 1001 values Range: -150 dBm to 50 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:MAXimum:MAXimum?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:GPRF:MEASurement<Instance>:SPECtrum:MAXimum:MAXimum \n
 		Snippet: value: List[float] = driver.spectrum.maximum.maximum.read() \n
 		Returns the traces calculated with the maximum peak detector. Current, average, maximum and minimum traces can be
 		retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 1001 values Range: -150 dBm to 50 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:SPECtrum:MAXimum:MAXimum?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Maximum_/Minimum.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Rms/Maximum.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,35 +3,33 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:MAXimum:MINimum \n
-		Snippet: value: List[float] = driver.spectrum.maximum.minimum.fetch() \n
-		Returns the traces calculated with the maximum peak detector. Current, average, maximum and minimum traces can be
-		retrieved. \n
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:RMS:MAXimum \n
+		Snippet: value: List[float] = driver.spectrum.rms.maximum.fetch() \n
+		Returns the traces calculated with the RMS detector. Current, average, maximum and minimum traces can be retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 1001 values Range: -150 dBm to 50 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:MAXimum:MINimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:RMS:MAXimum?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:GPRF:MEASurement<Instance>:SPECtrum:MAXimum:MINimum \n
-		Snippet: value: List[float] = driver.spectrum.maximum.minimum.read() \n
-		Returns the traces calculated with the maximum peak detector. Current, average, maximum and minimum traces can be
-		retrieved. \n
+		"""SCPI: READ:GPRF:MEASurement<Instance>:SPECtrum:RMS:MAXimum \n
+		Snippet: value: List[float] = driver.spectrum.rms.maximum.read() \n
+		Returns the traces calculated with the RMS detector. Current, average, maximum and minimum traces can be retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 1001 values Range: -150 dBm to 50 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:SPECtrum:MAXimum:MINimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:SPECtrum:RMS:MAXimum?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Minimum.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Rms/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 8 total commands, 4 Sub-groups, 0 group commands"""
+class RmsCls:
+	"""Rms commands group definition. 8 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("rms", core, parent)
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Minimum_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
 	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Minimum_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def maximum(self):
 		"""maximum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_maximum'):
-			from .Minimum_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
 		return self._maximum
 
 	@property
 	def minimum(self):
 		"""minimum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Minimum_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
-	def clone(self) -> 'Minimum':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'RmsCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Minimum(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = RmsCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Minimum_/Average.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Minimum/Average.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,35 +3,35 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:MINimum:AVERage \n
 		Snippet: value: List[float] = driver.spectrum.minimum.average.fetch() \n
 		Returns the traces calculated with the minimum peak detector. Current, average, maximum and minimum traces can be
 		retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 1001 values Range: -150 dBm to 50 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:MINimum:AVERage?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:GPRF:MEASurement<Instance>:SPECtrum:MINimum:AVERage \n
 		Snippet: value: List[float] = driver.spectrum.minimum.average.read() \n
 		Returns the traces calculated with the minimum peak detector. Current, average, maximum and minimum traces can be
 		retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 1001 values Range: -150 dBm to 50 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:SPECtrum:MINimum:AVERage?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Minimum_/Current.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Minimum/Current.py`

 * *Files 16% similar despite different names*

```diff
@@ -3,35 +3,35 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:MINimum:CURRent \n
 		Snippet: value: List[float] = driver.spectrum.minimum.current.fetch() \n
 		Returns the traces calculated with the minimum peak detector. Current, average, maximum and minimum traces can be
 		retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 1001 values Range: -150 dBm to 50 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:MINimum:CURRent?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:GPRF:MEASurement<Instance>:SPECtrum:MINimum:CURRent \n
 		Snippet: value: List[float] = driver.spectrum.minimum.current.read() \n
 		Returns the traces calculated with the minimum peak detector. Current, average, maximum and minimum traces can be
 		retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 1001 values Range: -150 dBm to 50 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:SPECtrum:MINimum:CURRent?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Minimum_/Maximum.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Maximum/Current.py`

 * *Files 13% similar despite different names*

```diff
@@ -3,35 +3,35 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:MINimum:MAXimum \n
-		Snippet: value: List[float] = driver.spectrum.minimum.maximum.fetch() \n
-		Returns the traces calculated with the minimum peak detector. Current, average, maximum and minimum traces can be
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:MAXimum:CURRent \n
+		Snippet: value: List[float] = driver.spectrum.maximum.current.fetch() \n
+		Returns the traces calculated with the maximum peak detector. Current, average, maximum and minimum traces can be
 		retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 1001 values Range: -150 dBm to 50 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:MINimum:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:MAXimum:CURRent?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:GPRF:MEASurement<Instance>:SPECtrum:MINimum:MAXimum \n
-		Snippet: value: List[float] = driver.spectrum.minimum.maximum.read() \n
-		Returns the traces calculated with the minimum peak detector. Current, average, maximum and minimum traces can be
+		"""SCPI: READ:GPRF:MEASurement<Instance>:SPECtrum:MAXimum:CURRent \n
+		Snippet: value: List[float] = driver.spectrum.maximum.current.read() \n
+		Returns the traces calculated with the maximum peak detector. Current, average, maximum and minimum traces can be
 		retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 1001 values Range: -150 dBm to 50 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:SPECtrum:MINimum:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:SPECtrum:MAXimum:CURRent?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Minimum_/Minimum.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Sample/Maximum.py`

 * *Files 16% similar despite different names*

```diff
@@ -3,35 +3,33 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:MINimum:MINimum \n
-		Snippet: value: List[float] = driver.spectrum.minimum.minimum.fetch() \n
-		Returns the traces calculated with the minimum peak detector. Current, average, maximum and minimum traces can be
-		retrieved. \n
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:SAMPle:MAXimum \n
+		Snippet: value: List[float] = driver.spectrum.sample.maximum.fetch() \n
+		Returns the traces calculated with the sample detector. Current, average, maximum and minimum traces can be retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 1001 values Range: -150 dBm to 50 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:MINimum:MINimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:SAMPle:MAXimum?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:GPRF:MEASurement<Instance>:SPECtrum:MINimum:MINimum \n
-		Snippet: value: List[float] = driver.spectrum.minimum.minimum.read() \n
-		Returns the traces calculated with the minimum peak detector. Current, average, maximum and minimum traces can be
-		retrieved. \n
+		"""SCPI: READ:GPRF:MEASurement<Instance>:SPECtrum:SAMPle:MAXimum \n
+		Snippet: value: List[float] = driver.spectrum.sample.maximum.read() \n
+		Returns the traces calculated with the sample detector. Current, average, maximum and minimum traces can be retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 1001 values Range: -150 dBm to 50 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:SPECtrum:MINimum:MINimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:SPECtrum:SAMPle:MAXimum?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/ReferenceMarker.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Ploss/Eval/Trace/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ReferenceMarker:
-	"""ReferenceMarker commands group definition. 2 total commands, 2 Sub-groups, 0 group commands"""
+class TraceCls:
+	"""Trace commands group definition. 2 total commands, 2 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("referenceMarker", core, parent)
+		self._cmd_group = CommandsGroup("trace", core, parent)
 
 	@property
-	def speak(self):
-		"""speak commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_speak'):
-			from .ReferenceMarker_.Speak import Speak
-			self._speak = Speak(self._core, self._base)
-		return self._speak
+	def gain(self):
+		"""gain commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_gain'):
+			from .Gain import GainCls
+			self._gain = GainCls(self._core, self._cmd_group)
+		return self._gain
 
 	@property
-	def npeak(self):
-		"""npeak commands group. 0 Sub-classes, 1 commands."""
-		if not hasattr(self, '_npeak'):
-			from .ReferenceMarker_.Npeak import Npeak
-			self._npeak = Npeak(self._core, self._base)
-		return self._npeak
+	def frequency(self):
+		"""frequency commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_frequency'):
+			from .Frequency import FrequencyCls
+			self._frequency = FrequencyCls(self._core, self._cmd_group)
+		return self._frequency
 
-	def clone(self) -> 'ReferenceMarker':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'TraceCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ReferenceMarker(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = TraceCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/ReferenceMarker_/Npeak.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/ReferenceMarker/Speak.py`

 * *Files 11% similar despite different names*

```diff
@@ -5,41 +5,41 @@
 from ....Internal.ArgStruct import ArgStruct
 from ....Internal.ArgSingleList import ArgSingleList
 from ....Internal.ArgSingle import ArgSingle
 from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Npeak:
-	"""Npeak commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class SpeakCls:
+	"""Speak commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("npeak", core, parent)
+		self._cmd_group = CommandsGroup("speak", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: See 'Reliability Indicator'
-			- Xvalue: float: X value
-			- Yvalue: float: Y value Unit: dBm"""
+			- Reliability: int: decimal See 'Reliability indicator'
+			- Xvalue: float: float X value
+			- Yvalue: float: float Y value Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Xvalue'),
 			ArgStruct.scalar_float('Yvalue')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Xvalue: float = None
 			self.Yvalue: float = None
 
 	def fetch(self, detector: enums.Detector, statistic: enums.Statistic) -> FetchStruct:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:REFMarker:NPEak \n
-		Snippet: value: FetchStruct = driver.spectrum.referenceMarker.npeak.fetch(detector = enums.Detector.AUTopeak, statistic = enums.Statistic.AVERage) \n
-		Moves the reference marker to the next lower (or equal) peak, relative to the current marker position. Returns the X and
-		Y value of the new marker position. The trace is selected by <Detector> and <Statistic>. \n
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:REFMarker:SPEak \n
+		Snippet: value: FetchStruct = driver.spectrum.referenceMarker.speak.fetch(detector = enums.Detector.AUTopeak, statistic = enums.Statistic.AVERage) \n
+		Moves the reference marker to the highest peak of the trace determined by <Detector> and <Statistic> and returns the X
+		and Y value of the new marker position. \n
 			:param detector: AVERage | RMS | SAMPle | MINPeak | MAXPeak | AUTopeak Selects the detector type, see 'Detector hotkey'.
-			:param statistic: CURRent | AVERage | MAXimum | MINimum
+			:param statistic: CURRent | AVERage | MAXimum | MINimum Selects the trace type.
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		param = ArgSingleList().compose_cmd_string(ArgSingle('detector', detector, DataType.Enum), ArgSingle('statistic', statistic, DataType.Enum))
-		return self._core.io.query_struct(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:REFMarker:NPEak? {param}'.rstrip(), self.__class__.FetchStruct())
+		param = ArgSingleList().compose_cmd_string(ArgSingle('detector', detector, DataType.Enum, enums.Detector), ArgSingle('statistic', statistic, DataType.Enum, enums.Statistic))
+		return self._core.io.query_struct(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:REFMarker:SPEak? {param}'.rstrip(), self.__class__.FetchStruct())
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/ReferenceMarker_/Speak.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Marker/Npeak.py`

 * *Files 22% similar despite different names*

```diff
@@ -2,44 +2,47 @@
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.Types import DataType
 from ....Internal.StructBase import StructBase
 from ....Internal.ArgStruct import ArgStruct
 from ....Internal.ArgSingleList import ArgSingleList
 from ....Internal.ArgSingle import ArgSingle
 from .... import enums
+from .... import repcap
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Speak:
-	"""Speak commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class NpeakCls:
+	"""Npeak commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("speak", core, parent)
+		self._cmd_group = CommandsGroup("npeak", core, parent)
 
 	# noinspection PyTypeChecker
 	class FetchStruct(StructBase):
 		"""Response structure. Fields: \n
-			- Reliability: int: See 'Reliability Indicator'
-			- Xvalue: float: X value
-			- Yvalue: float: Y value Unit: dBm"""
+			- Reliability: int: decimal See 'Reliability indicator'
+			- Xvalue: float: float X value
+			- Yvalue: float: float Y value Unit: dBm"""
 		__meta_args_list = [
 			ArgStruct.scalar_int('Reliability', 'Reliability'),
 			ArgStruct.scalar_float('Xvalue'),
 			ArgStruct.scalar_float('Yvalue')]
 
 		def __init__(self):
 			StructBase.__init__(self, self)
 			self.Reliability: int = None
 			self.Xvalue: float = None
 			self.Yvalue: float = None
 
-	def fetch(self, detector: enums.Detector, statistic: enums.Statistic) -> FetchStruct:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:REFMarker:SPEak \n
-		Snippet: value: FetchStruct = driver.spectrum.referenceMarker.speak.fetch(detector = enums.Detector.AUTopeak, statistic = enums.Statistic.AVERage) \n
-		Moves the reference marker to the highest peak of the trace determined by <Detector> and <Statistic> and returns the X
-		and Y value of the new marker position. \n
+	def fetch(self, detector: enums.Detector, statistic: enums.Statistic, marker=repcap.Marker.Default) -> FetchStruct:
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:MARKer<MarkerNo>:NPEak \n
+		Snippet: value: FetchStruct = driver.spectrum.marker.npeak.fetch(detector = enums.Detector.AUTopeak, statistic = enums.Statistic.AVERage, marker = repcap.Marker.Default) \n
+		Moves marker <MarkerNo> to the next lower (or equal) peak, relative to the current marker position. Returns the X and Y
+		value of the new marker position. The trace is selected by <Detector> and <Statistic>. \n
 			:param detector: AVERage | RMS | SAMPle | MINPeak | MAXPeak | AUTopeak Selects the detector type, see 'Detector hotkey'.
-			:param statistic: CURRent | AVERage | MAXimum | MINimum Selects the trace type
+			:param statistic: CURRent | AVERage | MAXimum | MINimum Selects the trace type.
+			:param marker: optional repeated capability selector. Default value: Nr1 (settable in the interface 'Marker')
 			:return: structure: for return value, see the help for FetchStruct structure arguments."""
-		param = ArgSingleList().compose_cmd_string(ArgSingle('detector', detector, DataType.Enum), ArgSingle('statistic', statistic, DataType.Enum))
-		return self._core.io.query_struct(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:REFMarker:SPEak? {param}'.rstrip(), self.__class__.FetchStruct())
+		param = ArgSingleList().compose_cmd_string(ArgSingle('detector', detector, DataType.Enum, enums.Detector), ArgSingle('statistic', statistic, DataType.Enum, enums.Statistic))
+		marker_cmd_val = self._cmd_group.get_repcap_cmd_value(marker, repcap.Marker)
+		return self._core.io.query_struct(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:MARKer{marker_cmd_val}:NPEak? {param}'.rstrip(), self.__class__.FetchStruct())
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Rms_/Average.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Rms/Average.py`

 * *Files 16% similar despite different names*

```diff
@@ -3,33 +3,33 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Average:
-	"""Average commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("average", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:RMS:AVERage \n
 		Snippet: value: List[float] = driver.spectrum.rms.average.fetch() \n
 		Returns the traces calculated with the RMS detector. Current, average, maximum and minimum traces can be retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 1001 values Range: -150 dBm to 50 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:RMS:AVERage?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:GPRF:MEASurement<Instance>:SPECtrum:RMS:AVERage \n
 		Snippet: value: List[float] = driver.spectrum.rms.average.read() \n
 		Returns the traces calculated with the RMS detector. Current, average, maximum and minimum traces can be retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 1001 values Range: -150 dBm to 50 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:SPECtrum:RMS:AVERage?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Rms_/Current.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Rms/Current.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,33 +3,33 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
 		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:RMS:CURRent \n
 		Snippet: value: List[float] = driver.spectrum.rms.current.fetch() \n
 		Returns the traces calculated with the RMS detector. Current, average, maximum and minimum traces can be retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 1001 values Range: -150 dBm to 50 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:RMS:CURRent?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
 		"""SCPI: READ:GPRF:MEASurement<Instance>:SPECtrum:RMS:CURRent \n
 		Snippet: value: List[float] = driver.spectrum.rms.current.read() \n
 		Returns the traces calculated with the RMS detector. Current, average, maximum and minimum traces can be retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 1001 values Range: -150 dBm to 50 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
 		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:SPECtrum:RMS:CURRent?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Rms_/Maximum.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Average/Current.py`

 * *Files 27% similar despite different names*

```diff
@@ -3,33 +3,33 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Maximum:
-	"""Maximum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("maximum", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:RMS:MAXimum \n
-		Snippet: value: List[float] = driver.spectrum.rms.maximum.fetch() \n
-		Returns the traces calculated with the RMS detector. Current, average, maximum and minimum traces can be retrieved. \n
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:AVERage:CURRent \n
+		Snippet: value: List[float] = driver.spectrum.average.current.fetch() \n
+		Returns the traces calculated with the average detector. Current, average, maximum and minimum traces can be retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 1001 values Range: -150 dBm to 50 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:RMS:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:AVERage:CURRent?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:GPRF:MEASurement<Instance>:SPECtrum:RMS:MAXimum \n
-		Snippet: value: List[float] = driver.spectrum.rms.maximum.read() \n
-		Returns the traces calculated with the RMS detector. Current, average, maximum and minimum traces can be retrieved. \n
+		"""SCPI: READ:GPRF:MEASurement<Instance>:SPECtrum:AVERage:CURRent \n
+		Snippet: value: List[float] = driver.spectrum.average.current.read() \n
+		Returns the traces calculated with the average detector. Current, average, maximum and minimum traces can be retrieved. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 1001 values Range: -150 dBm to 50 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 1001 values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:SPECtrum:RMS:MAXimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:SPECtrum:AVERage:CURRent?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Rms_/Minimum.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/FftSpecAn/Power/Average.py`

 * *Files 25% similar despite different names*

```diff
@@ -3,33 +3,35 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Minimum:
-	"""Minimum commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class AverageCls:
+	"""Average commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("minimum", core, parent)
+		self._cmd_group = CommandsGroup("average", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:RMS:MINimum \n
-		Snippet: value: List[float] = driver.spectrum.rms.minimum.fetch() \n
-		Returns the traces calculated with the RMS detector. Current, average, maximum and minimum traces can be retrieved. \n
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:FFTSanalyzer:POWer:AVERage \n
+		Snippet: value: List[float] = driver.fftSpecAn.power.average.fetch() \n
+		Returns the traces of the spectrum diagram. The current, average, minimum and maximum traces can be retrieved. Each trace
+		contains 801 power values and covers the configured frequency span. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 1001 values Range: -150 dBm to 50 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 801 power values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:RMS:MINimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:FFTSanalyzer:POWer:AVERage?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:GPRF:MEASurement<Instance>:SPECtrum:RMS:MINimum \n
-		Snippet: value: List[float] = driver.spectrum.rms.minimum.read() \n
-		Returns the traces calculated with the RMS detector. Current, average, maximum and minimum traces can be retrieved. \n
+		"""SCPI: READ:GPRF:MEASurement<Instance>:FFTSanalyzer:POWer:AVERage \n
+		Snippet: value: List[float] = driver.fftSpecAn.power.average.read() \n
+		Returns the traces of the spectrum diagram. The current, average, minimum and maximum traces can be retrieved. Each trace
+		contains 801 power values and covers the configured frequency span. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 1001 values Range: -150 dBm to 50 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 801 power values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:SPECtrum:RMS:MINimum?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:FFTSanalyzer:POWer:AVERage?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Sample.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Spectrum/Maximum/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Sample:
-	"""Sample commands group definition. 8 total commands, 4 Sub-groups, 0 group commands"""
+class MaximumCls:
+	"""Maximum commands group definition. 8 total commands, 4 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("sample", core, parent)
-
-	@property
-	def maximum(self):
-		"""maximum commands group. 0 Sub-classes, 2 commands."""
-		if not hasattr(self, '_maximum'):
-			from .Sample_.Maximum import Maximum
-			self._maximum = Maximum(self._core, self._base)
-		return self._maximum
+		self._cmd_group = CommandsGroup("maximum", core, parent)
 
 	@property
 	def minimum(self):
 		"""minimum commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_minimum'):
-			from .Sample_.Minimum import Minimum
-			self._minimum = Minimum(self._core, self._base)
+			from .Minimum import MinimumCls
+			self._minimum = MinimumCls(self._core, self._cmd_group)
 		return self._minimum
 
 	@property
+	def maximum(self):
+		"""maximum commands group. 0 Sub-classes, 2 commands."""
+		if not hasattr(self, '_maximum'):
+			from .Maximum import MaximumCls
+			self._maximum = MaximumCls(self._core, self._cmd_group)
+		return self._maximum
+
+	@property
 	def current(self):
 		"""current commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_current'):
-			from .Sample_.Current import Current
-			self._current = Current(self._core, self._base)
+			from .Current import CurrentCls
+			self._current = CurrentCls(self._core, self._cmd_group)
 		return self._current
 
 	@property
 	def average(self):
 		"""average commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_average'):
-			from .Sample_.Average import Average
-			self._average = Average(self._core, self._base)
+			from .Average import AverageCls
+			self._average = AverageCls(self._core, self._cmd_group)
 		return self._average
 
-	def clone(self) -> 'Sample':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'MaximumCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Sample(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = MaximumCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/Sample_/Current.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/FftSpecAn/Power/Current.py`

 * *Files 18% similar despite different names*

```diff
@@ -3,33 +3,35 @@
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
 from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Current:
-	"""Current commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class CurrentCls:
+	"""Current commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("current", core, parent)
+		self._cmd_group = CommandsGroup("current", core, parent)
 
 	def fetch(self) -> List[float]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:SAMPle:CURRent \n
-		Snippet: value: List[float] = driver.spectrum.sample.current.fetch() \n
-		Returns the traces calculated with the sample detector. Current, average, maximum and minimum traces can be retrieved. \n
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:FFTSanalyzer:POWer:CURRent \n
+		Snippet: value: List[float] = driver.fftSpecAn.power.current.fetch() \n
+		Returns the traces of the spectrum diagram. The current, average, minimum and maximum traces can be retrieved. Each trace
+		contains 801 power values and covers the configured frequency span. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 1001 values Range: -150 dBm to 50 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 801 power values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:SAMPle:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:FFTSanalyzer:POWer:CURRent?', suppressed)
 		return response
 
 	def read(self) -> List[float]:
-		"""SCPI: READ:GPRF:MEASurement<Instance>:SPECtrum:SAMPle:CURRent \n
-		Snippet: value: List[float] = driver.spectrum.sample.current.read() \n
-		Returns the traces calculated with the sample detector. Current, average, maximum and minimum traces can be retrieved. \n
+		"""SCPI: READ:GPRF:MEASurement<Instance>:FFTSanalyzer:POWer:CURRent \n
+		Snippet: value: List[float] = driver.fftSpecAn.power.current.read() \n
+		Returns the traces of the spectrum diagram. The current, average, minimum and maximum traces can be retrieved. Each trace
+		contains 801 power values and covers the configured frequency span. \n
 		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
-			:return: power: 1001 values Range: -150 dBm to 50 dBm, Unit: dBm"""
+			:return: power: float Comma-separated list of 801 power values Unit: dBm"""
 		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
-		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:SPECtrum:SAMPle:CURRent?', suppressed)
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'READ:GPRF:MEASurement<Instance>:FFTSanalyzer:POWer:CURRent?', suppressed)
 		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Spectrum_/State_/All.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Power/CumulativeDistribFnc/Probability.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,26 +1,25 @@
 from typing import List
 
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
-from ....Internal import Conversions
-from .... import enums
+from ....Internal.ArgSingleSuppressed import ArgSingleSuppressed
+from ....Internal.Types import DataType
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class All:
-	"""All commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class ProbabilityCls:
+	"""Probability commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("all", core, parent)
+		self._cmd_group = CommandsGroup("probability", core, parent)
 
-	# noinspection PyTypeChecker
-	def fetch(self) -> List[enums.ResourceState]:
-		"""SCPI: FETCh:GPRF:MEASurement<Instance>:SPECtrum:STATe:ALL \n
-		Snippet: value: List[enums.ResourceState] = driver.spectrum.state.all.fetch() \n
-		Queries the main measurement state and the measurement substates. Both measurement substates are relevant for running
-		measurements only. Use FETCh:...:STATe? to query the main measurement state only. Use INITiate..., STOP..., ABORt...
-		to change the measurement state. \n
-			:return: meas_state: No help available"""
-		response = self._core.io.query_str(f'FETCh:GPRF:MEASurement<Instance>:SPECtrum:STATe:ALL?')
-		return Conversions.str_to_list_enum(response, enums.ResourceState)
+	def fetch(self) -> List[float]:
+		"""SCPI: FETCh:GPRF:MEASurement<Instance>:POWer:CCDF:PROBability \n
+		Snippet: value: List[float] = driver.power.cumulativeDistribFnc.probability.fetch() \n
+		Returns power values with a certain probability, taken from the CCDF diagram. \n
+		Use RsCmwGprfMeas.reliability.last_value to read the updated reliability indicator. \n
+			:return: probability: float Comma-separated list of 6 power values with the following probabilities: 10 %, 1 %, 0.1 %, 0.01 %, 0.001 %, 0.0001 % The power values are indicated in dB relative to the average power. Unit: dB"""
+		suppressed = ArgSingleSuppressed(0, DataType.Integer, False, 1, 'Reliability')
+		response = self._core.io.query_bin_or_ascii_float_list_suppressed(f'FETCh:GPRF:MEASurement<Instance>:POWer:CCDF:PROBability?', suppressed)
+		return response
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/FftSpecAn.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/FftSpecAn/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,177 +1,153 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ...Internal.Utilities import trim_str_response
-from ...Internal.StructBase import StructBase
-from ...Internal.ArgStruct import ArgStruct
-from ... import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from ....Internal.Utilities import trim_str_response
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class FftSpecAn:
-	"""FftSpecAn commands group definition. 9 total commands, 1 Sub-groups, 8 group commands"""
+class FftSpecAnCls:
+	"""FftSpecAn commands group definition. 9 total commands, 2 Subgroups, 7 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("fftSpecAn", core, parent)
+		self._cmd_group = CommandsGroup("fftSpecAn", core, parent)
 
 	@property
 	def catalog(self):
 		"""catalog commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_catalog'):
-			from .FftSpecAn_.Catalog import Catalog
-			self._catalog = Catalog(self._core, self._base)
+			from .Catalog import CatalogCls
+			self._catalog = CatalogCls(self._core, self._cmd_group)
 		return self._catalog
 
+	@property
+	def osStop(self):
+		"""osStop commands group. 0 Sub-classes, 1 commands."""
+		if not hasattr(self, '_osStop'):
+			from .OsStop import OsStopCls
+			self._osStop = OsStopCls(self._core, self._cmd_group)
+		return self._osStop
+
+	def get_source(self) -> str:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:SOURce \n
+		Snippet: value: str = driver.trigger.fftSpecAn.get_source() \n
+		Selects the source of the trigger events. Some values are always available. They are listed below. Depending on the
+		installed options, additional values are available. You can query a list of all supported values via TRIGger:...
+		:CATalog:SOURce?. \n
+			:return: source: string 'IF Power': IF power trigger 'Free Run': free run (untriggered)
+		"""
+		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:SOURce?')
+		return trim_str_response(response)
+
+	def set_source(self, source: str) -> None:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:SOURce \n
+		Snippet: driver.trigger.fftSpecAn.set_source(source = 'abc') \n
+		Selects the source of the trigger events. Some values are always available. They are listed below. Depending on the
+		installed options, additional values are available. You can query a list of all supported values via TRIGger:...
+		:CATalog:SOURce?. \n
+			:param source: string 'IF Power': IF power trigger 'Free Run': free run (untriggered)
+		"""
+		param = Conversions.value_to_quoted_str(source)
+		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:SOURce {param}')
+
 	# noinspection PyTypeChecker
 	def get_omode(self) -> enums.OffsetMode:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:OMODe \n
 		Snippet: value: enums.OffsetMode = driver.trigger.fftSpecAn.get_omode() \n
-		Selects a fixed or a variable trigger offset. In the FFT spectrum analyzer measurement, the trigger offset defines the
-		center of the FFT window. \n
-			:return: offset_mode: VARiable | FIXed VARiable Trigger offset defined via method RsCmwGprfMeas.Trigger.FftSpecAn.osStop. FIXed Trigger offset defined via method RsCmwGprfMeas.Trigger.FftSpecAn.offset.
+		Selects the trigger offset mode. \n
+			:return: offset_mode: VARiable | FIXed
 		"""
 		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:OMODe?')
 		return Conversions.str_to_scalar_enum(response, enums.OffsetMode)
 
 	def set_omode(self, offset_mode: enums.OffsetMode) -> None:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:OMODe \n
 		Snippet: driver.trigger.fftSpecAn.set_omode(offset_mode = enums.OffsetMode.FIXed) \n
-		Selects a fixed or a variable trigger offset. In the FFT spectrum analyzer measurement, the trigger offset defines the
-		center of the FFT window. \n
-			:param offset_mode: VARiable | FIXed VARiable Trigger offset defined via method RsCmwGprfMeas.Trigger.FftSpecAn.osStop. FIXed Trigger offset defined via method RsCmwGprfMeas.Trigger.FftSpecAn.offset.
+		Selects the trigger offset mode. \n
+			:param offset_mode: VARiable | FIXed
 		"""
 		param = Conversions.enum_scalar_to_str(offset_mode, enums.OffsetMode)
 		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:OMODe {param}')
 
-	# noinspection PyTypeChecker
-	class OsStopStruct(StructBase):
-		"""Structure for reading output parameters. Fields: \n
-			- Offset_Start: float: Must be smaller than the stop value. Range: -0.15 s to 0.15 s, Unit: s
-			- Offset_Stop: float: Must be larger than the start value. Range: -0.15 s to 0.15 s, Unit: s"""
-		__meta_args_list = [
-			ArgStruct.scalar_float('Offset_Start'),
-			ArgStruct.scalar_float('Offset_Stop')]
-
-		def __init__(self):
-			StructBase.__init__(self, self)
-			self.Offset_Start: float = None
-			self.Offset_Stop: float = None
-
-	def get_os_stop(self) -> OsStopStruct:
-		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:OSSTop \n
-		Snippet: value: OsStopStruct = driver.trigger.fftSpecAn.get_os_stop() \n
-		Defines the start and stop time for the variable trigger offset, see method RsCmwGprfMeas.Trigger.FftSpecAn.omode. \n
-			:return: structure: for return value, see the help for OsStopStruct structure arguments.
-		"""
-		return self._core.io.query_struct('TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:OSSTop?', self.__class__.OsStopStruct())
-
-	def set_os_stop(self, value: OsStopStruct) -> None:
-		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:OSSTop \n
-		Snippet: driver.trigger.fftSpecAn.set_os_stop(value = OsStopStruct()) \n
-		Defines the start and stop time for the variable trigger offset, see method RsCmwGprfMeas.Trigger.FftSpecAn.omode. \n
-			:param value: see the help for OsStopStruct structure arguments.
-		"""
-		self._core.io.write_struct('TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:OSSTop', value)
-
-	def get_source(self) -> str:
-		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:SOURce \n
-		Snippet: value: str = driver.trigger.fftSpecAn.get_source() \n
-		Selects the source of the trigger events. Some values are always available in this firmware application. They are listed
-		below. Depending on the installed options, additional values are available. A complete list of all supported values can
-		be displayed using TRIGger:...:CATalog:SOURce?. \n
-			:return: source: 'IF Power': IF power trigger 'Free Run': free run (untriggered)
-		"""
-		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:SOURce?')
-		return trim_str_response(response)
-
-	def set_source(self, source: str) -> None:
-		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:SOURce \n
-		Snippet: driver.trigger.fftSpecAn.set_source(source = '1') \n
-		Selects the source of the trigger events. Some values are always available in this firmware application. They are listed
-		below. Depending on the installed options, additional values are available. A complete list of all supported values can
-		be displayed using TRIGger:...:CATalog:SOURce?. \n
-			:param source: 'IF Power': IF power trigger 'Free Run': free run (untriggered)
-		"""
-		param = Conversions.value_to_quoted_str(source)
-		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:SOURce {param}')
-
 	def get_mgap(self) -> float:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:MGAP \n
 		Snippet: value: float = driver.trigger.fftSpecAn.get_mgap() \n
 		Sets a minimum time during which the IF signal must be below the trigger threshold before the trigger is armed so that an
 		IF power trigger event can be generated. \n
-			:return: minimum_gap: Range: 0 s to 0.01 s, Unit: s
+			:return: minimum_gap: numeric Range: 0 s to 0.01 s, Unit: s
 		"""
 		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:MGAP?')
 		return Conversions.str_to_float(response)
 
 	def set_mgap(self, minimum_gap: float) -> None:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:MGAP \n
 		Snippet: driver.trigger.fftSpecAn.set_mgap(minimum_gap = 1.0) \n
 		Sets a minimum time during which the IF signal must be below the trigger threshold before the trigger is armed so that an
 		IF power trigger event can be generated. \n
-			:param minimum_gap: Range: 0 s to 0.01 s, Unit: s
+			:param minimum_gap: numeric Range: 0 s to 0.01 s, Unit: s
 		"""
 		param = Conversions.decimal_value_to_str(minimum_gap)
 		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:MGAP {param}')
 
 	def get_timeout(self) -> float or bool:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:TOUT \n
 		Snippet: value: float or bool = driver.trigger.fftSpecAn.get_timeout() \n
-		Selects the maximum time that the R&S CMW waits for a trigger event before it stops the measurement in remote control
-		mode or indicates a trigger timeout in manual operation mode. This setting has no influence on 'Free Run' measurements. \n
-			:return: timeout: Range: 0.01 s to 300 s, Unit: s Additional values: OFF | ON (disables | enables the timeout check) .
+		Selects the maximum time that the measurement waits for a trigger event before it stops in remote control mode or
+		indicates a trigger timeout in manual operation mode. This setting has no influence on 'Free Run' measurements. \n
+			:return: timeout: (float or boolean) numeric | ON | OFF Range: 0.01 s to 300 s, Unit: s ON | OFF enables or disables the timeout check.
 		"""
 		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:TOUT?')
 		return Conversions.str_to_float_or_bool(response)
 
 	def set_timeout(self, timeout: float or bool) -> None:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:TOUT \n
 		Snippet: driver.trigger.fftSpecAn.set_timeout(timeout = 1.0) \n
-		Selects the maximum time that the R&S CMW waits for a trigger event before it stops the measurement in remote control
-		mode or indicates a trigger timeout in manual operation mode. This setting has no influence on 'Free Run' measurements. \n
-			:param timeout: Range: 0.01 s to 300 s, Unit: s Additional values: OFF | ON (disables | enables the timeout check) .
+		Selects the maximum time that the measurement waits for a trigger event before it stops in remote control mode or
+		indicates a trigger timeout in manual operation mode. This setting has no influence on 'Free Run' measurements. \n
+			:param timeout: (float or boolean) numeric | ON | OFF Range: 0.01 s to 300 s, Unit: s ON | OFF enables or disables the timeout check.
 		"""
 		param = Conversions.decimal_or_bool_value_to_str(timeout)
 		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:TOUT {param}')
 
 	def get_offset(self) -> float:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:OFFSet \n
 		Snippet: value: float = driver.trigger.fftSpecAn.get_offset() \n
-		Defines the fixed trigger offset, see method RsCmwGprfMeas.Trigger.FftSpecAn.omode. \n
-			:return: offset: Range: -0.15 s to 0.15 s, Unit: s
+		Defines the trigger offset for the trigger offset mode FIXed. The trigger offset defines the center of the measurement
+		interval relative to the trigger event. \n
+			:return: offset: numeric Range: -0.15 s to 0.15 s, Unit: s
 		"""
 		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:OFFSet?')
 		return Conversions.str_to_float(response)
 
 	def set_offset(self, offset: float) -> None:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:OFFSet \n
 		Snippet: driver.trigger.fftSpecAn.set_offset(offset = 1.0) \n
-		Defines the fixed trigger offset, see method RsCmwGprfMeas.Trigger.FftSpecAn.omode. \n
-			:param offset: Range: -0.15 s to 0.15 s, Unit: s
+		Defines the trigger offset for the trigger offset mode FIXed. The trigger offset defines the center of the measurement
+		interval relative to the trigger event. \n
+			:param offset: numeric Range: -0.15 s to 0.15 s, Unit: s
 		"""
 		param = Conversions.decimal_value_to_str(offset)
 		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:OFFSet {param}')
 
 	def get_threshold(self) -> float:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:THReshold \n
 		Snippet: value: float = driver.trigger.fftSpecAn.get_threshold() \n
 		Defines the trigger threshold for power trigger sources. \n
-			:return: threshold: Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
+			:return: threshold: numeric Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
 		"""
 		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:THReshold?')
 		return Conversions.str_to_float(response)
 
 	def set_threshold(self, threshold: float) -> None:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:THReshold \n
 		Snippet: driver.trigger.fftSpecAn.set_threshold(threshold = 1.0) \n
 		Defines the trigger threshold for power trigger sources. \n
-			:param threshold: Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
+			:param threshold: numeric Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
 		"""
 		param = Conversions.decimal_value_to_str(threshold)
 		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:THReshold {param}')
 
 	# noinspection PyTypeChecker
 	def get_slope(self) -> enums.SignalSlopeExt:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:SLOPe \n
@@ -189,14 +165,14 @@
 		Qualifies whether the trigger event is generated at the rising or at the falling edge of the trigger pulse (valid for
 		external and power trigger sources) . \n
 			:param event: REDGe | FEDGe REDGe: rising edge FEDGe: falling edge
 		"""
 		param = Conversions.enum_scalar_to_str(event, enums.SignalSlopeExt)
 		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:SLOPe {param}')
 
-	def clone(self) -> 'FftSpecAn':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'FftSpecAnCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = FftSpecAn(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = FftSpecAnCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/FftSpecAn_/Catalog.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/FftSpecAn/Catalog.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,22 +2,22 @@
 
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Catalog:
-	"""Catalog commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CatalogCls:
+	"""Catalog commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("catalog", core, parent)
+		self._cmd_group = CommandsGroup("catalog", core, parent)
 
 	def get_source(self) -> List[str]:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:CATalog:SOURce \n
 		Snippet: value: List[str] = driver.trigger.fftSpecAn.catalog.get_source() \n
 		Lists all trigger source values that can be set using method RsCmwGprfMeas.Trigger.FftSpecAn.source. \n
-			:return: trigger_sources: Comma-separated list of all supported values. Each value is represented as a string.
+			:return: trigger_sources: string Comma-separated list of all supported values. Each value is represented as a string.
 		"""
 		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:FFTSanalyzer:CATalog:SOURce?')
 		return Conversions.str_to_str_list(response)
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/IqRecorder.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/IqRecorder/__init__.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,136 +1,170 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ...Internal.Utilities import trim_str_response
-from ... import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from ....Internal.Utilities import trim_str_response
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class IqRecorder:
-	"""IqRecorder commands group definition. 7 total commands, 1 Sub-groups, 6 group commands"""
+class IqRecorderCls:
+	"""IqRecorder commands group definition. 9 total commands, 1 Subgroups, 8 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("iqRecorder", core, parent)
+		self._cmd_group = CommandsGroup("iqRecorder", core, parent)
 
 	@property
 	def catalog(self):
 		"""catalog commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_catalog'):
-			from .IqRecorder_.Catalog import Catalog
-			self._catalog = Catalog(self._core, self._base)
+			from .Catalog import CatalogCls
+			self._catalog = CatalogCls(self._core, self._cmd_group)
 		return self._catalog
 
+	def get_source(self) -> str:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:IQRecorder:SOURce \n
+		Snippet: value: str = driver.trigger.iqRecorder.get_source() \n
+		Selects the source of the trigger events. Some values are always available. They are listed below. Depending on the
+		installed options, additional values are available. You can query a list of all supported values via TRIGger:...
+		:CATalog:SOURce?. \n
+			:return: source: string 'IF Power': IF power trigger 'Free Run': free run (untriggered)
+		"""
+		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:IQRecorder:SOURce?')
+		return trim_str_response(response)
+
+	def set_source(self, source: str) -> None:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:IQRecorder:SOURce \n
+		Snippet: driver.trigger.iqRecorder.set_source(source = 'abc') \n
+		Selects the source of the trigger events. Some values are always available. They are listed below. Depending on the
+		installed options, additional values are available. You can query a list of all supported values via TRIGger:...
+		:CATalog:SOURce?. \n
+			:param source: string 'IF Power': IF power trigger 'Free Run': free run (untriggered)
+		"""
+		param = Conversions.value_to_quoted_str(source)
+		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:IQRecorder:SOURce {param}')
+
 	def get_offset(self) -> int:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:IQRecorder:OFFSet \n
 		Snippet: value: int = driver.trigger.iqRecorder.get_offset() \n
 		Defines a delay time for triggered measurements. The trigger offset delays the start of the measurement relative to the
 		trigger event. \n
-			:return: trigger_offset: Range: 0 to 64E+6, Unit: samples
+			:return: trigger_offset: numeric Trigger offset in samples. Range: 0 to 64E+6
 		"""
 		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:IQRecorder:OFFSet?')
 		return Conversions.str_to_int(response)
 
 	def set_offset(self, trigger_offset: int) -> None:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:IQRecorder:OFFSet \n
 		Snippet: driver.trigger.iqRecorder.set_offset(trigger_offset = 1) \n
 		Defines a delay time for triggered measurements. The trigger offset delays the start of the measurement relative to the
 		trigger event. \n
-			:param trigger_offset: Range: 0 to 64E+6, Unit: samples
+			:param trigger_offset: numeric Trigger offset in samples. Range: 0 to 64E+6
 		"""
 		param = Conversions.decimal_value_to_str(trigger_offset)
 		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:IQRecorder:OFFSet {param}')
 
-	def get_source(self) -> str:
-		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:IQRecorder:SOURce \n
-		Snippet: value: str = driver.trigger.iqRecorder.get_source() \n
-		Selects the source of the trigger events. Some values are always available in this firmware application. They are listed
-		below. Depending on the installed options, additional values are available. A complete list of all supported values can
-		be displayed using TRIGger:...:CATalog:SOURce?. \n
-			:return: source: 'IF Power': IF power trigger 'Free Run': free run (untriggered)
-		"""
-		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:IQRecorder:SOURce?')
-		return trim_str_response(response)
-
-	def set_source(self, source: str) -> None:
-		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:IQRecorder:SOURce \n
-		Snippet: driver.trigger.iqRecorder.set_source(source = '1') \n
-		Selects the source of the trigger events. Some values are always available in this firmware application. They are listed
-		below. Depending on the installed options, additional values are available. A complete list of all supported values can
-		be displayed using TRIGger:...:CATalog:SOURce?. \n
-			:param source: 'IF Power': IF power trigger 'Free Run': free run (untriggered)
-		"""
-		param = Conversions.value_to_quoted_str(source)
-		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:IQRecorder:SOURce {param}')
-
 	def get_mgap(self) -> float:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:IQRecorder:MGAP \n
 		Snippet: value: float = driver.trigger.iqRecorder.get_mgap() \n
 		Sets a minimum time during which the IF signal must be below the trigger threshold before the trigger is armed so that an
-		IF power trigger event can be generated. The I/Q recorder measurement is always performed in single-shot mode. Therefore
-		it is controlled by a single trigger event. As a consequence, the minimum trigger gap condition is valid between the
-		start of the measurement and the first trigger event only. For continuous or retriggered measurements, the gap condition
-		can be applied repeatedly. \n
-			:return: minimum_gap: Range: 0 s to 0.01 s, Unit: s
+		IF power trigger event can be generated. The I/Q recorder runs always in single-shot mode. Therefore it is controlled by
+		a single trigger event. The minimum trigger gap condition is valid between the start of the measurement and the first
+		trigger event. \n
+			:return: minimum_gap: numeric Range: 0 s to 0.01 s, Unit: s
 		"""
 		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:IQRecorder:MGAP?')
 		return Conversions.str_to_float(response)
 
 	def set_mgap(self, minimum_gap: float) -> None:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:IQRecorder:MGAP \n
 		Snippet: driver.trigger.iqRecorder.set_mgap(minimum_gap = 1.0) \n
 		Sets a minimum time during which the IF signal must be below the trigger threshold before the trigger is armed so that an
-		IF power trigger event can be generated. The I/Q recorder measurement is always performed in single-shot mode. Therefore
-		it is controlled by a single trigger event. As a consequence, the minimum trigger gap condition is valid between the
-		start of the measurement and the first trigger event only. For continuous or retriggered measurements, the gap condition
-		can be applied repeatedly. \n
-			:param minimum_gap: Range: 0 s to 0.01 s, Unit: s
+		IF power trigger event can be generated. The I/Q recorder runs always in single-shot mode. Therefore it is controlled by
+		a single trigger event. The minimum trigger gap condition is valid between the start of the measurement and the first
+		trigger event. \n
+			:param minimum_gap: numeric Range: 0 s to 0.01 s, Unit: s
 		"""
 		param = Conversions.decimal_value_to_str(minimum_gap)
 		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:IQRecorder:MGAP {param}')
 
 	def get_timeout(self) -> float or bool:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:IQRecorder:TOUT \n
 		Snippet: value: float or bool = driver.trigger.iqRecorder.get_timeout() \n
-		Selects the maximum time that the R&S CMW waits for a trigger event before it stops the measurement in remote control
-		mode or indicates a trigger timeout in manual operation mode. This setting has no influence on 'Free Run' measurements. \n
-			:return: timeout: Range: 0.01 s to 300 s, Unit: s Additional values: OFF | ON (disables | enables the timeout check) .
+		Selects the maximum time that the measurement waits for a trigger event before it stops in remote control mode or
+		indicates a trigger timeout in manual operation mode. This setting has no influence on 'Free Run' measurements. \n
+			:return: timeout: (float or boolean) numeric | ON | OFF Range: 0.01 s to 300 s, Unit: s ON | OFF enables or disables the timeout check.
 		"""
 		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:IQRecorder:TOUT?')
 		return Conversions.str_to_float_or_bool(response)
 
 	def set_timeout(self, timeout: float or bool) -> None:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:IQRecorder:TOUT \n
 		Snippet: driver.trigger.iqRecorder.set_timeout(timeout = 1.0) \n
-		Selects the maximum time that the R&S CMW waits for a trigger event before it stops the measurement in remote control
-		mode or indicates a trigger timeout in manual operation mode. This setting has no influence on 'Free Run' measurements. \n
-			:param timeout: Range: 0.01 s to 300 s, Unit: s Additional values: OFF | ON (disables | enables the timeout check) .
+		Selects the maximum time that the measurement waits for a trigger event before it stops in remote control mode or
+		indicates a trigger timeout in manual operation mode. This setting has no influence on 'Free Run' measurements. \n
+			:param timeout: (float or boolean) numeric | ON | OFF Range: 0.01 s to 300 s, Unit: s ON | OFF enables or disables the timeout check.
 		"""
 		param = Conversions.decimal_or_bool_value_to_str(timeout)
 		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:IQRecorder:TOUT {param}')
 
 	def get_threshold(self) -> float:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:IQRecorder:THReshold \n
 		Snippet: value: float = driver.trigger.iqRecorder.get_threshold() \n
 		Defines the trigger threshold for power trigger sources. \n
-			:return: threshold: Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
+			:return: threshold: numeric Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
 		"""
 		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:IQRecorder:THReshold?')
 		return Conversions.str_to_float(response)
 
 	def set_threshold(self, threshold: float) -> None:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:IQRecorder:THReshold \n
 		Snippet: driver.trigger.iqRecorder.set_threshold(threshold = 1.0) \n
 		Defines the trigger threshold for power trigger sources. \n
-			:param threshold: Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
+			:param threshold: numeric Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
 		"""
 		param = Conversions.decimal_value_to_str(threshold)
 		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:IQRecorder:THReshold {param}')
 
+	def get_pc_threshold(self) -> float:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:IQRecorder:PCTHreshold \n
+		Snippet: value: float = driver.trigger.iqRecorder.get_pc_threshold() \n
+		No command help available \n
+			:return: phase_chg_thres: No help available
+		"""
+		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:IQRecorder:PCTHreshold?')
+		return Conversions.str_to_float(response)
+
+	def set_pc_threshold(self, phase_chg_thres: float) -> None:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:IQRecorder:PCTHreshold \n
+		Snippet: driver.trigger.iqRecorder.set_pc_threshold(phase_chg_thres = 1.0) \n
+		No command help available \n
+			:param phase_chg_thres: No help available
+		"""
+		param = Conversions.decimal_value_to_str(phase_chg_thres)
+		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:IQRecorder:PCTHreshold {param}')
+
+	def get_pc_time(self) -> float or bool:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:IQRecorder:PCTime \n
+		Snippet: value: float or bool = driver.trigger.iqRecorder.get_pc_time() \n
+		No command help available \n
+			:return: phase_chg_time: (float or boolean) No help available
+		"""
+		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:IQRecorder:PCTime?')
+		return Conversions.str_to_float_or_bool(response)
+
+	def set_pc_time(self, phase_chg_time: float or bool) -> None:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:IQRecorder:PCTime \n
+		Snippet: driver.trigger.iqRecorder.set_pc_time(phase_chg_time = 1.0) \n
+		No command help available \n
+			:param phase_chg_time: (float or boolean) No help available
+		"""
+		param = Conversions.decimal_or_bool_value_to_str(phase_chg_time)
+		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:IQRecorder:PCTime {param}')
+
 	# noinspection PyTypeChecker
 	def get_slope(self) -> enums.SignalSlopeExt:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:IQRecorder:SLOPe \n
 		Snippet: value: enums.SignalSlopeExt = driver.trigger.iqRecorder.get_slope() \n
 		Qualifies whether the trigger event is generated at the rising or at the falling edge of the trigger pulse (valid for
 		external and power trigger sources) . \n
 			:return: event: REDGe | FEDGe REDGe: rising edge FEDGe: falling edge
@@ -144,14 +178,14 @@
 		Qualifies whether the trigger event is generated at the rising or at the falling edge of the trigger pulse (valid for
 		external and power trigger sources) . \n
 			:param event: REDGe | FEDGe REDGe: rising edge FEDGe: falling edge
 		"""
 		param = Conversions.enum_scalar_to_str(event, enums.SignalSlopeExt)
 		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:IQRecorder:SLOPe {param}')
 
-	def clone(self) -> 'IqRecorder':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'IqRecorderCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = IqRecorder(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = IqRecorderCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/IqRecorder_/Catalog.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/Power/Catalog.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,22 +2,22 @@
 
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Catalog:
-	"""Catalog commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CatalogCls:
+	"""Catalog commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("catalog", core, parent)
+		self._cmd_group = CommandsGroup("catalog", core, parent)
 
 	def get_source(self) -> List[str]:
-		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:IQRecorder:CATalog:SOURce \n
-		Snippet: value: List[str] = driver.trigger.iqRecorder.catalog.get_source() \n
-		Lists all trigger source values that can be set using method RsCmwGprfMeas.Trigger.IqRecorder.source. \n
-			:return: trigger_sources: Comma-separated list of all supported values. Each value is represented as a string.
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:CATalog:SOURce \n
+		Snippet: value: List[str] = driver.trigger.power.catalog.get_source() \n
+		Lists all trigger source values that can be set using method RsCmwGprfMeas.Trigger.Power.source. \n
+			:return: trigger_sources: string Comma-separated list of all supported values. Each value is represented as a string.
 		"""
-		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:IQRecorder:CATalog:SOURce?')
+		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:POWer:CATalog:SOURce?')
 		return Conversions.str_to_str_list(response)
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/IqVsSlot.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/IqVsSlot/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,126 +1,126 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ...Internal.Utilities import trim_str_response
-from ... import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from ....Internal.Utilities import trim_str_response
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class IqVsSlot:
-	"""IqVsSlot commands group definition. 8 total commands, 1 Sub-groups, 7 group commands"""
+class IqVsSlotCls:
+	"""IqVsSlot commands group definition. 8 total commands, 1 Subgroups, 7 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("iqVsSlot", core, parent)
+		self._cmd_group = CommandsGroup("iqVsSlot", core, parent)
 
 	@property
 	def catalog(self):
 		"""catalog commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_catalog'):
-			from .IqVsSlot_.Catalog import Catalog
-			self._catalog = Catalog(self._core, self._base)
+			from .Catalog import CatalogCls
+			self._catalog = CatalogCls(self._core, self._cmd_group)
 		return self._catalog
 
 	def get_source(self) -> str:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:IQVSlot:SOURce \n
 		Snippet: value: str = driver.trigger.iqVsSlot.get_source() \n
-		Selects the source of the trigger events. Some values are always available in this firmware application. They are listed
-		below. Depending on the installed options, additional values are available. A complete list of all supported values can
-		be displayed using TRIGger:...:CATalog:SOURce?. \n
-			:return: source: 'IF Power': IF power trigger 'Free Run': free run (untriggered)
+		Selects the source of the trigger events. Some values are always available. They are listed below. Depending on the
+		installed options, additional values are available. You can query a list of all supported values via TRIGger:...
+		:CATalog:SOURce?. \n
+			:return: source: string 'IF Power': IF power trigger 'Free Run': free run (untriggered)
 		"""
 		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:IQVSlot:SOURce?')
 		return trim_str_response(response)
 
 	def set_source(self, source: str) -> None:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:IQVSlot:SOURce \n
-		Snippet: driver.trigger.iqVsSlot.set_source(source = '1') \n
-		Selects the source of the trigger events. Some values are always available in this firmware application. They are listed
-		below. Depending on the installed options, additional values are available. A complete list of all supported values can
-		be displayed using TRIGger:...:CATalog:SOURce?. \n
-			:param source: 'IF Power': IF power trigger 'Free Run': free run (untriggered)
+		Snippet: driver.trigger.iqVsSlot.set_source(source = 'abc') \n
+		Selects the source of the trigger events. Some values are always available. They are listed below. Depending on the
+		installed options, additional values are available. You can query a list of all supported values via TRIGger:...
+		:CATalog:SOURce?. \n
+			:param source: string 'IF Power': IF power trigger 'Free Run': free run (untriggered)
 		"""
 		param = Conversions.value_to_quoted_str(source)
 		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:IQVSlot:SOURce {param}')
 
 	def get_mgap(self) -> float:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:IQVSlot:MGAP \n
 		Snippet: value: float = driver.trigger.iqVsSlot.get_mgap() \n
 		Sets a minimum time during which the IF signal must be below the trigger threshold before the trigger is armed so that an
 		IF power trigger event can be generated. \n
-			:return: minimum_gap: Range: 0 s to 0.01 s, Unit: s
+			:return: minimum_gap: numeric Range: 0 s to 0.01 s, Unit: s
 		"""
 		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:IQVSlot:MGAP?')
 		return Conversions.str_to_float(response)
 
 	def set_mgap(self, minimum_gap: float) -> None:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:IQVSlot:MGAP \n
 		Snippet: driver.trigger.iqVsSlot.set_mgap(minimum_gap = 1.0) \n
 		Sets a minimum time during which the IF signal must be below the trigger threshold before the trigger is armed so that an
 		IF power trigger event can be generated. \n
-			:param minimum_gap: Range: 0 s to 0.01 s, Unit: s
+			:param minimum_gap: numeric Range: 0 s to 0.01 s, Unit: s
 		"""
 		param = Conversions.decimal_value_to_str(minimum_gap)
 		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:IQVSlot:MGAP {param}')
 
 	def get_offset(self) -> float:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:IQVSlot:OFFSet \n
 		Snippet: value: float = driver.trigger.iqVsSlot.get_offset() \n
 		Defines a delay time for triggered measurements. The trigger offset delays the start of the measurement relative to the
 		trigger event. \n
-			:return: offset: Range: 0 s to 1 s, Unit: s
+			:return: offset: numeric Range: 0 s to 1 s, Unit: s
 		"""
 		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:IQVSlot:OFFSet?')
 		return Conversions.str_to_float(response)
 
 	def set_offset(self, offset: float) -> None:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:IQVSlot:OFFSet \n
 		Snippet: driver.trigger.iqVsSlot.set_offset(offset = 1.0) \n
 		Defines a delay time for triggered measurements. The trigger offset delays the start of the measurement relative to the
 		trigger event. \n
-			:param offset: Range: 0 s to 1 s, Unit: s
+			:param offset: numeric Range: 0 s to 1 s, Unit: s
 		"""
 		param = Conversions.decimal_value_to_str(offset)
 		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:IQVSlot:OFFSet {param}')
 
 	def get_timeout(self) -> float or bool:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:IQVSlot:TOUT \n
 		Snippet: value: float or bool = driver.trigger.iqVsSlot.get_timeout() \n
-		Selects the maximum time that the R&S CMW waits for a trigger event before it stops the measurement in remote control
-		mode or indicates a trigger timeout in manual operation mode. This setting has no influence on 'Free Run' measurements. \n
-			:return: timeout: Range: 0.01 s to 300 s, Unit: s Additional values: OFF | ON (disables | enables the timeout check) .
+		Selects the maximum time that the measurement waits for a trigger event before it stops in remote control mode or
+		indicates a trigger timeout in manual operation mode. This setting has no influence on 'Free Run' measurements. \n
+			:return: timeout: (float or boolean) numeric | ON | OFF Range: 0.01 s to 300 s, Unit: s ON | OFF enables or disables the timeout check.
 		"""
 		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:IQVSlot:TOUT?')
 		return Conversions.str_to_float_or_bool(response)
 
 	def set_timeout(self, timeout: float or bool) -> None:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:IQVSlot:TOUT \n
 		Snippet: driver.trigger.iqVsSlot.set_timeout(timeout = 1.0) \n
-		Selects the maximum time that the R&S CMW waits for a trigger event before it stops the measurement in remote control
-		mode or indicates a trigger timeout in manual operation mode. This setting has no influence on 'Free Run' measurements. \n
-			:param timeout: Range: 0.01 s to 300 s, Unit: s Additional values: OFF | ON (disables | enables the timeout check) .
+		Selects the maximum time that the measurement waits for a trigger event before it stops in remote control mode or
+		indicates a trigger timeout in manual operation mode. This setting has no influence on 'Free Run' measurements. \n
+			:param timeout: (float or boolean) numeric | ON | OFF Range: 0.01 s to 300 s, Unit: s ON | OFF enables or disables the timeout check.
 		"""
 		param = Conversions.decimal_or_bool_value_to_str(timeout)
 		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:IQVSlot:TOUT {param}')
 
 	def get_threshold(self) -> float:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:IQVSlot:THReshold \n
 		Snippet: value: float = driver.trigger.iqVsSlot.get_threshold() \n
 		Defines the trigger threshold for power trigger sources. \n
-			:return: threshold: Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
+			:return: threshold: numeric Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
 		"""
 		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:IQVSlot:THReshold?')
 		return Conversions.str_to_float(response)
 
 	def set_threshold(self, threshold: float) -> None:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:IQVSlot:THReshold \n
 		Snippet: driver.trigger.iqVsSlot.set_threshold(threshold = 1.0) \n
 		Defines the trigger threshold for power trigger sources. \n
-			:param threshold: Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
+			:param threshold: numeric Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
 		"""
 		param = Conversions.decimal_value_to_str(threshold)
 		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:IQVSlot:THReshold {param}')
 
 	# noinspection PyTypeChecker
 	def get_slope(self) -> enums.SignalSlopeExt:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:IQVSlot:SLOPe \n
@@ -159,14 +159,14 @@
 		Selects the measurement sequence that is triggered by each single trigger event. This setting is not valid for free run
 		measurements. \n
 			:param mode: ONCE | PRESelect ONCE: 'Trigger Once' PRESelect: 'Retrigger Preselect'
 		"""
 		param = Conversions.enum_scalar_to_str(mode, enums.TriggerSequenceMode)
 		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:IQVSlot:MODE {param}')
 
-	def clone(self) -> 'IqVsSlot':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'IqVsSlotCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = IqVsSlot(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = IqVsSlotCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/IqVsSlot_/Catalog.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/IqVsSlot/Catalog.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,22 +2,22 @@
 
 from ....Internal.Core import Core
 from ....Internal.CommandsGroup import CommandsGroup
 from ....Internal import Conversions
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Catalog:
-	"""Catalog commands group definition. 1 total commands, 0 Sub-groups, 1 group commands"""
+class CatalogCls:
+	"""Catalog commands group definition. 1 total commands, 0 Subgroups, 1 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("catalog", core, parent)
+		self._cmd_group = CommandsGroup("catalog", core, parent)
 
 	def get_source(self) -> List[str]:
 		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:IQVSlot:CATalog:SOURce \n
 		Snippet: value: List[str] = driver.trigger.iqVsSlot.catalog.get_source() \n
 		Lists all trigger source values that can be set using method RsCmwGprfMeas.Trigger.IqVsSlot.source. \n
-			:return: trigger_sources: Comma-separated list of all supported values. Each value is represented as a string.
+			:return: trigger_sources: string Comma-separated list of all supported values. Each value is represented as a string.
 		"""
 		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:IQVSlot:CATalog:SOURce?')
 		return Conversions.str_to_str_list(response)
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/Power.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/Spectrum/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,180 +1,151 @@
-from ...Internal.Core import Core
-from ...Internal.CommandsGroup import CommandsGroup
-from ...Internal import Conversions
-from ...Internal.Utilities import trim_str_response
-from ... import enums
+from ....Internal.Core import Core
+from ....Internal.CommandsGroup import CommandsGroup
+from ....Internal import Conversions
+from ....Internal.Utilities import trim_str_response
+from .... import enums
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Power:
-	"""Power commands group definition. 10 total commands, 2 Sub-groups, 7 group commands"""
+class SpectrumCls:
+	"""Spectrum commands group definition. 7 total commands, 1 Subgroups, 6 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("power", core, parent)
-
-	@property
-	def parameterSetList(self):
-		"""parameterSetList commands group. 1 Sub-classes, 0 commands."""
-		if not hasattr(self, '_parameterSetList'):
-			from .Power_.ParameterSetList import ParameterSetList
-			self._parameterSetList = ParameterSetList(self._core, self._base)
-		return self._parameterSetList
+		self._cmd_group = CommandsGroup("spectrum", core, parent)
 
 	@property
 	def catalog(self):
 		"""catalog commands group. 0 Sub-classes, 1 commands."""
 		if not hasattr(self, '_catalog'):
-			from .Power_.Catalog import Catalog
-			self._catalog = Catalog(self._core, self._base)
+			from .Catalog import CatalogCls
+			self._catalog = CatalogCls(self._core, self._cmd_group)
 		return self._catalog
 
 	def get_source(self) -> str:
-		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:SOURce \n
-		Snippet: value: str = driver.trigger.power.get_source() \n
-		Selects the source of the trigger events. Some values are always available in this firmware application. They are listed
-		below. Depending on the installed options, additional values are available. A complete list of all supported values can
-		be displayed using TRIGger:...:CATalog:SOURce?. \n
-			:return: source: 'IF Power': IF power trigger 'Free Run': free run (untriggered)
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:SPECtrum:SOURce \n
+		Snippet: value: str = driver.trigger.spectrum.get_source() \n
+		Selects the source of the trigger events. Some values are always available. They are listed below. Depending on the
+		installed options, additional values are available. You can query a list of all supported values via TRIGger:...
+		:CATalog:SOURce?. \n
+			:return: source: string 'Free Run': free run (untriggered) 'Video': power trigger at video band
 		"""
-		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:POWer:SOURce?')
+		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:SPECtrum:SOURce?')
 		return trim_str_response(response)
 
 	def set_source(self, source: str) -> None:
-		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:SOURce \n
-		Snippet: driver.trigger.power.set_source(source = '1') \n
-		Selects the source of the trigger events. Some values are always available in this firmware application. They are listed
-		below. Depending on the installed options, additional values are available. A complete list of all supported values can
-		be displayed using TRIGger:...:CATalog:SOURce?. \n
-			:param source: 'IF Power': IF power trigger 'Free Run': free run (untriggered)
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:SPECtrum:SOURce \n
+		Snippet: driver.trigger.spectrum.set_source(source = 'abc') \n
+		Selects the source of the trigger events. Some values are always available. They are listed below. Depending on the
+		installed options, additional values are available. You can query a list of all supported values via TRIGger:...
+		:CATalog:SOURce?. \n
+			:param source: string 'Free Run': free run (untriggered) 'Video': power trigger at video band
 		"""
 		param = Conversions.value_to_quoted_str(source)
-		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:POWer:SOURce {param}')
+		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:SPECtrum:SOURce {param}')
 
-	def get_mgap(self) -> float:
-		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:MGAP \n
-		Snippet: value: float = driver.trigger.power.get_mgap() \n
-		Sets a minimum time during which the IF signal must be below the trigger threshold before the trigger is armed so that an
-		IF power trigger event can be generated. \n
-			:return: minimum_gap: Range: 0 s to 0.01 s, Unit: s
+	def get_threshold(self) -> float:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:SPECtrum:THReshold \n
+		Snippet: value: float = driver.trigger.spectrum.get_threshold() \n
+		Defines the trigger threshold for power trigger sources. \n
+			:return: threshold: numeric Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
 		"""
-		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:POWer:MGAP?')
+		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:SPECtrum:THReshold?')
 		return Conversions.str_to_float(response)
 
-	def set_mgap(self, minimum_gap: float) -> None:
-		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:MGAP \n
-		Snippet: driver.trigger.power.set_mgap(minimum_gap = 1.0) \n
-		Sets a minimum time during which the IF signal must be below the trigger threshold before the trigger is armed so that an
-		IF power trigger event can be generated. \n
-			:param minimum_gap: Range: 0 s to 0.01 s, Unit: s
+	def set_threshold(self, threshold: float) -> None:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:SPECtrum:THReshold \n
+		Snippet: driver.trigger.spectrum.set_threshold(threshold = 1.0) \n
+		Defines the trigger threshold for power trigger sources. \n
+			:param threshold: numeric Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
 		"""
-		param = Conversions.decimal_value_to_str(minimum_gap)
-		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:POWer:MGAP {param}')
+		param = Conversions.decimal_value_to_str(threshold)
+		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:SPECtrum:THReshold {param}')
 
-	def get_timeout(self) -> float or bool:
-		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:TOUT \n
-		Snippet: value: float or bool = driver.trigger.power.get_timeout() \n
-		Selects the maximum time that the R&S CMW waits for a trigger event before it stops the measurement in remote control
-		mode or indicates a trigger timeout in manual operation mode. This setting has no influence on 'Free Run' measurements. \n
-			:return: timeout: Range: 0.01 s to 300 s, Unit: s Additional values: OFF | ON (disables | enables the timeout check) .
+	# noinspection PyTypeChecker
+	def get_slope(self) -> enums.SignalSlopeExt:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:SPECtrum:SLOPe \n
+		Snippet: value: enums.SignalSlopeExt = driver.trigger.spectrum.get_slope() \n
+		Qualifies whether the trigger event is generated at the rising or at the falling edge of the trigger pulse (valid for
+		external and power trigger sources) . \n
+			:return: slope: REDGe | FEDGe REDGe: rising edge FEDGe: falling edge
 		"""
-		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:POWer:TOUT?')
-		return Conversions.str_to_float_or_bool(response)
+		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:SPECtrum:SLOPe?')
+		return Conversions.str_to_scalar_enum(response, enums.SignalSlopeExt)
 
-	def set_timeout(self, timeout: float or bool) -> None:
-		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:TOUT \n
-		Snippet: driver.trigger.power.set_timeout(timeout = 1.0) \n
-		Selects the maximum time that the R&S CMW waits for a trigger event before it stops the measurement in remote control
-		mode or indicates a trigger timeout in manual operation mode. This setting has no influence on 'Free Run' measurements. \n
-			:param timeout: Range: 0.01 s to 300 s, Unit: s Additional values: OFF | ON (disables | enables the timeout check) .
+	def set_slope(self, slope: enums.SignalSlopeExt) -> None:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:SPECtrum:SLOPe \n
+		Snippet: driver.trigger.spectrum.set_slope(slope = enums.SignalSlopeExt.FALLing) \n
+		Qualifies whether the trigger event is generated at the rising or at the falling edge of the trigger pulse (valid for
+		external and power trigger sources) . \n
+			:param slope: REDGe | FEDGe REDGe: rising edge FEDGe: falling edge
 		"""
-		param = Conversions.decimal_or_bool_value_to_str(timeout)
-		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:POWer:TOUT {param}')
+		param = Conversions.enum_scalar_to_str(slope, enums.SignalSlopeExt)
+		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:SPECtrum:SLOPe {param}')
 
-	def get_offset(self) -> float:
-		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:OFFSet \n
-		Snippet: value: float = driver.trigger.power.get_offset() \n
-		Defines a delay time for triggered measurements. The trigger offset delays the start of the measurement relative to the
-		trigger event. \n
-			:return: offset: Range: 0 s to 1 s, Unit: s
+	def get_mgap(self) -> float:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:SPECtrum:MGAP \n
+		Snippet: value: float = driver.trigger.spectrum.get_mgap() \n
+		Sets a minimum time during which the IF signal must be below the trigger threshold before the trigger is armed so that an
+		IF power trigger event can be generated. \n
+			:return: minimum_gap: numeric Range: 0 s to 0.01 s, Unit: s
 		"""
-		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:POWer:OFFSet?')
+		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:SPECtrum:MGAP?')
 		return Conversions.str_to_float(response)
 
-	def set_offset(self, offset: float) -> None:
-		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:OFFSet \n
-		Snippet: driver.trigger.power.set_offset(offset = 1.0) \n
-		Defines a delay time for triggered measurements. The trigger offset delays the start of the measurement relative to the
-		trigger event. \n
-			:param offset: Range: 0 s to 1 s, Unit: s
-		"""
-		param = Conversions.decimal_value_to_str(offset)
-		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:POWer:OFFSet {param}')
-
-	# noinspection PyTypeChecker
-	def get_mode(self) -> enums.TriggerPowerMode:
-		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:MODE \n
-		Snippet: value: enums.TriggerPowerMode = driver.trigger.power.get_mode() \n
-		Selects the measurement sequence that is triggered by each single trigger event. This setting is not valid for free run
-		measurements. \n
-			:return: mode: ONCE | SWEep | ALL | PRESelect ONCE: 'Trigger Once' SWEep: 'Retrigger Sweep' ALL: 'Retrigger All' PRESelect: 'Retrigger Preselect'
-		"""
-		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:POWer:MODE?')
-		return Conversions.str_to_scalar_enum(response, enums.TriggerPowerMode)
-
-	def set_mode(self, mode: enums.TriggerPowerMode) -> None:
-		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:MODE \n
-		Snippet: driver.trigger.power.set_mode(mode = enums.TriggerPowerMode.ALL) \n
-		Selects the measurement sequence that is triggered by each single trigger event. This setting is not valid for free run
-		measurements. \n
-			:param mode: ONCE | SWEep | ALL | PRESelect ONCE: 'Trigger Once' SWEep: 'Retrigger Sweep' ALL: 'Retrigger All' PRESelect: 'Retrigger Preselect'
+	def set_mgap(self, minimum_gap: float) -> None:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:SPECtrum:MGAP \n
+		Snippet: driver.trigger.spectrum.set_mgap(minimum_gap = 1.0) \n
+		Sets a minimum time during which the IF signal must be below the trigger threshold before the trigger is armed so that an
+		IF power trigger event can be generated. \n
+			:param minimum_gap: numeric Range: 0 s to 0.01 s, Unit: s
 		"""
-		param = Conversions.enum_scalar_to_str(mode, enums.TriggerPowerMode)
-		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:POWer:MODE {param}')
+		param = Conversions.decimal_value_to_str(minimum_gap)
+		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:SPECtrum:MGAP {param}')
 
-	def get_threshold(self) -> float:
-		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:THReshold \n
-		Snippet: value: float = driver.trigger.power.get_threshold() \n
-		Defines the trigger threshold for power trigger sources. \n
-			:return: threshold: Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
+	def get_offset(self) -> float:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:SPECtrum:OFFSet \n
+		Snippet: value: float = driver.trigger.spectrum.get_offset() \n
+		Defines the trigger offset, i.e. the offset of a triggered zero span measurement relative to the corresponding trigger
+		event. \n
+			:return: trigger_offset: numeric Range: -0.5 s to 0.5 s, Unit: s
 		"""
-		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:POWer:THReshold?')
+		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:SPECtrum:OFFSet?')
 		return Conversions.str_to_float(response)
 
-	def set_threshold(self, threshold: float) -> None:
-		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:THReshold \n
-		Snippet: driver.trigger.power.set_threshold(threshold = 1.0) \n
-		Defines the trigger threshold for power trigger sources. \n
-			:param threshold: Range: -50 dB to 0 dB, Unit: dB (full scale, i.e. relative to reference level minus external attenuation)
+	def set_offset(self, trigger_offset: float) -> None:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:SPECtrum:OFFSet \n
+		Snippet: driver.trigger.spectrum.set_offset(trigger_offset = 1.0) \n
+		Defines the trigger offset, i.e. the offset of a triggered zero span measurement relative to the corresponding trigger
+		event. \n
+			:param trigger_offset: numeric Range: -0.5 s to 0.5 s, Unit: s
 		"""
-		param = Conversions.decimal_value_to_str(threshold)
-		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:POWer:THReshold {param}')
+		param = Conversions.decimal_value_to_str(trigger_offset)
+		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:SPECtrum:OFFSet {param}')
 
-	# noinspection PyTypeChecker
-	def get_slope(self) -> enums.SignalSlopeExt:
-		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:SLOPe \n
-		Snippet: value: enums.SignalSlopeExt = driver.trigger.power.get_slope() \n
-		Qualifies whether the trigger event is generated at the rising or at the falling edge of the trigger pulse (valid for
-		external and power trigger sources) . \n
-			:return: event: REDGe | FEDGe REDGe: rising edge FEDGe: falling edge
+	def get_timeout(self) -> float or bool:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:SPECtrum:TOUT \n
+		Snippet: value: float or bool = driver.trigger.spectrum.get_timeout() \n
+		Selects the maximum time that the measurement waits for a trigger event before it stops in remote control mode or
+		indicates a trigger timeout in manual operation mode. This setting has no influence on 'Free Run' measurements. \n
+			:return: trigger_timeout: (float or boolean) numeric | ON | OFF Range: 0.01 s to 300 s, Unit: s ON | OFF enables or disables the timeout check.
 		"""
-		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:POWer:SLOPe?')
-		return Conversions.str_to_scalar_enum(response, enums.SignalSlopeExt)
+		response = self._core.io.query_str('TRIGger:GPRF:MEASurement<Instance>:SPECtrum:TOUT?')
+		return Conversions.str_to_float_or_bool(response)
 
-	def set_slope(self, event: enums.SignalSlopeExt) -> None:
-		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:SLOPe \n
-		Snippet: driver.trigger.power.set_slope(event = enums.SignalSlopeExt.FALLing) \n
-		Qualifies whether the trigger event is generated at the rising or at the falling edge of the trigger pulse (valid for
-		external and power trigger sources) . \n
-			:param event: REDGe | FEDGe REDGe: rising edge FEDGe: falling edge
+	def set_timeout(self, trigger_timeout: float or bool) -> None:
+		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:SPECtrum:TOUT \n
+		Snippet: driver.trigger.spectrum.set_timeout(trigger_timeout = 1.0) \n
+		Selects the maximum time that the measurement waits for a trigger event before it stops in remote control mode or
+		indicates a trigger timeout in manual operation mode. This setting has no influence on 'Free Run' measurements. \n
+			:param trigger_timeout: (float or boolean) numeric | ON | OFF Range: 0.01 s to 300 s, Unit: s ON | OFF enables or disables the timeout check.
 		"""
-		param = Conversions.enum_scalar_to_str(event, enums.SignalSlopeExt)
-		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:POWer:SLOPe {param}')
+		param = Conversions.decimal_or_bool_value_to_str(trigger_timeout)
+		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:SPECtrum:TOUT {param}')
 
-	def clone(self) -> 'Power':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'SpectrumCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = Power(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = SpectrumCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/Power_/ParameterSetList.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Trigger/Power/ParameterSetList/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-from ....Internal.Core import Core
-from ....Internal.CommandsGroup import CommandsGroup
+from .....Internal.Core import Core
+from .....Internal.CommandsGroup import CommandsGroup
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class ParameterSetList:
-	"""ParameterSetList commands group definition. 2 total commands, 1 Sub-groups, 0 group commands"""
+class ParameterSetListCls:
+	"""ParameterSetList commands group definition. 2 total commands, 1 Subgroups, 0 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("parameterSetList", core, parent)
+		self._cmd_group = CommandsGroup("parameterSetList", core, parent)
 
 	@property
 	def offset(self):
 		"""offset commands group. 0 Sub-classes, 2 commands."""
 		if not hasattr(self, '_offset'):
-			from .ParameterSetList_.Offset import Offset
-			self._offset = Offset(self._core, self._base)
+			from .Offset import OffsetCls
+			self._offset = OffsetCls(self._core, self._cmd_group)
 		return self._offset
 
-	def clone(self) -> 'ParameterSetList':
-		"""Clones the group by creating new object from it and its whole existing sub-groups
+	def clone(self) -> 'ParameterSetListCls':
+		"""Clones the group by creating new object from it and its whole existing subgroups
 		Also copies all the existing default Repeated Capabilities setting,
 		which you can change independently without affecting the original group"""
-		new_group = ParameterSetList(self._core, self._base.parent)
-		self._base.synchronize_repcaps(new_group)
+		new_group = ParameterSetListCls(self._core, self._cmd_group.parent)
+		self._cmd_group.synchronize_repcaps(new_group)
 		return new_group
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Implementations/Trigger_/Power_/ParameterSetList_/Offset.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Implementations/Configure/Power/ListPy/ParameterSetList.py`

 * *Files 27% similar despite different names*

```diff
@@ -5,51 +5,51 @@
 from .....Internal import Conversions
 from .....Internal.Types import DataType
 from .....Internal.ArgSingleList import ArgSingleList
 from .....Internal.ArgSingle import ArgSingle
 
 
 # noinspection PyPep8Naming,PyAttributeOutsideInit,SpellCheckingInspection
-class Offset:
-	"""Offset commands group definition. 2 total commands, 0 Sub-groups, 2 group commands"""
+class ParameterSetListCls:
+	"""ParameterSetList commands group definition. 2 total commands, 0 Subgroups, 2 group commands"""
 
 	def __init__(self, core: Core, parent):
 		self._core = core
-		self._base = CommandsGroup("offset", core, parent)
+		self._cmd_group = CommandsGroup("parameterSetList", core, parent)
 
-	def set(self, index: int, trigger_offset: float) -> None:
-		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:PSET:OFFSet \n
-		Snippet: driver.trigger.power.parameterSetList.offset.set(index = 1, trigger_offset = 1.0) \n
-		Defines a delay time relative to the trigger event for a particular parameter set <Index>. \n
-			:param index: Number of the parameter set Range: 0 to 31
-			:param trigger_offset: Range: 0 s to 1 s, Unit: s
+	def set(self, index: int, parameter_set: int) -> None:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:PSET \n
+		Snippet: driver.configure.power.listPy.parameterSetList.set(index = 1, parameter_set = 1) \n
+		Selects the parameter set for segment <Index>. \n
+			:param index: integer Range: 0 to 3999
+			:param parameter_set: numeric Range: 0 to 31
 		"""
-		param = ArgSingleList().compose_cmd_string(ArgSingle('index', index, DataType.Integer), ArgSingle('trigger_offset', trigger_offset, DataType.Float))
-		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:POWer:PSET:OFFSet {param}'.rstrip())
+		param = ArgSingleList().compose_cmd_string(ArgSingle('index', index, DataType.Integer), ArgSingle('parameter_set', parameter_set, DataType.Integer))
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:PSET {param}'.rstrip())
 
-	def get(self, index: int) -> float:
-		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:PSET:OFFSet \n
-		Snippet: value: float = driver.trigger.power.parameterSetList.offset.get(index = 1) \n
-		Defines a delay time relative to the trigger event for a particular parameter set <Index>. \n
-			:param index: Number of the parameter set Range: 0 to 31
-			:return: trigger_offset: Range: 0 s to 1 s, Unit: s"""
+	def get(self, index: int) -> int:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:PSET \n
+		Snippet: value: int = driver.configure.power.listPy.parameterSetList.get(index = 1) \n
+		Selects the parameter set for segment <Index>. \n
+			:param index: integer Range: 0 to 3999
+			:return: parameter_set: numeric Range: 0 to 31"""
 		param = Conversions.decimal_value_to_str(index)
-		response = self._core.io.query_str(f'TRIGger:GPRF:MEASurement<Instance>:POWer:PSET:OFFSet? {param}')
-		return Conversions.str_to_float(response)
+		response = self._core.io.query_str(f'CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:PSET? {param}')
+		return Conversions.str_to_int(response)
 
-	def get_all(self) -> List[float]:
-		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:PSET:OFFSet:ALL \n
-		Snippet: value: List[float] = driver.trigger.power.parameterSetList.offset.get_all() \n
-		Defines a delay time relative to the trigger event for all parameter sets. \n
-			:return: trigger_offset: Comma-separated list of 32 trigger offsets, for parameter set no. 0 to 31 Range: 0 s to 1 s, Unit: s
+	def get_all(self) -> List[int]:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:PSET:ALL \n
+		Snippet: value: List[int] = driver.configure.power.listPy.parameterSetList.get_all() \n
+		Selects the parameter set for all segments. \n
+			:return: parameter_set: numeric Comma-separated list of parameter set numbers, one value per segment. Range: 0 to 31
 		"""
-		response = self._core.io.query_bin_or_ascii_float_list('TRIGger:GPRF:MEASurement<Instance>:POWer:PSET:OFFSet:ALL?')
+		response = self._core.io.query_bin_or_ascii_int_list('CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:PSET:ALL?')
 		return response
 
-	def set_all(self, trigger_offset: List[float]) -> None:
-		"""SCPI: TRIGger:GPRF:MEASurement<Instance>:POWer:PSET:OFFSet:ALL \n
-		Snippet: driver.trigger.power.parameterSetList.offset.set_all(trigger_offset = [1.1, 2.2, 3.3]) \n
-		Defines a delay time relative to the trigger event for all parameter sets. \n
-			:param trigger_offset: Comma-separated list of 32 trigger offsets, for parameter set no. 0 to 31 Range: 0 s to 1 s, Unit: s
+	def set_all(self, parameter_set: List[int]) -> None:
+		"""SCPI: CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:PSET:ALL \n
+		Snippet: driver.configure.power.listPy.parameterSetList.set_all(parameter_set = [1, 2, 3]) \n
+		Selects the parameter set for all segments. \n
+			:param parameter_set: numeric Comma-separated list of parameter set numbers, one value per segment. Range: 0 to 31
 		"""
-		param = Conversions.list_to_csv_str(trigger_offset)
-		self._core.io.write(f'TRIGger:GPRF:MEASurement<Instance>:POWer:PSET:OFFSet:ALL {param}')
+		param = Conversions.list_to_csv_str(parameter_set)
+		self._core.io.write(f'CONFigure:GPRF:MEASurement<Instance>:POWer:LIST:PSET:ALL {param}')
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/ArgLinkedEventArgs.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/ArgLinkedEventArgs.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""Class defining Linked argument Event."""
+
 import time
 
 
 class ArgLinkedEventArgs(object):
 	"""Contains event data for suppressed argument."""
 
 	def __init__(self, link_name: str, arg_name: str, value: object = None, context: str = '', timestamp: time = None):
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/ArgSingle.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/ArgSingle.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,54 +1,57 @@
+"""Single argument definition for a scalar argument."""
+
 from .ConverterFromScpiString import ConverterFromScpiString
 from .ConverterToScpiString import ConverterToScpiString
+from .InstrumentErrors import RsInstrException
+
 from .Types import DataType
 
 
 class ArgSingle(object):
 	"""Single Argument outside a structure - used for composing query arguments.
 	Contains the argument value as well (self.value)."""
 
-	def __init__(self, name: str, value, data_type: DataType, is_optional: bool = False, is_open_list: bool = False, repetition: int = 1, intern_link: str = None):
+	def __init__(self, name: str, value, data_type: DataType, enum_type=None, is_optional: bool = False, is_open_list: bool = False, repetition: int = 1, intern_link: str = None):
 		self.name = name if name else ''
 		self.argument_ix = None
 		self.value = value
 		self.data_type = data_type
+		self.enum_type = enum_type
 		self.is_optional = is_optional
 		self.is_open_list = is_open_list
 		self.repetition = repetition
 		self.intern_link = intern_link
 		self.conv_from_scpi_string = None
 		self.conv_to_scpi_string = None
 
-		if self.data_type == DataType.Enum:
-			self.assert_mandatory_has_value(self)
-			if self.value is not None:
-				self.enum_type = type(self.value)
-				self.conv_from_scpi_string = ConverterFromScpiString(self.data_type, self.enum_type)
-				self.conv_to_scpi_string = ConverterToScpiString(self.data_type, self.enum_type)
-		elif self.data_type == DataType.EnumList:
-			self.assert_mandatory_has_value(self)
+		if self.data_type.is_scalar_enum:
+			# self.assert_mandatory_has_value(self)
+			self.conv_from_scpi_string = ConverterFromScpiString(self.data_type, self.enum_type)
+			self.conv_to_scpi_string = ConverterToScpiString(self.data_type, self.enum_type)
+		elif self.data_type.is_list_enum:
+			# self.assert_mandatory_has_value(self)
 			if self.value is not None:
-				self.enum_type = type(self.value[0])
 				self.conv_from_scpi_string = ConverterFromScpiString(self.data_type, self.enum_type)
 				self.conv_to_scpi_string = ConverterToScpiString(self.data_type, self.enum_type)
 		else:
 			self.conv_from_scpi_string = ConverterFromScpiString(self.data_type)
 			self.conv_to_scpi_string = ConverterToScpiString(self.data_type)
 
 		self.check_consistency()
 
 	@classmethod
-	def as_open_list(cls, name: str, value: object, data_type: DataType) -> 'ArgSingle':
+	def as_open_list(cls, name: str, value: object, data_type: DataType, enum_type=None) -> 'ArgSingle':
 		"""Creates new ArgSingle of open list type.Use this method for all non-interleaved list types. \n
-		:param name: name of the argument.
-		:param value: value of the argument.
-		:param data_type: data type of the argument.
-		:return: ArgSingle object of an open list type."""
-		return cls(name, value, data_type, False, True, 1, None)
+		:param name: name of the argument
+		:param value: value of the argument
+		:param data_type: data type of the argument
+		:param enum_type: enum type if the data_type is Enum or EnumExt (or list of those)
+		:return: ArgSingle object of an open list type"""
+		return cls(name, value, data_type, enum_type, False, True, 1, None)
 
 	def __str__(self):
 		opt = '~' if self.is_optional else ''
 		name = f" '{self.name}'" if self.name != '' else ''
 		out = f"SingleArg {opt}{self.data_type.name}{name}"
 
 		if self.is_open_list is False and self.repetition > 1:
@@ -72,15 +75,15 @@
 
 	# noinspection PyUnusedLocal
 	def assert_is_optional(self, obj=None) -> None:
 		"""Asserts that the parameter is optional.
 		If not, the method throws an exception."""
 		if self.is_optional:
 			return
-		raise Exception(f'Single argument is not optional: {self}')
+		raise RsInstrException(f'Single argument is not optional: {self}')
 
 	# noinspection PyUnusedLocal
 	def assert_mandatory_has_value(self, value_obj=None) -> None:
 		"""Asserts that if the parameter is mandatory, it must have value assigned.
 		If not, the method throws an exception."""
 		if self.is_optional:
 			return
@@ -93,11 +96,11 @@
 
 	def check_consistency(self) -> None:
 		"""Checks the consistency of the object"""
 		if self.value is None:
 			return
 		if isinstance(self.value, list):
 			if self.data_type.is_scalar:
-				raise Exception(f'Argument real data type is list, but it is declared as {self.data_type}. Value: {self.value}')
+				raise RsInstrException(f'Argument real data type is list, but it is declared as {self.data_type}. Value: {self.value}')
 		else:
 			if self.data_type.is_list:
-				raise Exception(f'Argument real data type is scalar, but it is declared as {self.data_type}. Value: {self.value}')
+				raise RsInstrException(f'Argument real data type is scalar, but it is declared as {self.data_type}. Value: {self.value}')
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/ArgSingleList.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/ArgSingleList.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""Single argument definition for a list argument."""
+
 from .ArgSingle import ArgSingle
 from .ArgStringComposer import compose_cmd_string_from_single_args
 
 
 class ArgSingleList(object):
 	"""Contains methods for composing cmd string for the list of single arguments.
 	Used in methods with 1+ set or query arguments.
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/ArgSingleSuppressed.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/ArgSingleSuppressed.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,7 +1,10 @@
+"""Contains definition for an argument that is suppressed and not exposed to the user.
+Usually such arguments are also linked to a callback."""
+
 from .Types import DataType
 
 
 class ArgSingleSuppressed(object):
 	"""Single suppressed Argument - used in Query_XxXx_Suppressed() to remove it from the returned value.
 	It does not contain:
 	- 'value' attribute, since this is discarded or linked internally directly  in the Query_XxXx_Suppressed().
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/ArgStringComposer.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/ArgStringComposer.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,14 +6,15 @@
 The composing of the SCPI parameter string is similar for the ArgStruct and ArgSingle[] objects, therefore they share the same module."""
 
 from typing import Dict
 
 from .ArgSingle import ArgSingle
 from .ArgStruct import ArgStruct
 from .Utilities import get_plural_string
+from .InstrumentErrors import RsInstrException
 
 
 class SingleComposer:
 	"""Composes strings for single argument.
 	Provides Composer interface with 3 functions:
 	- from_scalar_arg
 	- from_list_arg
@@ -135,15 +136,15 @@
 					# The last argument, ignore the repetitions and convert the whole list to string
 					string_arg.append(composer.from_list_arg(arg))
 				else:
 					# The optional argument, which has no value. End the entire string_arg composition
 					arg.assert_is_optional(values_obj)
 					opt_null_ix = arg_ix
 			else:
-				# More than one arguments remaining. Loop through them interleaving the result strings
+				# More than one argument remaining. Loop through them interleaving the result strings
 				# Interleaving arguments must all have values
 
 				# Check if each list has at least Repetition number of elements
 				cycles_error = False
 				alignments_error = False
 				cycle = -1
 				data = {}
@@ -151,19 +152,18 @@
 					arg = args[x]
 					curr_size: int = composer.get_arg_list_size(arg)
 					curr_cycle: int = curr_size // arg.repetition
 					curr_align: int = curr_size % arg.repetition
 					data[x] = (curr_size, curr_cycle, curr_align)
 
 					if curr_size < 0:
-						raise Exception(
-							f"Argument '{arg.name}' has repetitions, therefore it must be declared as a list. Current Declaration: '{arg.data_type}'")
+						raise RsInstrException(f"Argument '{arg.name}' has repetitions, therefore it must be declared as a list. Current Declaration: '{arg.data_type}'")
 
 					if arg.repetition > curr_size:
-						raise Exception(f"Argument '{arg.name}' has repetitions {arg.repetition}, but its list size is only {curr_size}")
+						raise RsInstrException(f"Argument '{arg.name}' has repetitions {arg.repetition}, but its list size is only {curr_size}")
 
 					# noinspection PyChainedComparisons
 					if cycle >= 0 and curr_cycle != cycle:
 						cycles_error = True
 
 					cycle = curr_cycle
 
@@ -171,23 +171,21 @@
 						alignments_error = True
 
 				if cycles_error:
 					message = 'Arguments interleaving is not aligned - all the cycles must be the same. Actual cycles:\n'
 					for x in range(arg_ix, arg_count):
 						message += f'{args[x].name}[{data[x][0]}] sliced by {get_plural_string("element", args[x].repetition)} ' \
 							f'results in {data[x][0] / args[x].repetition} cycles\n'
-
-					raise Exception(message)
+					raise RsInstrException(message)
 
 				if alignments_error:
 					message = 'At least one argument has a list size not dividable by the defined repetitions:\n'
 					for x in range(arg_ix, arg_count):
 						message += f'{args[x].name}[{data[x][0]}] modulo {args[x].repetition}x results in {data[x][0] % args[x].repetition}\n'
-
-					raise Exception(message)
+					raise RsInstrException(message)
 
 				for x in range(cycle):
 					for y in range(arg_ix, arg_count):
 						arg = args[y]
 						string_arg.append(composer.from_list_arg(arg, arg.repetition * x, arg.repetition))
 
 	if opt_null_ix >= 0:
@@ -198,15 +196,15 @@
 			if arg.has_value(values_obj):
 				rest.append(arg.name)
 
 		if len(rest):
 			msg = f"Optional Argument '{args[opt_null_ix].name}' has no value, but the further ones do. " \
 				f"If you skip an optional argument, you have to skip all the ones following it. " \
 				f"Clear the values for the rest of the argument(s):\n{', '.join(rest)}"
-			raise Exception(msg)
+			raise RsInstrException(msg)
 
 	return ','.join(string_arg)
 
 
 def compose_cmd_string_from_single_args(args: Dict[int, ArgSingle]) -> str:
 	"""Returns SCPI-composed string based on the single args specification.
 	We can use the same function as for the struct arguments, with the difference of providing a SingleComposer.
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/ArgStruct.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/ArgStruct.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,13 @@
+"""Definition for an argument which is a part of a structure."""
+
 from .ConverterFromScpiString import ConverterFromScpiString
 from .ConverterToScpiString import ConverterToScpiString
 from .Types import DataType
+from .InstrumentErrors import RsInstrException
 
 
 class ArgStruct(object):
 	"""Describes an argument in data structures.
 	This info is used to parse a string query response to the output structure,
 	or to parse the output structure to the string parameter for writing.
 	Contains reference to the value in the owning structure."""
@@ -121,17 +124,17 @@
 	def assert_is_optional(self, obj) -> None:
 		"""Asserts that the parameter is optional.
 		If not, the method throws an exception."""
 		if self.is_optional:
 			return
 		value = getattr(obj, self.name)
 		if value is None:
-			raise Exception(f"Structure '{obj}', argument without value is not optional: {self}")
+			raise RsInstrException(f"Structure '{obj}', argument without value is not optional: {self}")
 		else:
-			raise Exception(f"Structure '{obj}', argument is not optional: {self}', value '{value}'")
+			raise RsInstrException(f"Structure '{obj}', argument is not optional: {self}', value '{value}'")
 
 	def assert_mandatory_has_value(self, obj) -> None:
 		"""Asserts that if the parameter is mandatory, it must have value assigned.
 		If not, the method throws an exception."""
 		if self.is_optional:
 			return
 		if getattr(obj, self.name) is None:
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/ArgStructList.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/ArgStructList.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,13 @@
+"""See the class docstring."""
+
 from .ArgStringComposer import StructComposer, compose_cmd_string_from_struct_args
 from .ArgStructStringParser import ArgStructStringParser
 from .StructBase import StructBase
+from .InstrumentErrors import RsInstrException
 
 
 class ArgStructList(object):
 	"""Contains methods for composing cmd string and parsing cmd response to the provided structure instance."""
 
 	RAW_DATA_PROP_NAME = 'RawReturnData'
 
@@ -53,22 +56,22 @@
 			# Still some args to go
 			if arg.is_open_list is True:
 				# The previous loop ended because the next argument had is_open_list True
 				if arg_ix == (arg_count - 1):
 					# This is the last argument, ignore the repetitions and take the whole rest of the elements
 					parser.to_list_value(arg, True, 0, parser.remaining, parser.remaining, 1)
 				else:
-					# More than one arguments remaining. Loop through them interleaving the result strings
+					# More than one argument remaining. Loop through them interleaving the result strings
 					open_list_args = {key: value for key, value in self.args.items() if key >= arg_ix}
 
 					# Accumulate the number of repetitions from all the open_list_args
 					period: int = sum(open_list_args[ix].repetition for ix in open_list_args)
 					reminder: int = parser.remaining % period
 					if reminder != 0:
-						raise Exception(
+						raise RsInstrException(
 							f'Arguments parsing is not aligned - source string elements remaining to parse {parser.remaining}'
 							f'is not dividable by the summary Period {period} of all the open list arguments:\n' + '\n'.join(['{}'.format(x) for x in open_list_args]))
 					# Go through the arguments and accumulate the list content
 					offset = 0
 					for x in open_list_args:
 						arg = open_list_args[x]
 						parser.to_list_value(arg, False, offset, arg.repetition, period, -1)
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/ArgStructStringParser.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/ArgStructStringParser.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,9 +1,12 @@
+"""See the class docstring."""
+
 from . import Utilities
 from .ArgStruct import ArgStruct
+from .InstrumentErrors import RsInstrException
 
 
 class ArgStructStringParser:
 	"""Class for parsing a response from the instrument to an output structure of arguments.
 	It is used by the ArgStructList class for filling structures with return values."""
 
 	def __init__(self, struct, value: str):
@@ -17,34 +20,34 @@
 		"""Remaining items to parse."""
 		return self.count - self.position
 
 	def to_scalar_value(self, arg: ArgStruct):
 		"""Parses the current element to a scalar argument."""
 		assert arg.data_type.is_scalar, f'to_scalar_value() method only works with scalar values. Data type: {arg.data_type}'
 		if self.position >= self.count:
-			raise Exception(
+			raise RsInstrException(
 				f"Cannot parse a scalar value to structure argument. Response contains only {self.count} elements, "
 				f"argument '{arg.name}' has position {self.position + 1}.\n"
 				f"Response (commas replaced by new lines):\n" + Utilities.truncate_string_from_end('\n'.join(self.elements), 1000))
 		string = self.elements[self.position]
 		value = arg.conv_from_scpi_string.get_one_element_value(string)
 		setattr(self.struct, arg.name, value)
 		self.position += 1
 
 	def to_list_value(self, arg: ArgStruct, increase_pos: bool, offset: int, count: int, period: int, cycles: int) -> None:
 		"""Parses more elements to the list argument - slicing."""
 		assert arg.data_type.is_list, f'to_list_value method only works with list values. Data type: {arg.data_type}'
 		if cycles < 0:
 			cycles = self.remaining // period
 		if self.position >= self.count:
-			raise Exception(
+			raise RsInstrException(
 				f"Cannot parse an list value to the argument '{arg.name}', "
 				f"because the element position {self.position} is over the parsed list length {self.count}")
 		if (self.position + offset + count) > self.count:
-			raise Exception(
+			raise RsInstrException(
 				f"Cannot parse the whole list value to the argument '{arg.name}', because the element position {self.position} "
 				f"plus the argument offset {offset} and argument length {count} would be over the parsed list length {self.count}")
 
 		result = []
 		for cycle in range(cycles):
 			start_ix = self.position + (cycle * period) + offset
 			for i in range(count):
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/CommandsGroup.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/CommandsGroup.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""See the class docstring."""
+
 from enum import Enum
 from typing import List
 from .Core import Core
 from .RepeatedCapability import RepeatedCapability as RepCap
 from .InstrumentErrors import DriverValueError
 
 
@@ -38,27 +40,27 @@
 		return self.multi_repcap_types != ''
 
 	def add_existing_child(self, child: 'CommandsGroup') -> None:
 		"""Adds the child to the parent's list of created children.
 		This is used when the group is cloned, where the whole existing tree of groups have to be recreated"""
 		self.existing_children.append(child)
 
-	def set_repcap_enum_value(self, enum_value: Enum) -> None:
-		"""Sets RepCap value as enum
-		Default is not allowed."""
+	def set_repcap_enum_value(self, enum_value: Enum or int) -> None:
+		"""Sets RepCap value as enum or integer
+		Default is not allowed here."""
 		try:
 			self.rep_cap.set_enum_value(enum_value)
 		except ValueError:
 			raise DriverValueError(self.io.resource_name, f"Commands group RepCap value '{self.rep_cap.name}.Default' cannot be set. Please select a concrete value.")
 
 	def get_repcap_enum_value(self) -> Enum:
 		"""Returns RepCap value as enum"""
 		return self.rep_cap.get_enum_value()
 
-	def get_repcap_cmd_value(self, enum_value: Enum, enum_type) -> str:
+	def get_repcap_cmd_value(self, enum_value: Enum or int, enum_type) -> str:
 		"""Returns the current string of RepCapCmdValue for the entered RepCapEnumName
 		The enum_value can be a repcap of the current CommandsGroup or any of their parents"""
 		# Use the static functions of the RepeatedCapability to get the non-default value
 		# It is faster, since there is no need to use the RepCap instance
 		if not RepCap.clsm_is_default_value(enum_value, enum_type):
 			return RepCap.clsm_get_cmd_string_value(enum_value, enum_type)
 		# Default value - get it from the group or the parent groups
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/Conversions.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/Conversions.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,14 +1,20 @@
+"""Contains conversion functions for SCPI string -> parameter and vice versa."""
+
 import math
 import struct
 import sys
 from enum import Enum
-from typing import List
+from typing import List, Tuple
+from .ScpiEnums import ScpiEnum, enum_spec_prefixes, enum_spec_strings
+from .Properties import Properties
+from datetime import datetime
 
 from . import Utilities
+from .InstrumentErrors import RsInstrException
 
 
 class BinFloatFormat(Enum):
 	"""Binary format of a float number."""
 	Single_4bytes = 1
 	Single_4bytes_swapped = 2
 	Double_8bytes = 3
@@ -24,15 +30,15 @@
 
 
 def assert_string_data(value: str) -> None:
 	"""Asserts value is string type."""
 	assert isinstance(value, str), f"Input value type must be string. Actual type: {type(value)}, value: {value}"
 
 
-def assert_list_data(value: list) -> None:
+def assert_list_data(value: List) -> None:
 	"""Asserts value is list type."""
 	assert isinstance(value, list), f"Input value type must be a list. Actual type: {type(value)}, value: {value}"
 
 
 def _get_endianness_symbol(swap_endianness: bool) -> str:
 	"""Based on the current endianness returns the symbol used in the 'struct' module."""
 	if swap_endianness is False:
@@ -143,15 +149,15 @@
 bool_true_lookup = frozenset(['1', 'on', 'On', 'ON', 'true', 'True', 'TRUE'])
 bool_false_lookup = frozenset(['0', 'off', 'Off', 'OFF', 'false', 'False', 'FALSE'])
 pure_bool_false_lookup = frozenset(['off', 'Off', 'OFF', 'false', 'False', 'FALSE'])
 
 
 def str_to_bool(string: str) -> bool:
 	"""Converts string to boolean value.
-	The function robust, and case insensitive.
+	The function is robust, and case-insensitive.
 	If the string can not be converted to a boolean, the function returns False."""
 	assert_string_data(string)
 	if string in bool_true_lookup:
 		return True
 	if string in bool_false_lookup:
 		return False
 	# If leading/trailing spaces
@@ -193,24 +199,38 @@
 
 
 number_plus_inf_lookup = frozenset(['Inf', 'INF', 'INFINITY', '+Inf', '+INF', '+inf', '+INFINITY', '+Infinity', '+infinity'])
 number_minus_inf_lookup = frozenset(['-Inf', '-INF', '-inf', '-INFINITY', '-Infinity', '-infinity'])
 number_nan_lookup = frozenset(['Nan', 'NAN', 'nan', 'NaN', 'NAV', 'NaV', 'NCAP', 'INV', 'NONE', 'none', 'None', 'DTX', 'UND', 'und'])
 number_max_lookup = frozenset(['OFL', 'ofl', 'Ofl'])
 number_min_lookup = frozenset(['UFL', 'ufl', 'Ufl'])
+number_si_suffix = {
+	'pHz': 1E-12, 'MHz': 1E+6, 'kHz': 1E+3, 'GHz': 1E+9, 'mHz': 1E-3, 'uHz': 1E-6, 'µHz': 1E-6, 'THz': 1E+12, 'nHz': 1E-9, 'ns': 1E-9, 'fW': 1E-15,
+	'pW': 1E-12, 'nW': 1E-9, 'uW': 1E-6, 'µW': 1E-6, 'mW': 1E-3, 'kW': 1E3, 'MW': 1E6, 'GW': 1E9, 'MV': 1E+6, 'MA': 1E+6, 'ps': 1E-12, 'fs': 1E-15,
+	'km': 1E+3, 'kV': 1E+3, 'kA': 1E+3, 'pF': 1E-2, 'Hz': 1.0, 'mm': 1E-3, 'mA': 1E-3, 'mF': 1E-3, 'mV': 1E-3, 'pV': 1E-12, 'nF': 1E-9, 'nA': 1E-9,
+	'nV': 1E-9, 'nm': 1E-9, 'pm': 1E-12, 'us': 1E-6, 'µs': 1E-6, 'uF': 1E-6, 'µF': 1E-6, 'ms': 1E-3, 'uA': 1E-6, 'µA': 1E-6, 'uV': 1E-6, 'µV': 1E-6,
+	'um': 1E-6, 'µm': 1E-6, 'pA': 1E-12, 'V': 1, 'W': 1, 'A': 1, 'F': 1, 's': 1, 'm': 1}
 int_neg_inf = -(sys.maxsize - 1)
-enum_spec_prefixes = {'_minus': '-', '_plus': '+', '_': ''}
-enum_spec_strings = {'_dash_': '-', '_dot_': '.'}
+
+
+def strip_si_suffix(string: str) -> Tuple[bool, str, float]:
+	"""Tries to find defined suffixes in the text and returns the stripped text and the multiplier as double number.
+	If no known suffix is detected, the method returns false, strippedText=text, multiplier=1.0
+	Example: text='123 MHz' strippedText='123' multiplier=1E6"""
+	for suffix in number_si_suffix.keys():
+		if string.endswith(suffix):
+			return True, string[:-len(suffix)].rstrip(), number_si_suffix[suffix]
+	return False, string, 1.0
 
 
 def str_to_int(string: str) -> int:
 	"""Converts string to integer value. Float values are coerced to integer.
-	Also recognizes case insensitive special values like NaN, INV, NCAP..."""
+	Also recognizes case-insensitive special values like NaN, INV, NCAP..."""
 	assert_string_data(string)
-	string = string.strip()
+	string = string.strip(" \t\r\n'\"")
 	if string == '':
 		return 0
 	value = str_special_values_to_int(string)
 	if value:
 		return value
 
 	# Hexadecimal numbers
@@ -232,15 +252,24 @@
 		if ',' in string:
 			return int(string[2:string.find(',')], 8)
 		else:
 			return int(string[2:], 8)
 	# Simulation
 	if string == 'Simulating':
 		return 0
-	return int(round(float(string)))
+	try:
+		return int(round(float(string)))
+	except ValueError:
+		result = strip_si_suffix(string)
+		if result[0] is False:
+			raise
+		try:
+			return int(round(float(result[1]) * result[2]))
+		except ValueError:
+			raise ValueError(f"could not convert string to integer: '{string}'")
 
 
 def str_special_values_to_int(string: str) -> int:
 	"""Converts special string values to integer. Returns None if no special value was found."""
 	assert_string_data(string)
 	if string in number_plus_inf_lookup or string in number_max_lookup:
 		return sys.maxsize
@@ -270,17 +299,17 @@
 	if result is not None:
 		return result
 	return str_to_int(string)
 
 
 def str_to_float(string: str) -> float:
 	"""Converts string to float value.
-	Also recognizes case insensitive special values like NaN, INV, NCAP..."""
+	Also recognizes case-insensitive special values like NaN, INV, NCAP..."""
 	assert_string_data(string)
-	string = string.strip()
+	string = string.strip(" \t\r\n'\"")
 	if string == '':
 		return 0.0
 	if string in number_plus_inf_lookup:
 		return math.inf
 	if string in number_minus_inf_lookup:
 		return -math.inf
 	if string in number_nan_lookup:
@@ -299,15 +328,24 @@
 		return -sys.float_info.max / 100
 	if string == 'ULEU':
 		return sys.float_info.max / 10
 	if string == 'ULEL':
 		return -sys.float_info.max / 10
 	if string == 'Simulating':
 		return 0.0
-	return float(string)
+	try:
+		return float(string)
+	except ValueError:
+		result = strip_si_suffix(string)
+		if result[0] is False:
+			raise
+		try:
+			return float(result[1]) * result[2]
+		except ValueError:
+			raise ValueError(f"could not convert string to float: '{string}'")
 
 
 def str_to_float_or_bool(string: str) -> float or bool:
 	"""Similar to str_to_float, but for special values "ON/OFF" the function returns boolean"""
 	result = string_to_pure_bool(string)
 	if result is not None:
 		return result
@@ -320,24 +358,24 @@
 
 
 def bool_to_str(value: bool) -> str:
 	"""Converts boolean to 'ON' or 'OFF' string."""
 	if type(value) is bool:
 		return 'ON' if value is True else 'OFF'
 	else:
-		raise Exception(f"bool_to_str: unsupported variable type '{type(value)}', value '{value}'. Only boolean values are supported.")
+		raise RsInstrException(f"bool_to_str: unsupported variable type '{type(value)}', value '{value}'. Only boolean values are supported.")
 
 
 def str_enclose_by_quotes(string: str) -> str:
 	"""Returns string enclosed by single quotes."""
 	assert_string_data(string)
-	return "'" + string + "'"
+	return Properties.scpi_quotes + string + Properties.scpi_quotes
 
 
-def list_to_csv_str(value: list) -> str:
+def list_to_csv_str(value: List, delimiter: str = ',') -> str:
 	"""Converts list of elements to strings separated by commas.
 	Element types can differ on an individual basis.
 	Supported element types:
 	- int
 	- bool
 	- float
 	- string -> string no quotes
@@ -345,18 +383,18 @@
 	assert_list_data(value)
 	result = []
 	for x in value:
 		el = value_to_str(x)
 		if not el:
 			raise TypeError(f"List element type is not supported by Conversions.list_to_csv_str: '{x}'")
 		result.append(el)
-	return ','.join(result)
+	return delimiter.join(result)
 
 
-def list_to_csv_quoted_str(value: list) -> str:
+def list_to_csv_quoted_str(value: List) -> str:
 	"""Converts list of elements to quoted strings separated by commas.
 	Only string elements are enclosed by single quotes
 	Element types can differ on an individual basis.
 	Supported element types:
 	- int
 	- bool
 	- float
@@ -368,29 +406,28 @@
 		if isinstance(x, str):
 			el = str_enclose_by_quotes(x)
 		else:
 			el = value_to_str(x)
 		if not el:
 			raise TypeError(f"List element type is not supported by Conversions.list_to_csv_quoted_str: '{x}'")
 		result.append(el)
-
 	return ','.join(result)
 
 
 def decimal_value_to_str(x: int or float) -> str:
 	"""Converts scalar decimal value to string.
 	Supported element types:
 	- int
 	- float"""
 	if isinstance(x, int) and type(x) is not bool:
 		return str(x)
 	elif isinstance(x, float):
 		return float_to_str(x)
 	else:
-		raise Exception(f"decimal_value_to_str: unsupported variable type '{type(x)}', value '{x}'. Only integer and float types are supported.")
+		raise RsInstrException(f"decimal_value_to_str: unsupported variable type '{type(x)}', value '{x}'. Only integer and float types are supported.")
 
 
 def decimal_or_bool_value_to_str(x: int or float or bool) -> str:
 	"""Converts scalar decimal value to string.
 	Supported element types:
 	- int
 	- float
@@ -398,15 +435,15 @@
 	if type(x) is bool:
 		return bool_to_str(x)
 	if isinstance(x, int):
 		return str(x)
 	elif isinstance(x, float):
 		return float_to_str(x)
 	else:
-		raise Exception(f"decimal_or_bool_value_to_str: unsupported variable type '{type(x)}', value '{x}'. Only integer, float and boolean types are supported.")
+		raise RsInstrException(f"decimal_or_bool_value_to_str: unsupported variable type '{type(x)}', value '{x}'. Only integer, float and boolean types are supported.")
 
 
 def value_to_str(x: int or bool or float or str or Enum) -> str:
 	"""Converts scalar value to string.
 	Supported element types:
 	- int
 	- bool
@@ -418,17 +455,19 @@
 	elif isinstance(x, int):
 		return str(x)
 	elif isinstance(x, float):
 		return float_to_str(x)
 	elif isinstance(x, str):
 		return x
 	elif isinstance(x, Enum):
+		if isinstance(x.value, str):
+			return enum_value_to_scpi_string(x.value)
 		return enum_value_to_scpi_string(x.name)
 	else:
-		raise Exception(f"value_to_str: unsupported variable type '{type(x)}', value '{x}'. Supported types: int, bool, float, str, enum.")
+		raise RsInstrException(f"value_to_str: unsupported variable type '{type(x)}', value '{x}'. Supported types: int, bool, float, str, enum.")
 
 
 def enum_value_to_scpi_string(enum_value: str) -> str:
 	"""Conversion EnumValue -> SCPI_String
 	Unescapes all the special characters that can not be contained in the enum member definition, but can be sent to the instrument as enum string.
 	Use this to send the scpi enum value to the instrument."""
 	for key in enum_spec_prefixes:
@@ -443,15 +482,15 @@
 	"""Converts scalar value to string enclosed by single quotes.
 	Supported element types:
 	- int
 	- bool
 	- float
 	- string
 	- enum"""
-	return f"'{value_to_str(x)}'"
+	return Properties.scpi_quotes + value_to_str(x) + Properties.scpi_quotes
 
 
 def str_to_float_list(string: str) -> List[float]:
 	"""Converts string with comma-separated values to list of Floats."""
 	assert_string_data(string)
 	if not string:
 		return []
@@ -504,103 +543,158 @@
 		return []
 	result = [*map(Utilities.trim_str_response, string.split(','))]
 	if clear_one_empty_item and len(result) == 1 and result[0] == '':
 		return []
 	return result
 
 
-def _find_in_enum_members(item: str, enum_members: List[str]) -> int:
-	"""Matches a string in the provided list of member strings.
-	The item must be not fully matched.
-	The item is matched if a member string starts with the item (the item is a prefix of the member).
-	Example: item='CONN' will match the enum_member 'CONNected'
-	If the item contains a comma, only the value before comma is considered
-	Returns found index in the enum_members list"""
-	if ',' in item:
-		item = item[:item.index(',')].strip()
-	i = 0
-	for x in enum_members:
-		if x.startswith(item):
-			return i
-		i += 1
-
-	# smart matching:
-	# item = 'MAX' matches enum 'MAXpeak'
-	# item = 'SPECtrum1' matches enum 'SPEC1'
-	# item = 'SPEC' matches enum 'SPECtrum1'
-
-	item = ''.join([c for c in item if not c.islower()])
-	# item must be longer than 1 character
-	if len(item) < 2:
-		return -1
-	i = 0
-	for x in enum_members:
-		x_uc = ''.join([c for c in x if not c.islower()])
-		if x_uc == item:
-			return i
-		i += 1
-	return -1
-
-
-def str_to_scalar_enum_helper(string: str, enum_type: Enum, enum_members=None) -> Enum:
+def str_to_scalar_enum_helper(string: str, scpi_enum: ScpiEnum, array_search: bool, exc_if_not_found) -> Enum:
 	"""Converts string to one enum element.
-	enum_members are optional to improve the performance for repeated conversions.
-	If you do not provide them, they are generated inside the function."""
-	value = Utilities.trim_str_response(string)
-	if not enum_members:
-		# noinspection PyTypeChecker
-		enum_members = [x.name for x in enum_type]
-
-	# Search in the enum member and return the index of the matched item
-	ix = _find_in_enum_members(value, enum_members)
-	if ix >= 0:
-		# noinspection PyUnresolvedReferences
-		return enum_type[enum_members[ix]]
-
-	# If the result is -1 (not found), try to replace the special values and search again
-	# This is done to improve the performance, since most of the enums have no special values
-	enum_members_conv = [enum_value_to_scpi_string(x) for x in enum_members]
-	ix = _find_in_enum_members(value, enum_members_conv)
-	if ix >= 0:
-		# noinspection PyUnresolvedReferences
-		return enum_type[enum_members[ix]]
-
+	array_search signal no need to force the comma removing,
+	because the elements definitely do not have any commas - commas have been used to split string to the list of strings
+	The function can also return:
+	- integer special value, if the string was not found in the enum, and it is a special value.
+	- input string, if the string was not found and raise_if_not_found is set to False - used for the EnumExt types."""
+	if scpi_enum.has_quotes:
+		value = Utilities.trim_str_response(string, mode=Utilities.TrimStringMode.white_chars_double_quotes)
+	else:
+		value = Utilities.trim_str_response(string)
+	enum_value = scpi_enum.find_in_enum_members(value, False)
+	if enum_value is not None:
+		return enum_value
+	if array_search is False:
+		# If the result is still -1 (not found), try to force removing the comma in the string.
+		enum_value = scpi_enum.find_in_enum_members(value, True)
+		if enum_value is not None:
+			return enum_value
 	# If not found, search in the special integer numbers:
 	spec_value = str_special_values_to_int(value)
-	if not spec_value:
-		raise Exception(f"String '{value}' can not be found in the enum type '{enum_type}'")
+	if spec_value:
+		# noinspection PyTypeChecker
+		return spec_value
+	if exc_if_not_found:
+		raise RsInstrException(f"String '{value}' can not be found in the enum type '{scpi_enum.enum_type}'")
 	# noinspection PyTypeChecker
-	return spec_value
+	return Utilities.trim_str_response(string)
 
 
-def str_to_list_enum_helper(string: str, enum_type: Enum, enum_members=None) -> List[Enum]:
-	"""Converts string to list of enum elements.
-	enum_members are optional to improve the performance for repeated conversions.
-	If you do not provide them, they are generated inside the function."""
-	if not enum_members:
-		# noinspection PyTypeChecker
-		enum_members = [x.name for x in enum_type]
+def str_to_simple_scalar_enum(string: str, enum_type, case_sensitive: bool = True, ignore_underscores: bool = False) -> Enum or None:
+	"""Converts string to one enum element.
+	Does not handle special value or non-mandatory parts.
+	The function is used in core only for standard enum conversions, not for SCPI enum conversions."""
+	value = Utilities.trim_str_response(string)
+	enum_members = [x.name for x in enum_type]
+	enum_members_mod = [x.name for x in enum_type]
+	if not case_sensitive:
+		enum_members_mod = [x.upper() for x in enum_members]
+		value = value.upper()
+	if ignore_underscores:
+		enum_members_mod = [x.replace('_', '') for x in enum_members_mod]
+		value = value.replace('_', '')
+	if value in enum_members_mod:
+		return enum_type[enum_members[enum_members_mod.index(value)]]
+	return None
+
+
+def str_to_list_enum_helper(string: str, scpi_enum: ScpiEnum, exc_if_not_found: bool = True) -> List[Enum]:
+	"""Converts string to list of enum elements. separated by comma"""
 	elements = string.split(',')
-	return [str_to_scalar_enum_helper(x, enum_type, enum_members) for x in elements]
+	return [str_to_scalar_enum_helper(x, scpi_enum, True, exc_if_not_found) for x in elements]
 
 
 def enum_scalar_to_str(data, enum_type) -> str:
 	"""Converts enum scalar value to string."""
 	assert isinstance(data, enum_type), f"Expected command parameter {enum_type}, actual data type: {type(data)}. Value: {data}"
 	return value_to_str(data)
 
 
+def enum_ext_scalar_to_str(data, enum_type) -> str:
+	"""Converts enum scalar value to string.
+	If the input value is string, the function returns the string with single quotes."""
+	if isinstance(data, str):
+		# Return string with quotes
+		return value_to_quoted_str(Utilities.trim_str_response(data))
+	assert isinstance(data, enum_type), f"Expected command parameter string or {enum_type}, actual data type: {type(data)}. Value: {data}"
+	return value_to_str(data)
+
+
 def enum_list_to_str(data: List, enum_type) -> str:
 	"""Converts enum list to csv-string."""
 	# For enums, check that each element is an enum
 	assert all(isinstance(x, enum_type) for x in data), f"Expected command parameter list of {enum_type}, detected one or more elements of non-enum type. Value: {data}"
 	return list_to_csv_str(data)
 
 
+def enum_ext_list_to_str(data: List, enum_type) -> str:
+	"""Converts enum list to csv-string. Allows the elements to be either enum or string."""
+	assert all((isinstance(x, enum_type or str) or isinstance(x, str)) for x in data), f"Expected command parameter list of strings or {enum_type}, detected one or more elements of non-enum/non-string type. Value: {data}"
+	return list_to_csv_quoted_str(data)
+
+
 def str_to_scalar_enum(string: str, enum_type) -> Enum:
-	"""Converts string to one enum element."""
-	return str_to_scalar_enum_helper(string, enum_type)
+	"""Converts string to one enum element.
+	Throws exception if the string can not be converted to an enum element or a special value."""
+	return str_to_scalar_enum_helper(string, ScpiEnum(enum_type), False, exc_if_not_found=True)
+
+
+def str_to_scalar_enum_ext(string: str, enum_type) -> Enum:
+	"""Converts string to one enum element.
+	Compared to str_to_scalar_enum, in case the string can not be converted, it is returned trimmed for quotes and ."""
+	return str_to_scalar_enum_helper(string, ScpiEnum(enum_type), False, exc_if_not_found=False)
 
 
 def str_to_list_enum(string: str, enum_type) -> List[Enum]:
 	"""Converts string to list of enum elements."""
-	return str_to_list_enum_helper(string, enum_type)
+	return str_to_list_enum_helper(string, ScpiEnum(enum_type))
+
+
+def str_to_list_enum_ext(string: str, enum_type) -> List[Enum]:
+	"""Converts string to list of enum or string elements."""
+	return str_to_list_enum_helper(string, ScpiEnum(enum_type), exc_if_not_found=False)
+
+
+def convert_ts_to_datetime(timestamp: datetime or float) -> datetime:
+	"""Converts timestamp as float to datetime. For datetime tuple it just passes the value."""
+	if isinstance(timestamp, float) or isinstance(timestamp, int):
+		return datetime.fromtimestamp(timestamp)
+	return timestamp
+
+
+def get_timestamp_string(timestamp: datetime or float) -> str:
+	"""Returns the timestamp as string. The timestamp can be a datetime tuple or float seconds coming from the time.time()."""
+	timestamp = convert_ts_to_datetime(timestamp)
+	cur_time = timestamp.strftime('%H:%M:%S.%f')[:-3]
+	return cur_time
+
+
+def get_timedelta_fixed_string(time_start: datetime or float, time_end: datetime or float) -> str:
+	"""Returns the time span as string - fixed in the format of '%H:%M:%S.%f'."""
+	time_a = convert_ts_to_datetime(time_start)
+	time_b = convert_ts_to_datetime(time_end)
+	frac = (time_b - time_a).total_seconds()
+	wh = math.floor(frac)
+	d = int(wh / 86400)
+	h = int((wh - (d * 86400)) / 3600)
+	m = int((wh - (d * 86400 + h * 3600)) / 60)
+	s = int((wh - (d * 86400 + h * 3600 + m * 60)))
+	ms = int((frac - wh) * 1000)
+	res = f'{h:02d}:{m:02d}:{s:02d}.{ms:03d}'
+	if d > 0:
+		res = f'{d}d ' + res
+	return res
+
+
+def get_timedelta_string(time_a: datetime or float, time_b: datetime or float) -> str:
+	"""Returns the time span as string - dynamic based on the difference."""
+	time_a = convert_ts_to_datetime(time_a)
+	time_b = convert_ts_to_datetime(time_b)
+	if time_b < time_a:
+		return '0.000 ms'
+	diff = time_b - time_a
+	if diff.seconds < 10:
+		return f'{diff.total_seconds() * 1000:0.3f} ms'
+	elif diff.seconds < 1000:
+		a = diff.total_seconds()
+		return f'{a:0.3f} secs'
+	hours, remainder = divmod(diff.seconds, 3600)
+	minutes, seconds = divmod(remainder, 60)
+	return f'{hours:02d}:{minutes:02d}:{seconds:02d}'
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/ConverterFromScpiString.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/ConverterFromScpiString.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,28 +1,32 @@
+"""See the class docstring."""
+
 from enum import Enum
 
 from .Conversions import str_to_bool, str_to_int, str_to_int_or_bool, str_to_float, str_to_float_or_bool, str_to_scalar_enum_helper
 from .Conversions import str_to_str_list, str_to_bool_list, str_to_int_list, str_to_int_or_bool_list, str_to_float_list, str_to_float_or_bool_list, str_to_list_enum_helper
 from .Types import DataType
 from .Utilities import trim_str_response
+from .InstrumentErrors import RsInstrException
+from .ScpiEnums import ScpiEnum
 
 
 class ConverterFromScpiString:
 	"""Converter from SCPI response string to argument value
 	For list argument types, you must use the method get_one_element_value in a loop for each element.
 	Provides methods:
 	- get_one_element_value(str): returns one scalar value converted from the SCPI string.
 	- get_list_value(str): return complete list value converted from the SCPI string.
 	- get_value(str): calls either get_one_element_value or get_list_value() depending on the data type. \n
 	The reason for the different methods is, that sometimes the list data are interleaved with other arguments.
 	In order to parse them properly, the ArgStructStringParser module must be able to set the argument value element-by-element.
-	On the other side, the driver methods might want to set the whole argument value, because the result scpi string is a single argument response."""
+	The driver methods might want to set the whole argument value, because the result scpi string is a single argument response."""
 
 	def __init__(self, data_type: DataType, enum_type: Enum = None):
-		self.enum_type = enum_type
+		self.scpi_enum = None
 		self.data_type = data_type
 		self.element_type = self.data_type.element_type
 
 		if self.element_type == DataType.RawString:
 			self.converter = trim_str_response
 			self.list_converter = str_to_str_list
 
@@ -46,30 +50,29 @@
 			self.converter = str_to_float
 			self.list_converter = str_to_float_list
 
 		elif self.element_type == DataType.FloatExt:
 			self.converter = str_to_float_or_bool
 			self.list_converter = str_to_float_or_bool_list
 
-		elif self.element_type == DataType.Enum:
-			assert self.enum_type, f"For data type enum, you have to define the enum_type variable."
+		elif self.element_type.is_scalar_enum:
+			assert enum_type, f"For data type enum, you have to define the enum_type variable."
 			# noinspection PyTypeChecker
-			self.enum_members = [x.name for x in self.enum_type]
+			self.scpi_enum = ScpiEnum(enum_type)
 		else:
-			raise Exception(f"Unsupported data type '{data_type}'")
+			raise RsInstrException(f"Unsupported data type '{data_type}'")
 
 	def get_one_element_value(self, scpi_string: str):
-		"""Returns single element !!! of the argument value converted from the SCPI string (single element)"""
+		"""Returns single element (not an array!!!) of the argument value converted from the SCPI string (single element)"""
 		assert isinstance(scpi_string, str), f"Input parameter scpi_string must be string. Actual parameter: {type(scpi_string)}, value: {scpi_string}"
-		if self.element_type is DataType.Enum:
-			return str_to_scalar_enum_helper(scpi_string, self.enum_type, self.enum_members)
+		if self.element_type.is_scalar_enum:
+			return str_to_scalar_enum_helper(scpi_string, self.scpi_enum, False, exc_if_not_found=self.element_type == DataType.Enum)
 		return self.converter(scpi_string)
 
 	def get_value(self, scpi_string: str):
 		"""Returns complete value of the argument converted from the SCPI string (list or scalar)"""
 		if not self.data_type.is_list:
 			return self.get_one_element_value(scpi_string)
-
 		assert isinstance(scpi_string, str), f"Input parameter scpi_string must be string. Actual parameter: {type(scpi_string)}, value: {scpi_string}"
 		if self.element_type is DataType.Enum:
-			return str_to_list_enum_helper(scpi_string, self.enum_type, self.enum_members)
+			return str_to_list_enum_helper(scpi_string, self.scpi_enum, exc_if_not_found=self.element_type == DataType.Enum)
 		return self.list_converter(scpi_string)
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/ConverterToScpiString.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/ConverterToScpiString.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,16 +1,19 @@
+"""See the class docstring."""
+
 from enum import Enum
 
-from .Conversions import list_to_csv_quoted_str, value_to_quoted_str, list_to_csv_str, value_to_str, enum_list_to_str, enum_scalar_to_str
+from .Conversions import list_to_csv_quoted_str, value_to_quoted_str, list_to_csv_str, value_to_str, enum_list_to_str, enum_scalar_to_str, enum_ext_scalar_to_str, enum_ext_list_to_str
 from .Types import DataType
+from .InstrumentErrors import RsInstrException
 
 
-def value_to_scpi_string(data, data_type: DataType):
-	"""Method to be used in the driver implementation.
-	Convert data to SCPI string parameter: data -> str"""
+def value_to_scpi_string(data, data_type: DataType) -> str:
+	"""Convert data to SCPI string parameter: data -> str.
+	Does not work with enum data types."""
 	if data_type.is_list:
 		assert isinstance(data, list), f"Expected command parameter list, actual data type: {type(data)}. Value: {data}"
 	else:
 		assert not isinstance(data, list), f"Expected command parameter scalar, actual data type: {type(data)}. Value: {data}"
 	# Strings are enclosed by single quotes
 	if data_type == DataType.StringList:
 		assert all(isinstance(x, str) for x in data), f"Expected command parameter list of strings, detected one or more elements of non-string type. Value: {data}"
@@ -46,35 +49,37 @@
 	elif data_type == DataType.IntegerExtList or data_type == DataType.FloatExtList:
 		assert all((isinstance(x, int) or isinstance(x, float) or isinstance(x, bool)) for x in data), f"Expected command parameter list of numbers or booleans, detected one or more elements of non-number type. Value: {data}"
 		return list_to_csv_str(data)
 	elif data_type == DataType.IntegerExt or data_type == DataType.FloatExt:
 		assert (isinstance(data, int) or isinstance(data, float) or isinstance(data, bool)), f"Expected command parameter number or boolean, actual data type: {type(data)}. Value: {data}"
 		return value_to_str(data)
 	else:
-		raise Exception(f"Unsupported data type: '{type(data_type)}'.")
+		raise RsInstrException(f"Unsupported data type: '{type(data_type)}'.")
 
 
 class ConverterToScpiString:
 	"""Converter from argument value to SCPI string.
 	Provides method get_value(arg_value) -> str
 	"""
 
 	def __init__(self, data_type: DataType, enum_type: Enum = None):
 		self.enum_type = enum_type
 		self.data_type = data_type
 		self.element_type = self.data_type.element_type
-		if self.element_type == DataType.Enum:
+		if self.element_type == DataType.Enum or self.element_type == DataType.EnumExt:
 			assert self.enum_type, f"For data_type {data_type.name}, you have to define the enum_type variable."
 
 	def get_value(self, data) -> str:
 		"""Returns SCPI string converted from the argument data."""
 		if self.data_type.is_list:
 			assert isinstance(data, list), f"Expected command parameter list, actual data type: {type(data)}. Value: {data}"
 		else:
 			assert not isinstance(data, list), f"Expected command parameter scalar, actual data type: {type(data)}. Value: {data}"
-
 		if self.data_type == DataType.Enum:
 			return enum_scalar_to_str(data, self.enum_type)
-		elif self.data_type == DataType.EnumList:
+		if self.data_type == DataType.EnumExt:
+			return enum_ext_scalar_to_str(data, self.enum_type)
+		if self.data_type == DataType.EnumList:
 			return enum_list_to_str(data, self.enum_type)
-
+		if self.data_type == DataType.EnumExtList:
+			return enum_ext_list_to_str(data, self.enum_type)
 		return value_to_scpi_string(data, self.data_type)
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/Core.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/Core.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,28 +1,126 @@
-import re
+"""See the class docstring."""
+
 from typing import Callable
 
-from . import InstrumentOptions as Options, Conversions as Conv
+from . import InstrumentOptions as Options
 from .ArgSingle import ArgSingle
 from .ArgSingleList import ArgSingleList
 from .Conversions import BinFloatFormat, BinIntFormat
 from .Instrument import Instrument
-from .InstrumentSettings import InstrViClearMode, InstrumentSettings, WaitForOpcMode
-from .Utilities import parse_token_to_key_and_value, trim_str_response
+from .InstrumentSettings import InstrViClearMode, InstrumentSettings, WaitForOpcMode, OpcSyncQueryMechanism
+from .ScpiLogger import LoggingMode
+from .InstrumentErrors import RsInstrException
+from .Properties import Properties
 
 
 class Core(object):
 	"""Main driver component. Provides: \n
 		- Main core constructor
 		- 'io' interface for all the write / query operations
 		- Command parameters string composer for single arguments...
 		- Link handlers adding / changing / deleting
 
 		Version history:
 
+		1.70.0 (27.02.2024)
+			- Added settings profile 'XK41' for R&S Software Defined Radios.
+			- Added settings 'FirstCmds' where you can send the defined commands right after the init. Send more commands in a row with ';;' separator.
+			- Added settings 'EachCmdPrefix' - this prefix is added to each command sent to the instrument. Supported values are also 'lf', 'cr', 'tab'
+
+		1.60.0 (31.01.2024)
+			- Added Properties script for global properties.
+			- Added Properties.scpi_quotes, string option settings token: 'ScpiQuotes'. Example: ScpiQuotes=double. Default: Single
+			- Fixed VisaPluginSocketIo read() method for cases where the session is lost. The method now generates exception in that case.
+			- Added settings 'OpcSyncQueryMechanism' with values: Standard, AlsoCheckMav, ClsOnlyCheckMavErrQueue, OnlyCheckMavErrQueue
+
+		1.54.0 (27.06.2023)
+			- Added new options profile for ATS chambers.
+			- Added settings boolean token EachCmdAsQuery. Example: EachCmdAsQuery=True. Default: False
+
+		1.53.0 (18.10.2022)
+			- Improved mode where the instrument works with a session from another object.
+			- Silently ignoring invalid *IDN? string.
+			- Added new options profile 'Minimal' for non-SCPI-99 instruments.
+
+		1.52.0 (28.09.2022)
+			- Fixed DisableOpcQuery=True settings effect.
+			- Improved robustness of the TerminationCharacter option value entry.
+			- Added new options profile for CMQ500.
+
+		1.51.0 (08.09.2022)
+			- Changed the accepted IDN? response to more permissive.
+			- added methods go_to_remote() and go_to_local()
+			- added methods file_exists() and get_file_size()
+
+		1.50.0 (23.06.2022)
+			- Added relative timestamp to the logger.
+			- ScpiLogger can read GlobalData class variables making it possible to define common target and reference timestamp for all instances.
+			- Logger stream entries are by default immediately flushed, making sure that the log is complete.
+			- Added time statistic methods get_total_execution_time(), get_total_time(), reset_time_statistics().
+
+		1.24.0 (03.06.2022)
+			- Changed parsing of SYST:ERR? response to tolerate +0,"No Error" response.
+			- Added settings integer token OpenTimeout. Example: OpenTimeout=5000. Default: 0
+			- Added settings boolean token ExclusiveLock. Example: ExclusiveLock=True. Default: False
+
+		1.23.0 (24.05.2022)
+			- Added stripping of trailing commas when parsing the *IDN? response.
+			- If the Resource Manager does not find any default VISA implementation, it falls back to R&S VISA - relevant for LINUX or macOS
+			- Other typos and formatting corrections.
+
+		1.22.0 (20.04.2022)
+			- Added optional parameter timeout to reset()
+			- Added query list methods:  query_bool_list, query_bool_list_with_opc
+
+		1.21.0 (07.01.2022)
+			- Added logging to UDP port (49200) to integrate with new R&S Instrument Control plugin for Pycharm
+
+		1.20.0 (19.11.2021)
+			- Fixed logging strings when device name was a substring of the resource name
+
+		1.18.0 (build 64) 05.11.2021
+			- Added setting profile for non-standard instruments. Example of the options string: options='Profile=hm8123'
+
+		1.17.0 (build 63) 15.10.2021
+			- Added correct conversion of strings with SI suffixes (e.g.: MHz, KHz, THz, GHz, ms, us) to float and integer
+
+		1.16.0 (build 62) 31.08.2021
+			- Changed default encoding of string<=>bin from utf-8 to charmap.
+			- Added settable encoding for the session. Property: RsInstrument.encoding
+
+		1.15.0 (build 61) 17.08.2021
+			- Added support for EnumExt and EnumExtList
+			- Added support for custom scpi enums
+			- Improved exception handling in cases where the instrument session is closed.
+			- Fixed warning in Instrument.py
+			- Fixed Instrument.query_bin_block() for timeout errors
+			- Repeated capabilities are now allowed to be integer numbers as well
+
+		1.14.0 (build 53) 12.07.2021
+			- Scpi logger time entries now support not only datetime tuples, but also float timestamps
+			- changed handling of the syst:err? responses - now they are always Tuple (code, message)
+			- StatusException has new field errors_list: List[ Tuple[code, message] ]
+			- Added logger.log_status_check_ok property. This allows for skipping lines with 'Status check: OK'
+
+		1.12.0 (build 50) 26.06.2021
+			- Added SCPI Logger
+			- Simplified constructor's options string format - removed DriverSetup=() syntax:
+			Instead of "DriverSetup=(TerminationCharacter='\n')", you use "TerminationCharacter='\n'"
+			The original format is still supported.
+
+			- Fixed calling SYST:ERR? even if *STB? returned 0
+			- Replaced @ni backend with @ivi for resource manager - this is necessary for the future pyvisa version 1.12+
+
+		1.11.0 (build 49) 09.06.2021
+			- Added is_connection_active() + reconnect()
+
+		1.10.1 (build 47) 01.06.2021
+			- Fixed bug with error checking when events are defined
+
 		1.10.0 (build 46) 03.05.2021
 			- Added methods to Instrument: query_struct_with_opc(), query_str_suppressed_with_opc()
 
 		1.9.0 (build 45) 13.04.2021
 			- Added option to set callbacks before_write and before_query
 			- When a RepCap has a member with integer number 0 defined, the command string interpretation of such member is '0', not empty string
 
@@ -32,15 +130,15 @@
 		1.7.7 (build 42) 26.11.2020
 			- Extended ArgSingleList.compose_cmd_string() to 9 arguments
 
 		1.7.6 (build 41) 23.11.2020
 			- Extended data types for IntegerExt, FloatExt, IntegerExtArray, FloatExtArray
 
 		1.7.5 (build 40) 12.11.2020
-			- Extended Conversions method str_to_str_list() by parameter 'clear_one_empty_item' with default value False
+			- Extended 'Conversions' method str_to_str_list() by parameter 'clear_one_empty_item' with default value False
 
 		1.7.4 (build 39) 11.09.2020
 			- Fixed parsing of the instrument errors when an error message contains two double quotes
 
 		1.7.3 (build 38) 21.10.2020
 			- Added 'UND' to the list of float numbers that are represented as NaN
 
@@ -60,15 +158,15 @@
 
 		1.4.0 (build 32) 17.09.2020
 			- Added recognition of RsVisa library location for linux when using options string 'SelectVisa=rs'
 			- Fixed bug in reading binary data 16 bit
 
 		1.3.0 (build 31) 04.09.2020
 			- added DRIVERSETUP_QUERYOPT to the driver's option string
-			- *OPT? is no longer performed at the init, but only at the first access to options string.
+			- *OPT? is no longer performed at the init, but only at the first access to the options string.
 				In addition, the *OPT? query is executed with 1000 ms timeout, and the errors are suppressed
 
 		1.2.0 (build 30), 03.08.2020
 			- Fixed NRP-Z session parameters: vxi_capable = False, io_segment_size = 1000000
 
 		1.1.0 (build 29), 20.06.2020
 			- Added RepeatedCapability and base class CommandsGroup
@@ -89,85 +187,94 @@
 			reset: bool = False,
 			driver_options: str = None,
 			user_options: str = None,
 			direct_session: object = None):
 		"""Initializes new driver session. For cleaner code, use the class methods: \n
 		- Core.from_existing_session() - initializes a new Core with an existing pyvisa session."""
 
-		self.core_version = '1.9.0'
-		self.simulating = False
-		self.supported_idn_patterns = []
-		self.supported_instr_models = []
-
-		self._args_single_list = ArgSingleList()
-		sett_dr = self._parse_init_settings_string(driver_options)
-		self._apply_settings_to_core(sett_dr)
-		sett_user = self._parse_init_settings_string(user_options)
-		self._apply_settings_to_core(sett_user)
+		self.core_version = '1.55.0'
+		self.resource_name = resource_name
 
 		# Typical settings for the Core
 		self._instrumentSettings = InstrumentSettings(
 			InstrViClearMode.execute_on_all,  # Instrument viClear mode
 			False,  # Full model name. True: SMW200A, False: SMW
 			0,  # Delay by each write
 			0,  # Delay by each read
-			100000,  # Max chunk read / write size in bytes
+			1000000,  # Max chunk read / write size in bytes
 			WaitForOpcMode.stb_poll,  # Waiting for OPC Mode: Status byte polling
 			30000,  # OPC timeout
 			10000,  # VISA timeout
 			60000,  # Self-test timeout
 			Options.ParseMode.Auto,  # *OPT? response parsing mode
 			BinFloatFormat.Single_4bytes,  # Format for parsing of binary float numbers
 			BinIntFormat.Integer32_4bytes,  # Format for parsing of binary integer numbers
-			False  # OPC query after each setting
+			False,  # OPC query after each setting
+			LoggingMode.Off,
+			OpcSyncQueryMechanism.only_check_mav_err_queue
+			# Logging mode
 		)
 
-		self._instrumentSettings.apply_option_settings(sett_dr)
-		self._instrumentSettings.apply_option_settings(sett_user)
+		self._instrumentSettings.apply_option_settings(driver_options)
+		self._instrumentSettings.apply_option_settings(user_options)
 
-		# Resolve the direct_session to handle. Options for direct_session type:
-		# - VisaSession object, retrieved from the driver's RsInstrument.get_session_handle() method
-		# - string in case of a simulation session
-		handle = direct_session
-		if handle:
-			# Check if the entered 'direct_session' is either the driver object or the Visa session
-			if hasattr(direct_session, 'get_session_handle'):
-				assert hasattr(direct_session, '_core'), f"Direct session is a class type. It must be an instance of the top-level driver class."
-				handle = direct_session.get_session_handle()
-			# Check if the handle is not a simulation mode string
-			if isinstance(handle, str):
-				if "Simulating session, resource name " in handle:
-					self.simulating = True
-					handle = None
+		self.simulating = self._instrumentSettings.simulating
+		self.supported_idn_patterns = self._instrumentSettings.supported_idn_patterns
+		self.supported_instr_models = self._instrumentSettings.supported_instr_models
 
-		self.io = Instrument(resource_name, self.simulating, self._instrumentSettings, handle)
+		self._args_single_list = ArgSingleList()
+		handle = self._resolve_direct_session(direct_session)
+		self.io = Instrument(self.resource_name, self.simulating, self._instrumentSettings, handle)
 		self.io.query_instr_status = True
+		# Update the resource name if it changed, for example because of the direct session
+		self.resource_name = self.io.resource_name
+		self.allow_reconnect = self.io.allow_reconnect
 
-		self._apply_settings_to_instrument(sett_dr)
-		self._apply_settings_to_instrument(sett_user)
-
+		self._apply_settings_to_instrument(self._instrumentSettings)
+		self._apply_global_properties(self._instrumentSettings)
 		self.io.set_simulating_cmds()
 
 		if id_query:
 			self.io.fits_idn_pattern(self.supported_idn_patterns, self.supported_instr_models)
 
 		if reset:
 			self.io.reset()
 		else:
 			self.io.check_status()
 
 	@classmethod
 	def from_existing_session(cls, session: object, driver_options: str = None) -> 'Core':
 		"""Creates a new Core object with the entered 'session' reused."""
 		# noinspection PyTypeChecker
-		return cls(None, False, False, driver_options, None, session)
+		return cls(resource_name=None, id_query=False, reset=False, driver_options=driver_options, user_options=None, direct_session=session)
 
 	def __str__(self):
 		return f"Core session '{self.io.resource_name}'"
 
+	def _resolve_direct_session(self, direct_session):
+		# Resolve the direct_session to handle. Options for direct_session type:
+		# - VisaSession object, retrieved from the driver's RsInstrument.get_session_handle() method
+		# - string in case of a simulation session
+		handle = direct_session
+		if not direct_session:
+			return None
+		# Check if the entered 'direct_session' is either the driver object or the Visa session
+		if hasattr(direct_session, 'get_session_handle'):
+			if not hasattr(direct_session, '_core'):
+				raise RsInstrException('Direct session is a class type. It must be an instance of the top-level driver class.')
+			handle = direct_session.get_session_handle()
+		# If the handle is a simulating session, change the session to simulating and set disable the 'from existing session' feature
+		if isinstance(handle, str):
+			mand_string = 'Simulating session, resource name '
+			if mand_string in handle:
+				self.resource_name = handle[len(mand_string):].strip().strip("'").strip()
+				self.simulating = True
+				handle = None
+		return handle
+
 	def set_link_handler(self, link_name: str, handler: Callable) -> Callable:
 		"""Adds / Updates link handler for the entered link_name.
 		Handler API: handler(event_args: ArgLinkedEventArgs)
 		Returns the previous registered handler, or None if no handler was registered before."""
 		return self.io.set_link_handler(link_name, handler)
 
 	def del_link_handler(self, link_name: str) -> Callable:
@@ -176,82 +283,30 @@
 		return self.io.del_link_handler(link_name)
 
 	def del_all_link_handlers(self) -> int:
 		"""Deletes all the link handlers.
 		Returns number of deleted links."""
 		return self.io.del_all_link_handlers()
 
-	# noinspection PyMethodMayBeStatic
-	def _parse_init_settings_string(self, text: str) -> dict:
-		"""Parses init string to a dictionary of settings: name -> value."""
-		tokens = {}
-		if not text:
-			return tokens
-
-		# Text enclosed in single brackets '' must have the commas escaped
-		literal_pattern = r"'([^']+)'"
-		while True:
-			# literal loop
-			m = re.search(literal_pattern, text)
-			if not m:
-				break
-			lit_part = '"' + m.group(1).replace(',', '<COMMA_ESC>') + '"'
-			text = text.replace(m.group(0), lit_part)
-
-		# Remove all the class-options enclosed by round brackets e.g. "<groupName>=(<groupTokens>)"
-		group_pattern = r'(\w+)\s*=\s*\(([^\)]*)\)'
-		# Match class-settings, add them as separate keys with groupName_Key
-		while True:
-			# Group loop
-			m = re.search(group_pattern, text)
-			if not m:
-				break
-			text = text.replace(m.group(0), '')
-			group_name = m.group(1).upper()
-			group_tokens = m.group(2).strip().split(',')
-			for token in group_tokens:
-				key, value = parse_token_to_key_and_value(token)
-				if value:
-					tokens[f'{group_name}_{key.upper()}'] = value
-
-		# All groups are removed from the text, now we can use splitting on commas and remove white-space-only elements
-		for token in text.split(','):
-			key, value = parse_token_to_key_and_value(token.replace('<COMMA_ESC>', ','))
-			if value:
-				tokens[key.upper()] = value
-		return tokens
-
-	def _apply_settings_to_core(self, settings: dict) -> None:
-		"""Applies settings relevant for the Core from the dictionary."""
-		value = settings.get('SIMULATE')
-		if value:
-			self.simulating = Conv.str_to_bool(value)
-
-		value = settings.get('SUPPORTEDINSTRMODELS')
-		if value:
-			self.supported_instr_models = [*map(trim_str_response, value.split('/'))]
-
-		value = settings.get('SUPPORTEDIDNPATTERNS')
-		if value:
-			self.supported_idn_patterns = [*map(trim_str_response, value.split('/'))]
-
-	def _apply_settings_to_instrument(self, settings: dict) -> None:
-		"""Applies settings relevant for the Instrument from the dictionary."""
-		value = settings.get('QUERYINSTRUMENTSTATUS')
-		if value:
-			self.io.query_instr_status = Conv.str_to_bool(value)
-
-		value = settings.get('SIMULATIONIDNSTRING')
-		if value and self.simulating:
-			# Use the '*' instead of the ',' in the value to avoid comma as token delimiter
-			self.io.idn_string = value.replace('*', ',')
+	def _apply_settings_to_instrument(self, settings: InstrumentSettings) -> None:
+		"""Applies settings relevant for the Instrument from the InstrumentSettings structure."""
+		if settings.instrument_status_check is not None:
+			self.io.query_instr_status = settings.instrument_status_check
+		if self.simulating and settings.instrument_simulation_idn_string is not None:
+			self.io.idn_string = settings.instrument_simulation_idn_string
+
+	@staticmethod
+	def _apply_global_properties(settings: InstrumentSettings) -> None:
+		"""Applies settings valid for the entire module. All are available in the module 'Properties'."""
+		if settings.scpi_quotes is not None:
+			Properties.scpi_quotes = settings.scpi_quotes
 
 	def compose_cmd_arg_param(
 			self, arg1: ArgSingle, arg2: ArgSingle = None, arg3: ArgSingle = None, arg4: ArgSingle = None, arg5: ArgSingle = None, arg6: ArgSingle = None) -> str:
-		"""Composes command parameter string based on the single arguments definition."""
+		"""Composes command parameter string based on the single argument definition."""
 		return self._args_single_list.compose_cmd_string(arg1, arg2, arg3, arg4, arg5, arg6)
 
 	def get_last_sent_cmd(self) -> str:
 		"""Returns the last commands sent to the instrument. Only works in simulation mode"""
 		return self.io.get_last_sent_cmd()
 
 	def get_session_handle(self):
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/InstrumentErrors.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/InstrumentErrors.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,63 +1,79 @@
+"""Definition of RsInstrument exceptions, assert functions, and other error-related functions."""
+
+from typing import List, Tuple
+
+
 class RsInstrException(Exception):
 	"""Exception base class for all the RsInstrument exceptions."""
 	def __init__(self, message: str):
 		super(RsInstrException, self).__init__(message)
+		self.message = message
 
 
 class TimeoutException(RsInstrException):
 	"""Exception for timeout errors."""
 	def __init__(self, message: str):
 		super(TimeoutException, self).__init__(message)
 
 
 class StatusException(RsInstrException):
-	"""Exception for instrument status errors."""
-	def __init__(self, rsrc_name: str, message: str):
-		self.rsrc_name = rsrc_name
+	"""Exception for instrument status errors.
+	Tje field  errors_list contains the complete list of all the errors with messages and codes."""
+	def __init__(self, rsrc_name: str, message: str, errors_list: List[Tuple[int, str]], first_exc: Exception = None):
+		self.rsrc_name: str = rsrc_name
+		self.first_exc: Exception = first_exc
+		self.errors_list: List[Tuple[int, str]] = errors_list
 		super(StatusException, self).__init__(message)
 
 
 class UnexpectedResponseException(RsInstrException):
 	"""Exception for instrument unexpected responses."""
 	def __init__(self, rsrc_name: str, message: str):
-		self.rsrc_name = rsrc_name
+		self.rsrc_name: str = rsrc_name
 		super(UnexpectedResponseException, self).__init__(message)
 
 
 class ResourceError(RsInstrException):
 	"""Exception for resource name - e.g. resource not found."""
 	def __init__(self, rsrc_name: str, message: str):
-		self.rsrc_name = rsrc_name
+		self.rsrc_name: str = rsrc_name
 		super(ResourceError, self).__init__(message)
 
 
 class DriverValueError(RsInstrException):
 	"""Exception for different driver value settings e.g. RepCap values or Enum values."""
 	def __init__(self, rsrc_name: str, message: str):
-		self.rsrc_name = rsrc_name
+		self.rsrc_name: str = rsrc_name
 		super(DriverValueError, self).__init__(message)
 
 
-def assert_no_instrument_status_errors(rsrc_name: str, errors: list, context: str = '') -> None:
-	"""Checks the errors list and of it contains at least one element, it throws StatusException."""
-	if errors is None:
-		return
-	if len(errors) == 0:
+def get_instrument_status_errors(rsrc_name: str, errors: List[Tuple[int, str]], context: str = '') -> str or None:
+	"""Checks the errors list and of it contains at least one element, it returns the error message.
+	Otherwise, it returns None."""
+	if errors is None or len(errors) == 0:
 		return
 	if context:
 		message = f"'{rsrc_name}': {context} "
 	else:
 		message = f"'{rsrc_name}': "
+	errors_msg = '\n'.join([f'{x[0]},"{x[1]}"' for x in errors])
 	if len(errors) == 1:
-		message += f'Instrument error detected: {errors[0]}'
-		raise StatusException(rsrc_name, message)
+		message += f'Instrument error detected: {errors_msg}'
+		return message
 	if len(errors) > 1:
-		message += '{} Instrument errors detected:\n{}'.format(len(errors), '\n'.join(errors))
-		raise StatusException(rsrc_name, message)
+		message += f'{len(errors)} Instrument errors detected:\n{errors_msg}'
+		return message
+
+
+def assert_no_instrument_status_errors(rsrc_name: str, errors: List[Tuple[int, str]], context: str = '', first_exc=None) -> None:
+	"""Checks the errors list and of it contains at least one element, it throws StatusException."""
+	msg = get_instrument_status_errors(rsrc_name, errors, context)
+	if msg:
+		raise StatusException(rsrc_name, msg, errors, first_exc=first_exc)
 
 
 def throw_opc_tout_exception(opc_tout: int, used_tout: int, context: str = '') -> None:
 	"""Throws TimeoutException - use it for any timeout error."""
 	if not context:
 		message = ''
 	else:
@@ -83,21 +99,21 @@
 
 def assert_query_has_qmark(query: str, context: str = '') -> None:
 	"""Throws Exception if the query does not contain any question marks."""
 	if '?' in query:
 		return
 	message = ''
 	if context:
-		message = ' ' + context
+		message = context.strip() + ': '
 	message = message + "Query commands must contain question-marks. Sent query: '{0}'".format(query.strip('\n'))
-	raise Exception(message)
+	raise RsInstrException(message)
 
 
 def assert_cmd_has_no_qmark(command: str, context: str = '') -> None:
 	"""Throws Exception if the query contains a question marks."""
 	if '?' not in command:
 		return
 	message = ''
 	if context:
-		message = ' ' + context
+		message = context.strip() + ': '
 	message = message + "Set commands must not contain question-marks. Sent command: '{0}'".format(command.strip('\n'))
-	raise Exception(message)
+	raise RsInstrException(message)
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/InstrumentOptions.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/InstrumentOptions.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""See the class docstring."""
+
 import re
 from enum import Enum
 
 from .Utilities import trim_str_response
 
 
 class ParseMode(Enum):
@@ -10,14 +12,15 @@
 	KeepOriginal = 1
 	KeepBeforeDash = 2
 	KeepAfterDash = 3
 	Auto = 4
 
 
 class Options(object):
+	"""Class for handling the instrument options - parsing from the *OPT? string and providing method get_all()"""
 	_optionsList = []
 
 	def __init__(self, options_str: str, mode=ParseMode.Auto):
 		"""Initializes the options with the *OPT? return string."""
 		self._initialize_from_string(options_str, mode)
 
 	def __str__(self):
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/InternalLinker.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/InternalLinker.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,13 +1,16 @@
+"""Links a variable from a structure to a callback in the driver."""
+
 from time import time
 from typing import Dict, Callable
 
 from . import ArgSingle, ArgSingleSuppressed
 from .ArgLinkedEventArgs import ArgLinkedEventArgs
 from .Utilities import get_plural_string
+from .InstrumentErrors import RsInstrException
 
 
 class InternalLinker(object):
 	"""Class for:
 		- cutting out suppressed arguments from a device response.
 		- invoking a handler if the argument has InternalLinking defined.
 		- holds dictionary of handlers where the dict_key is the InternalLinking string.
@@ -44,22 +47,22 @@
 		Returns number of deleted links."""
 		count = len(self._handlers)
 		self._handlers = {}
 		return count
 
 	def cut_from_response_string(self, arg: ArgSingleSuppressed, response: str, context: str) -> str:
 		"""Takes the string 'response', removes the suppressed argument value from it and returns the rest.
-		The cut out part is sent via handler if the internal linking exists for that argument exists."""
+		The cut-out part is sent via handler if the internal linking exists for that argument exists."""
 		result = ''
 		if arg.argument_ix is None:
-			raise Exception(f'Argument has argument_ix attribute not assigned (equals None). Argument: {arg}')
+			raise RsInstrException(f'Argument has argument_ix attribute not assigned (equals None). Argument: {arg}')
 		if arg.argument_ix != 0:
-			raise Exception(f'Only arguments with index 0 can be suppressed. Argument: {arg}')
+			raise RsInstrException(f'Only arguments with index 0 can be suppressed. Argument: {arg}')
 		if arg.is_open_list:
-			raise Exception(f'Open List arguments can not be suppressed. Argument: {arg}')
+			raise RsInstrException(f'Open List arguments can not be suppressed. Argument: {arg}')
 		repetition = 0
 		i = 0
 		for c in response:
 			if c == ',':
 				repetition += 1
 			if repetition == arg.repetition:
 				break
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/IoTransferEventArgs.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/IoTransferEventArgs.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""See the docstring for the IoTransferEventArgs class."""
+
 import itertools
 from typing import AnyStr
 
 from .Utilities import size_to_kb_mb_string
 
 
 class IoTransferEventArgs(object):
@@ -48,25 +50,25 @@
 		return cls(True, opc_sync, None, context)
 
 	@classmethod
 	def write_str(cls, opc_sync: bool, total_size: int, context: str) -> 'IoTransferEventArgs':
 		"""Creates new IoTransferEventArgs of write string \n
 		:param opc_sync: defines if the command is OPC-synchronised
 		:param total_size: size of the data to write
-		:param context: SCPI command write. It is truncated to maximum of 100 characters.
-		:return: IoTransferEventArgs object of a write string operation."""
+		:param context: SCPI command write. It is truncated to maximum of 100 characters
+		:return: IoTransferEventArgs object of a write-string operation."""
 		obj = cls(False, opc_sync, total_size, context)
 		obj.binary = False
 		return obj
 
 	@classmethod
 	def write_bin(cls, context: str) -> 'IoTransferEventArgs':
 		"""Creates new IoTransferEventArgs of read binary data \n
 		:param context: SCPI command. It is truncated to maximum of 100 characters.
-		:return: IoTransferEventArgs object of a write binary data operation."""
+		:return: IoTransferEventArgs object of a write-binary-data operation."""
 		# noinspection PyTypeChecker
 		obj = cls(False, False, None, context.rstrip())
 		obj.binary = True
 		return obj
 
 	def __str__(self):
 		if self.binary:
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/RepeatedCapability.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/RepeatedCapability.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""See the docstring for the RepeatedCapability class."""
+
 from enum import Enum
 
 
 # Command integer value that signals Default value "DEFAULT"
 VALUE_DEFAULT = -1
 
 # Command integer value that signals "EMPTY"
@@ -26,39 +28,47 @@
 	def __str__(self) -> str:
 		out = f'RepCap {self.name}'
 		if self._enum_value is not None:
 			out += f" = {self._enum_value}"
 		return out
 
 	@classmethod
-	def clsm_assert_type(cls, enum_value: Enum, enum_type) -> None:
-		"""Static assertion function to check if the entered value is a member of the defined repcap enum"""
+	def clsm_assert_type(cls, enum_value: Enum or int, enum_type) -> None:
+		"""Static assertion function to check if the entered value is a member of the defined repcap enum.
+		In addition, the integer value is also supported."""
+		if isinstance(enum_value, int):
+			return
 		if not isinstance(enum_value, enum_type):
 			raise TypeError(f"RepCap value must be of type '{enum_type}'. Entered value type: {type(enum_value)}, value '{enum_value}'")
 
 	@classmethod
-	def clsm_get_direct_cmd_value_int(cls, enum_value: Enum, enum_type) -> int:
+	def clsm_get_direct_cmd_value_int(cls, enum_value: Enum or int, enum_type) -> int:
 		"""Static function to get an integer interpretation of a direct enum value
 		Does not work with Empty or Default"""
 		RepeatedCapability.clsm_assert_type(enum_value, enum_type)
+		if isinstance(enum_value, int):
+			return enum_value
 		return enum_value.value
 
 	@classmethod
-	def clsm_is_default_value(cls, enum_value: Enum, enum_type) -> bool:
+	def clsm_is_default_value(cls, enum_value: Enum or int, enum_type) -> bool:
 		"""Returns True, if the entered value is enum.Default"""
 		return cls.clsm_get_direct_cmd_value_int(enum_value, enum_type) == VALUE_DEFAULT
 
 	def is_default_value(self) -> bool:
 		"""Returns True, if the repcap value is enum.Default"""
 		return RepeatedCapability.clsm_is_default_value(self._enum_value, self.enum_type)
 
-	def set_enum_value(self, enum_value: Enum) -> None:
+	def set_enum_value(self, enum_value: Enum or int) -> None:
 		"""Sets new enum value. Can not be Default"""
 		if RepeatedCapability.clsm_is_default_value(enum_value, self.enum_type):
 			raise ValueError(f"Setting RepCap enum value '{enum_value}' is not allowed. Please select a concrete value")
+		if isinstance(enum_value, int):
+			# Find the enum value that corresponds to the entered integer value
+			enum_value = self.enum_type(enum_value)
 		self._enum_value = enum_value
 
 	def get_enum_value(self) -> Enum:
 		"""Returns the actual enum value"""
 		return self._enum_value
 
 	def set_to_start_value(self) -> None:
@@ -66,16 +76,17 @@
 		self.set_enum_value(self._start_value)
 
 	def matches_type(self, enum_type) -> bool:
 		"""Returns true, if the entered type matches the EnumType"""
 		return self.enum_type == enum_type
 
 	@classmethod
-	def clsm_get_cmd_string_value(cls, enum_value: Enum, enum_type) -> str:
-		"""Converts RepCap integer value to string
+	def clsm_get_cmd_string_value(cls, enum_value: Enum or int, enum_type) -> str:
+		"""Class method version of the get_cmd_string_value().
+		Converts RepCap integer value to string
 		ValueEmpty is converted to "" (Not valid, but tolerated)
 		ValueDefault throws an exception
 		0 is converted to "" (Not valid, but tolerated)
 		Positive numbers are converted to integer strings e.g. 1 => '1' """
 		number = cls.clsm_get_direct_cmd_value_int(enum_value, enum_type)
 		if number == VALUE_EMPTY:
 			return ''
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/StreamReader.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/StreamReader.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,15 +1,19 @@
+"""See the docstring for the StreamReader class."""
+
 from enum import Enum
 from os import path
 from typing import AnyStr
 
 from .Utilities import size_to_kb_mb_string
+from .InstrumentErrors import RsInstrException
 
 
 class Type(Enum):
+	"""Defines type of the stream - variable or file."""
 	Variable = 1
 	File = 2
 
 
 class StreamReader:
 	"""Lightweight stream reader implementation. Data source can be: \n
 	- variable
@@ -21,31 +25,32 @@
 		:param source: Source type for the stream. Variable / File
 		:param data: Depending on the 'binary' and 'source':
 		For source type Variable the data must be either bytes() or str
 		For source type File data must be string with existing file path."""
 		self._source = source
 		self._binary = binary
 		self._start_ptr = 0
+		self._read_len = 0
 
 		if self._source == Type.Variable:
 			if self._binary:
 				assert isinstance(data, bytes), f'Data must be of bytes type. Actual type: {type(data)}'
 			else:
 				assert isinstance(data, str), f'Data must be of string type. Actual type: {type(data)}'
 			self._data = data
 			self._full_len = len(self._data)
 		elif self._source == Type.File:
 			assert isinstance(data, str), f'Data must be of string type (file path). Actual type: {type(data)}'
 			if not path.isfile(data):
-				raise Exception(f'File does not exist. File path: {data}')
+				raise RsInstrException(f'File does not exist. File path: {data}')
 			self.file_path = data
 			self._data = open(self.file_path, 'rb' if self._binary else 'r')
 			self._full_len = path.getsize(self.file_path)
 		else:
-			raise Exception(f'StreamReader unknown type {source}')
+			raise RsInstrException(f'StreamReader unknown type {source}')
 
 	@classmethod
 	def as_bin_var(cls, data: bytes) -> 'StreamReader':
 		"""Creates new StreamReader from bytes.
 		:param data: [bytes] data for the stream."""
 		return cls(True, Type.Variable, data)
 
@@ -100,29 +105,34 @@
 		If the remaining length is smaller than the chunk_size, the method returns the remaining length only.
 		:param chunk_size: chunk to read. If not set, the method reads the entire data."""
 		assert self._data is not None, 'StreamReader buffer is invalid. You have probably closed it already.'
 		chunk_size = len(self) if chunk_size is None else chunk_size
 		chunk_size = min(chunk_size, len(self))
 		if chunk_size < 0:
 			raise ValueError(f'Chunk size can not be negative number: {chunk_size}')
-
+		self._read_len += chunk_size
 		if self._source == Type.Variable:
 			self._start_ptr += chunk_size
 			return self._data[self._start_ptr - chunk_size: self._start_ptr]
 		elif self._source == Type.File:
 			self._start_ptr += chunk_size
 			return self._data.read(chunk_size)
 
-	def read_as_binary(self, chunk_size: int = None) -> bytes:
+	@property
+	def read_len(self) -> int:
+		"""Returns number of bytes read from the stream since its creation."""
+		return self._read_len
+
+	def read_as_binary(self, encoding: str, chunk_size: int = None) -> bytes:
 		"""Same as read(), but always returns the data in binary format.
 		Practically works exactly as read() for binary streams.
-		For string streams, the method converts the returned data using utf-8 encoding to bytes()."""
+		For string streams, the method converts the returned data using the provided encoding to bytes()."""
 		if self._binary:
 			return self.read(chunk_size)
 		else:
-			return self.read(chunk_size).encode('utf-8')
+			return self.read(chunk_size).encode(encoding)
 
 	def close(self):
 		"""Closes the StreamReader. You can not use its instance afterwards."""
 		if self._source == Type.File and self._data:
 			self._data.close()
 		self._data = None
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/StreamWriter.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/StreamWriter.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,17 +1,23 @@
+"""See the docstring for the StreamWriter class."""
+
 from enum import Flag
 from typing import AnyStr
+from io import BytesIO, StringIO
 
 from .Utilities import size_to_kb_mb_string
+from .InstrumentErrors import RsInstrException
 
 
 class Type(Flag):
+	"""Defines type of the stream - variable or file."""
 	Variable = 1
-	File = 2
-	FileAppend = 6
+	Forget = 2
+	File = 4
+	FileAppend = 12
 
 
 class StreamWriter:
 	"""Lightweight stream writer implementation. Data target can be: \n
 	- bytes
 	- string
 	- file"""
@@ -19,41 +25,48 @@
 	def __init__(self, binary: bool, target: Type, meta_data=None):
 		"""Initializes StreamWriter instance.\n
 		:param binary: True: Binary data, False: ASCII data
 		:param target: Target for the stream. Variable / File (FileAppend)
 		:param meta_data: Only valid for File and FileAppend - define file path as string:
 		For Type.File, data must be string with file path. If the file exists, it will be overwritten.
 		For Type.FileAppend, data must be string with file path. If the file exists, it will be appended."""
-		self._binary = binary
-		self._written_len = 0
+		self._binary: bool = binary
+		self._written_len: int = 0
 		self._target = target
 
 		if Type.Variable in self._target:
 			assert meta_data is None, f'You can not define input meta_data for a Variable StreamWriter.'
-			self._data: AnyStr = bytes() if binary else ''
+			self._data = BytesIO() if binary else StringIO()
+		elif Type.Forget in self._target:
+			self._data: AnyStr = ''
 		elif Type.File in self._target:
 			assert isinstance(meta_data, str), f'Additional data must be of string type (file path). Actual type: {type(meta_data)}'
 			self._file_path = meta_data
 			mode = 'w' if self._target == Type.File else 'a'
 			mode += 'b' if self._binary else ''
 			self._data = open(self._file_path, mode)
 		else:
-			raise Exception(f'StreamWriter unknown target {target}')
+			raise RsInstrException(f'StreamWriter unknown target {target}')
 
 	@classmethod
 	def as_bin_var(cls) -> 'StreamWriter':
 		"""Creates new StreamWriter with bytes variable."""
 		return cls(True, Type.Variable)
 
 	@classmethod
 	def as_string_var(cls) -> 'StreamWriter':
 		"""Creates new StreamWriter with string variable."""
 		return cls(False, Type.Variable)
 
 	@classmethod
+	def as_forget(cls) -> 'StreamWriter':
+		"""Creates new StreamWriter which writes to nowhere - forgets the data."""
+		return cls(False, Type.Forget)
+
+	@classmethod
 	def as_bin_file(cls, file_path: str, append: bool = False) -> 'StreamWriter':
 		"""Creates new StreamWriter to binary file.
 		:param file_path: [str] Path to the file.
 		:param append: Optional [bool] If True, the content is appended to the existing content."""
 		return cls(True, Type.FileAppend if append else Type.File, file_path)
 
 	@classmethod
@@ -67,14 +80,16 @@
 		if Type.Variable in self._target:
 			mode = 'binary' if self._binary else 'string'
 			return f'StreamWriter {mode} variable, current size {size_to_kb_mb_string(len(self), True)}'
 		if Type.File in self._target:
 			mode = 'binary' if self._binary else 'text'
 			append = ' appended' if Type.FileAppend in self._target else ''
 			return f'StreamWriter {mode} file{append}, current{append} size {size_to_kb_mb_string(len(self), True)}, file: {self._file_path}'
+		if Type.Forget in self._target:
+			return 'StreamWriter to nowhere.'
 
 	def __len__(self):
 		"""Returns remaining length."""
 		return self._written_len
 
 	def __enter__(self):
 		return self
@@ -88,49 +103,62 @@
 		File streams are always binary."""
 		return self._binary
 
 	def write(self, data: AnyStr) -> None:
 		"""Writes chunk to the stream.
 			- For Type.Bytes data must be bytes.
 			- For Type.String, data must be string.
-			- For Type.File and Type.FileAppend, data must be bytes"""
+			- For Type.File and Type.FileAppend, data must be bytes."""
+		if Type.Forget in self._target:
+			self._written_len += len(data)
+			return
+
 		assert self._data is not None, 'StreamWriter buffer is invalid. You have probably closed it already.'
 		if self._binary:
 			assert isinstance(data, bytes), f'Bytes data is required. Actual type: {type(data)}. {self}'
 		else:
 			assert isinstance(data, str), f'String data is required. Actual type: {type(data)}. {self}'
-
 		if Type.Variable in self._target:
-			self._data += data
+			self._data.write(data)
 		elif Type.File in self._target:
 			self._data.write(data)
 		self._written_len += len(data)
 
-	def switch_to_string_data(self) -> None:
+	def switch_to_string_data(self, encoding: str) -> None:
 		"""Switches from binary to string data.
-		For variables, the current content is converted.
+		For variables, the current content is converted to string using the provided encoding.
 		For files, they are closed and reopened as for appended text writing."""
 		if self._binary is False:
 			return
 		self._binary = False
 		if Type.Variable in self._target:
-			if len(self) == 0:
-				self._data = ''
-			else:
-				# noinspection PyUnresolvedReferences
-				self._data = self._data.decode('utf-8')
+			self._data = StringIO(self.content.decode(encoding))
 		elif Type.File in self._target:
 			self._data.close()
 			self._data = open(self._file_path, 'a')
 
+	# noinspection PyTypeChecker
 	@property
 	def content(self) -> AnyStr:
-		"""Returns content of the writer. Does only work with variable types."""
-		assert Type.Variable in self._target, f'Can not return content for the current {self}'
+		"""Returns content of the writer. Only works with variable types."""
+		if self._target == Type.Forget:
+			return ''
+		if self._target != Type.Variable:
+			raise RsInstrException(f'Can not return content for the current {self}')
 		# noinspection PyTypeChecker
-		return self._data
+		if not self._data:
+			return None
+		self._data.seek(0)
+		ret_val = self._data.read()
+		self._data.close()
+		return ret_val
+
+	@property
+	def written_len(self) -> int:
+		"""Returns number of bytes written to the stream since its creation."""
+		return self._written_len
 
 	def close(self) -> None:
 		"""Closes the StreamWriter. You can not use its instance afterwards."""
 		if Type.File in self._target and self._data:
 			self._data.close()
 		self._data = None
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/StructBase.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/StructBase.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,20 +1,22 @@
+"""See the docstring for the StructBase class."""
+
 from .Types import DataType
 
 
 class StructBase:
 	"""Base class for all the driver's argument structures."""
 	def __init__(self, owner):
 		self.__meta_args_link = dict()
 		ix = 0
 		for arg in self.__get_meta_args_list(owner):
 			arg.argument_ix = ix
 			ix += 1
 
-			if arg.data_type == DataType.Enum or arg.data_type == DataType.EnumList:
+			if arg.data_type in [DataType.Enum, DataType.EnumExt, DataType.EnumList, DataType.EnumExtList]:
 				assert arg.enum_type, f"Struct Argument '{arg.name}' is of enum type, you must define the parameter 'enum_type'"
 			else:
 				assert not arg.enum_type, f"Struct Argument '{arg.name}' data type is '{arg.data_type.name}'. You must set the parameter 'enum_type' to None"
 
 			if arg.is_optional:
 				# set all optional values to None
 				setattr(self, arg.name, None)
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/Types.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/Types.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,54 +1,70 @@
+"""Data type class for the variables containing all the methods related to data types."""
+
 from enum import Enum, auto
 from typing import Any
 
 
+# noinspection PyArgumentList
 class DataType(Enum):
-	"""Data type of a variable in the driver."""
+	"""Data type of variable in the driver."""
 	String = auto()
 	RawString = auto()
 	Integer = auto()
 	IntegerExt = auto()
 	Boolean = auto()
 	Float = auto()
 	FloatExt = auto()
 	Enum = auto()
+	EnumExt = auto()
 	StringList = auto()
 	RawStringList = auto()
 	IntegerList = auto()
 	IntegerExtList = auto()
 	BooleanList = auto()
 	FloatList = auto()
 	FloatExtList = auto()
 	EnumList = auto()
+	EnumExtList = auto()
 
 	@property
 	def is_list(self) -> bool:
 		"""Returns True, if the data type is a list."""
 		return self in frozenset(
 			{
 				DataType.StringList,
 				DataType.RawStringList,
 				DataType.IntegerList,
 				DataType.IntegerExtList,
 				DataType.BooleanList,
 				DataType.FloatList,
 				DataType.FloatExtList,
-				DataType.EnumList
+				DataType.EnumList,
+				DataType.EnumExtList
 			})
 
 	@property
 	def is_scalar(self) -> bool:
 		"""Returns True, if the data type is a scalar."""
 		return not self.is_list
 
 	@property
+	def is_scalar_enum(self) -> bool:
+		"""Returns True, if the data type is a scalar enum or enum_ext."""
+		return self == DataType.Enum or self == DataType.EnumExt
+
+	@property
+	def is_list_enum(self) -> bool:
+		"""Returns True, if the data type is a list enum or list enum_ext."""
+		return self == DataType.EnumList or self == DataType.EnumExtList
+
+	@property
 	def is_enum(self) -> bool:
-		"""Returns True, if the data type is enum or enum array."""
-		return self == DataType.Enum or self == DataType.EnumList
+		"""Returns True, if the data type is enum or enum array - including the extended."""
+		return self in [DataType.Enum, DataType.EnumExt, DataType.EnumList, DataType.EnumExtList]
 
 	@property
 	def is_raw_string(self) -> bool:
 		"""Returns True for raw string and raw string list."""
 		return self == DataType.RawString or self == DataType.RawStringList
 
 	@property
@@ -81,14 +97,16 @@
 			return DataType.IntegerExt
 		elif self == DataType.FloatList:
 			return DataType.Float
 		elif self == DataType.FloatExtList:
 			return DataType.FloatExt
 		elif self == DataType.EnumList:
 			return DataType.Enum
+		elif self == DataType.EnumExtList:
+			return DataType.EnumExt
 
 	def get_default_value(self, enm: Enum = None) -> Any:
 		"""Returns default value for the current type.
 		If the data type is Enum or EnumString, you have to provide the enum class."""
 		if self.is_list:
 			return []
 		if self == DataType.RawString:
@@ -103,7 +121,9 @@
 			return 0
 		elif self == DataType.Float:
 			return 0.0
 		elif self == DataType.FloatExt:
 			return 0.0
 		elif self == DataType.Enum:
 			return enm(0)
+		elif self == DataType.EnumExt:
+			return enm(0)
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/Utilities.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/Utilities.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""Utilities for string manipulation and string formatting for the user."""
+
 from enum import Flag
 from typing import Tuple
 
 
 class TrimStringMode(Flag):
 	"""Trimming mode for strings."""
 	white_chars_only = 1
@@ -133,7 +135,41 @@
 
 
 def calculate_chunks_count(data_size: int, chunk_size: int) -> int:
 	"""Returns number of chunks needed to transfer the data_size split to maximum of chunk_size blocks. \n
 	:param data_size: total data size
 	:param chunk_size: maximum size of one block"""
 	return (data_size // chunk_size) + (1 if (data_size % chunk_size) > 0 else 0)
+
+
+def escape_nonprintable_chars(string: str, encoding: str = 'charmap') -> str:
+	"""
+	Replace nonprintable characters in string s by its hex representation.
+	"""
+	if string.isprintable():
+		return string
+	new_string = ''
+	for char in string:
+		if char.isprintable():
+			new_string += char
+		elif char == '\n':
+			new_string += r'\n'
+		elif char == '\r':
+			new_string += r'\r'
+		elif char == '\t':
+			new_string += r'\t'
+		else:
+			byte = bytes(char, encoding)
+			char = byte.hex()
+			new_string += r'\x' + char
+	return new_string
+
+
+def shorten_string_middle(string: str, max_len: int) -> str:
+	"""If the length of the string is bigger than the max_len,
+	the middle of the string is abbreviated with ' .... ' """
+	count = len(string)
+	if count <= max_len:
+		return string
+	half = int((max_len - 6) / 2)
+	md = (max_len - 6) % 2
+	return string[:half + md] + ' .... ' + string[(count - half):]
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/VisaPluginSocketIo.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/VisaPluginSocketIo.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,23 +1,28 @@
+"""See the docstring for the SocketIo class."""
+
 import socket
 import re
 from contextlib import contextmanager
+from typing import Any
+
+from .InstrumentErrors import RsInstrException
 
 # noinspection PyPackageRequirements
 import pyvisa
 
 
 class SocketIo:
-
+	"""Socket IO plugin providing implementations for all the necessary VISA functions. This class does not need the underlying VISA installation."""
 	def __init__(self, resource_name: str):
 		self.session = socket.socket()
 		self.resource_name = resource_name
 		m = re.search(r'TCPIP::([^:]+)::([^:]+)::SOCKET', self.resource_name)
 		if not m:
-			raise Exception(f"SocketIO instrument unsupported resource name. '{self.resource_name}' Supported resource name example: 'TCPIP::192.168.1.100::5025::SOCKET'")
+			raise RsInstrException(f"SocketIO instrument unsupported resource name. '{self.resource_name}' Supported resource name example: 'TCPIP::192.168.1.100::5025::SOCKET'")
 		self.host = m.group(1).strip()
 		self.port = int(m.group(2).strip())
 		self._read_termination = None
 		self._chunk_size = 1024
 		self._timeout = 5000
 		self.visalib = VisaLib(self)
 
@@ -90,14 +95,22 @@
 
 	# noinspection PyUnusedLocal
 	def read_bytes(self, count: int, **kwargs) -> bytes:
 		"""Reads count bytes"""
 		data, status = self.visalib.read(self.session, count)
 		return data
 
+	def go_to_local(self) -> None:
+		"""Puts the instrument into local state."""
+		self.write("&GTL")
+
+	def go_to_remote(self) -> None:
+		"""Puts the instrument into remote state."""
+		self.write("&GTR")
+
 	# noinspection PyUnusedLocal
 	@contextmanager
 	def ignore_warning(self, filter_value: int) -> None:
 		"""Context property with no effect for the socket connection"""
 		try:
 			yield None
 		finally:
@@ -106,15 +119,15 @@
 
 	def close(self) -> None:
 		"""Closes the socket connection"""
 		self.session.close()
 
 
 class VisaLib:
-
+	"""Implementation of the pyvisa's VisaLib providing the method read()"""
 	def __init__(self, socket_io: SocketIo):
 		self._socket_io = socket_io
 
 	def __str__(self):
 		return "SocketIO"
 
 	# noinspection PyUnresolvedReferences
@@ -127,14 +140,16 @@
 
 		try:
 			while True:
 				to_read_len = chunk_size - read_len
 				if to_read_len <= 0:
 					break
 				data = session.recv(to_read_len)
+				if not data:
+					raise pyvisa.VisaIOError(pyvisa.constants.VI_ERROR_CONN_LOST)
 				chunk += data
 				read_len += len(data)
 
 				if self._socket_io.read_termination is not None:
 					# Read termination character is ON, look for it and stop the reading if found
 					term_char = self._socket_io.read_termination.encode()
 					if term_char in data:
@@ -159,17 +174,18 @@
 				more_data_available = True
 
 		return_code = pyvisa.constants.StatusCode.success_max_count_read if more_data_available else pyvisa.constants.StatusCode.success
 		return chunk, return_code
 
 
 class ResourceManager:
-
+	"""Implementation of the VISA's Resource Manager."""
 	def __init__(self):
 		self.VisaManufacturerName = "SocketIO"
 		self.connection = None
 
-	def open_resource(self, resource_name: str) -> SocketIo:
-		"""Creates new Socket connection"""
+	# noinspection PyUnusedLocal
+	def open_resource(self, resource_name: str, access_mode: Any = None, open_timeout: Any = None) -> SocketIo:
+		"""Creates new Socket connection. access_mode and open_timeout are here for compatibility reasons with the pyvisa rm.open_resource()"""
 		self.connection = SocketIo(resource_name)
 		self.connection.connect()
 		return self.connection
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/VisaSession.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/VisaSession.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,20 +1,23 @@
+"""Visa Session is an extension of the pure VISA providing higher level of methods regardless of the session kind."""
+
 import time
 from enum import Enum, Flag
-from typing import Tuple, Callable, AnyStr
+from typing import List, Tuple, Callable, AnyStr
 import os.path
 import re
 import threading
 
 # noinspection PyPackageRequirements
 import pyvisa
+from pyvisa.errors import StatusCode
 
 from .VisaPluginSocketIo import ResourceManager, SocketIo
 from . import InstrumentSettings, InstrumentErrors, Conversions as Conv
-from .InstrumentSettings import WaitForOpcMode, InstrViClearMode as ViClearMode
+from .InstrumentSettings import WaitForOpcMode, OpcSyncQueryMechanism, InstrViClearMode as ViClearMode
 from .StreamReader import StreamReader
 from .StreamWriter import StreamWriter
 from .Utilities import size_to_kb_mb_string, calculate_chunks_count
 import platform
 import struct
 
 
@@ -37,14 +40,16 @@
 	bin_known_len = 3
 	bin_unknown_len = 4
 
 
 class StatusByte(Flag):
 	"""Status Byte flags."""
 	NONE = 0x00
+	custom_bit_0 = 0x01
+	custom_bit_1 = 0x02
 	error_queue_not_empty = 0x04
 	questionable_status_reg = 0x08
 	message_available = 0x10
 	event_status_byte = 0x20
 	request_service = 0x40
 	operation_status_reg = 0x80
 
@@ -64,14 +69,22 @@
 		# noinspection PyTypeChecker
 		self._data_chunk_size: int = None
 		self._std_bin_block_header_max_len: int = 999999999
 		self._lock = None
 		self.disable_opc_query: bool = settings.disable_opc_query
 		self.last_status = None
 		self.visa_library_name = None
+		self.resource_name = resource_name  # might be changed later if direct_session is used
+		self.encoding = settings.encoding  # default encoder between bytes and string
+		self.cmd_idn = settings.cmd_idn
+		self.skip_status_system_setting = settings.skip_status_system_setting
+		self.skip_clear_status = settings.skip_clear_status
+		self.stb_in_error_check = settings.stb_in_error_check
+		self.opc_sync_query_mechanism = settings.opc_query_sync_mechanism
+		self.each_cmd_prefix = settings.each_cmd_prefix
 
 		# Implemented for interface compatibility with VisaSessionSim
 		self.cached_to_stream = False
 
 		# Event handlers
 		# noinspection PyTypeChecker
 		self.on_read_chunk_handler: Callable = None
@@ -80,36 +93,36 @@
 		self.on_write_chunk_handler: Callable = None
 		"""If assigned a handler, the VisaSession sends it event on each write chunk transfer."""
 		self.io_events_include_data: bool = False
 		"""If true, the VisaSession events sent to on_read_chunk_handler and on_write_chunk_handler contain transferred data."""
 
 		if self.reusing_session:
 			# Reuse the session
-			assert isinstance(direct_session, pyvisa.Resource) or isinstance(direct_session, SocketIo), f"Direct_session must be a VISA resource object. Actual type: '{type(direct_session)}', value: '{direct_session}'"
-			self._session = direct_session
-			self._resource_name = self._session.resource_name
+			self._session = VisaSession.get_and_check_direct_session(direct_session)
+			self.resource_name = self._session.resource_name
 		else:
 			# Create new session
 			# Check resource_name for the trailing (SelectVisa=..)
 			pure_resource_name, visa_select = self._get_pure_resource_name(resource_name)
 			if settings.visa_select is not None:
 				visa_select = settings.visa_select
 			self._rm = VisaSession.get_resource_manager(visa_select)
 			self.manufacturer = self._get_visa_manufacturer()
 
 			# Resource manager opening
 			try:
-				self._session = self._rm.open_resource(pure_resource_name)
+				acc_mode = pyvisa.constants.AccessModes.no_lock if settings.exclusive_lock is False else pyvisa.constants.AccessModes.exclusive_lock
+				self._session = self._rm.open_resource(resource_name=pure_resource_name, open_timeout=settings.open_timeout, access_mode=acc_mode)
 			except pyvisa.VisaIOError as e:
 				if e.error_code != pyvisa.constants.StatusCode.error_resource_not_found:
 					raise e
 				message = e.description
 				message += f"\nLibrary: {self._rm.visalib}\nManufacturer: {self.manufacturer}\nResource Name: '{resource_name}'"
 				raise InstrumentErrors.ResourceError(resource_name, message)
-			self._resource_name = resource_name
+			self.resource_name = resource_name
 
 		# Decide, whether to create a new thread lock or the existing one from the session
 		if hasattr(self._session, 'session_thread_rlock'):
 			rlock = self._session.session_thread_rlock
 			if isinstance(rlock, type(threading.RLock())):
 				self.assign_lock(rlock)
 		if self.get_lock() is None:
@@ -136,28 +149,22 @@
 			self._interface_type = SessionKind.vxi11
 			if self._session.resource_class == 'SOCKET':
 				self._interface_type = SessionKind.socket
 
 		# Specifics for different interfaces
 		self._assure_write_with_tc = settings.assure_write_with_tc
 		self._term_char = settings.term_char
-		self._term_char_bin = self._term_char.encode('utf-8')
+		self._term_char_bin = self._term_char.encode(self.encoding)
 		self._session.write_termination = ''
-		self.vxi_capable = True
+		self.vxi_capable = settings.vxi_capable
 
 		if self._interface_type == SessionKind.serial:
-			self._session.read_termination = self._term_char
 			self.vxi_capable = False
-			self._assure_write_with_tc = True
 		elif self._interface_type == SessionKind.socket:
-			self._session.read_termination = self._term_char
 			self.vxi_capable = False
-			self._assure_write_with_tc = True
-		else:
-			self._session.read_termination = ''
 
 		# NRP-Z specific settings
 		if self.is_rsnrp_session():
 			self.disable_opc_query = True
 			# NRP-Z does not support chunk reading, therefore the segment must be in one piece
 			settings.io_segment_size = 1000000
 			self.vxi_capable = False
@@ -166,78 +173,125 @@
 		self.read_delay = settings.read_delay
 		self._viclear_exe_mode = settings.viclear_exe_mode
 		self._opc_wait_mode = settings.opc_wait_mode
 
 		# Parameters that need to be coerced based on Vxi-capability
 		if self.vxi_capable:
 			self._add_term_char_to_write_bin_block = settings.add_term_char_to_write_bin_block
+			self._session.read_termination = ''
 		else:
 			self._add_term_char_to_write_bin_block = True
+			self._session.read_termination = self._term_char
+			self._assure_write_with_tc = True
 
 		# Changeable settings
 		self.opc_timeout = 10000 if settings.opc_timeout == 0 else settings.opc_timeout
 		self.visa_timeout = settings.visa_timeout
 		self._session.chunk_size = settings.io_segment_size
 		self._data_chunk_size = settings.io_segment_size
 
-		# Must call the VISA viClear() before the any communication with the instrument
+		# Must call the VISA viClear() before any communication with the instrument
 		self.clear()
 
 		# Further steps are for NRP-Z session not valid
 		if self.is_rsnrp_session():
 			return
 
+		# First commands, can be more than one, separated by ';;'
+		if settings.first_cmds:
+			cmds = settings.first_cmds.split(';;')
+			for cmd in cmds:
+				if cmd.startswith('<w>'):
+					self.write(cmd[3:])
+				elif cmd.startswith('<q>'):
+					_ = self._query_str_no_events(cmd[3:])
+				elif '?' in cmd:
+					_ = self._query_str_no_events(cmd)
+				else:
+					self.write(cmd)
+
 		# Clear instrument status
-		self.write('*CLS')
-		if self.vxi_capable:
-			stb = self._read_stb()
-			if stb & StatusByte.message_available:
-				self._flush_junk_data()
+		if self.skip_clear_status is False:
+			self.write('*CLS')
+			if self.vxi_capable:
+				stb = self._read_stb()
+				if stb & StatusByte.message_available:
+					self._flush_junk_data()
 
 		# Apply settings for ESE and SRE, plus coerce the _opcWaitMode if necessary
 		self._opc_wait_mode = self._set_regs_ese_sre(self._opc_wait_mode)
 
 	@staticmethod
+	def get_and_check_direct_session(direct_session):
+		"""Returns direct session if it's a proper type.
+		If the direct_session is None, the function returns None.
+		If the direct_session is of an unsupported type, the function raises RsInstrException."""
+		if direct_session is None:
+			return None
+		# Reuse the session
+		if not isinstance(direct_session, pyvisa.Resource) and not isinstance(direct_session, SocketIo):
+			raise InstrumentErrors.RsInstrException(f"Direct_session must be a VISA resource object. Actual type: '{type(direct_session)}', value: '{direct_session}'")
+		return direct_session
+
+	@staticmethod
 	def _get_pure_resource_name(resource_name: str):
 		"""Returns pure resource name stripped of the (SelectVisa) part and the visa_select string"""
 		m = re.search(r'(.+)\(SelectVisa=([^),]+)\)', resource_name)
 		if not m:
 			return resource_name, None
 		resource_name = m.group(1).strip()
 		visa_select = m.group(2).strip()
 		return resource_name, visa_select
 
 	@classmethod
 	def get_resource_manager(cls, visa_select: str) -> pyvisa.ResourceManager:
 		"""Returns resource manager for the desired VISA implementation"""
 		operating_system = platform.system().lower()
+		vsl = None if visa_select is None else visa_select.lower()
 		bittness = struct.calcsize('P') * 8
-		if visa_select is None or visa_select in ['@default', '@standard', 'default', 'standard', 'defaultvisa', 'standardvisa', '@defaultvisa', '@standardvisa']:
-			return pyvisa.ResourceManager()
-		if visa_select.lower() in ['@ni', 'ni', 'visa-ni', 'nivisa', 'ni-visa', 'nationalinstruments', 'nationalinstrumentsvisa']:
-			return pyvisa.ResourceManager('@ni')
-		if visa_select.lower() in ['@py', 'pyvisa', 'visa-py', 'pyvisa-py']:
-			return pyvisa.ResourceManager('@py')
-		if 'rohde&schwarz' in visa_select.lower() or 'rohdeschwarz' in visa_select.lower() or visa_select.lower() == 'rsvisa' or visa_select.lower() == 'rs' or visa_select.lower() == 'r&s':
+		# Try if you find the default VISA dll
+		try:
+			if visa_select is None or visa_select in ['@default', '@standard', 'default', 'standard', 'defaultvisa', 'standardvisa', '@defaultvisa', '@standardvisa']:
+				return pyvisa.ResourceManager()
+
+			if vsl in ['@ni', 'ni', 'ivi', '@ivi', 'visa-ni', 'nivisa', 'ni-visa', 'nationalinstruments', 'nationalinstrumentsvisa']:
+				return pyvisa.ResourceManager()
+
+			if vsl in ['@py', 'pyvisa', 'visa-py', 'pyvisa-py']:
+				return pyvisa.ResourceManager('@py')
+		except ValueError:
+			# None of the required implementations found, fall back to the R&S VISA
+			visa_select = 'rsvisa'
+			vsl = visa_select.lower()
+
+		# from here, RsVisa implementation is considered
+		if 'rohde&schwarz' in vsl or 'rohdeschwarz' in vsl or vsl == 'rsvisa' or vsl == 'rs' or vsl == 'r&s':
 			if operating_system == 'windows':
 				if bittness == 32:
 					visa_select = r'c:\Windows\SysWOW64\RsVisa32.dll'
 				else:
 					visa_select = r'c:\Windows\system32\RsVisa32.dll'
 				return pyvisa.ResourceManager(visa_select)
 			elif operating_system == 'linux':
 				# The default install location may be different
 				# for debian/red hat/opensuse derived distributions
 				check_visa = [f'/usr/lib{bittness}/librsvisa.so', r'/usr/lib/librsvisa.so']
 				for check in check_visa:
 					if os.path.isfile(check):
 						return pyvisa.ResourceManager(check)
+			elif operating_system == 'darwin':
+				# MacOS
+				check_visa = [f'/Library/Frameworks/RsVisa.framework/Versions/Current/RsVisa/librsvisa.dylib']
+				for check in check_visa:
+					if os.path.isfile(check):
+						return pyvisa.ResourceManager(check)
 
-		if visa_select.lower() in ['socketio', 'socket', 'none']:
+		if vsl in ['socketio', 'socket', 'none']:
 			return ResourceManager()
+
 		return pyvisa.ResourceManager(visa_select)
 
 	def _get_visa_manufacturer(self) -> str:
 		"""Returns manufacturer of the current VISA"""
 		if hasattr(self._rm, 'VisaManufacturerName'):
 			return self._rm.VisaManufacturerName
 		try:
@@ -256,14 +310,26 @@
 		setattr(self._session, 'session_thread_rlock', lock)
 		self._lock = lock
 
 	def get_lock(self) -> threading.RLock:
 		"""Returns the current RLock object."""
 		return self._lock
 
+	def lock_resource(self, timeout: int, requested_key: str or bytes = None) -> bytes or None:
+		"""Locks the instrument to prevent it from communicating with other clients."""
+		if requested_key is None:
+			self._session.lock_excl(timeout)
+			return None
+		else:
+			return self._session.lock(timeout, requested_key)
+
+	def unlock_resource(self) -> None:
+		"""Unlocks the instrument to other clients."""
+		self._session.unlock()
+
 	@property
 	def visa_timeout(self) -> int:
 		"""See the visa_timeout.setter."""
 		return int(self._session.timeout)
 
 	@visa_timeout.setter
 	def visa_timeout(self, value: int) -> None:
@@ -278,73 +344,96 @@
 	@data_chunk_size.setter
 	def data_chunk_size(self, chunk_size: int) -> None:
 		"""Sets the maximum size of one block transferred during write/read operations."""
 		self._data_chunk_size = int(chunk_size)
 		self._session.chunk_size = int(chunk_size)
 
 	def _resolve_opc_timeout(self, timeout: int) -> int:
-		"""Resolves entered timeout value - if the input value is less than 1, it is replaces with opc_timeout."""
+		"""Resolves entered timeout value - if the input value is less than 1, it is replaced with opc_timeout."""
 		if timeout is None or timeout < 1:
 			return self.opc_timeout
 		else:
 			return timeout
 
 	def _set_regs_ese_sre(self, mode: WaitForOpcMode) -> WaitForOpcMode:
 		"""Based on the WaitForOpcMode, it sets the ESE and SRE register masks.
 		Returns coerced WaitForOpcMode."""
 		# Set the SRE and ESE registers accordingly
 		# No SRE is supported
+		if self.skip_status_system_setting:
+			return mode
 		self._set_ese_mask(EventStatusRegister.operation_complete)
 		self._set_sre_mask(StatusByte.NONE)
 		return mode
 
+	# noinspection PyTypeChecker
 	def _set_ese_mask(self, mask: EventStatusRegister, reset: bool = True) -> None:
 		"""Sends *ESE command with mask parameter."""
 		if reset is False:
 			current_value = int(self._query_str_no_events('*ESE?'))
 			mask = current_value | mask.value
 		self.write("*ESE %d" % mask.value)
 
+	# noinspection PyTypeChecker
 	def _set_sre_mask(self, mask: StatusByte, reset: bool = True) -> None:
 		"""Sends *SRE command with StatusByte mask parameter."""
 		if reset is False:
 			current_value = int(self._query_str_no_events('*SRE?'))
 			mask = current_value | mask.value
 		# Also affect the _opc_wait_mode:
 		# If the mask has event_status_byte == false, and the _opc_wait_mode is service_request, set it to stb_poll
 		# If the mask has event_status_byte == true, do not change anything
 		self.write(f'*SRE {mask.value}')
 
-	def _write_and_poll_stb_vxi(self, command: str, is_query: bool, timeout: int, end_mask: StatusByte) -> StatusByte:
+	def _write_and_poll_stb_vxi(self, command: str, is_query: bool, timeout: int) -> StatusByte:
 		"""Reads Status Byte Register and ends if the ESB bit (5) is set to 1.
 		Also works with the SOCKET and SERIAL interface by sending *STB? query.
 		In that case however, command cannot be a query.
 		Returns the last read Status Byte value."""
 		timeout_secs = timeout / 1000
-		self.clear_before_read()
+		end_mask = StatusByte.error_queue_not_empty | StatusByte.event_status_byte
 		if command.endswith(self._term_char):
 			command = command.rstrip(self._term_char)
-		self.write(command + ';*OPC')
-		# Use catch to return the VISA Timeout back
+
+		if is_query is True:
+			if self.opc_sync_query_mechanism == OpcSyncQueryMechanism.standard or self.opc_sync_query_mechanism == OpcSyncQueryMechanism.also_check_mav:
+				self.clear_before_read()
+				self.write(command + ';*OPC')
+				if self.opc_sync_query_mechanism == OpcSyncQueryMechanism.also_check_mav:
+					end_mask |= StatusByte.message_available
+
+			elif self.opc_sync_query_mechanism == OpcSyncQueryMechanism.only_check_mav_err_queue:
+				self.write(command)
+				end_mask = StatusByte.error_queue_not_empty | StatusByte.message_available
+
+			elif self.opc_sync_query_mechanism == OpcSyncQueryMechanism.cls_only_check_mav_err_queue:
+				self.clear_before_read()
+				self.write(command)
+				end_mask = StatusByte.error_queue_not_empty | StatusByte.message_available
+		else:
+			self.clear_before_read()
+			self.write(command + ';*OPC')
+
 		start = time.time()
 		# STB polling loop
 		while True:
 			stb = self._read_stb()
 			elapsed = self._polling_delay(start)
 			if elapsed > timeout_secs:
 				self._narrow_down_opc_tout_error(command, is_query, timeout)
 			if end_mask & stb:
 				break
 		return stb
 
-	def _write_and_poll_stb_non_vxi(self, command: str, timeout: int, end_mask: StatusByte) -> StatusByte:
+	def _write_and_poll_stb_non_vxi(self, command: str, timeout: int) -> StatusByte:
 		"""Queries Status Byte Register (*STB?) and ends if the ESB bit (5) is set to 1.
 			The command must not be a query. Also works with the SOCKET and SERIAL interface.
 			Returns the last read Status Byte value."""
 		timeout_secs = timeout / 1000
+		end_mask = StatusByte.error_queue_not_empty | StatusByte.event_status_byte
 		self.clear_before_read()
 		if command.endswith(self._term_char):
 			command = command.rstrip(self._term_char)
 		self.write(command + ';*OPC')
 		start = time.time()
 		# STB polling loop
 		while True:
@@ -360,43 +449,47 @@
 		"""Called by the _write_and_poll_stb_vxi when the timeout expires.
 		The method tries to closer identify the cause of the timeout."""
 		stb = self._read_stb()
 		timeout = self._resolve_opc_timeout(timeout)
 		if is_query:
 			if stb & StatusByte.error_queue_not_empty:
 				self.clear()
-				context = f"Sending query '{command.strip()}' with OPC Wait resulted in timeout. OPC Timeout is set to {timeout} ms. Additionally, "
-				InstrumentErrors.assert_no_instrument_status_errors(self._resource_name, self.query_all_syst_errors(), context)
-			InstrumentErrors.throw_opc_tout_exception(self.opc_timeout, timeout, f"Sending query '{command.strip()}'.")
+				context = f"Query '{command.strip()}' with OPC Wait resulted in timeout. OPC Timeout is set to {timeout} ms. Additionally, "
+				InstrumentErrors.assert_no_instrument_status_errors(self.resource_name, self.query_all_syst_errors(), context, first_exc=InstrumentErrors.TimeoutException)
+			InstrumentErrors.throw_opc_tout_exception(self.opc_timeout, timeout, f"Query '{command.strip()}'.")
 		else:
 			if stb & StatusByte.error_queue_not_empty:
 				self.clear()
-				context = f"Sending command '{command.strip()}' with OPC Wait resulted in timeout. OPC Timeout is set to {timeout} ms. Additionally, "
-				InstrumentErrors.assert_no_instrument_status_errors(self._resource_name, self.query_all_syst_errors(), context)
-			InstrumentErrors.throw_opc_tout_exception(self.opc_timeout, timeout, f"Sending command '{command.strip()}'.")
+				context = f"Command '{command.strip()}' with OPC Wait resulted in timeout. OPC Timeout is set to {timeout} ms. Additionally, "
+				InstrumentErrors.assert_no_instrument_status_errors(self.resource_name, self.query_all_syst_errors(), context, first_exc=InstrumentErrors.TimeoutException)
+			InstrumentErrors.throw_opc_tout_exception(self.opc_timeout, timeout, f"Command '{command.strip()}'.")
 
 	def _narrow_down_io_tout_error(self, context: str, visa_timeout: int = 0) -> None:
 		"""Called internally after IOTimeoutException can narrow down the error to more specific exception.
-		You can define the visa_timeout value for the error message. Otherwise the current visa_timeout is reported."""
+		You can define the visa_timeout value for the error message. Otherwise, the current visa_timeout is reported."""
+		context_stripped = context.strip().rstrip("- ")
+		if self.stb_in_error_check is False:
+			raise InstrumentErrors.TimeoutException(context_stripped)
 		if self.vxi_capable:
 			stb = self._read_stb()
 		else:
 			# Non-Vxi session
 			old_tout = self.visa_timeout
 			try:
 				self.visa_timeout = 500
-				stb = self._query_stb()
+				stb = self._query_stb(False)
 			finally:
 				self.visa_timeout = old_tout
 		if visa_timeout <= 0:
 			visa_timeout = self.visa_timeout
+
 		context = context + f'VISA Timeout error occurred ({visa_timeout} milliseconds)'
 		if stb & StatusByte.error_queue_not_empty:
-			InstrumentErrors.assert_no_instrument_status_errors(self._resource_name, self.query_all_syst_errors(), context + ' and ...')
-		# In case the previous exception is not thrown
+			InstrumentErrors.assert_no_instrument_status_errors(self.resource_name, self.query_all_syst_errors(), context + ' and ...', first_exc=InstrumentErrors.TimeoutException)
+		# In case none of the previous exceptions is thrown
 		raise InstrumentErrors.TimeoutException(context)
 
 	def _polling_delay(self, start):
 		"""Generates progressive polling delay."""
 
 		elapsed = time.time() - start
 		if self._opc_wait_mode == WaitForOpcMode.stb_poll:
@@ -445,59 +538,80 @@
 			if elapsed < 20:
 				time.sleep(1)
 				return elapsed
 			time.sleep(2)
 
 		return elapsed
 
-	def query_syst_error(self) -> str or None:
-		"""Returns one response to the SYSTEM:ERROR? query."""
-		error = self.query_str('SYST:ERR?')
-		if error.startswith('0,'):
+	@staticmethod
+	def _parse_err_query_response(response: str) -> Tuple[int, str]:
+		"""
+		Parses entered response string to Tuple(code, message).
+		E.g.: response = '-110,"Command error"' returns: (-110,'Command error')
+		"""
+		m = re.match(r'([-+]?\d+).*?[\'"](.*)[\'"]', response)
+		code = 0
+		if m:
+			try:
+				code = int(m.group(1))
+			except ValueError:
+				pass
+			return code, m.group(2)
+		else:
+			return code, response
+
+	def query_syst_error(self) -> Tuple[int, str] or None:
+		"""Returns one response to the SYSTEM:ERROR? query.
+		The response is a Tuple of (code: int, message: str)"""
+		error = self._query_str_no_events('SYST:ERR?')
+		if error.startswith('0,') or error.startswith('+0,'):
 			return None
-		return error.strip()
+		return self._parse_err_query_response(error.strip())
 
-	def query_all_syst_errors(self) -> list or None:
-		"""Returns all errors in the instrument's error queue."""
+	def query_all_syst_errors(self) -> List[Tuple[int, str]] or None:
+		"""Returns all errors in the instrument's error queue.
+		If no error is detected, the return value is None."""
 		errors = []
 		while True:
 			entry = self.query_syst_error()
 			if entry is None:
 				break
 			errors.append(entry)
 			if len(errors) > 50:
 				# Safety stop
 				errors.append('query_all_syst_errors - max limit 50 of SYST:ERR? sent.')
 				break
-
 		if len(errors) == 0:
 			return None
 		else:
 			return errors
 
-	def _query_stb(self) -> StatusByte:
+	def _query_stb(self, allow_tout_error_narrow_down: bool = True) -> StatusByte:
 		"""Sends *STB? query and reads the result."""
-		return StatusByte(int(self._query_str_no_events('*STB?')))
+		return StatusByte(int(self._query_str_no_events('*STB?', allow_tout_error_narrow_down)))
 
 	def _read_stb(self) -> StatusByte:
 		"""Calls viReadStb and returns the result."""
 		return StatusByte(self._session.read_stb())
 
 	def clear_before_read(self) -> None:
 		"""Clears IO buffers and the ESR register before reading/writing responses synchronized with *OPC."""
 
 		# For NRP-Z sessions, skip this completely
-		if self.is_rsnrp_session():
+		if self.is_rsnrp_session() or self.skip_clear_status:
 			return
 
 		if not self.vxi_capable:
 			# Non-Vxi session must use *CLS in any case
 			self.write('*CLS')
 			correct = False
-			opc = self._query_str_no_events('*OPC?')
+			if self.disable_opc_query:
+				opc = '1'
+			else:
+				opc = self._query_str_no_events('*OPC?')
 			repeat = 0
 			while not correct:
 				if len(opc) <= 2:
 					opc = opc.strip()
 					correct = opc == '0' or opc == '1'
 				if not correct:
 					# Read again with a small VISA timeout
@@ -525,15 +639,15 @@
 				self.query_and_clear_esr()
 			# Check if the status byte value changed
 			previous_stb = stb
 			stb = self._query_stb()
 			if stb == previous_stb:
 				repeat += 1
 				if repeat > 10:
-					raise Exception(f"Cannot clear the instrument's status subsystem. Status Byte: '{stb}'")
+					raise RsInstrException(f"Cannot clear the instrument's status subsystem. Status Byte: '{stb}'")
 
 	def _flush_junk_data(self) -> None:
 		"""Reads junk bytes to clear the instrument's output buffer."""
 		if self.read_delay > 0:
 			time.sleep(self.read_delay / 1000)
 		self._read_unknown_len(StreamWriter.as_bin_var(), False)
 
@@ -568,39 +682,55 @@
 			try:
 				self._session.clear()
 			except Exception:
 				pass
 		else:
 			self._session.clear()
 
+	def is_connection_active(self) -> bool:
+		"""Returns true, if the VISA connection is active and the communication with the instrument still works.
+		This is achieved by:
+		- checking the session property timeout
+		- sending the *IDN? query"""
+		if self._session is None:
+			return False
+		# noinspection PyBroadException
+		try:
+			old_tout = self.visa_timeout
+			self.visa_timeout = 2000
+			if len(self.cmd_idn) > 0:
+				self.write(self.cmd_idn)
+				_ = self._read_str_no_events()
+			self.visa_timeout = old_tout
+			return True
+		except Exception:
+			return False
+
 	def _write_and_wait_for_opc(self, command: str, is_query: bool, timeout: int) -> StatusByte:
 		"""Internal method to synchronise a command with OPC timeout.
 		Timeout value 0 means the OPC timeout is used."""
 		timeout = self._resolve_opc_timeout(timeout)
 
 		if command.endswith(self._term_char):
 			command = command.rstrip(self._term_char)
 		if is_query:
 			InstrumentErrors.assert_query_has_qmark(command, 'Query with OPC')
 		else:
 			InstrumentErrors.assert_cmd_has_no_qmark(command, 'Write with OPC')
 
 		if self._opc_wait_mode == WaitForOpcMode.opc_query:
 			if is_query:
-				raise Exception('Sending a query with OpcQuery synchronization is not possible')
+				raise RsInstrException('Sending a query with OpcQuery synchronization is not possible')
 			stb = self._write_and_query_opc(command, timeout)
 		else:
 			# STB polling
-			end_stb_mask = StatusByte.error_queue_not_empty | StatusByte.event_status_byte
-			if is_query:
-				end_stb_mask |= StatusByte.message_available
 			if self.vxi_capable:
-				stb = self._write_and_poll_stb_vxi(command, is_query, timeout, end_stb_mask)
+				stb = self._write_and_poll_stb_vxi(command, is_query, timeout)
 			else:
-				stb = self._write_and_poll_stb_non_vxi(command, timeout, end_stb_mask)
+				stb = self._write_and_poll_stb_non_vxi(command, timeout)
 
 		return stb
 
 	def _write_and_query_opc(self, cmd: str, timeout: int) -> StatusByte:
 		"""Internal method to write a command followed by query_opc().
 		Used for opc-synchronization if the mode is set to WaitForOpcMode.opc_query or the session is not-vxi.
 		Timeout value 0 means the OPC timeout is used."""
@@ -614,40 +744,52 @@
 			self.write(cmd)
 			self.query_opc()
 		finally:
 			if old_tout != timeout:
 				self.visa_timeout = old_tout
 		return self._query_stb()
 
+	def clear_status_after_query_with_opc(self) -> bool:
+		"""Returns true, if the opc-sync queries require status clearing afterward."""
+		if self.vxi_capable is False or self._opc_wait_mode is WaitForOpcMode.opc_query:
+			return False
+		if self.opc_sync_query_mechanism == InstrumentSettings.OpcSyncQueryMechanism.standard:
+			return True
+		if self.opc_sync_query_mechanism == InstrumentSettings.OpcSyncQueryMechanism.also_check_mav:
+			return True
+		return False
+
 	def write(self, cmd: str) -> None:
 		"""Writes command to the instrument."""
 		if self.write_delay > 0:
 			time.sleep(self.write_delay / 1000)
 		add_tc = False
 		if self._assure_write_with_tc and not cmd.endswith(self._term_char):
 			add_tc = True
+		if self.each_cmd_prefix:
+			cmd = self.each_cmd_prefix + cmd
+		cmd_bytes = cmd.encode(self.encoding)
 		if add_tc:
-			self._session.write(cmd + self._term_char)
-		else:
-			self._session.write(cmd)
+			cmd_bytes += self._term_char.encode(self.encoding)
+		self._session.write_raw(cmd_bytes)
 
 	def _read_unknown_len(self, stream: StreamWriter, allow_chunk_events: bool, prepend_data: AnyStr = None) -> None:
 		"""Reads data of unknown length to the provided WriteStream.
 		The read is performed in an incremental chunk steps to optimize memory use (for NRP-Z session it is set to fixed self._data_chunk_size):
 			- The first read is performed with the fixed size of 1024 bytes
 			- The 2nd one reads 64 kBytes
 			- The 3rd one reads 128 kBytes
 			- The 4th one reads 256 kBytes and so on, with the max cap of self._data_chunk_size
 		:param stream: [StreamWriter] target for the read data
 		:param allow_chunk_events: [bool] if True, the method can send the chunk_events. If False, sending events is blocked.
-		:param prepend_data: Optional[bytes or string] You can prepend this data to the beginning. It will be considered part of the first chunk read
+		:param prepend_data: Optional[bytes or string] You can prepend this data to the beginning. It will be considered part of the first read chunk
 		:return: read data [bytes or string], depending on the parameter binary."""
 		with self._session.ignore_warning(pyvisa.constants.StatusCode.success_max_count_read):
 			if prepend_data and isinstance(prepend_data, str):
-				prepend_data = prepend_data.encode('utf-8')
+				prepend_data = prepend_data.encode(self.encoding)
 			chunk_ix = 0
 			eot = False
 			while not eot:
 				if self.is_rsnrp_session():
 					chunk_size = self._data_chunk_size
 				else:
 					if chunk_ix == 0:
@@ -660,15 +802,15 @@
 				if chunk_size > self._data_chunk_size:
 					chunk_size = self._data_chunk_size
 				chunk, self.last_status = self._session.visalib.read(self._session.session, chunk_size)
 				if chunk_ix == 0 and prepend_data:
 					chunk = prepend_data + chunk
 				eot = not self._last_status_more_data_available()
 				if not stream.binary:
-					chunk = chunk.decode('utf-8')
+					chunk = chunk.decode(self.encoding)
 					if eot:
 						chunk = chunk.rstrip(self._term_char)
 				stream.write(chunk)
 				if self.on_read_chunk_handler and allow_chunk_events:
 					total_size = len(stream) if eot is True else None
 					event_args = EventArgsChunk(stream.binary, chunk_ix, len(chunk), total_size, len(stream), eot, None, chunk if self.io_events_include_data else None)
 					self.on_read_chunk_handler(event_args)
@@ -683,37 +825,44 @@
 		Sending of any read events is blocked."""
 		if self.read_delay > 0:
 			time.sleep(self.read_delay / 1000)
 		stream = StreamWriter.as_string_var()
 		self._read_unknown_len(stream, False)
 		return stream.content
 
-	def _query_str_no_events(self, query: str) -> str:
+	def _query_str_no_events(self, query: str, allow_tout_error_narrow_down: bool = True) -> str:
 		"""Queries the instrument and reads the response as string.
 		The length of the string is not limited. The response is then trimmed for trailing LF.
 		Sending of any read events is blocked. Use this method for all the service VisaSession queries."""
 		response = ''
 		self.write(query)
 		try:
 			response = self._read_str_no_events()
-		except pyvisa.VisaIOError:
-			self._narrow_down_io_tout_error(f"Querying '{query.rstrip(self._term_char)}' - ")
+		except pyvisa.VisaIOError as e:
+			context = f"Query '{query.rstrip(self._term_char)}'"
+			if e.error_code == StatusCode.error_timeout:
+				if allow_tout_error_narrow_down:
+					self._narrow_down_io_tout_error(context + ' - ')
+				else:
+					raise InstrumentErrors.TimeoutException(context)
+			else:
+				raise InstrumentErrors.RsInstrException(context)
 		return response
 
 	def _query_str_no_events_timed(self, query: str, timeout: int, suppress_read_tout: bool = False) -> str:
 		"""Queries the instrument and reads the response as string.
 		The entered timeout sets the VISA timeout just for this call. You can suppress the timeout error.
 		The length of the string is not limited. The response is then trimmed for trailing LF.
 		Sending of any read events is blocked. Use this method for all the service VisaSession queries."""
 		response = ''
 		self.write(query)
 		try:
 			response = self._read_str_timed(timeout, suppress_read_tout)
 		except pyvisa.VisaIOError:
-			self._narrow_down_io_tout_error(f"Querying with timeout {timeout} ms '{query.rstrip(self._term_char)}' - ", timeout)
+			self._narrow_down_io_tout_error(f"Query with timeout {timeout} ms '{query.rstrip(self._term_char)}' - ", timeout)
 		return response
 
 	def _read_str_timed(self, timeout: int, suppress_read_tout: bool = False) -> str:
 		"""Reads response from the instrument with a VISA timeout temporarily set for the read.
 		The VISA timeout is set back to the previous value before the method finishes even if an exception occurs.
 		Sending of any read events is blocked."""
 		old_visa_tout = self.visa_timeout
@@ -748,15 +897,15 @@
 		"""Queries the instrument and reads the response as string.
 		The length of the string is not limited. The response is then trimmed for trailing LF."""
 		response = ''
 		self.write(query)
 		try:
 			response = self._read_str()
 		except pyvisa.VisaIOError:
-			self._narrow_down_io_tout_error(f"Querying '{query.rstrip(self._term_char)}' - ")
+			self._narrow_down_io_tout_error(f"Query '{query.rstrip(self._term_char)}' - ")
 		return response
 
 	def query_str_no_tout_err(self, query: str, tout: int) -> str:
 		"""Same as query_str, but you can set the timeout just for this one call.
 		If the timeout exception occurs, it is suppressed and the method returns Null"""
 		response = None
 		old_tout = self.visa_timeout
@@ -770,23 +919,23 @@
 		return response
 
 	def write_with_opc(self, command: str, timeout: int = None) -> None:
 		"""Sends command with OPC-sync.
 		If you do not provide timeout, the method uses current opc_timeout."""
 		self._write_and_wait_for_opc(command, False, timeout)
 
-	def query_str_with_opc(self, query: str, timeout: int = None) -> str:
+	def query_str_with_opc(self, query: str, timeout: int = None, context: str = 'Query string with OPC') -> str:
 		"""Query string with OPC synchronization.
 		The response is trimmed for any trailing LF.
 		If you do not provide timeout, the method uses current opc_timeout."""
 		timeout = self._resolve_opc_timeout(timeout)
 		if self.vxi_capable and self._opc_wait_mode is not WaitForOpcMode.opc_query:
 			# For Vxi session, use the STB poll or SRQ wait and then read the response
 			stb = self._write_and_wait_for_opc(query, True, timeout)
-			self._check_msg_available_after_opc_wait(stb, query, timeout, 'Query String With OPC')
+			self._check_msg_available_after_opc_wait(stb, query, timeout, context)
 			response = self._read_str()
 		else:
 			# For non-Vxi sessions, use the longer VISA Timeout without the *OPC?
 			# Same is valid for WaitForOpcMode.OpcQuery
 			InstrumentErrors.assert_query_has_qmark(query, 'Query with VISA timeout')
 			self.write(query)
 			old_tout = self.visa_timeout
@@ -824,57 +973,59 @@
 		"""Used internally after _StbPolling() to check if the message is available.
 		Throws an exception in case of MAV not available."""
 		if not self.vxi_capable:
 			return
 		if stb & StatusByte.message_available:
 			return
 		# Message not available
-		context = context + f" SCPI query '{query.rstrip(self._term_char)}'"
+		context = context + f" Query '{query.rstrip(self._term_char)}'"
 		if stb & StatusByte.error_queue_not_empty:
 			# Instrument reports an error
-			InstrumentErrors.assert_no_instrument_status_errors(self._resource_name, self.query_all_syst_errors(), context)
+			InstrumentErrors.assert_no_instrument_status_errors(self.resource_name, self.query_all_syst_errors(), context)
 		else:
 			# Sometimes even if the StatusByte.MessageAvailable is false, the message is available.
 			# Try to read the STB again
 			stb = self._read_stb()
 			if not stb & StatusByte.event_status_byte:
 				# Instrument did not respond within the defined time
 				InstrumentErrors.throw_opc_tout_exception(self.opc_timeout, timeout, f'{context} No response from the instrument.')
 
 	def error_in_error_queue(self) -> bool:
 		"""Returns true, if error queue contains at least one error."""
 		stb = self._query_stb()
-		return (stb & StatusByte.error_queue_not_empty) != 0
+		if stb & StatusByte.error_queue_not_empty:
+			return True
+		return False
 
 	def reset_ese_sre(self) -> None:
 		"""Resets the status of ESE and SRE registers to default values."""
 		self._set_regs_ese_sre(self._opc_wait_mode)
 
 	def write_bin_block(self, cmd: str, data_stream: StreamReader) -> None:
 		"""Writes all the payload as binary data block to the instrument.
 		The binary data header is added at the beginning of the transmission automatically.
 		:param cmd: [str] SCPI command with which to send the data
 		:param data_stream: [StreamReader] data provider for the payload"""
 		data_size = len(data_stream)
 		len_str = f'{data_size}'
 		cmd = cmd.rstrip(self._term_char)
 		if '#' in cmd:
-			raise Exception(
+			raise RsInstrException(
 				f"Command '{cmd}' must be provided without the binary data header. "
 				f"The method 'write_bin_block' composes and prepends the binary data header automatically.")
 		if data_size <= self._std_bin_block_header_max_len:
 			# Standard bin data header for sizes below 1E9 bytes, e.g.: '#512345'
-			cmd_plus_header = f'{cmd}#{len(len_str)}{len_str}'.encode('utf-8')
+			cmd_plus_header = f'{cmd}#{len(len_str)}{len_str}'.encode(self.encoding)
 		else:
 			# Big sizes bin data header: e.g.: '#(3000000000)'
-			cmd_plus_header = f'{cmd}#({len_str})'.encode('utf-8')
+			cmd_plus_header = f'{cmd}#({len_str})'.encode(self.encoding)
 
 		if data_size <= self._data_chunk_size:
 			# Write all in one step
-			full_chunk = data_stream.read_as_binary()
+			full_chunk = data_stream.read_as_binary(self.encoding)
 			write_buf = cmd_plus_header + full_chunk
 			if self._add_term_char_to_write_bin_block:
 				write_buf += self._term_char_bin
 			self._session.write_raw(write_buf)
 			# Event sending
 			if self.on_write_chunk_handler:
 				event_args = EventArgsChunk(True, 0, data_size, data_size, data_size, True, 1, full_chunk if self.io_events_include_data else None)
@@ -890,24 +1041,24 @@
 					time.sleep(self.write_delay / 1000)
 				# Write bin header
 				self._session.write_raw(cmd_plus_header)
 				# Write chunks
 				while True:
 					if len(data_stream) > self._data_chunk_size:
 						#  Not the last segment
-						chunk = data_stream.read_as_binary(self._data_chunk_size)
+						chunk = data_stream.read_as_binary(self.encoding, self._data_chunk_size)
 						self._session.write_raw(chunk)
 						# Event sending
 						if self.on_write_chunk_handler:
 							event_args = EventArgsChunk(
 								True, chunk_ix, self._data_chunk_size, data_size, data_size - len(data_stream), False, total_chunks, chunk if self.io_events_include_data else None)
 							self.on_write_chunk_handler(event_args)
 					else:
 						# Last segment, indicate end of message again
-						chunk = data_stream.read_as_binary()
+						chunk = data_stream.read_as_binary(self.encoding)
 						if self._add_term_char_to_write_bin_block:
 							# Append LF
 							self._session.write_raw(chunk)
 							self._session.send_end = True
 							self._session.write_raw(self._term_char_bin)
 						else:
 							self._session.send_end = True
@@ -936,60 +1087,88 @@
 			char = self._session.read_bytes(1, break_on_termchar=True)
 			if char == b'0':
 				data_type = ReadDataType.bin_unknown_len
 				return data_type, '#0', -1
 			if char == b'(':
 				# format for big lengths i.e. > 1E9 bytes: '#(1234567890123)...'
 				data_type = ReadDataType.bin_known_len
-				len_str = (self.read_up_to_char(b')', 100)[:-1]).decode('utf-8')
+				len_str = (self.read_up_to_char(b')', 100)[:-1]).decode(self.encoding)
 				whole_hdr = '#(' + len_str + ')'
 				length = int(len_str)
 				return data_type, whole_hdr, length
 
 			# classic format for < 1E9 bytes: '#9123456789...'
 			data_type = ReadDataType.bin_known_len
 			len_of_len = int(char)
-			len_str = self._session.read_bytes(len_of_len).decode('utf-8')
+			len_str = self._session.read_bytes(len_of_len).decode(self.encoding)
 			length = int(len_str)
-			whole_hdr = '#' + char.decode('utf-8') + len_str
+			whole_hdr = '#' + char.decode(self.encoding) + len_str
 			return data_type, whole_hdr, length
 
 		data_type = ReadDataType.ascii
 		if char == self._term_char_bin:
 			data_type = ReadDataType.null
 		if self.vxi_capable:
 			# For Vxi session, to be sure, check whether there are more chars in the read buffer
 			stb = self._read_stb()
 			if stb & StatusByte.message_available:
 				data_type = ReadDataType.ascii
-		whole_hdr = char.decode('utf-8')
+		whole_hdr = char.decode(self.encoding)
 		if exc_if_not_bin:
 			if data_type == ReadDataType.null:
-				InstrumentErrors.throw_bin_block_unexp_resp_exception(self._resource_name, self._term_char)
+				InstrumentErrors.throw_bin_block_unexp_resp_exception(self.resource_name, self._term_char)
 			# Read 20 more characters to compose a better exception message
-			whole_hdr += self.read_up_to_char(self._term_char_bin, 20).decode('utf-8')
+			whole_hdr += self.read_up_to_char(self._term_char_bin, 20).decode(self.encoding)
 			if self.last_status == pyvisa.constants.StatusCode.success_max_count_read:
 				self._flush_junk_data()
-			InstrumentErrors.throw_bin_block_unexp_resp_exception(self._resource_name, whole_hdr)
+			InstrumentErrors.throw_bin_block_unexp_resp_exception(self.resource_name, whole_hdr)
 		return data_type, whole_hdr, length
 
+	def get_bin_data_length(self, query: str) -> int or None:
+		"""Returns only the length binary data header, and discards the actual data.
+		Any timeout error is suppressed, and the method returns None instead.
+		Warning!!! - for non-VXI sessions (SOCKET, ASRL) this method transfers the entire file to the control PC, which might take a long time."""
+		if self.vxi_capable and self._opc_wait_mode != WaitForOpcMode.opc_query:
+			# For Vxi session, use the STB poll and read the header
+			stb = self._write_and_wait_for_opc(query, True, 0)
+			try:
+				self._check_msg_available_after_opc_wait(stb, query, 0, 'get_bin_data_length')
+			except InstrumentErrors.StatusException:
+				return None
+			data_type, header, length = self._parse_bin_data_header(True)
+			self.clear()
+			self.clear_before_read()
+			return length
+		else:
+			with StreamWriter.as_forget() as stream:
+				old_timeout = self.visa_timeout
+				try:
+					self.visa_timeout = 2000
+					self.query_bin_block(query, stream, True)
+				except InstrumentErrors.StatusException:
+					return None
+				finally:
+					self.visa_timeout = old_timeout
+				length = stream.written_len
+		return length
+
 	def read_bin_block(self, stream: StreamWriter, exc_if_not_bin: bool) -> None:
 		"""Reads binary data block to the provided stream. \n
 		:param stream: [StreamWriter] target for the read data. Can be string, bytes, or a file
 		:param exc_if_not_bin: if True, the method throws exception if the received data is not binary"""
 		data_type, header, length = self._parse_bin_data_header(exc_if_not_bin)
 		if data_type == ReadDataType.ascii:
-			stream.switch_to_string_data()
+			stream.switch_to_string_data(self.encoding)
 			self._read_unknown_len(stream, True, header)
 		elif data_type == ReadDataType.null:
-			# No data, consider it ASCII, Return empty string, and False (signaling ASCII transfer)
-			stream.switch_to_string_data()
+			# No data, consider it ASCII. Change the stream type to ASCII and return empty string
+			stream.switch_to_string_data(self.encoding)
 		elif data_type == ReadDataType.bin_unknown_len:
 			if not self.vxi_capable:
-				raise Exception(f'Non-Vxi11 sessions can not read binary data block of unknown length.')
+				raise RsInstrException(f'Non-Vxi11 sessions can not read binary data block of unknown length.')
 			self._read_unknown_len(stream, True)
 		elif length == 0:
 			self._flush_junk_data()
 		else:
 			self._read_bin_block_known_len(stream, length)
 
 	def _read_bin_block_known_len(self, stream: StreamWriter, length: int) -> None:
@@ -1027,15 +1206,18 @@
 
 	def query_bin_block(self, query: str, stream: StreamWriter, exc_if_not_bin: bool = True) -> None:
 		"""Query binary data block and returns it as byte data. \n
 		:param query: [str] query to send to the instrument
 		:param stream: [StreamWriter] target for the read data. Can be string, bytes, or a file
 		:param exc_if_not_bin: [Boolean] if True, the method throws exception if the received data is not binary"""
 		self.write(query)
-		self.read_bin_block(stream, exc_if_not_bin)
+		try:
+			self.read_bin_block(stream, exc_if_not_bin)
+		except pyvisa.VisaIOError:
+			self._narrow_down_io_tout_error(f"Query bin block '{query.rstrip(self._term_char)}' - ")
 		return
 
 	def query_bin_block_with_opc(self, query: str, stream: StreamWriter, exc_if_not_bin: bool = True, timeout: int = None) -> None:
 		"""Query binary data block with OPC and returns it as byte data.
 		:param query: [str] query to send to the instrument
 		:param stream: [StreamWriter] target for the read data. Can be string, bytes, or a file
 		:param exc_if_not_bin: [Boolean] if True, the method throws exception if the received data is not binary
@@ -1073,14 +1255,28 @@
 			response += char
 			if char in stop_chars:
 				break
 			if self.last_status != pyvisa.constants.StatusCode.success_max_count_read:
 				break
 		return response
 
+	def go_to_local(self) -> None:
+		"""Puts the instrument into local state."""
+		if self.vxi_capable:
+			self._session.control_ren(pyvisa.constants.RENLineOperation.deassert_gtl)
+		else:
+			self.write("&GTL")
+
+	def go_to_remote(self) -> None:
+		"""Puts the instrument into remote state."""
+		if self.vxi_capable:
+			self._session.control_ren(pyvisa.constants.RENLineOperation.asrt_address)
+		else:
+			self.write("&GTR")
+
 	def get_session_handle(self) -> object:
 		"""Returns the underlying pyvisa session."""
 		return self._session
 
 	def close(self) -> None:
 		"""Closes the Visa session.
 		If the object was created with the direct session input, the session is not closed."""
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/Internal/VisaSessionSim.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/Internal/VisaSessionSim.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+"""VisaSession for simulated sessions."""
+
 import threading
 from typing import Callable, Dict, AnyStr
 
 from . import InstrumentSettings
 from .StreamReader import StreamReader
 from .StreamWriter import StreamWriter
 
@@ -9,14 +11,15 @@
 # noinspection PyMethodMayBeStatic,PyUnusedLocal
 class VisaSessionSim(object):
 	"""Visa session in simulation mode.
 	Provides the properties for the simulation mode.
 	Also serves as a cache for the SCPI command values: If you query a SCPI command value, it returns the last set value by that SCPI command."""
 
 	def __init__(self, resource_name: str, settings: InstrumentSettings, direct_session=None):
+		self.reusing_session = direct_session is not None
 		# noinspection PyTypeChecker
 		self._data_chunk_size: int = None
 		# noinspection PyTypeChecker
 		self._lock: threading.RLock = None
 
 		# Event handlers
 		# noinspection PyTypeChecker
@@ -25,16 +28,17 @@
 		# noinspection PyTypeChecker
 		self.on_write_chunk_handler: Callable = None
 		"""If assigned a handler, the VisaSession sends it event on each write chunk transfer."""
 		self.io_events_include_data: bool = False
 		"""If true, the VisaSession events sent to on_read_chunk_handler and on_write_chunk_handler contain transferred data."""
 
 		self.manufacturer: str = 'Rohde&Schwarz'
-		self._resource_name = resource_name
+		self.resource_name = resource_name
 		self.vxi_capable = True
+		self.encoding = settings.encoding  # default encoder between bytes and string
 
 		# Changeable settings
 		self.opc_timeout = 10000 if settings.opc_timeout == 0 else settings.opc_timeout
 		self.visa_timeout = settings.visa_timeout
 		self.data_chunk_size = settings.io_segment_size
 
 		self._last_cmd = None
@@ -50,14 +54,17 @@
 			rlock = direct_session.session_thread_rlock
 			if isinstance(rlock, type(threading.RLock())):
 				self.assign_lock(rlock)
 		if self.get_lock() is None:
 			# The existing session did not have a thread lock, assign a new one
 			self.assign_lock(threading.RLock())
 
+		if self.reusing_session:
+			self.resource_name = direct_session.resource_name
+
 	def assign_lock(self, lock: threading.RLock) -> None:
 		"""Assigns the provided thread lock. The lock is only used by the parent class Instrument."""
 		self._lock = lock
 
 	def get_lock(self) -> threading.RLock:
 		"""Returns the current RLock object."""
 		return self._lock
@@ -92,25 +99,30 @@
 		return False
 
 	def query_syst_error(self) -> str or None:
 		"""Returns one response to the SYSTEM:ERROR? query."""
 		return None
 
 	def query_all_syst_errors(self) -> list or None:
-		"""Returns all errors in the instrument's error queue."""
-		return []
+		"""Returns all errors in the instrument's error queue.
+		If no error is detected, the return value is None."""
+		return None
 
 	def clear_before_read(self) -> None:
 		"""Clears IO buffers and the ESR register before reading/writing responses synchronized with *OPC."""
 		return
 
 	def clear(self) -> None:
 		"""Perform VISA viClear conditionally based on the instrument settings."""
 		return
 
+	def clear_status_after_query_with_opc(self) -> bool:
+		"""Returns true, if the opc-sync queries require status clearing afterward."""
+		return False
+
 	def write(self, cmd: str) -> None:
 		"""Writes command to the instrument."""
 		self._last_cmd = cmd
 		self._update_cmd_vals_cache(cmd)
 		return
 
 	def query_str(self, query: str) -> str:
@@ -121,15 +133,15 @@
 		return 'Simulating' if cached is None else cached
 
 	def write_with_opc(self, cmd: str, timeout: int = None) -> None:
 		"""Sends command with OPC-sync.
 		If you do not provide timeout, the method uses current opc_timeout."""
 		self.write(cmd)
 
-	def query_str_with_opc(self, query: str, timeout: int = None) -> str:
+	def query_str_with_opc(self, query: str, timeout: int = None, context: str = 'Query string with OPC') -> str:
 		"""Query string with OPC synchronization.
 		The response is trimmed for any trailing LF.
 		If you do not provide timeout, the method uses current opc_timeout."""
 		return self.query_str(query)
 
 	def query_opc(self, timeout: int = 0) -> bool:
 		"""Sends *OPC? query and reads the result."""
@@ -160,28 +172,28 @@
 		cached = self._get_cmd_cached_value(query)
 
 		if cached is None:
 			stream.write(bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 65, 66]))
 			self.cached_to_stream = False
 		else:
 			if isinstance(cached, str):
-				stream.switch_to_string_data()
+				stream.switch_to_string_data(self.encoding)
 			stream.write(cached)
 			self.cached_to_stream = True
 
 	def query_bin_block_with_opc(self, query: str, stream: StreamWriter, exc_if_not_bin: bool = True, timeout: int = None) -> None:
 		"""Query binary data block with OPC and returns it as byte data."""
 		self.query_bin_block(query, stream)
 
 	def read_up_to_char(self, stop_chars: bytes, max_cnt: int) -> bytes:
 		"""Reads until one of the stop_chars is read or the max_cnt is reached, or EOT is detected.
 		Returns the read data including the stop character."""
 		return b'Simulating'
 
 	def get_session_handle(self) -> object:
 		"""Returns the underlying pyvisa session."""
-		return f"Simulating session, resource name '{self._resource_name}'"
+		return f"Simulating session, resource name '{self.resource_name}'"
 
 	def close(self) -> None:
 		"""Closes the Visa session.
 		If the object was created with the direct session input, the session is not closed."""
 		return
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/__init__.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,27 +1,30 @@
 """RsCmwGprfMeas instrument driver
-	:version: 3.7.30.31
-	:copyright: 2021 by Rohde & Schwarz GMBH & Co. KG
+	:version: 4.0.140.33
+	:copyright: 2023 by Rohde & Schwarz GMBH & Co. KG
 	:license: MIT, see LICENSE for more details.
 """
 
-__version__ = '3.7.30.31'
+__version__ = '4.0.140.33'
 
 # Main class
 from RsCmwGprfMeas.RsCmwGprfMeas import RsCmwGprfMeas
 
 # Bin data format
 from RsCmwGprfMeas.Internal.Conversions import BinIntFormat, BinFloatFormat
 
 # Exceptions
 from RsCmwGprfMeas.Internal.InstrumentErrors import RsInstrException, TimeoutException, StatusException, UnexpectedResponseException, ResourceError, DriverValueError
 
 # Callback Event Argument prototypes
 from RsCmwGprfMeas.Internal.IoTransferEventArgs import IoTransferEventArgs
 
+# Logging Mode
+from RsCmwGprfMeas.Internal.ScpiLogger import LoggingMode
+
 # enums
 from RsCmwGprfMeas import enums
 
 # repcaps
 from RsCmwGprfMeas import repcap
 
 # Reliability interface
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/enums.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/enums.py`

 * *Files 2% similar despite different names*

```diff
@@ -150,18 +150,20 @@
 	OFF = 0
 	ON = 1
 	ONLY = 2
 
 
 # noinspection SpellCheckingInspection
 class FilterType(Enum):
-	"""3 Members, GAUSs ... NYQuist"""
-	GAUSs = 0
-	NY1Mhz = 1
-	NYQuist = 2
+	"""5 Members, B10Mhz ... NYQuist"""
+	B10Mhz = 0
+	B1MHz = 1
+	GAUSs = 2
+	NY1Mhz = 3
+	NYQuist = 4
 
 
 # noinspection SpellCheckingInspection
 class IqFormat(Enum):
 	"""2 Members, IQ ... RPHI"""
 	IQ = 0
 	RPHI = 1
@@ -276,15 +278,15 @@
 	UFL = 7
 	ULEL = 8
 	ULEU = 9
 
 
 # noinspection SpellCheckingInspection
 class RfConnector(Enum):
-	"""154 Members, I11I ... RH8"""
+	"""163 Members, I11I ... RH8"""
 	I11I = 0
 	I13I = 1
 	I15I = 2
 	I17I = 3
 	I21I = 4
 	I23I = 5
 	I25I = 6
@@ -293,152 +295,161 @@
 	I33I = 9
 	I35I = 10
 	I37I = 11
 	I41I = 12
 	I43I = 13
 	I45I = 14
 	I47I = 15
-	IF1 = 16
-	IF2 = 17
-	IF3 = 18
-	IQ1I = 19
-	IQ3I = 20
-	IQ5I = 21
-	IQ7I = 22
-	R11 = 23
-	R11C = 24
-	R12 = 25
-	R12C = 26
-	R12I = 27
-	R13 = 28
-	R13C = 29
-	R14 = 30
-	R14C = 31
-	R14I = 32
-	R15 = 33
-	R16 = 34
-	R17 = 35
-	R18 = 36
-	R21 = 37
-	R21C = 38
-	R22 = 39
-	R22C = 40
-	R22I = 41
-	R23 = 42
-	R23C = 43
-	R24 = 44
-	R24C = 45
-	R24I = 46
-	R25 = 47
-	R26 = 48
-	R27 = 49
-	R28 = 50
-	R31 = 51
-	R31C = 52
-	R32 = 53
-	R32C = 54
-	R32I = 55
-	R33 = 56
-	R33C = 57
-	R34 = 58
-	R34C = 59
-	R34I = 60
-	R35 = 61
-	R36 = 62
-	R37 = 63
-	R38 = 64
-	R41 = 65
-	R41C = 66
-	R42 = 67
-	R42C = 68
-	R42I = 69
-	R43 = 70
-	R43C = 71
-	R44 = 72
-	R44C = 73
-	R44I = 74
-	R45 = 75
-	R46 = 76
-	R47 = 77
-	R48 = 78
-	RA1 = 79
-	RA2 = 80
-	RA3 = 81
-	RA4 = 82
-	RA5 = 83
-	RA6 = 84
-	RA7 = 85
-	RA8 = 86
-	RB1 = 87
-	RB2 = 88
-	RB3 = 89
-	RB4 = 90
-	RB5 = 91
-	RB6 = 92
-	RB7 = 93
-	RB8 = 94
-	RC1 = 95
-	RC2 = 96
-	RC3 = 97
-	RC4 = 98
-	RC5 = 99
-	RC6 = 100
-	RC7 = 101
-	RC8 = 102
-	RD1 = 103
-	RD2 = 104
-	RD3 = 105
-	RD4 = 106
-	RD5 = 107
-	RD6 = 108
-	RD7 = 109
-	RD8 = 110
-	RE1 = 111
-	RE2 = 112
-	RE3 = 113
-	RE4 = 114
-	RE5 = 115
-	RE6 = 116
-	RE7 = 117
-	RE8 = 118
-	RF1 = 119
-	RF1C = 120
-	RF2 = 121
-	RF2C = 122
-	RF2I = 123
-	RF3 = 124
-	RF3C = 125
-	RF4 = 126
-	RF4C = 127
-	RF4I = 128
-	RF5 = 129
-	RF5C = 130
-	RF6 = 131
-	RF6C = 132
-	RF7 = 133
-	RF8 = 134
-	RFAC = 135
-	RFBC = 136
-	RFBI = 137
-	RG1 = 138
-	RG2 = 139
-	RG3 = 140
-	RG4 = 141
-	RG5 = 142
-	RG6 = 143
-	RG7 = 144
-	RG8 = 145
-	RH1 = 146
-	RH2 = 147
-	RH3 = 148
-	RH4 = 149
-	RH5 = 150
-	RH6 = 151
-	RH7 = 152
-	RH8 = 153
+	IFI1 = 16
+	IFI2 = 17
+	IFI3 = 18
+	IFI4 = 19
+	IFI5 = 20
+	IFI6 = 21
+	IQ1I = 22
+	IQ3I = 23
+	IQ5I = 24
+	IQ7I = 25
+	R10D = 26
+	R11 = 27
+	R11C = 28
+	R11D = 29
+	R12 = 30
+	R12C = 31
+	R12D = 32
+	R12I = 33
+	R13 = 34
+	R13C = 35
+	R14 = 36
+	R14C = 37
+	R14I = 38
+	R15 = 39
+	R16 = 40
+	R17 = 41
+	R18 = 42
+	R21 = 43
+	R21C = 44
+	R22 = 45
+	R22C = 46
+	R22I = 47
+	R23 = 48
+	R23C = 49
+	R24 = 50
+	R24C = 51
+	R24I = 52
+	R25 = 53
+	R26 = 54
+	R27 = 55
+	R28 = 56
+	R31 = 57
+	R31C = 58
+	R32 = 59
+	R32C = 60
+	R32I = 61
+	R33 = 62
+	R33C = 63
+	R34 = 64
+	R34C = 65
+	R34I = 66
+	R35 = 67
+	R36 = 68
+	R37 = 69
+	R38 = 70
+	R41 = 71
+	R41C = 72
+	R42 = 73
+	R42C = 74
+	R42I = 75
+	R43 = 76
+	R43C = 77
+	R44 = 78
+	R44C = 79
+	R44I = 80
+	R45 = 81
+	R46 = 82
+	R47 = 83
+	R48 = 84
+	RA1 = 85
+	RA2 = 86
+	RA3 = 87
+	RA4 = 88
+	RA5 = 89
+	RA6 = 90
+	RA7 = 91
+	RA8 = 92
+	RB1 = 93
+	RB2 = 94
+	RB3 = 95
+	RB4 = 96
+	RB5 = 97
+	RB6 = 98
+	RB7 = 99
+	RB8 = 100
+	RC1 = 101
+	RC2 = 102
+	RC3 = 103
+	RC4 = 104
+	RC5 = 105
+	RC6 = 106
+	RC7 = 107
+	RC8 = 108
+	RD1 = 109
+	RD2 = 110
+	RD3 = 111
+	RD4 = 112
+	RD5 = 113
+	RD6 = 114
+	RD7 = 115
+	RD8 = 116
+	RE1 = 117
+	RE2 = 118
+	RE3 = 119
+	RE4 = 120
+	RE5 = 121
+	RE6 = 122
+	RE7 = 123
+	RE8 = 124
+	RF1 = 125
+	RF1C = 126
+	RF2 = 127
+	RF2C = 128
+	RF2I = 129
+	RF3 = 130
+	RF3C = 131
+	RF4 = 132
+	RF4C = 133
+	RF4I = 134
+	RF5 = 135
+	RF5C = 136
+	RF6 = 137
+	RF6C = 138
+	RF7 = 139
+	RF7C = 140
+	RF8 = 141
+	RF8C = 142
+	RF9C = 143
+	RFAC = 144
+	RFBC = 145
+	RFBI = 146
+	RG1 = 147
+	RG2 = 148
+	RG3 = 149
+	RG4 = 150
+	RG5 = 151
+	RG6 = 152
+	RG7 = 153
+	RG8 = 154
+	RH1 = 155
+	RH2 = 156
+	RH3 = 157
+	RH4 = 158
+	RH5 = 159
+	RH6 = 160
+	RH7 = 161
+	RH8 = 162
 
 
 # noinspection SpellCheckingInspection
 class RxConverter(Enum):
 	"""40 Members, IRX1 ... RX44"""
 	IRX1 = 0
 	IRX11 = 1
@@ -514,14 +525,29 @@
 	AVERage = 0
 	CURRent = 1
 	MAXimum = 2
 	MINimum = 3
 
 
 # noinspection SpellCheckingInspection
+class TargetMainState(Enum):
+	"""3 Members, OFF ... RUN"""
+	OFF = 0
+	RDY = 1
+	RUN = 2
+
+
+# noinspection SpellCheckingInspection
+class TargetSyncState(Enum):
+	"""2 Members, ADJusted ... PENDing"""
+	ADJusted = 0
+	PENDing = 1
+
+
+# noinspection SpellCheckingInspection
 class Timing(Enum):
 	"""2 Members, CENTered ... STEP"""
 	CENTered = 0
 	STEP = 1
 
 
 # noinspection SpellCheckingInspection
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas/repcap.py` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas/repcap.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,18 +1,19 @@
 from enum import Enum
-from .Internal.RepeatedCapability import VALUE_DEFAULT
-from .Internal.RepeatedCapability import VALUE_EMPTY
+# noinspection PyPep8Naming
+from .Internal.RepeatedCapability import VALUE_DEFAULT as DefaultRepCap
+# noinspection PyPep8Naming
+from .Internal.RepeatedCapability import VALUE_EMPTY as EmptyRepCap
 
 
 # noinspection SpellCheckingInspection
 class Instance(Enum):
-	"""Global Repeated capability Instance \n
-	Selects the instrument"""
-	Empty = VALUE_EMPTY
-	Default = VALUE_DEFAULT
+	"""Global Repeated capability Instance"""
+	Empty = EmptyRepCap
+	Default = DefaultRepCap
 	Inst1 = 1
 	Inst2 = 2
 	Inst3 = 3
 	Inst4 = 4
 	Inst5 = 5
 	Inst6 = 6
 	Inst7 = 7
@@ -41,24 +42,22 @@
 	Inst30 = 30
 	Inst31 = 31
 	Inst32 = 32
 
 
 # noinspection SpellCheckingInspection
 class Marker(Enum):
-	"""Repeated capability Marker \n
-	Selects the Marker"""
-	Empty = VALUE_EMPTY
-	Default = VALUE_DEFAULT
+	"""Repeated capability Marker"""
+	Empty = EmptyRepCap
+	Default = DefaultRepCap
 	Nr1 = 1
 	Nr2 = 2
 
 
 # noinspection SpellCheckingInspection
 class Sensor(Enum):
-	"""Repeated capability Sensor \n
-	Selects the NRPM"""
-	Empty = VALUE_EMPTY
-	Default = VALUE_DEFAULT
+	"""Repeated capability Sensor"""
+	Empty = EmptyRepCap
+	Default = DefaultRepCap
 	Nr1 = 1
 	Nr2 = 2
 	Nr3 = 3
```

### Comparing `RsCmwGprfMeas-3.7.30.31/RsCmwGprfMeas.egg-info/SOURCES.txt` & `RsCmwGprfMeas-4.0.140/RsCmwGprfMeas.egg-info/SOURCES.txt`

 * *Files 18% similar despite different names*

```diff
@@ -1,332 +1,275 @@
-README.md
+README.rst
 setup.py
 RsCmwGprfMeas/RsCmwGprfMeas.py
 RsCmwGprfMeas/__init__.py
 RsCmwGprfMeas/enums.py
 RsCmwGprfMeas/repcap.py
 RsCmwGprfMeas.egg-info/PKG-INFO
 RsCmwGprfMeas.egg-info/SOURCES.txt
 RsCmwGprfMeas.egg-info/dependency_links.txt
 RsCmwGprfMeas.egg-info/requires.txt
 RsCmwGprfMeas.egg-info/top_level.txt
 RsCmwGprfMeas/CustomFiles/__init__.py
 RsCmwGprfMeas/CustomFiles/events.py
 RsCmwGprfMeas/CustomFiles/reliability.py
 RsCmwGprfMeas/CustomFiles/utilities.py
-RsCmwGprfMeas/Implementations/Calibration.py
-RsCmwGprfMeas/Implementations/Configure.py
-RsCmwGprfMeas/Implementations/ExtPwrSensor.py
-RsCmwGprfMeas/Implementations/FftSpecAn.py
-RsCmwGprfMeas/Implementations/Initiate.py
-RsCmwGprfMeas/Implementations/IqRecorder.py
-RsCmwGprfMeas/Implementations/IqVsSlot.py
-RsCmwGprfMeas/Implementations/Nrpm.py
-RsCmwGprfMeas/Implementations/Ploss.py
-RsCmwGprfMeas/Implementations/Power.py
-RsCmwGprfMeas/Implementations/Route.py
-RsCmwGprfMeas/Implementations/Spectrum.py
-RsCmwGprfMeas/Implementations/Trigger.py
 RsCmwGprfMeas/Implementations/__init__.py
-RsCmwGprfMeas/Implementations/Calibration_/ExtPwrSensor.py
-RsCmwGprfMeas/Implementations/Calibration_/__init__.py
-RsCmwGprfMeas/Implementations/Calibration_/ExtPwrSensor_/Zero.py
-RsCmwGprfMeas/Implementations/Calibration_/ExtPwrSensor_/__init__.py
-RsCmwGprfMeas/Implementations/Configure_/ExtPwrSensor.py
-RsCmwGprfMeas/Implementations/Configure_/FftSpecAn.py
-RsCmwGprfMeas/Implementations/Configure_/IqRecorder.py
-RsCmwGprfMeas/Implementations/Configure_/IqVsSlot.py
-RsCmwGprfMeas/Implementations/Configure_/Nrpm.py
-RsCmwGprfMeas/Implementations/Configure_/Ploss.py
-RsCmwGprfMeas/Implementations/Configure_/Power.py
-RsCmwGprfMeas/Implementations/Configure_/RfSettings.py
-RsCmwGprfMeas/Implementations/Configure_/Spectrum.py
-RsCmwGprfMeas/Implementations/Configure_/__init__.py
-RsCmwGprfMeas/Implementations/Configure_/ExtPwrSensor_/Attenuation.py
-RsCmwGprfMeas/Implementations/Configure_/ExtPwrSensor_/__init__.py
-RsCmwGprfMeas/Implementations/Configure_/FftSpecAn_/PeakSearch.py
-RsCmwGprfMeas/Implementations/Configure_/FftSpecAn_/__init__.py
-RsCmwGprfMeas/Implementations/Configure_/IqRecorder_/FilterPy.py
-RsCmwGprfMeas/Implementations/Configure_/IqRecorder_/ListPy.py
-RsCmwGprfMeas/Implementations/Configure_/IqRecorder_/Trigger.py
-RsCmwGprfMeas/Implementations/Configure_/IqRecorder_/__init__.py
-RsCmwGprfMeas/Implementations/Configure_/IqRecorder_/FilterPy_/Bandpass.py
-RsCmwGprfMeas/Implementations/Configure_/IqRecorder_/FilterPy_/Gauss.py
-RsCmwGprfMeas/Implementations/Configure_/IqRecorder_/FilterPy_/__init__.py
-RsCmwGprfMeas/Implementations/Configure_/IqRecorder_/ListPy_/EnvelopePower.py
-RsCmwGprfMeas/Implementations/Configure_/IqRecorder_/ListPy_/Frequency.py
-RsCmwGprfMeas/Implementations/Configure_/IqRecorder_/ListPy_/__init__.py
-RsCmwGprfMeas/Implementations/Configure_/IqVsSlot_/ListPy.py
-RsCmwGprfMeas/Implementations/Configure_/IqVsSlot_/Trigger.py
-RsCmwGprfMeas/Implementations/Configure_/IqVsSlot_/__init__.py
-RsCmwGprfMeas/Implementations/Configure_/IqVsSlot_/ListPy_/EnvelopePower.py
-RsCmwGprfMeas/Implementations/Configure_/IqVsSlot_/ListPy_/Frequency.py
-RsCmwGprfMeas/Implementations/Configure_/IqVsSlot_/ListPy_/Retrigger.py
-RsCmwGprfMeas/Implementations/Configure_/IqVsSlot_/ListPy_/__init__.py
-RsCmwGprfMeas/Implementations/Configure_/Nrpm_/Sensor.py
-RsCmwGprfMeas/Implementations/Configure_/Nrpm_/__init__.py
-RsCmwGprfMeas/Implementations/Configure_/Nrpm_/Sensor_/Frequency.py
-RsCmwGprfMeas/Implementations/Configure_/Nrpm_/Sensor_/__init__.py
-RsCmwGprfMeas/Implementations/Configure_/Ploss_/ListPy.py
-RsCmwGprfMeas/Implementations/Configure_/Ploss_/Mpath.py
-RsCmwGprfMeas/Implementations/Configure_/Ploss_/View.py
-RsCmwGprfMeas/Implementations/Configure_/Ploss_/__init__.py
-RsCmwGprfMeas/Implementations/Configure_/Ploss_/ListPy_/Frequency.py
-RsCmwGprfMeas/Implementations/Configure_/Ploss_/ListPy_/__init__.py
-RsCmwGprfMeas/Implementations/Configure_/Ploss_/Mpath_/ListPy.py
-RsCmwGprfMeas/Implementations/Configure_/Ploss_/Mpath_/__init__.py
-RsCmwGprfMeas/Implementations/Configure_/Ploss_/Mpath_/ListPy_/Frequency.py
-RsCmwGprfMeas/Implementations/Configure_/Ploss_/Mpath_/ListPy_/__init__.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/Catalog.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/FilterPy.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/ListPy.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/Trigger.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/__init__.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/FilterPy_/Bandpass.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/FilterPy_/Gauss.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/FilterPy_/__init__.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/ListPy_/EnvelopePower.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/ListPy_/Frequency.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/ListPy_/IqData.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/ListPy_/Irepetition.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/ListPy_/ParameterSetList.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/ListPy_/Retrigger.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/ListPy_/SingleCmw.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/ListPy_/__init__.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/ListPy_/SingleCmw_/Connector.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/ListPy_/SingleCmw_/__init__.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/Catalog.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/FilterPy.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/Mlength.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/PdefSet.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/Slength.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/__init__.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/FilterPy_/Bandpass.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/FilterPy_/Gauss.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/FilterPy_/TypePy.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/FilterPy_/__init__.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/FilterPy_/Bandpass_/Bandwidth.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/FilterPy_/Bandpass_/__init__.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/FilterPy_/Gauss_/Bandwidth.py
-RsCmwGprfMeas/Implementations/Configure_/Power_/ParameterSetList_/FilterPy_/Gauss_/__init__.py
-RsCmwGprfMeas/Implementations/Configure_/Spectrum_/FreqSweep.py
-RsCmwGprfMeas/Implementations/Configure_/Spectrum_/Frequency.py
-RsCmwGprfMeas/Implementations/Configure_/Spectrum_/ZeroSpan.py
-RsCmwGprfMeas/Implementations/Configure_/Spectrum_/__init__.py
-RsCmwGprfMeas/Implementations/Configure_/Spectrum_/FreqSweep_/Rbw.py
-RsCmwGprfMeas/Implementations/Configure_/Spectrum_/FreqSweep_/Swt.py
-RsCmwGprfMeas/Implementations/Configure_/Spectrum_/FreqSweep_/Vbw.py
-RsCmwGprfMeas/Implementations/Configure_/Spectrum_/FreqSweep_/__init__.py
-RsCmwGprfMeas/Implementations/Configure_/Spectrum_/Frequency_/Span.py
-RsCmwGprfMeas/Implementations/Configure_/Spectrum_/Frequency_/__init__.py
-RsCmwGprfMeas/Implementations/Configure_/Spectrum_/ZeroSpan_/Rbw.py
-RsCmwGprfMeas/Implementations/Configure_/Spectrum_/ZeroSpan_/Vbw.py
-RsCmwGprfMeas/Implementations/Configure_/Spectrum_/ZeroSpan_/__init__.py
-RsCmwGprfMeas/Implementations/ExtPwrSensor_/State.py
-RsCmwGprfMeas/Implementations/ExtPwrSensor_/__init__.py
-RsCmwGprfMeas/Implementations/ExtPwrSensor_/State_/All.py
-RsCmwGprfMeas/Implementations/ExtPwrSensor_/State_/__init__.py
-RsCmwGprfMeas/Implementations/FftSpecAn_/Icomponent.py
-RsCmwGprfMeas/Implementations/FftSpecAn_/Peaks.py
-RsCmwGprfMeas/Implementations/FftSpecAn_/Power.py
-RsCmwGprfMeas/Implementations/FftSpecAn_/Qcomponent.py
-RsCmwGprfMeas/Implementations/FftSpecAn_/State.py
-RsCmwGprfMeas/Implementations/FftSpecAn_/__init__.py
-RsCmwGprfMeas/Implementations/FftSpecAn_/Peaks_/Average.py
-RsCmwGprfMeas/Implementations/FftSpecAn_/Peaks_/Current.py
-RsCmwGprfMeas/Implementations/FftSpecAn_/Peaks_/__init__.py
-RsCmwGprfMeas/Implementations/FftSpecAn_/Power_/Average.py
-RsCmwGprfMeas/Implementations/FftSpecAn_/Power_/Current.py
-RsCmwGprfMeas/Implementations/FftSpecAn_/Power_/Maximum.py
-RsCmwGprfMeas/Implementations/FftSpecAn_/Power_/Minimum.py
-RsCmwGprfMeas/Implementations/FftSpecAn_/Power_/__init__.py
-RsCmwGprfMeas/Implementations/FftSpecAn_/State_/All.py
-RsCmwGprfMeas/Implementations/FftSpecAn_/State_/__init__.py
-RsCmwGprfMeas/Implementations/Initiate_/Ploss.py
-RsCmwGprfMeas/Implementations/Initiate_/__init__.py
-RsCmwGprfMeas/Implementations/IqRecorder_/Bin.py
-RsCmwGprfMeas/Implementations/IqRecorder_/Reliability.py
-RsCmwGprfMeas/Implementations/IqRecorder_/State.py
-RsCmwGprfMeas/Implementations/IqRecorder_/SymbolRate.py
-RsCmwGprfMeas/Implementations/IqRecorder_/Talignment.py
-RsCmwGprfMeas/Implementations/IqRecorder_/__init__.py
-RsCmwGprfMeas/Implementations/IqRecorder_/State_/All.py
-RsCmwGprfMeas/Implementations/IqRecorder_/State_/__init__.py
-RsCmwGprfMeas/Implementations/IqVsSlot_/FreqError.py
-RsCmwGprfMeas/Implementations/IqVsSlot_/Icomponent.py
-RsCmwGprfMeas/Implementations/IqVsSlot_/Level.py
-RsCmwGprfMeas/Implementations/IqVsSlot_/OfError.py
-RsCmwGprfMeas/Implementations/IqVsSlot_/Phase.py
-RsCmwGprfMeas/Implementations/IqVsSlot_/Qcomponent.py
-RsCmwGprfMeas/Implementations/IqVsSlot_/State.py
-RsCmwGprfMeas/Implementations/IqVsSlot_/__init__.py
-RsCmwGprfMeas/Implementations/IqVsSlot_/State_/All.py
-RsCmwGprfMeas/Implementations/IqVsSlot_/State_/__init__.py
-RsCmwGprfMeas/Implementations/Nrpm_/Sensor.py
-RsCmwGprfMeas/Implementations/Nrpm_/State.py
-RsCmwGprfMeas/Implementations/Nrpm_/__init__.py
-RsCmwGprfMeas/Implementations/Nrpm_/Sensor_/Power.py
-RsCmwGprfMeas/Implementations/Nrpm_/Sensor_/__init__.py
-RsCmwGprfMeas/Implementations/Nrpm_/State_/All.py
-RsCmwGprfMeas/Implementations/Nrpm_/State_/__init__.py
-RsCmwGprfMeas/Implementations/Ploss_/Clear.py
-RsCmwGprfMeas/Implementations/Ploss_/Eval.py
-RsCmwGprfMeas/Implementations/Ploss_/Open.py
-RsCmwGprfMeas/Implementations/Ploss_/Short.py
-RsCmwGprfMeas/Implementations/Ploss_/State.py
-RsCmwGprfMeas/Implementations/Ploss_/__init__.py
-RsCmwGprfMeas/Implementations/Ploss_/Eval_/Frequency.py
-RsCmwGprfMeas/Implementations/Ploss_/Eval_/Gain.py
-RsCmwGprfMeas/Implementations/Ploss_/Eval_/State.py
-RsCmwGprfMeas/Implementations/Ploss_/Eval_/Trace.py
-RsCmwGprfMeas/Implementations/Ploss_/Eval_/__init__.py
-RsCmwGprfMeas/Implementations/Ploss_/Eval_/Trace_/Frequency.py
-RsCmwGprfMeas/Implementations/Ploss_/Eval_/Trace_/Gain.py
-RsCmwGprfMeas/Implementations/Ploss_/Eval_/Trace_/__init__.py
-RsCmwGprfMeas/Implementations/Ploss_/State_/All.py
-RsCmwGprfMeas/Implementations/Ploss_/State_/__init__.py
-RsCmwGprfMeas/Implementations/Power_/AmplitudeProbDensity.py
-RsCmwGprfMeas/Implementations/Power_/Average.py
-RsCmwGprfMeas/Implementations/Power_/CumulativeDistribFnc.py
-RsCmwGprfMeas/Implementations/Power_/Current.py
-RsCmwGprfMeas/Implementations/Power_/ElapsedStats.py
-RsCmwGprfMeas/Implementations/Power_/IqData.py
-RsCmwGprfMeas/Implementations/Power_/IqInfo.py
-RsCmwGprfMeas/Implementations/Power_/ListPy.py
-RsCmwGprfMeas/Implementations/Power_/Maximum.py
-RsCmwGprfMeas/Implementations/Power_/Minimum.py
-RsCmwGprfMeas/Implementations/Power_/Peak.py
-RsCmwGprfMeas/Implementations/Power_/StandardDev.py
-RsCmwGprfMeas/Implementations/Power_/State.py
-RsCmwGprfMeas/Implementations/Power_/__init__.py
-RsCmwGprfMeas/Implementations/Power_/Average_/Rms.py
-RsCmwGprfMeas/Implementations/Power_/Average_/__init__.py
-RsCmwGprfMeas/Implementations/Power_/CumulativeDistribFnc_/Power.py
-RsCmwGprfMeas/Implementations/Power_/CumulativeDistribFnc_/Probability.py
-RsCmwGprfMeas/Implementations/Power_/CumulativeDistribFnc_/Sample.py
-RsCmwGprfMeas/Implementations/Power_/CumulativeDistribFnc_/__init__.py
-RsCmwGprfMeas/Implementations/Power_/Current_/Maximum.py
-RsCmwGprfMeas/Implementations/Power_/Current_/Minimum.py
-RsCmwGprfMeas/Implementations/Power_/Current_/Rms.py
-RsCmwGprfMeas/Implementations/Power_/Current_/__init__.py
-RsCmwGprfMeas/Implementations/Power_/IqData_/Bin.py
-RsCmwGprfMeas/Implementations/Power_/IqData_/__init__.py
-RsCmwGprfMeas/Implementations/Power_/ListPy_/Average.py
-RsCmwGprfMeas/Implementations/Power_/ListPy_/Current.py
-RsCmwGprfMeas/Implementations/Power_/ListPy_/Maximum.py
-RsCmwGprfMeas/Implementations/Power_/ListPy_/Minimum.py
-RsCmwGprfMeas/Implementations/Power_/ListPy_/Peak.py
-RsCmwGprfMeas/Implementations/Power_/ListPy_/StandardDev.py
-RsCmwGprfMeas/Implementations/Power_/ListPy_/__init__.py
-RsCmwGprfMeas/Implementations/Power_/ListPy_/Maximum_/Current.py
-RsCmwGprfMeas/Implementations/Power_/ListPy_/Maximum_/__init__.py
-RsCmwGprfMeas/Implementations/Power_/ListPy_/Minimum_/Current.py
-RsCmwGprfMeas/Implementations/Power_/ListPy_/Minimum_/__init__.py
-RsCmwGprfMeas/Implementations/Power_/ListPy_/Peak_/Maximum.py
-RsCmwGprfMeas/Implementations/Power_/ListPy_/Peak_/Minimum.py
-RsCmwGprfMeas/Implementations/Power_/ListPy_/Peak_/__init__.py
-RsCmwGprfMeas/Implementations/Power_/Maximum_/Current.py
-RsCmwGprfMeas/Implementations/Power_/Maximum_/Maximum.py
-RsCmwGprfMeas/Implementations/Power_/Maximum_/__init__.py
-RsCmwGprfMeas/Implementations/Power_/Minimum_/Current.py
-RsCmwGprfMeas/Implementations/Power_/Minimum_/Minimum.py
-RsCmwGprfMeas/Implementations/Power_/Minimum_/__init__.py
-RsCmwGprfMeas/Implementations/Power_/Peak_/Maximum.py
-RsCmwGprfMeas/Implementations/Power_/Peak_/Minimum.py
-RsCmwGprfMeas/Implementations/Power_/Peak_/__init__.py
-RsCmwGprfMeas/Implementations/Power_/StandardDev_/Current.py
-RsCmwGprfMeas/Implementations/Power_/StandardDev_/__init__.py
-RsCmwGprfMeas/Implementations/Power_/State_/All.py
-RsCmwGprfMeas/Implementations/Power_/State_/__init__.py
-RsCmwGprfMeas/Implementations/Route_/Scenario.py
-RsCmwGprfMeas/Implementations/Route_/__init__.py
-RsCmwGprfMeas/Implementations/Route_/Scenario_/Catalog.py
-RsCmwGprfMeas/Implementations/Route_/Scenario_/MaProtocol.py
-RsCmwGprfMeas/Implementations/Route_/Scenario_/__init__.py
-RsCmwGprfMeas/Implementations/Spectrum_/Average.py
-RsCmwGprfMeas/Implementations/Spectrum_/Marker.py
-RsCmwGprfMeas/Implementations/Spectrum_/Maximum.py
-RsCmwGprfMeas/Implementations/Spectrum_/Minimum.py
-RsCmwGprfMeas/Implementations/Spectrum_/ReferenceMarker.py
-RsCmwGprfMeas/Implementations/Spectrum_/Rms.py
-RsCmwGprfMeas/Implementations/Spectrum_/Sample.py
-RsCmwGprfMeas/Implementations/Spectrum_/State.py
-RsCmwGprfMeas/Implementations/Spectrum_/__init__.py
-RsCmwGprfMeas/Implementations/Spectrum_/Average_/Average.py
-RsCmwGprfMeas/Implementations/Spectrum_/Average_/Current.py
-RsCmwGprfMeas/Implementations/Spectrum_/Average_/Maximum.py
-RsCmwGprfMeas/Implementations/Spectrum_/Average_/Minimum.py
-RsCmwGprfMeas/Implementations/Spectrum_/Average_/__init__.py
-RsCmwGprfMeas/Implementations/Spectrum_/Marker_/Npeak.py
-RsCmwGprfMeas/Implementations/Spectrum_/Marker_/__init__.py
-RsCmwGprfMeas/Implementations/Spectrum_/Maximum_/Average.py
-RsCmwGprfMeas/Implementations/Spectrum_/Maximum_/Current.py
-RsCmwGprfMeas/Implementations/Spectrum_/Maximum_/Maximum.py
-RsCmwGprfMeas/Implementations/Spectrum_/Maximum_/Minimum.py
-RsCmwGprfMeas/Implementations/Spectrum_/Maximum_/__init__.py
-RsCmwGprfMeas/Implementations/Spectrum_/Minimum_/Average.py
-RsCmwGprfMeas/Implementations/Spectrum_/Minimum_/Current.py
-RsCmwGprfMeas/Implementations/Spectrum_/Minimum_/Maximum.py
-RsCmwGprfMeas/Implementations/Spectrum_/Minimum_/Minimum.py
-RsCmwGprfMeas/Implementations/Spectrum_/Minimum_/__init__.py
-RsCmwGprfMeas/Implementations/Spectrum_/ReferenceMarker_/Npeak.py
-RsCmwGprfMeas/Implementations/Spectrum_/ReferenceMarker_/Speak.py
-RsCmwGprfMeas/Implementations/Spectrum_/ReferenceMarker_/__init__.py
-RsCmwGprfMeas/Implementations/Spectrum_/Rms_/Average.py
-RsCmwGprfMeas/Implementations/Spectrum_/Rms_/Current.py
-RsCmwGprfMeas/Implementations/Spectrum_/Rms_/Maximum.py
-RsCmwGprfMeas/Implementations/Spectrum_/Rms_/Minimum.py
-RsCmwGprfMeas/Implementations/Spectrum_/Rms_/__init__.py
-RsCmwGprfMeas/Implementations/Spectrum_/Sample_/Average.py
-RsCmwGprfMeas/Implementations/Spectrum_/Sample_/Current.py
-RsCmwGprfMeas/Implementations/Spectrum_/Sample_/Maximum.py
-RsCmwGprfMeas/Implementations/Spectrum_/Sample_/Minimum.py
-RsCmwGprfMeas/Implementations/Spectrum_/Sample_/__init__.py
-RsCmwGprfMeas/Implementations/Spectrum_/State_/All.py
-RsCmwGprfMeas/Implementations/Spectrum_/State_/__init__.py
-RsCmwGprfMeas/Implementations/Trigger_/FftSpecAn.py
-RsCmwGprfMeas/Implementations/Trigger_/IqRecorder.py
-RsCmwGprfMeas/Implementations/Trigger_/IqVsSlot.py
-RsCmwGprfMeas/Implementations/Trigger_/Power.py
-RsCmwGprfMeas/Implementations/Trigger_/Spectrum.py
-RsCmwGprfMeas/Implementations/Trigger_/__init__.py
-RsCmwGprfMeas/Implementations/Trigger_/FftSpecAn_/Catalog.py
-RsCmwGprfMeas/Implementations/Trigger_/FftSpecAn_/__init__.py
-RsCmwGprfMeas/Implementations/Trigger_/IqRecorder_/Catalog.py
-RsCmwGprfMeas/Implementations/Trigger_/IqRecorder_/__init__.py
-RsCmwGprfMeas/Implementations/Trigger_/IqVsSlot_/Catalog.py
-RsCmwGprfMeas/Implementations/Trigger_/IqVsSlot_/__init__.py
-RsCmwGprfMeas/Implementations/Trigger_/Power_/Catalog.py
-RsCmwGprfMeas/Implementations/Trigger_/Power_/ParameterSetList.py
-RsCmwGprfMeas/Implementations/Trigger_/Power_/__init__.py
-RsCmwGprfMeas/Implementations/Trigger_/Power_/ParameterSetList_/Offset.py
-RsCmwGprfMeas/Implementations/Trigger_/Power_/ParameterSetList_/__init__.py
-RsCmwGprfMeas/Implementations/Trigger_/Spectrum_/Catalog.py
-RsCmwGprfMeas/Implementations/Trigger_/Spectrum_/__init__.py
+RsCmwGprfMeas/Implementations/Calibration/__init__.py
+RsCmwGprfMeas/Implementations/Calibration/ExtPwrSensor/Zero.py
+RsCmwGprfMeas/Implementations/Calibration/ExtPwrSensor/__init__.py
+RsCmwGprfMeas/Implementations/Canalyzer/__init__.py
+RsCmwGprfMeas/Implementations/Canalyzer/State/All.py
+RsCmwGprfMeas/Implementations/Canalyzer/State/__init__.py
+RsCmwGprfMeas/Implementations/Configure/__init__.py
+RsCmwGprfMeas/Implementations/Configure/Canalyzer/IqFile.py
+RsCmwGprfMeas/Implementations/Configure/Canalyzer/Sall.py
+RsCmwGprfMeas/Implementations/Configure/Canalyzer/__init__.py
+RsCmwGprfMeas/Implementations/Configure/ExtPwrSensor/Attenuation.py
+RsCmwGprfMeas/Implementations/Configure/ExtPwrSensor/__init__.py
+RsCmwGprfMeas/Implementations/Configure/FftSpecAn/PeakSearch.py
+RsCmwGprfMeas/Implementations/Configure/FftSpecAn/__init__.py
+RsCmwGprfMeas/Implementations/Configure/IqRecorder/Capture.py
+RsCmwGprfMeas/Implementations/Configure/IqRecorder/Trigger.py
+RsCmwGprfMeas/Implementations/Configure/IqRecorder/__init__.py
+RsCmwGprfMeas/Implementations/Configure/IqRecorder/FilterPy/Bandpass.py
+RsCmwGprfMeas/Implementations/Configure/IqRecorder/FilterPy/Gauss.py
+RsCmwGprfMeas/Implementations/Configure/IqRecorder/FilterPy/__init__.py
+RsCmwGprfMeas/Implementations/Configure/IqRecorder/ListPy/EnvelopePower.py
+RsCmwGprfMeas/Implementations/Configure/IqRecorder/ListPy/Frequency.py
+RsCmwGprfMeas/Implementations/Configure/IqRecorder/ListPy/Sstop.py
+RsCmwGprfMeas/Implementations/Configure/IqRecorder/ListPy/__init__.py
+RsCmwGprfMeas/Implementations/Configure/IqVsSlot/Trigger.py
+RsCmwGprfMeas/Implementations/Configure/IqVsSlot/__init__.py
+RsCmwGprfMeas/Implementations/Configure/IqVsSlot/ListPy/EnvelopePower.py
+RsCmwGprfMeas/Implementations/Configure/IqVsSlot/ListPy/Frequency.py
+RsCmwGprfMeas/Implementations/Configure/IqVsSlot/ListPy/Retrigger.py
+RsCmwGprfMeas/Implementations/Configure/IqVsSlot/ListPy/Sstop.py
+RsCmwGprfMeas/Implementations/Configure/IqVsSlot/ListPy/__init__.py
+RsCmwGprfMeas/Implementations/Configure/Nrpm/__init__.py
+RsCmwGprfMeas/Implementations/Configure/Nrpm/Sensor/Frequency.py
+RsCmwGprfMeas/Implementations/Configure/Nrpm/Sensor/__init__.py
+RsCmwGprfMeas/Implementations/Configure/Ploss/View.py
+RsCmwGprfMeas/Implementations/Configure/Ploss/__init__.py
+RsCmwGprfMeas/Implementations/Configure/Ploss/ListPy/Frequency.py
+RsCmwGprfMeas/Implementations/Configure/Ploss/ListPy/__init__.py
+RsCmwGprfMeas/Implementations/Configure/Ploss/Mpath/__init__.py
+RsCmwGprfMeas/Implementations/Configure/Ploss/Mpath/ListPy/Frequency.py
+RsCmwGprfMeas/Implementations/Configure/Ploss/Mpath/ListPy/__init__.py
+RsCmwGprfMeas/Implementations/Configure/Power/Catalog.py
+RsCmwGprfMeas/Implementations/Configure/Power/Trigger.py
+RsCmwGprfMeas/Implementations/Configure/Power/__init__.py
+RsCmwGprfMeas/Implementations/Configure/Power/FilterPy/Bandpass.py
+RsCmwGprfMeas/Implementations/Configure/Power/FilterPy/Gauss.py
+RsCmwGprfMeas/Implementations/Configure/Power/FilterPy/__init__.py
+RsCmwGprfMeas/Implementations/Configure/Power/ListPy/EnvelopePower.py
+RsCmwGprfMeas/Implementations/Configure/Power/ListPy/Frequency.py
+RsCmwGprfMeas/Implementations/Configure/Power/ListPy/IqData.py
+RsCmwGprfMeas/Implementations/Configure/Power/ListPy/Irepetition.py
+RsCmwGprfMeas/Implementations/Configure/Power/ListPy/ParameterSetList.py
+RsCmwGprfMeas/Implementations/Configure/Power/ListPy/Retrigger.py
+RsCmwGprfMeas/Implementations/Configure/Power/ListPy/Sstop.py
+RsCmwGprfMeas/Implementations/Configure/Power/ListPy/__init__.py
+RsCmwGprfMeas/Implementations/Configure/Power/ListPy/SingleCmw/Connector.py
+RsCmwGprfMeas/Implementations/Configure/Power/ListPy/SingleCmw/__init__.py
+RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/Catalog.py
+RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/Mlength.py
+RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/PdefSet.py
+RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/Slength.py
+RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/__init__.py
+RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/FilterPy/TypePy.py
+RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/FilterPy/__init__.py
+RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/FilterPy/Bandpass/Bandwidth.py
+RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/FilterPy/Bandpass/__init__.py
+RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/FilterPy/Gauss/Bandwidth.py
+RsCmwGprfMeas/Implementations/Configure/Power/ParameterSetList/FilterPy/Gauss/__init__.py
+RsCmwGprfMeas/Implementations/Configure/RfSettings/LrStart.py
+RsCmwGprfMeas/Implementations/Configure/RfSettings/__init__.py
+RsCmwGprfMeas/Implementations/Configure/Spectrum/__init__.py
+RsCmwGprfMeas/Implementations/Configure/Spectrum/FreqSweep/Rbw.py
+RsCmwGprfMeas/Implementations/Configure/Spectrum/FreqSweep/Swt.py
+RsCmwGprfMeas/Implementations/Configure/Spectrum/FreqSweep/Vbw.py
+RsCmwGprfMeas/Implementations/Configure/Spectrum/FreqSweep/__init__.py
+RsCmwGprfMeas/Implementations/Configure/Spectrum/Frequency/Span.py
+RsCmwGprfMeas/Implementations/Configure/Spectrum/Frequency/__init__.py
+RsCmwGprfMeas/Implementations/Configure/Spectrum/ZeroSpan/Rbw.py
+RsCmwGprfMeas/Implementations/Configure/Spectrum/ZeroSpan/Vbw.py
+RsCmwGprfMeas/Implementations/Configure/Spectrum/ZeroSpan/__init__.py
+RsCmwGprfMeas/Implementations/ExtPwrSensor/__init__.py
+RsCmwGprfMeas/Implementations/ExtPwrSensor/State/All.py
+RsCmwGprfMeas/Implementations/ExtPwrSensor/State/__init__.py
+RsCmwGprfMeas/Implementations/FftSpecAn/Icomponent.py
+RsCmwGprfMeas/Implementations/FftSpecAn/Qcomponent.py
+RsCmwGprfMeas/Implementations/FftSpecAn/__init__.py
+RsCmwGprfMeas/Implementations/FftSpecAn/Peaks/Average.py
+RsCmwGprfMeas/Implementations/FftSpecAn/Peaks/Current.py
+RsCmwGprfMeas/Implementations/FftSpecAn/Peaks/__init__.py
+RsCmwGprfMeas/Implementations/FftSpecAn/Power/Average.py
+RsCmwGprfMeas/Implementations/FftSpecAn/Power/Current.py
+RsCmwGprfMeas/Implementations/FftSpecAn/Power/Maximum.py
+RsCmwGprfMeas/Implementations/FftSpecAn/Power/Minimum.py
+RsCmwGprfMeas/Implementations/FftSpecAn/Power/__init__.py
+RsCmwGprfMeas/Implementations/FftSpecAn/State/All.py
+RsCmwGprfMeas/Implementations/FftSpecAn/State/__init__.py
+RsCmwGprfMeas/Implementations/Initiate/__init__.py
+RsCmwGprfMeas/Implementations/Initiate/Ploss/Evaluate.py
+RsCmwGprfMeas/Implementations/Initiate/Ploss/Open.py
+RsCmwGprfMeas/Implementations/Initiate/Ploss/Short.py
+RsCmwGprfMeas/Implementations/Initiate/Ploss/__init__.py
+RsCmwGprfMeas/Implementations/IqRecorder/Bin.py
+RsCmwGprfMeas/Implementations/IqRecorder/Reliability.py
+RsCmwGprfMeas/Implementations/IqRecorder/SymbolRate.py
+RsCmwGprfMeas/Implementations/IqRecorder/Talignment.py
+RsCmwGprfMeas/Implementations/IqRecorder/__init__.py
+RsCmwGprfMeas/Implementations/IqRecorder/State/All.py
+RsCmwGprfMeas/Implementations/IqRecorder/State/__init__.py
+RsCmwGprfMeas/Implementations/IqVsSlot/FreqError.py
+RsCmwGprfMeas/Implementations/IqVsSlot/Icomponent.py
+RsCmwGprfMeas/Implementations/IqVsSlot/Level.py
+RsCmwGprfMeas/Implementations/IqVsSlot/OfError.py
+RsCmwGprfMeas/Implementations/IqVsSlot/Phase.py
+RsCmwGprfMeas/Implementations/IqVsSlot/Qcomponent.py
+RsCmwGprfMeas/Implementations/IqVsSlot/__init__.py
+RsCmwGprfMeas/Implementations/IqVsSlot/State/All.py
+RsCmwGprfMeas/Implementations/IqVsSlot/State/__init__.py
+RsCmwGprfMeas/Implementations/Nrpm/__init__.py
+RsCmwGprfMeas/Implementations/Nrpm/Sensor/Power.py
+RsCmwGprfMeas/Implementations/Nrpm/Sensor/__init__.py
+RsCmwGprfMeas/Implementations/Nrpm/State/All.py
+RsCmwGprfMeas/Implementations/Nrpm/State/__init__.py
+RsCmwGprfMeas/Implementations/Ploss/Clear.py
+RsCmwGprfMeas/Implementations/Ploss/Open.py
+RsCmwGprfMeas/Implementations/Ploss/Short.py
+RsCmwGprfMeas/Implementations/Ploss/__init__.py
+RsCmwGprfMeas/Implementations/Ploss/Eval/Frequency.py
+RsCmwGprfMeas/Implementations/Ploss/Eval/Gain.py
+RsCmwGprfMeas/Implementations/Ploss/Eval/State.py
+RsCmwGprfMeas/Implementations/Ploss/Eval/__init__.py
+RsCmwGprfMeas/Implementations/Ploss/Eval/Trace/Frequency.py
+RsCmwGprfMeas/Implementations/Ploss/Eval/Trace/Gain.py
+RsCmwGprfMeas/Implementations/Ploss/Eval/Trace/__init__.py
+RsCmwGprfMeas/Implementations/Ploss/State/All.py
+RsCmwGprfMeas/Implementations/Ploss/State/__init__.py
+RsCmwGprfMeas/Implementations/Power/AmplitudeProbDensity.py
+RsCmwGprfMeas/Implementations/Power/ElapsedStats.py
+RsCmwGprfMeas/Implementations/Power/IqInfo.py
+RsCmwGprfMeas/Implementations/Power/__init__.py
+RsCmwGprfMeas/Implementations/Power/Average/Rms.py
+RsCmwGprfMeas/Implementations/Power/Average/__init__.py
+RsCmwGprfMeas/Implementations/Power/CumulativeDistribFnc/Power.py
+RsCmwGprfMeas/Implementations/Power/CumulativeDistribFnc/Probability.py
+RsCmwGprfMeas/Implementations/Power/CumulativeDistribFnc/Sample.py
+RsCmwGprfMeas/Implementations/Power/CumulativeDistribFnc/__init__.py
+RsCmwGprfMeas/Implementations/Power/Current/Maximum.py
+RsCmwGprfMeas/Implementations/Power/Current/Minimum.py
+RsCmwGprfMeas/Implementations/Power/Current/Rms.py
+RsCmwGprfMeas/Implementations/Power/Current/__init__.py
+RsCmwGprfMeas/Implementations/Power/IqData/Bin.py
+RsCmwGprfMeas/Implementations/Power/IqData/__init__.py
+RsCmwGprfMeas/Implementations/Power/ListPy/Average.py
+RsCmwGprfMeas/Implementations/Power/ListPy/Current.py
+RsCmwGprfMeas/Implementations/Power/ListPy/StandardDev.py
+RsCmwGprfMeas/Implementations/Power/ListPy/__init__.py
+RsCmwGprfMeas/Implementations/Power/ListPy/Maximum/Current.py
+RsCmwGprfMeas/Implementations/Power/ListPy/Maximum/__init__.py
+RsCmwGprfMeas/Implementations/Power/ListPy/Minimum/Current.py
+RsCmwGprfMeas/Implementations/Power/ListPy/Minimum/__init__.py
+RsCmwGprfMeas/Implementations/Power/ListPy/Peak/Maximum.py
+RsCmwGprfMeas/Implementations/Power/ListPy/Peak/Minimum.py
+RsCmwGprfMeas/Implementations/Power/ListPy/Peak/__init__.py
+RsCmwGprfMeas/Implementations/Power/Maximum/Current.py
+RsCmwGprfMeas/Implementations/Power/Maximum/Maximum.py
+RsCmwGprfMeas/Implementations/Power/Maximum/__init__.py
+RsCmwGprfMeas/Implementations/Power/Minimum/Current.py
+RsCmwGprfMeas/Implementations/Power/Minimum/Minimum.py
+RsCmwGprfMeas/Implementations/Power/Minimum/__init__.py
+RsCmwGprfMeas/Implementations/Power/Peak/Maximum.py
+RsCmwGprfMeas/Implementations/Power/Peak/Minimum.py
+RsCmwGprfMeas/Implementations/Power/Peak/__init__.py
+RsCmwGprfMeas/Implementations/Power/StandardDev/Current.py
+RsCmwGprfMeas/Implementations/Power/StandardDev/__init__.py
+RsCmwGprfMeas/Implementations/Power/State/All.py
+RsCmwGprfMeas/Implementations/Power/State/__init__.py
+RsCmwGprfMeas/Implementations/Route/__init__.py
+RsCmwGprfMeas/Implementations/Route/Scenario/Catalog.py
+RsCmwGprfMeas/Implementations/Route/Scenario/MaProtocol.py
+RsCmwGprfMeas/Implementations/Route/Scenario/Maiq.py
+RsCmwGprfMeas/Implementations/Route/Scenario/Salone.py
+RsCmwGprfMeas/Implementations/Route/Scenario/__init__.py
+RsCmwGprfMeas/Implementations/Spectrum/__init__.py
+RsCmwGprfMeas/Implementations/Spectrum/Average/Average.py
+RsCmwGprfMeas/Implementations/Spectrum/Average/Current.py
+RsCmwGprfMeas/Implementations/Spectrum/Average/Maximum.py
+RsCmwGprfMeas/Implementations/Spectrum/Average/Minimum.py
+RsCmwGprfMeas/Implementations/Spectrum/Average/__init__.py
+RsCmwGprfMeas/Implementations/Spectrum/Marker/Npeak.py
+RsCmwGprfMeas/Implementations/Spectrum/Marker/__init__.py
+RsCmwGprfMeas/Implementations/Spectrum/Maximum/Average.py
+RsCmwGprfMeas/Implementations/Spectrum/Maximum/Current.py
+RsCmwGprfMeas/Implementations/Spectrum/Maximum/Maximum.py
+RsCmwGprfMeas/Implementations/Spectrum/Maximum/Minimum.py
+RsCmwGprfMeas/Implementations/Spectrum/Maximum/__init__.py
+RsCmwGprfMeas/Implementations/Spectrum/Minimum/Average.py
+RsCmwGprfMeas/Implementations/Spectrum/Minimum/Current.py
+RsCmwGprfMeas/Implementations/Spectrum/Minimum/Maximum.py
+RsCmwGprfMeas/Implementations/Spectrum/Minimum/Minimum.py
+RsCmwGprfMeas/Implementations/Spectrum/Minimum/__init__.py
+RsCmwGprfMeas/Implementations/Spectrum/ReferenceMarker/Npeak.py
+RsCmwGprfMeas/Implementations/Spectrum/ReferenceMarker/Speak.py
+RsCmwGprfMeas/Implementations/Spectrum/ReferenceMarker/__init__.py
+RsCmwGprfMeas/Implementations/Spectrum/Rms/Average.py
+RsCmwGprfMeas/Implementations/Spectrum/Rms/Current.py
+RsCmwGprfMeas/Implementations/Spectrum/Rms/Maximum.py
+RsCmwGprfMeas/Implementations/Spectrum/Rms/Minimum.py
+RsCmwGprfMeas/Implementations/Spectrum/Rms/__init__.py
+RsCmwGprfMeas/Implementations/Spectrum/Sample/Average.py
+RsCmwGprfMeas/Implementations/Spectrum/Sample/Current.py
+RsCmwGprfMeas/Implementations/Spectrum/Sample/Maximum.py
+RsCmwGprfMeas/Implementations/Spectrum/Sample/Minimum.py
+RsCmwGprfMeas/Implementations/Spectrum/Sample/__init__.py
+RsCmwGprfMeas/Implementations/Spectrum/State/All.py
+RsCmwGprfMeas/Implementations/Spectrum/State/__init__.py
+RsCmwGprfMeas/Implementations/Trigger/__init__.py
+RsCmwGprfMeas/Implementations/Trigger/FftSpecAn/Catalog.py
+RsCmwGprfMeas/Implementations/Trigger/FftSpecAn/OsStop.py
+RsCmwGprfMeas/Implementations/Trigger/FftSpecAn/__init__.py
+RsCmwGprfMeas/Implementations/Trigger/IqRecorder/Catalog.py
+RsCmwGprfMeas/Implementations/Trigger/IqRecorder/__init__.py
+RsCmwGprfMeas/Implementations/Trigger/IqVsSlot/Catalog.py
+RsCmwGprfMeas/Implementations/Trigger/IqVsSlot/__init__.py
+RsCmwGprfMeas/Implementations/Trigger/Power/Catalog.py
+RsCmwGprfMeas/Implementations/Trigger/Power/__init__.py
+RsCmwGprfMeas/Implementations/Trigger/Power/ParameterSetList/Offset.py
+RsCmwGprfMeas/Implementations/Trigger/Power/ParameterSetList/__init__.py
+RsCmwGprfMeas/Implementations/Trigger/Spectrum/Catalog.py
+RsCmwGprfMeas/Implementations/Trigger/Spectrum/__init__.py
 RsCmwGprfMeas/Internal/ArgLinkedEventArgs.py
 RsCmwGprfMeas/Internal/ArgSingle.py
 RsCmwGprfMeas/Internal/ArgSingleList.py
 RsCmwGprfMeas/Internal/ArgSingleSuppressed.py
 RsCmwGprfMeas/Internal/ArgStringComposer.py
 RsCmwGprfMeas/Internal/ArgStruct.py
 RsCmwGprfMeas/Internal/ArgStructList.py
 RsCmwGprfMeas/Internal/ArgStructStringParser.py
 RsCmwGprfMeas/Internal/CommandsGroup.py
 RsCmwGprfMeas/Internal/Conversions.py
 RsCmwGprfMeas/Internal/ConverterFromScpiString.py
 RsCmwGprfMeas/Internal/ConverterToScpiString.py
 RsCmwGprfMeas/Internal/Core.py
+RsCmwGprfMeas/Internal/GlobalData.py
 RsCmwGprfMeas/Internal/Instrument.py
 RsCmwGprfMeas/Internal/InstrumentErrors.py
 RsCmwGprfMeas/Internal/InstrumentOptions.py
 RsCmwGprfMeas/Internal/InstrumentSettings.py
 RsCmwGprfMeas/Internal/InternalLinker.py
 RsCmwGprfMeas/Internal/IoTransferEventArgs.py
+RsCmwGprfMeas/Internal/Properties.py
 RsCmwGprfMeas/Internal/RepeatedCapability.py
+RsCmwGprfMeas/Internal/ScpiEnums.py
+RsCmwGprfMeas/Internal/ScpiLogger.py
 RsCmwGprfMeas/Internal/StreamReader.py
 RsCmwGprfMeas/Internal/StreamWriter.py
 RsCmwGprfMeas/Internal/StructBase.py
 RsCmwGprfMeas/Internal/Types.py
 RsCmwGprfMeas/Internal/Utilities.py
 RsCmwGprfMeas/Internal/VisaPluginSocketIo.py
 RsCmwGprfMeas/Internal/VisaSession.py
```

