# Comparing `tmp/pyaedt-0.8.7.tar.gz` & `tmp/pyaedt-0.8.8.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "pyaedt-0.8.7.tar", last modified: Fri Jan  1 00:00:00 2016, max compression
+gzip compressed data, was "pyaedt-0.8.8.tar", last modified: Fri Jan  1 00:00:00 2016, max compression
```

## Comparing `pyaedt-0.8.7.tar` & `pyaedt-0.8.8.tar`

### file list

```diff
@@ -1,172 +1,174 @@
--rw-r--r--   0        0        0     1111 2024-01-08 19:14:30.151334 pyaedt-0.8.7/LICENSE
--rw-r--r--   0        0        0    10530 2024-03-18 17:51:52.716931 pyaedt-0.8.7/README.md
--rw-r--r--   0        0        0     3483 2024-04-03 08:15:12.879753 pyaedt-0.8.7/pyaedt/__init__.py
--rw-r--r--   0        0        0    33008 2024-03-26 18:55:40.973822 pyaedt-0.8.7/pyaedt/aedt_logger.py
--rw-r--r--   0        0        0     6966 2023-11-15 14:48:55.940401 pyaedt-0.8.7/pyaedt/application/AEDT_File_Management.py
--rw-r--r--   0        0        0    94519 2024-03-28 08:42:12.578899 pyaedt-0.8.7/pyaedt/application/Analysis.py
--rw-r--r--   0        0        0    56666 2024-03-28 13:42:38.055724 pyaedt-0.8.7/pyaedt/application/Analysis3D.py
--rw-r--r--   0        0        0    18347 2024-03-29 15:34:49.291988 pyaedt-0.8.7/pyaedt/application/Analysis3DLayout.py
--rw-r--r--   0        0        0     3225 2024-02-29 13:41:13.886891 pyaedt-0.8.7/pyaedt/application/AnalysisMaxwellCircuit.py
--rw-r--r--   0        0        0    20947 2024-03-29 15:34:49.291988 pyaedt-0.8.7/pyaedt/application/AnalysisNexxim.py
--rw-r--r--   0        0        0     4655 2024-03-26 18:55:40.973822 pyaedt-0.8.7/pyaedt/application/AnalysisRMxprt.py
--rw-r--r--   0        0        0     4856 2024-03-22 10:54:58.724857 pyaedt-0.8.7/pyaedt/application/AnalysisTwinBuilder.py
--rw-r--r--   0        0        0   141844 2024-04-01 07:45:19.391915 pyaedt-0.8.7/pyaedt/application/Design.py
--rw-r--r--   0        0        0     6194 2023-11-15 14:48:55.940401 pyaedt-0.8.7/pyaedt/application/JobManager.py
--rw-r--r--   0        0        0    80899 2024-03-29 15:34:49.307604 pyaedt-0.8.7/pyaedt/application/Variables.py
--rw-r--r--   0        0        0        0 2023-11-15 14:48:55.940401 pyaedt-0.8.7/pyaedt/application/__init__.py
--rw-r--r--   0        0        0    13127 2024-03-26 18:55:40.973822 pyaedt-0.8.7/pyaedt/application/aedt_objects.py
--rw-r--r--   0        0        0    38436 2024-03-26 18:55:40.973822 pyaedt-0.8.7/pyaedt/application/design_solutions.py
--rw-r--r--   0        0        0    64136 2024-03-28 13:42:38.055724 pyaedt-0.8.7/pyaedt/circuit.py
--rw-r--r--   0        0        0    10629 2024-03-28 08:42:12.594588 pyaedt-0.8.7/pyaedt/common_rpc.py
--rw-r--r--   0        0        0    92849 2024-04-02 14:49:39.042380 pyaedt-0.8.7/pyaedt/desktop.py
--rw-r--r--   0        0        0    25696 2024-03-26 18:55:40.989446 pyaedt-0.8.7/pyaedt/downloads.py
--rw-r--r--   0        0        0      210 2024-02-23 10:20:46.907198 pyaedt-0.8.7/pyaedt/edb.py
--rw-r--r--   0        0        0    11572 2024-02-02 15:15:46.553784 pyaedt-0.8.7/pyaedt/emit.py
--rw-r--r--   0        0        0     6102 2024-01-31 08:29:55.307606 pyaedt-0.8.7/pyaedt/emit_core/Couplings.py
--rw-r--r--   0        0        0     3762 2024-02-06 15:33:49.564252 pyaedt-0.8.7/pyaedt/emit_core/__init__.py
--rw-r--r--   0        0        0     2664 2023-11-15 14:48:56.128198 pyaedt-0.8.7/pyaedt/emit_core/emit_constants.py
--rw-r--r--   0        0        0        2 2023-11-15 14:48:56.128198 pyaedt-0.8.7/pyaedt/emit_core/results/__init__.py
--rw-r--r--   0        0        0     7406 2023-11-15 14:48:56.128198 pyaedt-0.8.7/pyaedt/emit_core/results/results.py
--rw-r--r--   0        0        0    30545 2023-12-04 07:28:21.919850 pyaedt-0.8.7/pyaedt/emit_core/results/revision.py
--rw-r--r--   0        0        0     9836 2024-01-08 11:44:42.739939 pyaedt-0.8.7/pyaedt/generic/Ansys.png
--rw-r--r--   0        0        0      761 2024-02-02 17:43:33.722695 pyaedt-0.8.7/pyaedt/generic/AnsysTemplate.json
--rw-r--r--   0        0        0    15945 2024-03-26 18:55:40.989446 pyaedt-0.8.7/pyaedt/generic/DataHandlers.py
--rw-r--r--   0        0        0    16547 2024-03-22 10:54:58.724857 pyaedt-0.8.7/pyaedt/generic/LoadAEDTFile.py
--rw-r--r--   0        0        0        0 2023-11-15 14:48:56.128198 pyaedt-0.8.7/pyaedt/generic/__init__.py
--rw-r--r--   0        0        0     1413 2023-11-15 14:48:56.128198 pyaedt-0.8.7/pyaedt/generic/ami.json
--rw-r--r--   0        0        0     3347 2024-03-26 18:55:40.989446 pyaedt-0.8.7/pyaedt/generic/clr_module.py
--rw-r--r--   0        0        0    37660 2024-03-29 09:59:34.311519 pyaedt-0.8.7/pyaedt/generic/compliance.py
--rw-r--r--   0        0        0    90998 2024-04-02 14:49:39.042380 pyaedt-0.8.7/pyaedt/generic/configurations.py
--rw-r--r--   0        0        0    28707 2024-03-19 11:00:02.376642 pyaedt-0.8.7/pyaedt/generic/constants.py
--rw-r--r--   0        0        0    73959 2024-03-22 10:54:58.724857 pyaedt-0.8.7/pyaedt/generic/design_types.py
--rw-r--r--   0        0        0      168 2023-11-15 14:48:56.143712 pyaedt-0.8.7/pyaedt/generic/desktop_sessions.py
--rw-r--r--   0        0        0     3934 2024-03-26 18:55:40.989446 pyaedt-0.8.7/pyaedt/generic/filesystem.py
--rw-r--r--   0        0        0    66060 2024-03-28 13:42:38.055724 pyaedt-0.8.7/pyaedt/generic/general_methods.py
--rw-r--r--   0        0        0     9430 2024-03-26 18:55:40.989446 pyaedt-0.8.7/pyaedt/generic/grpc_plugin.py
--rw-r--r--   0        0        0     3473 2024-02-06 15:33:49.564252 pyaedt-0.8.7/pyaedt/generic/grpc_plugin_dll.py
--rw-r--r--   0        0        0    45059 2024-03-28 08:42:12.594588 pyaedt-0.8.7/pyaedt/generic/ibis_reader.py
--rw-r--r--   0        0        0     2776 2024-01-02 08:48:38.514823 pyaedt-0.8.7/pyaedt/generic/ibis_v7.json
--rw-r--r--   0        0        0     7029 2023-11-15 14:48:56.143712 pyaedt-0.8.7/pyaedt/generic/near_field_import.py
--rw-r--r--   0        0        0    21859 2024-03-28 13:42:38.055724 pyaedt-0.8.7/pyaedt/generic/pdf.py
--rw-r--r--   0        0        0    65225 2024-03-28 13:42:38.055724 pyaedt-0.8.7/pyaedt/generic/plot.py
--rw-r--r--   0        0        0    20256 2023-11-15 14:48:56.143712 pyaedt-0.8.7/pyaedt/generic/python_optimizers.py
--rw-r--r--   0        0        0     3536 2024-02-06 15:33:49.564252 pyaedt-0.8.7/pyaedt/generic/report_file_parser.py
--rw-r--r--   0        0        0    17381 2024-03-22 10:54:58.740472 pyaedt-0.8.7/pyaedt/generic/settings.py
--rw-r--r--   0        0        0    25174 2024-03-28 08:42:12.594588 pyaedt-0.8.7/pyaedt/generic/spisim.py
--rw-r--r--   0        0        0    20374 2024-03-29 09:59:34.311519 pyaedt-0.8.7/pyaedt/generic/touchstone_parser.py
--rw-r--r--   0        0        0   271206 2024-04-03 07:09:02.589712 pyaedt-0.8.7/pyaedt/hfss.py
--rw-r--r--   0        0        0    85858 2024-03-28 13:42:38.071355 pyaedt-0.8.7/pyaedt/hfss3dlayout.py
--rw-r--r--   0        0        0   278583 2024-03-28 13:42:38.071355 pyaedt-0.8.7/pyaedt/icepak.py
--rw-r--r--   0        0        0   127720 2024-04-01 08:15:37.788471 pyaedt-0.8.7/pyaedt/maxwell.py
--rw-r--r--   0        0        0     7953 2024-03-26 18:55:41.005072 pyaedt-0.8.7/pyaedt/maxwellcircuit.py
--rw-r--r--   0        0        0    24538 2024-03-28 13:42:38.071355 pyaedt-0.8.7/pyaedt/mechanical.py
--rw-r--r--   0        0        0     3642 2023-11-15 14:48:56.159371 pyaedt-0.8.7/pyaedt/misc/Console.py_build
--rw-r--r--   0        0        0     2230 2023-11-15 14:48:56.159371 pyaedt-0.8.7/pyaedt/misc/Job_Settings.areg
--rw-r--r--   0        0        0     3394 2023-11-15 14:48:56.159371 pyaedt-0.8.7/pyaedt/misc/Jupyter.py_build
--rw-r--r--   0        0        0     4125 2023-11-15 14:48:56.159371 pyaedt-0.8.7/pyaedt/misc/Run_PyAEDT_Script.py_build
--rw-r--r--   0        0        0     3526 2023-11-15 14:48:56.159371 pyaedt-0.8.7/pyaedt/misc/Run_PyAEDT_Toolkit_Script.py_build
--rw-r--r--   0        0        0      202 2023-11-15 14:48:56.159371 pyaedt-0.8.7/pyaedt/misc/__init__.py
--rw-r--r--   0        0        0    10796 2024-03-26 18:55:41.005072 pyaedt-0.8.7/pyaedt/misc/aedtlib_personalib_install.py
--rw-r--r--   0        0        0    19870 2023-11-15 14:48:56.174972 pyaedt-0.8.7/pyaedt/misc/amat.xml
--rw-r--r--   0        0        0     2620 2023-11-15 14:48:56.174972 pyaedt-0.8.7/pyaedt/misc/ansys_cloud.areg
--rw-r--r--   0        0        0     2013 2024-01-03 08:09:11.617311 pyaedt-0.8.7/pyaedt/misc/config.schema.json
--rw-r--r--   0        0        0     3554 2024-01-31 08:29:55.323250 pyaedt-0.8.7/pyaedt/misc/console_setup.py
--rw-r--r--   0        0        0       48 2023-11-15 14:48:56.174972 pyaedt-0.8.7/pyaedt/misc/create_remote_dir.py
--rw-r--r--   0        0        0    15250 2023-11-15 14:48:56.174972 pyaedt-0.8.7/pyaedt/misc/images/gallery/PyAEDT.png
--rw-r--r--   0        0        0      855 2023-11-15 14:48:56.174972 pyaedt-0.8.7/pyaedt/misc/images/large/pyansys.png
--rw-r--r--   0        0        0     5630 2024-03-08 09:52:28.386458 pyaedt-0.8.7/pyaedt/misc/install_extra_toolkits.py
--rw-r--r--   0        0        0     1728 2023-11-15 14:48:56.174972 pyaedt-0.8.7/pyaedt/misc/jupyter_template.ipynb
--rw-r--r--   0        0        0     2700 2024-03-26 18:55:41.005072 pyaedt-0.8.7/pyaedt/misc/misc.py
--rw-r--r--   0        0        0   771467 2023-11-15 14:48:56.174972 pyaedt-0.8.7/pyaedt/misc/ml_data_file_train_100MHz_1GHz.json
--rw-r--r--   0        0        0   502580 2023-11-15 14:48:56.190611 pyaedt-0.8.7/pyaedt/misc/ml_data_file_train_1GHz_10GHz.json
--rw-r--r--   0        0        0   162026 2023-11-15 14:48:56.190611 pyaedt-0.8.7/pyaedt/misc/patch_svr_model_100MHz_1GHz.joblib
--rw-r--r--   0        0        0   134414 2023-11-15 14:48:56.190611 pyaedt-0.8.7/pyaedt/misc/patch_svr_model_1GHz_10GHz.joblib
--rw-r--r--   0        0        0      289 2023-11-15 14:48:56.190611 pyaedt-0.8.7/pyaedt/misc/pyaedt.runtimeconfig.json
--rw-r--r--   0        0        0      960 2023-11-15 14:48:56.190611 pyaedt-0.8.7/pyaedt/misc/pyaedt_local_config.acf
--rw-r--r--   0        0        0    16550 2023-11-15 14:48:56.190611 pyaedt-0.8.7/pyaedt/misc/pyansys-logo-black-cropped.png
--rw-r--r--   0        0        0       61 2024-03-22 10:54:58.740472 pyaedt-0.8.7/pyaedt/misc/spisim_com_configuration_files/__init__.py
--rw-r--r--   0        0        0     5192 2024-03-22 10:54:58.740472 pyaedt-0.8.7/pyaedt/misc/spisim_com_configuration_files/com_120d_8.json
--rw-r--r--   0        0        0     5153 2024-03-22 10:54:58.740472 pyaedt-0.8.7/pyaedt/misc/spisim_com_configuration_files/com_93_8.json
--rw-r--r--   0        0        0     5155 2024-03-22 10:54:58.740472 pyaedt-0.8.7/pyaedt/misc/spisim_com_configuration_files/com_94_17.json
--rw-r--r--   0        0        0    12280 2024-03-22 10:54:58.740472 pyaedt-0.8.7/pyaedt/misc/spisim_com_configuration_files/com_parameters.py
--rw-r--r--   0        0        0    15308 2024-03-22 10:54:58.740472 pyaedt-0.8.7/pyaedt/misc/spisim_com_configuration_files/com_settings_mapping.py
--rw-r--r--   0        0        0      868 2023-11-15 14:48:56.190611 pyaedt-0.8.7/pyaedt/misc/template.acf
--rw-r--r--   0        0        0        0 2023-11-15 14:48:56.190611 pyaedt-0.8.7/pyaedt/modeler/__init__.py
--rw-r--r--   0        0        0        0 2023-11-15 14:48:56.190611 pyaedt-0.8.7/pyaedt/modeler/advanced_cad/__init__.py
--rw-r--r--   0        0        0    14073 2024-02-09 10:07:59.429453 pyaedt-0.8.7/pyaedt/modeler/advanced_cad/actors.py
--rw-r--r--   0        0        0    20019 2024-02-09 10:07:59.429453 pyaedt-0.8.7/pyaedt/modeler/advanced_cad/multiparts.py
--rw-r--r--   0        0        0    18513 2023-11-15 14:48:56.190611 pyaedt-0.8.7/pyaedt/modeler/advanced_cad/oms.py
--rw-r--r--   0        0        0    16809 2023-11-15 14:48:56.190611 pyaedt-0.8.7/pyaedt/modeler/advanced_cad/parts.py
--rw-r--r--   0        0        0   126188 2024-02-06 15:33:49.579885 pyaedt-0.8.7/pyaedt/modeler/advanced_cad/stackup_3d.py
--rw-r--r--   0        0        0    80015 2024-03-26 18:55:41.005072 pyaedt-0.8.7/pyaedt/modeler/cad/Modeler.py
--rw-r--r--   0        0        0   335961 2024-04-01 07:45:19.391915 pyaedt-0.8.7/pyaedt/modeler/cad/Primitives.py
--rw-r--r--   0        0        0    13476 2024-03-27 08:05:27.450020 pyaedt-0.8.7/pyaedt/modeler/cad/Primitives2D.py
--rw-r--r--   0        0        0   143002 2024-04-01 07:45:19.407506 pyaedt-0.8.7/pyaedt/modeler/cad/Primitives3D.py
--rw-r--r--   0        0        0        0 2023-11-15 14:48:56.206131 pyaedt-0.8.7/pyaedt/modeler/cad/__init__.py
--rw-r--r--   0        0        0    29696 2024-03-20 14:17:36.246401 pyaedt-0.8.7/pyaedt/modeler/cad/component_array.py
--rw-r--r--   0        0        0    40015 2024-03-26 18:55:41.020699 pyaedt-0.8.7/pyaedt/modeler/cad/components_3d.py
--rw-r--r--   0        0        0    49410 2024-03-26 18:55:41.020699 pyaedt-0.8.7/pyaedt/modeler/cad/elements3d.py
--rw-r--r--   0        0        0    59455 2024-04-01 12:04:06.409314 pyaedt-0.8.7/pyaedt/modeler/cad/object3d.py
--rw-r--r--   0        0        0    53212 2024-03-26 18:55:41.020699 pyaedt-0.8.7/pyaedt/modeler/cad/polylines.py
--rw-r--r--   0        0        0    12604 2023-11-15 14:48:56.206131 pyaedt-0.8.7/pyaedt/modeler/calculators.py
--rw-r--r--   0        0        0    44084 2024-03-29 09:59:34.311519 pyaedt-0.8.7/pyaedt/modeler/circuits/PrimitivesCircuit.py
--rw-r--r--   0        0        0    39272 2024-02-06 15:33:49.595515 pyaedt-0.8.7/pyaedt/modeler/circuits/PrimitivesEmit.py
--rw-r--r--   0        0        0     8396 2023-11-15 14:48:56.221789 pyaedt-0.8.7/pyaedt/modeler/circuits/PrimitivesMaxwellCircuit.py
--rw-r--r--   0        0        0    67681 2024-03-07 08:39:44.005598 pyaedt-0.8.7/pyaedt/modeler/circuits/PrimitivesNexxim.py
--rw-r--r--   0        0        0    15130 2023-11-15 14:48:56.221789 pyaedt-0.8.7/pyaedt/modeler/circuits/PrimitivesTwinBuilder.py
--rw-r--r--   0        0        0        0 2023-11-15 14:48:56.221789 pyaedt-0.8.7/pyaedt/modeler/circuits/__init__.py
--rw-r--r--   0        0        0    34191 2024-03-26 18:55:41.020699 pyaedt-0.8.7/pyaedt/modeler/circuits/object3dcircuit.py
--rw-r--r--   0        0        0    68182 2024-03-28 13:42:38.086947 pyaedt-0.8.7/pyaedt/modeler/geometry_operators.py
--rw-r--r--   0        0        0     6929 2023-11-15 14:48:56.221789 pyaedt-0.8.7/pyaedt/modeler/modeler2d.py
--rw-r--r--   0        0        0    66173 2024-03-28 13:42:38.086947 pyaedt-0.8.7/pyaedt/modeler/modeler3d.py
--rw-r--r--   0        0        0    33255 2024-03-26 18:55:41.036345 pyaedt-0.8.7/pyaedt/modeler/modelerpcb.py
--rw-r--r--   0        0        0    50776 2024-03-26 18:55:41.036345 pyaedt-0.8.7/pyaedt/modeler/pcb/Primitives3DLayout.py
--rw-r--r--   0        0        0        0 2023-11-15 14:48:56.221789 pyaedt-0.8.7/pyaedt/modeler/pcb/__init__.py
--rw-r--r--   0        0        0    65931 2024-03-28 13:42:38.086947 pyaedt-0.8.7/pyaedt/modeler/pcb/object3dlayout.py
--rw-r--r--   0        0        0    23852 2024-03-26 18:55:41.036345 pyaedt-0.8.7/pyaedt/modeler/schematic.py
--rw-r--r--   0        0        0    54859 2024-03-28 13:42:38.086947 pyaedt-0.8.7/pyaedt/modules/AdvancedPostProcessing.py
--rw-r--r--   0        0        0   169955 2024-03-26 18:55:41.036345 pyaedt-0.8.7/pyaedt/modules/Boundary.py
--rw-r--r--   0        0        0    71690 2024-03-28 08:42:12.610163 pyaedt-0.8.7/pyaedt/modules/CableModeling.py
--rw-r--r--   0        0        0    16319 2023-11-15 14:48:56.237302 pyaedt-0.8.7/pyaedt/modules/CircuitTemplates.py
--rw-r--r--   0        0        0    56766 2024-03-29 09:59:34.311519 pyaedt-0.8.7/pyaedt/modules/DesignXPloration.py
--rw-r--r--   0        0        0    40449 2024-03-26 18:55:41.036345 pyaedt-0.8.7/pyaedt/modules/LayerStackup.py
--rw-r--r--   0        0        0   104701 2024-03-29 09:59:34.311519 pyaedt-0.8.7/pyaedt/modules/Material.py
--rw-r--r--   0        0        0    33683 2024-03-26 18:55:41.051947 pyaedt-0.8.7/pyaedt/modules/MaterialLib.py
--rw-r--r--   0        0        0    53774 2024-03-26 18:55:41.051947 pyaedt-0.8.7/pyaedt/modules/Mesh.py
--rw-r--r--   0        0        0    12018 2024-03-26 18:55:41.051947 pyaedt-0.8.7/pyaedt/modules/Mesh3DLayout.py
--rw-r--r--   0        0        0    48847 2024-03-26 18:55:41.051947 pyaedt-0.8.7/pyaedt/modules/MeshIcepak.py
--rw-r--r--   0        0        0     4437 2023-11-15 14:48:56.237302 pyaedt-0.8.7/pyaedt/modules/OptimetricsTemplates.py
--rw-r--r--   0        0        0   206587 2024-03-28 13:42:38.086947 pyaedt-0.8.7/pyaedt/modules/PostProcessor.py
--rw-r--r--   0        0        0    72048 2024-03-08 11:06:30.309390 pyaedt-0.8.7/pyaedt/modules/SetupTemplates.py
--rw-r--r--   0        0        0   147780 2024-03-28 13:42:38.086947 pyaedt-0.8.7/pyaedt/modules/SolveSetup.py
--rw-r--r--   0        0        0    34324 2024-03-26 18:55:41.051947 pyaedt-0.8.7/pyaedt/modules/SolveSweeps.py
--rw-r--r--   0        0        0        0 2023-11-15 14:48:56.252956 pyaedt-0.8.7/pyaedt/modules/__init__.py
--rw-r--r--   0        0        0    31434 2024-03-26 18:55:41.051947 pyaedt-0.8.7/pyaedt/modules/monitor_icepak.py
--rw-r--r--   0        0        0   132190 2024-03-26 18:55:41.067597 pyaedt-0.8.7/pyaedt/modules/report_templates.py
--rw-r--r--   0        0        0   134882 2024-04-02 06:26:14.161852 pyaedt-0.8.7/pyaedt/modules/solutions.py
--rw-r--r--   0        0        0    97835 2024-03-26 18:55:41.067597 pyaedt-0.8.7/pyaedt/q3d.py
--rw-r--r--   0        0        0    10664 2024-02-02 15:15:46.569416 pyaedt-0.8.7/pyaedt/rmxprt.py
--rw-r--r--   0        0        0        0 2023-11-15 14:48:56.252956 pyaedt-0.8.7/pyaedt/rpc/__init__.py
--rw-r--r--   0        0        0      415 2023-11-15 14:48:56.252956 pyaedt-0.8.7/pyaedt/rpc/local_server.py
--rw-r--r--   0        0        0    42133 2024-03-28 08:42:12.610163 pyaedt-0.8.7/pyaedt/rpc/rpyc_services.py
--rw-r--r--   0        0        0        0 2023-11-15 14:48:56.252956 pyaedt-0.8.7/pyaedt/sbrplus/__init__.py
--rw-r--r--   0        0        0     9463 2023-11-15 14:48:56.252956 pyaedt-0.8.7/pyaedt/sbrplus/hdm_parser.py
--rw-r--r--   0        0        0     2096 2023-11-15 14:48:56.252956 pyaedt-0.8.7/pyaedt/sbrplus/hdm_utils.py
--rw-r--r--   0        0        0     2607 2023-11-15 14:48:56.252956 pyaedt-0.8.7/pyaedt/sbrplus/matlab/HdmObject.m
--rw-r--r--   0        0        0       97 2023-11-15 14:48:56.252956 pyaedt-0.8.7/pyaedt/sbrplus/matlab/README.md
--rw-r--r--   0        0        0      735 2023-11-15 14:48:56.252956 pyaedt-0.8.7/pyaedt/sbrplus/matlab/SbrBounceType.m
--rw-r--r--   0        0        0     2886 2023-11-15 14:48:56.252956 pyaedt-0.8.7/pyaedt/sbrplus/matlab/StopWatch.m
--rw-r--r--   0        0        0     1402 2023-11-15 14:48:56.252956 pyaedt-0.8.7/pyaedt/sbrplus/matlab/add_3dlight.m
--rw-r--r--   0        0        0      340 2023-11-15 14:48:56.268468 pyaedt-0.8.7/pyaedt/sbrplus/matlab/amp2db.m
--rw-r--r--   0        0        0    36837 2023-11-15 14:48:56.268468 pyaedt-0.8.7/pyaedt/sbrplus/matlab/draw_rays1.m
--rw-r--r--   0        0        0     4322 2023-11-15 14:48:56.268468 pyaedt-0.8.7/pyaedt/sbrplus/matlab/draw_wfobj.m
--rw-r--r--   0        0        0    31414 2023-11-15 14:48:56.268468 pyaedt-0.8.7/pyaedt/sbrplus/matlab/filter_rays1.m
--rw-r--r--   0        0        0     1504 2023-11-15 14:48:56.268468 pyaedt-0.8.7/pyaedt/sbrplus/matlab/filtered_tracks.m
--rw-r--r--   0        0        0    20853 2023-11-15 14:48:56.268468 pyaedt-0.8.7/pyaedt/sbrplus/matlab/ld_sbrplushdm.m
--rw-r--r--   0        0        0    14781 2023-11-15 14:48:56.268468 pyaedt-0.8.7/pyaedt/sbrplus/matlab/ld_wfobj.m
--rw-r--r--   0        0        0      318 2023-11-15 14:48:56.268468 pyaedt-0.8.7/pyaedt/sbrplus/matlab/pwr2db.m
--rw-r--r--   0        0        0     2607 2023-11-15 14:48:56.268468 pyaedt-0.8.7/pyaedt/sbrplus/matlab/validate_sfields.m
--rw-r--r--   0        0        0     7621 2024-03-26 18:55:41.067597 pyaedt-0.8.7/pyaedt/sbrplus/plot.py
--rw-r--r--   0        0        0    21628 2024-03-28 08:42:12.610163 pyaedt-0.8.7/pyaedt/twinbuilder.py
--rw-r--r--   0        0        0     6767 2024-04-02 21:38:59.514185 pyaedt-0.8.7/pyproject.toml
--rw-r--r--   0        0        0    16443 1970-01-01 00:00:00.000000 pyaedt-0.8.7/PKG-INFO
+-rw-r--r--   0        0        0     1111 2023-12-31 17:45:46.144704 pyaedt-0.8.8/LICENSE
+-rw-r--r--   0        0        0    10530 2024-03-18 17:32:41.568450 pyaedt-0.8.8/README.md
+-rw-r--r--   0        0        0     3483 2024-04-16 19:20:04.036426 pyaedt-0.8.8/pyaedt/__init__.py
+-rw-r--r--   0        0        0    33008 2024-03-26 16:57:20.066432 pyaedt-0.8.8/pyaedt/aedt_logger.py
+-rw-r--r--   0        0        0     6966 2023-11-15 14:48:51.126062 pyaedt-0.8.8/pyaedt/application/AEDT_File_Management.py
+-rw-r--r--   0        0        0    92484 2024-04-15 11:56:45.704733 pyaedt-0.8.8/pyaedt/application/Analysis.py
+-rw-r--r--   0        0        0    56669 2024-04-16 16:03:45.141509 pyaedt-0.8.8/pyaedt/application/Analysis3D.py
+-rw-r--r--   0        0        0    11645 2024-04-15 11:56:45.704733 pyaedt-0.8.8/pyaedt/application/Analysis3DLayout.py
+-rw-r--r--   0        0        0     3225 2024-02-29 11:54:54.087433 pyaedt-0.8.8/pyaedt/application/AnalysisMaxwellCircuit.py
+-rw-r--r--   0        0        0    13652 2024-04-15 11:56:45.704733 pyaedt-0.8.8/pyaedt/application/AnalysisNexxim.py
+-rw-r--r--   0        0        0     4655 2024-03-26 16:57:20.066432 pyaedt-0.8.8/pyaedt/application/AnalysisRMxprt.py
+-rw-r--r--   0        0        0     4889 2024-04-15 11:56:45.704733 pyaedt-0.8.8/pyaedt/application/AnalysisTwinBuilder.py
+-rw-r--r--   0        0        0   141100 2024-04-12 06:21:23.624898 pyaedt-0.8.8/pyaedt/application/Design.py
+-rw-r--r--   0        0        0     6194 2023-11-15 14:48:51.126062 pyaedt-0.8.8/pyaedt/application/JobManager.py
+-rw-r--r--   0        0        0    80899 2024-03-29 15:34:31.534043 pyaedt-0.8.8/pyaedt/application/Variables.py
+-rw-r--r--   0        0        0        0 2023-11-15 14:48:51.141075 pyaedt-0.8.8/pyaedt/application/__init__.py
+-rw-r--r--   0        0        0    13127 2024-03-26 16:57:20.082054 pyaedt-0.8.8/pyaedt/application/aedt_objects.py
+-rw-r--r--   0        0        0    14049 2024-04-08 07:26:14.718804 pyaedt-0.8.8/pyaedt/application/analysis_hf.py
+-rw-r--r--   0        0        0    38458 2024-04-15 11:56:45.704733 pyaedt-0.8.8/pyaedt/application/design_solutions.py
+-rw-r--r--   0        0        0    80398 2024-04-16 16:03:45.141509 pyaedt-0.8.8/pyaedt/circuit.py
+-rw-r--r--   0        0        0    10845 2024-04-05 14:27:59.009689 pyaedt-0.8.8/pyaedt/common_rpc.py
+-rw-r--r--   0        0        0    93993 2024-04-16 16:03:45.141509 pyaedt-0.8.8/pyaedt/desktop.py
+-rw-r--r--   0        0        0    26397 2024-04-16 16:33:03.403200 pyaedt-0.8.8/pyaedt/downloads.py
+-rw-r--r--   0        0        0      210 2024-02-23 10:39:15.272359 pyaedt-0.8.8/pyaedt/edb.py
+-rw-r--r--   0        0        0    11388 2024-04-15 11:56:45.704733 pyaedt-0.8.8/pyaedt/emit.py
+-rw-r--r--   0        0        0     6102 2024-01-31 07:08:42.610124 pyaedt-0.8.8/pyaedt/emit_core/Couplings.py
+-rw-r--r--   0        0        0     3762 2023-11-15 14:48:51.281530 pyaedt-0.8.8/pyaedt/emit_core/__init__.py
+-rw-r--r--   0        0        0     2664 2023-11-15 14:48:51.281530 pyaedt-0.8.8/pyaedt/emit_core/emit_constants.py
+-rw-r--r--   0        0        0        2 2023-11-15 14:48:51.281530 pyaedt-0.8.8/pyaedt/emit_core/results/__init__.py
+-rw-r--r--   0        0        0     7406 2023-11-15 14:48:51.281530 pyaedt-0.8.8/pyaedt/emit_core/results/results.py
+-rw-r--r--   0        0        0    30406 2024-04-12 06:22:12.847095 pyaedt-0.8.8/pyaedt/emit_core/results/revision.py
+-rw-r--r--   0        0        0     9836 2024-01-08 11:44:37.567605 pyaedt-0.8.8/pyaedt/generic/Ansys.png
+-rw-r--r--   0        0        0      761 2024-02-02 17:51:14.912475 pyaedt-0.8.8/pyaedt/generic/AnsysTemplate.json
+-rw-r--r--   0        0        0    15961 2024-04-12 06:21:23.624898 pyaedt-0.8.8/pyaedt/generic/DataHandlers.py
+-rw-r--r--   0        0        0    16551 2024-04-12 06:21:23.624898 pyaedt-0.8.8/pyaedt/generic/LoadAEDTFile.py
+-rw-r--r--   0        0        0        0 2023-11-15 14:48:51.281530 pyaedt-0.8.8/pyaedt/generic/__init__.py
+-rw-r--r--   0        0        0     1413 2023-11-15 14:48:51.281530 pyaedt-0.8.8/pyaedt/generic/ami.json
+-rw-r--r--   0        0        0     3347 2024-03-26 16:57:20.082054 pyaedt-0.8.8/pyaedt/generic/clr_module.py
+-rw-r--r--   0        0        0        0 2024-04-05 14:27:59.009689 pyaedt-0.8.8/pyaedt/generic/com_parameters.py
+-rw-r--r--   0        0        0    37863 2024-04-12 06:22:12.847095 pyaedt-0.8.8/pyaedt/generic/compliance.py
+-rw-r--r--   0        0        0    91065 2024-04-16 16:03:45.141509 pyaedt-0.8.8/pyaedt/generic/configurations.py
+-rw-r--r--   0        0        0    28707 2024-03-18 17:32:41.568450 pyaedt-0.8.8/pyaedt/generic/constants.py
+-rw-r--r--   0        0        0    73888 2024-04-15 11:56:45.704733 pyaedt-0.8.8/pyaedt/generic/design_types.py
+-rw-r--r--   0        0        0      190 2024-04-16 16:03:45.141509 pyaedt-0.8.8/pyaedt/generic/desktop_sessions.py
+-rw-r--r--   0        0        0     3934 2024-03-26 16:57:20.082054 pyaedt-0.8.8/pyaedt/generic/filesystem.py
+-rw-r--r--   0        0        0    68771 2024-04-16 16:03:45.157131 pyaedt-0.8.8/pyaedt/generic/general_methods.py
+-rw-r--r--   0        0        0     9430 2024-03-26 16:57:20.082054 pyaedt-0.8.8/pyaedt/generic/grpc_plugin.py
+-rw-r--r--   0        0        0     3473 2023-12-13 11:29:08.166076 pyaedt-0.8.8/pyaedt/generic/grpc_plugin_dll.py
+-rw-r--r--   0        0        0    44398 2024-04-16 16:03:45.157131 pyaedt-0.8.8/pyaedt/generic/ibis_reader.py
+-rw-r--r--   0        0        0     2776 2024-01-02 08:48:34.102194 pyaedt-0.8.8/pyaedt/generic/ibis_v7.json
+-rw-r--r--   0        0        0     7029 2023-11-15 14:48:51.297153 pyaedt-0.8.8/pyaedt/generic/near_field_import.py
+-rw-r--r--   0        0        0    21938 2024-04-05 14:27:59.009689 pyaedt-0.8.8/pyaedt/generic/pdf.py
+-rw-r--r--   0        0        0    65524 2024-04-04 20:41:59.615015 pyaedt-0.8.8/pyaedt/generic/plot.py
+-rw-r--r--   0        0        0    20256 2023-11-15 14:48:51.297153 pyaedt-0.8.8/pyaedt/generic/python_optimizers.py
+-rw-r--r--   0        0        0     3536 2023-11-15 14:48:51.297153 pyaedt-0.8.8/pyaedt/generic/report_file_parser.py
+-rw-r--r--   0        0        0    17709 2024-04-05 13:12:25.411540 pyaedt-0.8.8/pyaedt/generic/settings.py
+-rw-r--r--   0        0        0    25263 2024-04-05 14:27:59.009689 pyaedt-0.8.8/pyaedt/generic/spisim.py
+-rw-r--r--   0        0        0    20374 2024-03-28 11:32:30.107010 pyaedt-0.8.8/pyaedt/generic/touchstone_parser.py
+-rw-r--r--   0        0        0   253753 2024-04-16 16:03:45.157131 pyaedt-0.8.8/pyaedt/hfss.py
+-rw-r--r--   0        0        0    84193 2024-04-16 16:03:45.157131 pyaedt-0.8.8/pyaedt/hfss3dlayout.py
+-rw-r--r--   0        0        0   278413 2024-04-16 16:03:45.157131 pyaedt-0.8.8/pyaedt/icepak.py
+-rw-r--r--   0        0        0   130037 2024-04-16 16:03:45.157131 pyaedt-0.8.8/pyaedt/maxwell.py
+-rw-r--r--   0        0        0     7953 2024-03-26 16:57:20.097680 pyaedt-0.8.8/pyaedt/maxwellcircuit.py
+-rw-r--r--   0        0        0    24791 2024-04-15 11:56:45.720413 pyaedt-0.8.8/pyaedt/mechanical.py
+-rw-r--r--   0        0        0     3642 2023-11-15 14:48:51.312829 pyaedt-0.8.8/pyaedt/misc/Console.py_build
+-rw-r--r--   0        0        0     2230 2023-11-15 14:48:51.312829 pyaedt-0.8.8/pyaedt/misc/Job_Settings.areg
+-rw-r--r--   0        0        0     3394 2023-11-15 14:48:51.312829 pyaedt-0.8.8/pyaedt/misc/Jupyter.py_build
+-rw-r--r--   0        0        0     4125 2023-11-15 14:48:51.312829 pyaedt-0.8.8/pyaedt/misc/Run_PyAEDT_Script.py_build
+-rw-r--r--   0        0        0     3526 2023-11-15 14:48:51.312829 pyaedt-0.8.8/pyaedt/misc/Run_PyAEDT_Toolkit_Script.py_build
+-rw-r--r--   0        0        0      202 2023-11-15 14:48:51.312829 pyaedt-0.8.8/pyaedt/misc/__init__.py
+-rw-r--r--   0        0        0    10796 2024-03-26 16:57:20.097680 pyaedt-0.8.8/pyaedt/misc/aedtlib_personalib_install.py
+-rw-r--r--   0        0        0    19870 2023-11-15 14:48:51.312829 pyaedt-0.8.8/pyaedt/misc/amat.xml
+-rw-r--r--   0        0        0     2620 2023-11-15 14:48:51.312829 pyaedt-0.8.8/pyaedt/misc/ansys_cloud.areg
+-rw-r--r--   0        0        0     2013 2024-01-03 08:09:17.894973 pyaedt-0.8.8/pyaedt/misc/config.schema.json
+-rw-r--r--   0        0        0     3554 2024-01-31 07:08:42.610124 pyaedt-0.8.8/pyaedt/misc/console_setup.py
+-rw-r--r--   0        0        0       48 2023-11-15 14:48:51.312829 pyaedt-0.8.8/pyaedt/misc/create_remote_dir.py
+-rw-r--r--   0        0        0    15250 2023-11-15 14:48:51.312829 pyaedt-0.8.8/pyaedt/misc/images/gallery/PyAEDT.png
+-rw-r--r--   0        0        0      855 2023-11-15 14:48:51.312829 pyaedt-0.8.8/pyaedt/misc/images/large/pyansys.png
+-rw-r--r--   0        0        0     5630 2024-03-08 10:07:44.551028 pyaedt-0.8.8/pyaedt/misc/install_extra_toolkits.py
+-rw-r--r--   0        0        0     1728 2023-11-15 14:48:51.312829 pyaedt-0.8.8/pyaedt/misc/jupyter_template.ipynb
+-rw-r--r--   0        0        0     2700 2024-03-26 16:57:20.097680 pyaedt-0.8.8/pyaedt/misc/misc.py
+-rw-r--r--   0        0        0   771467 2023-11-15 14:48:51.312829 pyaedt-0.8.8/pyaedt/misc/ml_data_file_train_100MHz_1GHz.json
+-rw-r--r--   0        0        0   502580 2023-11-15 14:48:51.328409 pyaedt-0.8.8/pyaedt/misc/ml_data_file_train_1GHz_10GHz.json
+-rw-r--r--   0        0        0   162026 2023-11-15 14:48:51.328409 pyaedt-0.8.8/pyaedt/misc/patch_svr_model_100MHz_1GHz.joblib
+-rw-r--r--   0        0        0   134414 2023-11-15 14:48:51.328409 pyaedt-0.8.8/pyaedt/misc/patch_svr_model_1GHz_10GHz.joblib
+-rw-r--r--   0        0        0      289 2023-11-15 14:48:51.328409 pyaedt-0.8.8/pyaedt/misc/pyaedt.runtimeconfig.json
+-rw-r--r--   0        0        0      960 2023-11-15 14:48:51.328409 pyaedt-0.8.8/pyaedt/misc/pyaedt_local_config.acf
+-rw-r--r--   0        0        0    16550 2023-11-15 14:48:51.328409 pyaedt-0.8.8/pyaedt/misc/pyansys-logo-black-cropped.png
+-rw-r--r--   0        0        0       61 2024-03-20 11:35:09.070685 pyaedt-0.8.8/pyaedt/misc/spisim_com_configuration_files/__init__.py
+-rw-r--r--   0        0        0     5192 2024-03-20 11:35:09.070685 pyaedt-0.8.8/pyaedt/misc/spisim_com_configuration_files/com_120d_8.json
+-rw-r--r--   0        0        0     5153 2024-03-20 11:35:09.070685 pyaedt-0.8.8/pyaedt/misc/spisim_com_configuration_files/com_93_8.json
+-rw-r--r--   0        0        0     5155 2024-03-20 11:35:09.070685 pyaedt-0.8.8/pyaedt/misc/spisim_com_configuration_files/com_94_17.json
+-rw-r--r--   0        0        0    12280 2024-03-21 13:12:02.821738 pyaedt-0.8.8/pyaedt/misc/spisim_com_configuration_files/com_parameters.py
+-rw-r--r--   0        0        0    15308 2024-03-20 11:35:09.070685 pyaedt-0.8.8/pyaedt/misc/spisim_com_configuration_files/com_settings_mapping.py
+-rw-r--r--   0        0        0      868 2023-11-15 14:48:51.328409 pyaedt-0.8.8/pyaedt/misc/template.acf
+-rw-r--r--   0        0        0        0 2023-11-15 14:48:51.328409 pyaedt-0.8.8/pyaedt/modeler/__init__.py
+-rw-r--r--   0        0        0        0 2023-11-15 14:48:51.328409 pyaedt-0.8.8/pyaedt/modeler/advanced_cad/__init__.py
+-rw-r--r--   0        0        0    14073 2024-02-09 10:59:25.236001 pyaedt-0.8.8/pyaedt/modeler/advanced_cad/actors.py
+-rw-r--r--   0        0        0    20019 2024-02-09 10:59:25.236001 pyaedt-0.8.8/pyaedt/modeler/advanced_cad/multiparts.py
+-rw-r--r--   0        0        0    18513 2023-11-15 14:48:51.328409 pyaedt-0.8.8/pyaedt/modeler/advanced_cad/oms.py
+-rw-r--r--   0        0        0    16676 2024-04-16 16:03:45.157131 pyaedt-0.8.8/pyaedt/modeler/advanced_cad/parts.py
+-rw-r--r--   0        0        0   126296 2024-04-16 16:03:45.157131 pyaedt-0.8.8/pyaedt/modeler/advanced_cad/stackup_3d.py
+-rw-r--r--   0        0        0    80031 2024-04-16 16:03:45.157131 pyaedt-0.8.8/pyaedt/modeler/cad/Modeler.py
+-rw-r--r--   0        0        0   335948 2024-04-16 16:03:45.172811 pyaedt-0.8.8/pyaedt/modeler/cad/Primitives.py
+-rw-r--r--   0        0        0    14603 2024-04-16 16:03:45.172811 pyaedt-0.8.8/pyaedt/modeler/cad/Primitives2D.py
+-rw-r--r--   0        0        0   144677 2024-04-16 16:03:45.172811 pyaedt-0.8.8/pyaedt/modeler/cad/Primitives3D.py
+-rw-r--r--   0        0        0        0 2023-11-15 14:48:51.344085 pyaedt-0.8.8/pyaedt/modeler/cad/__init__.py
+-rw-r--r--   0        0        0    29696 2024-04-16 16:03:45.172811 pyaedt-0.8.8/pyaedt/modeler/cad/component_array.py
+-rw-r--r--   0        0        0    41884 2024-04-16 16:03:45.172811 pyaedt-0.8.8/pyaedt/modeler/cad/components_3d.py
+-rw-r--r--   0        0        0    49374 2024-04-16 16:03:45.172811 pyaedt-0.8.8/pyaedt/modeler/cad/elements3d.py
+-rw-r--r--   0        0        0    59455 2024-04-16 16:03:45.172811 pyaedt-0.8.8/pyaedt/modeler/cad/object3d.py
+-rw-r--r--   0        0        0    53212 2024-04-16 16:03:45.172811 pyaedt-0.8.8/pyaedt/modeler/cad/polylines.py
+-rw-r--r--   0        0        0    12604 2023-11-15 14:48:51.344085 pyaedt-0.8.8/pyaedt/modeler/calculators.py
+-rw-r--r--   0        0        0    44326 2024-04-16 16:03:45.172811 pyaedt-0.8.8/pyaedt/modeler/circuits/PrimitivesCircuit.py
+-rw-r--r--   0        0        0    39329 2024-04-12 06:22:12.847095 pyaedt-0.8.8/pyaedt/modeler/circuits/PrimitivesEmit.py
+-rw-r--r--   0        0        0     8514 2024-04-16 16:03:45.172811 pyaedt-0.8.8/pyaedt/modeler/circuits/PrimitivesMaxwellCircuit.py
+-rw-r--r--   0        0        0    68319 2024-04-16 16:03:45.172811 pyaedt-0.8.8/pyaedt/modeler/circuits/PrimitivesNexxim.py
+-rw-r--r--   0        0        0    15130 2024-04-16 16:03:45.172811 pyaedt-0.8.8/pyaedt/modeler/circuits/PrimitivesTwinBuilder.py
+-rw-r--r--   0        0        0        0 2023-11-15 14:48:51.344085 pyaedt-0.8.8/pyaedt/modeler/circuits/__init__.py
+-rw-r--r--   0        0        0    34524 2024-04-16 16:03:45.172811 pyaedt-0.8.8/pyaedt/modeler/circuits/object3dcircuit.py
+-rw-r--r--   0        0        0    68299 2024-04-15 14:11:58.269561 pyaedt-0.8.8/pyaedt/modeler/geometry_operators.py
+-rw-r--r--   0        0        0     6929 2024-04-16 16:03:45.172811 pyaedt-0.8.8/pyaedt/modeler/modeler2d.py
+-rw-r--r--   0        0        0    66190 2024-04-16 16:03:45.172811 pyaedt-0.8.8/pyaedt/modeler/modeler3d.py
+-rw-r--r--   0        0        0    33272 2024-04-16 16:03:45.188385 pyaedt-0.8.8/pyaedt/modeler/modelerpcb.py
+-rw-r--r--   0        0        0    52444 2024-04-16 16:03:45.188385 pyaedt-0.8.8/pyaedt/modeler/pcb/Primitives3DLayout.py
+-rw-r--r--   0        0        0        0 2023-11-15 14:48:51.359653 pyaedt-0.8.8/pyaedt/modeler/pcb/__init__.py
+-rw-r--r--   0        0        0    66436 2024-04-16 16:03:45.188385 pyaedt-0.8.8/pyaedt/modeler/pcb/object3dlayout.py
+-rw-r--r--   0        0        0    23856 2024-04-16 16:03:45.188385 pyaedt-0.8.8/pyaedt/modeler/schematic.py
+-rw-r--r--   0        0        0    51557 2024-04-15 11:56:45.720413 pyaedt-0.8.8/pyaedt/modules/AdvancedPostProcessing.py
+-rw-r--r--   0        0        0   169925 2024-04-16 16:03:45.188385 pyaedt-0.8.8/pyaedt/modules/Boundary.py
+-rw-r--r--   0        0        0    71749 2024-04-05 14:27:59.025313 pyaedt-0.8.8/pyaedt/modules/CableModeling.py
+-rw-r--r--   0        0        0    16319 2023-11-15 14:48:51.359653 pyaedt-0.8.8/pyaedt/modules/CircuitTemplates.py
+-rw-r--r--   0        0        0    56829 2024-04-12 06:21:23.656143 pyaedt-0.8.8/pyaedt/modules/DesignXPloration.py
+-rw-r--r--   0        0        0    40453 2024-04-12 06:21:23.656143 pyaedt-0.8.8/pyaedt/modules/LayerStackup.py
+-rw-r--r--   0        0        0   105895 2024-04-16 16:03:45.188385 pyaedt-0.8.8/pyaedt/modules/Material.py
+-rw-r--r--   0        0        0    33683 2024-03-26 16:57:20.128932 pyaedt-0.8.8/pyaedt/modules/MaterialLib.py
+-rw-r--r--   0        0        0    55020 2024-04-16 16:03:45.188385 pyaedt-0.8.8/pyaedt/modules/Mesh.py
+-rw-r--r--   0        0        0    12354 2024-04-09 09:33:35.792297 pyaedt-0.8.8/pyaedt/modules/Mesh3DLayout.py
+-rw-r--r--   0        0        0    49218 2024-04-10 06:18:36.719407 pyaedt-0.8.8/pyaedt/modules/MeshIcepak.py
+-rw-r--r--   0        0        0     4437 2023-11-15 14:48:51.359653 pyaedt-0.8.8/pyaedt/modules/OptimetricsTemplates.py
+-rw-r--r--   0        0        0   211693 2024-04-16 16:03:45.188385 pyaedt-0.8.8/pyaedt/modules/PostProcessor.py
+-rw-r--r--   0        0        0    72048 2024-03-08 11:06:27.183697 pyaedt-0.8.8/pyaedt/modules/SetupTemplates.py
+-rw-r--r--   0        0        0   147699 2024-04-16 16:03:45.188385 pyaedt-0.8.8/pyaedt/modules/SolveSetup.py
+-rw-r--r--   0        0        0    32997 2024-04-15 11:56:45.720413 pyaedt-0.8.8/pyaedt/modules/SolveSweeps.py
+-rw-r--r--   0        0        0        0 2023-11-15 14:48:51.375283 pyaedt-0.8.8/pyaedt/modules/__init__.py
+-rw-r--r--   0        0        0    31386 2024-04-16 16:03:45.188385 pyaedt-0.8.8/pyaedt/modules/monitor_icepak.py
+-rw-r--r--   0        0        0   137795 2024-04-16 10:41:18.667222 pyaedt-0.8.8/pyaedt/modules/report_templates.py
+-rw-r--r--   0        0        0   135852 2024-04-15 11:56:45.735987 pyaedt-0.8.8/pyaedt/modules/solutions.py
+-rw-r--r--   0        0        0    97896 2024-04-16 16:03:45.188385 pyaedt-0.8.8/pyaedt/q3d.py
+-rw-r--r--   0        0        0    10722 2024-04-15 11:56:45.735987 pyaedt-0.8.8/pyaedt/rmxprt.py
+-rw-r--r--   0        0        0        0 2023-11-15 14:48:51.375283 pyaedt-0.8.8/pyaedt/rpc/__init__.py
+-rw-r--r--   0        0        0      415 2023-11-15 14:48:51.375283 pyaedt-0.8.8/pyaedt/rpc/local_server.py
+-rw-r--r--   0        0        0    42608 2024-04-16 16:03:45.188385 pyaedt-0.8.8/pyaedt/rpc/rpyc_services.py
+-rw-r--r--   0        0        0        0 2023-11-15 14:48:51.375283 pyaedt-0.8.8/pyaedt/sbrplus/__init__.py
+-rw-r--r--   0        0        0     9463 2023-11-15 14:48:51.375283 pyaedt-0.8.8/pyaedt/sbrplus/hdm_parser.py
+-rw-r--r--   0        0        0     2096 2023-11-15 14:48:51.375283 pyaedt-0.8.8/pyaedt/sbrplus/hdm_utils.py
+-rw-r--r--   0        0        0     2607 2023-11-15 14:48:51.375283 pyaedt-0.8.8/pyaedt/sbrplus/matlab/HdmObject.m
+-rw-r--r--   0        0        0       97 2023-11-15 14:48:51.375283 pyaedt-0.8.8/pyaedt/sbrplus/matlab/README.md
+-rw-r--r--   0        0        0      735 2023-11-15 14:48:51.375283 pyaedt-0.8.8/pyaedt/sbrplus/matlab/SbrBounceType.m
+-rw-r--r--   0        0        0     2886 2023-11-15 14:48:51.375283 pyaedt-0.8.8/pyaedt/sbrplus/matlab/StopWatch.m
+-rw-r--r--   0        0        0     1402 2023-11-15 14:48:51.375283 pyaedt-0.8.8/pyaedt/sbrplus/matlab/add_3dlight.m
+-rw-r--r--   0        0        0      340 2023-11-15 14:48:51.375283 pyaedt-0.8.8/pyaedt/sbrplus/matlab/amp2db.m
+-rw-r--r--   0        0        0    36837 2023-11-15 14:48:51.375283 pyaedt-0.8.8/pyaedt/sbrplus/matlab/draw_rays1.m
+-rw-r--r--   0        0        0     4322 2023-11-15 14:48:51.375283 pyaedt-0.8.8/pyaedt/sbrplus/matlab/draw_wfobj.m
+-rw-r--r--   0        0        0    31414 2023-11-15 14:48:51.375283 pyaedt-0.8.8/pyaedt/sbrplus/matlab/filter_rays1.m
+-rw-r--r--   0        0        0     1504 2023-11-15 14:48:51.390911 pyaedt-0.8.8/pyaedt/sbrplus/matlab/filtered_tracks.m
+-rw-r--r--   0        0        0    20853 2023-11-15 14:48:51.390911 pyaedt-0.8.8/pyaedt/sbrplus/matlab/ld_sbrplushdm.m
+-rw-r--r--   0        0        0    14781 2023-11-15 14:48:51.390911 pyaedt-0.8.8/pyaedt/sbrplus/matlab/ld_wfobj.m
+-rw-r--r--   0        0        0      318 2023-11-15 14:48:51.390911 pyaedt-0.8.8/pyaedt/sbrplus/matlab/pwr2db.m
+-rw-r--r--   0        0        0     2607 2023-11-15 14:48:51.390911 pyaedt-0.8.8/pyaedt/sbrplus/matlab/validate_sfields.m
+-rw-r--r--   0        0        0     7621 2024-03-26 16:57:20.144566 pyaedt-0.8.8/pyaedt/sbrplus/plot.py
+-rw-r--r--   0        0        0    21529 2024-04-15 11:56:45.735987 pyaedt-0.8.8/pyaedt/twinbuilder.py
+-rw-r--r--   0        0        0     6768 2024-04-16 10:43:22.619068 pyaedt-0.8.8/pyproject.toml
+-rw-r--r--   0        0        0    16490 1970-01-01 00:00:00.000000 pyaedt-0.8.8/PKG-INFO
```

### Comparing `pyaedt-0.8.7/LICENSE` & `pyaedt-0.8.8/LICENSE`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/README.md` & `pyaedt-0.8.8/README.md`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/__init__.py` & `pyaedt-0.8.8/pyaedt/__init__.py`

 * *Files 0% similar despite different names*

```diff
@@ -36,15 +36,15 @@
 
 
 deprecation_warning()
 
 #
 
 pyaedt_path = os.path.dirname(__file__)
-__version__ = "0.8.7"
+__version__ = "0.8.8"
 version = __version__
 
 #
 
 import pyaedt.downloads as downloads
 from pyaedt.generic import constants
 import pyaedt.generic.DataHandlers as data_handler
```

### Comparing `pyaedt-0.8.7/pyaedt/aedt_logger.py` & `pyaedt-0.8.8/pyaedt/aedt_logger.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/application/AEDT_File_Management.py` & `pyaedt-0.8.8/pyaedt/application/AEDT_File_Management.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/application/Analysis.py` & `pyaedt-0.8.8/pyaedt/application/Analysis.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,15 +9,14 @@
 
 from collections import OrderedDict
 import os
 import re
 import shutil
 import tempfile
 import time
-import warnings
 
 from pyaedt import is_ironpython
 from pyaedt import is_linux
 from pyaedt import is_windows
 from pyaedt.application.Design import Design
 from pyaedt.application.JobManager import update_hpc_option
 from pyaedt.application.Variables import Variable
@@ -118,14 +117,15 @@
             new_desktop_session,
             close_on_exit,
             student_version,
             machine,
             port,
             aedt_process_id,
         )
+        self._excitation_objects = {}
         self._setup = None
         if setup_name:
             self.active_setup = setup_name
         self._materials = None
         self._available_variations = self.AvailableVariations(self)
         self._setups = []
         self._parametrics = []
@@ -287,38 +287,14 @@
         if setup_list:
             assert setup_name in setup_list, "Invalid setup name {}".format(setup_name)
             self._setup = setup_name
         else:
             raise AttributeError("No setup defined")
 
     @property
-    def analysis_setup(self):
-        """Analysis setup.
-
-        .. deprecated:: 0.6.53
-           Use :func:`active_setup` property instead.
-
-        Returns
-        -------
-        str
-            Name of the active or first analysis setup.
-
-        References
-        ----------
-
-        >>> oModule.GetAllSolutionSetups()
-        """
-        warnings.warn("`analysis_setup` is deprecated. Use `active_setup` property instead.", DeprecationWarning)
-        return self.active_setup
-
-    @analysis_setup.setter
-    def analysis_setup(self, setup_name):
-        self.active_setup = setup_name
-
-    @property
     def existing_analysis_sweeps(self):
         """Existing analysis sweeps.
 
         Returns
         -------
         list of str
             List of all analysis sweeps in the design.
@@ -473,14 +449,54 @@
             list_names = list(self.oboundary.GetExcitations())
             del list_names[1::2]
             list_names = list(set(list_names))
             return list_names
         except Exception:
             return []
 
+    @property
+    def excitations_by_type(self):
+        """Design excitations by type.
+
+        Returns
+        -------
+        dict
+            Dictionary of excitations.
+        """
+        _dict_out = {}
+        for bound in self.excitation_objects.values():
+            if bound.type in _dict_out:
+                _dict_out[bound.type].append(bound)
+            else:
+                _dict_out[bound.type] = [bound]
+        return _dict_out
+
+    @property
+    def excitation_objects(self):
+        """Get all excitation.
+
+        Returns
+        -------
+        dict
+            List of excitation boundaries. Excitations with multiple modes will return one
+            excitation for each mode.
+
+        References
+        ----------
+
+        >>> oModule.GetExcitations
+        """
+        exc_names = self.excitations[::]
+
+        for el in self.boundaries:
+            if el.name in exc_names:
+                self._excitation_objects[el.name] = el
+
+        return self._excitation_objects
+
     @pyaedt_function_handler()
     def get_traces_for_plot(
         self,
         get_self_terms=True,
         get_mutual_terms=True,
         first_element_filter=None,
         second_element_filter=None,
@@ -1177,21 +1193,21 @@
         ----------
 
         >>> oModule.GetSweeps
         """
         sweeps = self.oanalysis.GetSweeps(name)
         return list(sweeps)
 
-    @pyaedt_function_handler()
-    def export_parametric_results(self, sweepname, filename, exportunits=True):
+    @pyaedt_function_handler(sweepname="sweep")
+    def export_parametric_results(self, sweep, filename, exportunits=True):
         """Export a list of all parametric variations solved for a sweep to a CSV file.
 
         Parameters
         ----------
-        sweepname : str
+        sweep : str
             Name of the optimetrics sweep.
         filename : str
             Full path and name for the CSV file.
         exportunits : bool, optional
             Whether to export units with the value. The default is ``True``. When ``False``,
             only the value is exported.
 
@@ -1202,15 +1218,15 @@
 
         References
         ----------
 
         >>> oModule.ExportParametricResults
         """
 
-        self.ooptimetrics.ExportParametricResults(sweepname, filename, exportunits)
+        self.ooptimetrics.ExportParametricResults(sweep, filename, exportunits)
         return True
 
     @pyaedt_function_handler()
     def generate_unique_setup_name(self, setup_name=None):
         """Generate a new setup with an unique name.
 
         Parameters
@@ -1228,32 +1244,32 @@
             setup_name = "Setup"
         index = 2
         while setup_name in self.existing_analysis_setups:
             setup_name = setup_name + "_{}".format(index)
             index += 1
         return setup_name
 
-    @pyaedt_function_handler()
-    def _create_setup(self, setupname="MySetupAuto", setuptype=None, props=None):
+    @pyaedt_function_handler(setupname="name", setuptype="setup_type")
+    def _create_setup(self, name="MySetupAuto", setup_type=None, props=None):
         if props is None:
             props = {}
 
-        if setuptype is None:
-            setuptype = self.design_solutions.default_setup
-        name = self.generate_unique_setup_name(setupname)
-        if setuptype == 0:
-            setup = SetupHFSSAuto(self, setuptype, name)
-        elif setuptype == 4:
-            setup = SetupSBR(self, setuptype, name)
-        elif setuptype in [5, 6, 7, 8, 9, 10, 56, 58, 59]:
-            setup = SetupMaxwell(self, setuptype, name)
-        elif setuptype in [14]:
-            setup = SetupQ3D(self, setuptype, name)
+        if setup_type is None:
+            setup_type = self.design_solutions.default_setup
+        name = self.generate_unique_setup_name(name)
+        if setup_type == 0:
+            setup = SetupHFSSAuto(self, setup_type, name)
+        elif setup_type == 4:
+            setup = SetupSBR(self, setup_type, name)
+        elif setup_type in [5, 6, 7, 8, 9, 10, 56, 58, 59]:
+            setup = SetupMaxwell(self, setup_type, name)
+        elif setup_type == 14:
+            setup = SetupQ3D(self, setup_type, name)
         else:
-            setup = SetupHFSS(self, setuptype, name)
+            setup = SetupHFSS(self, setup_type, name)
 
         if self.design_type == "HFSS":
             # Handle the situation when ports have not been defined.
 
             if not self.excitations and "MaxDeltaS" in setup.props:
                 new_dict = OrderedDict()
                 setup.auto_update = False
@@ -1317,21 +1333,21 @@
 
         self.active_setup = name
 
         self._setups = tmp_setups + [setup]
 
         return setup
 
-    @pyaedt_function_handler()
-    def delete_setup(self, setupname):
+    @pyaedt_function_handler(setupname="name")
+    def delete_setup(self, name):
         """Delete a setup.
 
         Parameters
         ----------
-        setupname : str
+        name : str
             Name of the setup.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
@@ -1342,83 +1358,83 @@
 
         Examples
         --------
         Create a setup and then delete it.
 
         >>> import pyaedt
         >>> hfss = pyaedt.Hfss()
-        >>> setup1 = hfss.create_setup(setupname='Setup1')
-        >>> hfss.delete_setup(setupname='Setup1')
+        >>> setup1 = hfss.create_setup(name='Setup1')
+        >>> hfss.delete_setup()
         ...
         PyAEDT INFO: Sweep was deleted correctly.
         """
-        if setupname in self.existing_analysis_setups:
-            self.oanalysis.DeleteSetups([setupname])
+        if name in self.existing_analysis_setups:
+            self.oanalysis.DeleteSetups([name])
             for s in self._setups:
-                if s.name == setupname:
+                if s.name == name:
                     self._setups.remove(s)
             return True
         return False
 
-    @pyaedt_function_handler()
-    def edit_setup(self, setupname, properties_dict):
+    @pyaedt_function_handler(setupname="name", properties_dict="properties")
+    def edit_setup(self, name, properties):
         """Modify a setup.
 
         Parameters
         ----------
-        setupname : str
+        name : str
             Name of the setup.
-        properties_dict : dict
+        properties : dict
             Dictionary containing the property to update with the value.
 
         Returns
         -------
         :class:`pyaedt.modules.SolveSetup.Setup`
 
         References
         ----------
 
         >>> oModule.EditSetup
         """
 
         setuptype = self.design_solutions.default_setup
-        setup = Setup(self, setuptype, setupname, isnewsetup=False)
-        setup.update(properties_dict)
-        self.active_setup = setupname
+        setup = Setup(self, setuptype, name)
+        setup.update(properties)
+        self.active_setup = name
         return setup
 
-    @pyaedt_function_handler()
-    def get_setup(self, setupname):
+    @pyaedt_function_handler(setupname="name")
+    def get_setup(self, name):
         """Get the setup from the current design.
 
         Parameters
         ----------
-        setupname : str
+        name : str
             Name of the setup.
 
         Returns
         -------
         :class:`pyaedt.modules.SolveSetup.Setup`
 
         """
         setuptype = self.design_solutions.default_setup
 
         if self.solution_type == "SBR+":
             setuptype = 4
-            setup = SetupSBR(self, setuptype, setupname, isnewsetup=False)
+            setup = SetupSBR(self, setuptype, name, is_new_setup=False)
         elif self.design_type in ["Q3D Extractor", "2D Extractor", "HFSS"]:
-            setup = SetupHFSS(self, setuptype, setupname, isnewsetup=False)
+            setup = SetupHFSS(self, setuptype, name, is_new_setup=False)
             if setup.props and setup.props.get("SetupType", "") == "HfssDrivenAuto":
-                setup = SetupHFSSAuto(self, 0, setupname, isnewsetup=False)
+                setup = SetupHFSSAuto(self, 0, name, is_new_setup=False)
         elif self.design_type in ["Maxwell 2D", "Maxwell 3D"]:
-            setup = SetupMaxwell(self, setuptype, setupname, isnewsetup=False)
+            setup = SetupMaxwell(self, setuptype, name, is_new_setup=False)
         else:
-            setup = Setup(self, setuptype, setupname, isnewsetup=False)
+            setup = Setup(self, setuptype, name, is_new_setup=False)
         if setup.props:
-            self.active_setup = setupname
+            self.active_setup = name
         return setup
 
     @pyaedt_function_handler()
     def create_output_variable(self, variable, expression, solution=None, context=None):
         """Create or modify an output variable.
 
 
@@ -1488,132 +1504,57 @@
         if solution is None:
             solution = self.existing_analysis_sweeps[0]
         value = self.ooutput_variable.GetOutputVariableValue(
             variable, nominal_variation, solution, self.solution_type, []
         )
         return value
 
-    @pyaedt_function_handler()
-    def get_object_material_properties(self, object_list=None, prop_names=None):
+    @pyaedt_function_handler(object_list="assignment")
+    def get_object_material_properties(self, assignment=None, prop_names=None):
         """Retrieve the material properties for a list of objects and return them in a dictionary.
 
         This high-level function ignores objects with no defined material properties.
 
         Parameters
         ----------
-        object_list : list, optional
+        assignment : list, optional
             List of objects to get material properties for. The default is ``None``,
             in which case material properties are retrieved for all objects.
         prop_names : str or list
             Property or list of properties to export. The default is ``None``, in
             which case all properties are exported.
 
         Returns
         -------
         dict
             Dictionary of objects with material properties.
         """
-        if object_list:
-            if not isinstance(object_list, list):
-                object_list = [object_list]
+        if assignment:
+            if not isinstance(assignment, list):
+                assignment = [assignment]
         else:
-            object_list = self.modeler.object_names
+            assignment = self.modeler.object_names
 
         if prop_names:
             if not isinstance(prop_names, list):
                 prop_names = [prop_names]
 
         dict = {}
-        for entry in object_list:
+        for entry in assignment:
             mat_name = self.modeler[entry].material_name
             mat_props = self._materials[mat_name]
             if prop_names is None:
                 dict[entry] = mat_props._props
             else:
                 dict[entry] = {}
                 for prop_name in prop_names:
                     dict[entry][prop_name] = mat_props._props[prop_name]
         return dict
 
     @pyaedt_function_handler()
-    def analyze_all(self):
-        """Analyze all setups in a design.
-
-        .. deprecated:: 0.6.52
-           Use :func:`analyze` method instead.
-
-        Returns
-        -------
-        bool
-            ``True`` when simulation is finished.
-        """
-        warnings.warn("`analyze_all` is deprecated. Use `analyze` method instead.", DeprecationWarning)
-        self.odesign.AnalyzeAll()
-        return True
-
-    @pyaedt_function_handler()
-    def analyze_from_initial_mesh(self):
-        """Revert the solution to the initial mesh and re-run the solve.
-
-        .. deprecated:: 0.6.52
-           Use :func:`analyze` method instead.
-
-        Returns
-        -------
-        bool
-           ``True`` when successful, ``False`` when failed.
-
-        References
-        ----------
-
-        >>> oModule.RevertSetupToInitial
-        >>> oDesign.Analyze
-        """
-        warnings.warn("`analyze_from_initial_mesh` is deprecated. Use `analyze` method instead.", DeprecationWarning)
-
-        self.oanalysis.RevertSetupToInitial(self._setup)
-        self.analyze(self.active_setup)
-        return True
-
-    @pyaedt_function_handler()
-    def analyze_nominal(self, num_cores=1, num_tasks=1, num_gpu=0, acf_file=None, use_auto_settings=True):
-        """Solve the nominal design.
-
-        .. deprecated:: 0.6.52
-           Use :func:`analyze` method instead.
-
-        Parameters
-        ----------
-        num_cores : int, optional
-            Number of simulation cores. Default is ``1``.
-        num_tasks : int, optional
-            Number of simulation tasks. Default is ``1``.
-        num_gpu : int, optional
-            Number of simulation graphic processing units to use. Default is ``0``.
-        acf_file : str, optional
-            Full path to the custom ACF file.
-        use_auto_settings : bool, optional
-            Set ``True`` to use automatic settings for HPC. The option is only considered for setups
-            that support automatic settings.
-
-        Returns
-        -------
-        bool
-            ``True`` when successful, ``False`` when failed.
-
-        References
-        ----------
-
-        >>> oDesign.Analyze
-        """
-        warnings.warn("`analyze_nominal` is deprecated. Use `analyze` method instead.", DeprecationWarning)
-
-        return self.analyze(self.active_setup, num_cores, num_tasks, num_gpu, acf_file, use_auto_settings)
-
-    @pyaedt_function_handler()
     def analyze(
         self,
         setup_name=None,
         num_cores=4,
         num_tasks=1,
         num_gpu=1,
         acf_file=None,
@@ -2046,15 +1987,15 @@
         else:
             subprocess.Popen(batch_run)
             self.logger.info("Batch job finished.")
 
         if machine == "localhost":
             while not os.path.exists(queue_file):
                 time.sleep(0.5)
-            with open(queue_file, "r") as f:
+            with open_file(queue_file, "r") as f:
                 lines = f.readlines()
                 for line in lines:
                     if "JobID" in line:
                         ls = line.split("=")[1].strip().strip("'")
                         self.last_run_job = ls
                         self.last_run_log = os.path.join(filename + ".batchinfo", project_name + "-" + ls + ".log")
             while not os.path.exists(queue_file_completed):
```

### Comparing `pyaedt-0.8.7/pyaedt/application/Analysis3D.py` & `pyaedt-0.8.8/pyaedt/application/Analysis3D.py`

 * *Files 0% similar despite different names*

```diff
@@ -276,21 +276,21 @@
                 view=view,
                 show_legend=show_legend,
                 dark_mode=dark_mode,
                 show_bounding=show_bounding,
                 show_grid=show_grid,
             )
 
-    @pyaedt_function_handler()
-    def export_mesh_stats(self, setup_name, variation_string="", mesh_path=None):
+    @pyaedt_function_handler(setup_name="setup")
+    def export_mesh_stats(self, setup, variation_string="", mesh_path=None):
         """Export mesh statistics to a file.
 
         Parameters
         ----------
-        setup_name : str
+        setup : str
             Setup name.
         variation_string : str, optional
             Variation list. The default is ``""``.
         mesh_path : str, optional
             Full path to the mesh statistics file. The default is ``None``, in which
             caswe the working directory is used.
 
@@ -301,15 +301,15 @@
 
         References
         ----------
         >>> oDesign.ExportMeshStats
         """
         if not mesh_path:
             mesh_path = os.path.join(self.working_directory, "meshstats.ms")
-        self.odesign.ExportMeshStats(setup_name, variation_string, mesh_path)
+        self.odesign.ExportMeshStats(setup, variation_string, mesh_path)
         return mesh_path
 
     @pyaedt_function_handler()
     def get_components3d_vars(self, component3dname):
         """Read the A3DCOMP file and check for variables.
 
         Parameters
```

### Comparing `pyaedt-0.8.7/pyaedt/application/AnalysisMaxwellCircuit.py` & `pyaedt-0.8.8/pyaedt/application/AnalysisMaxwellCircuit.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/application/AnalysisNexxim.py` & `pyaedt-0.8.8/pyaedt/twinbuilder.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,622 +1,577 @@
-from pyaedt.application.Analysis import Analysis
+"""This module contains the ``TwinBuilder`` class."""
+
+from __future__ import absolute_import  # noreorder
+
+import math
+import os.path
+
+from pyaedt.application.AnalysisTwinBuilder import AnalysisTwinBuilder
+from pyaedt.application.Variables import Variable
+from pyaedt.application.Variables import decompose_variable_value
+from pyaedt.generic.general_methods import generate_unique_name
+from pyaedt.generic.general_methods import is_number
+from pyaedt.generic.general_methods import open_file
 from pyaedt.generic.general_methods import pyaedt_function_handler
-from pyaedt.generic.settings import settings
-from pyaedt.modeler.circuits.object3dcircuit import CircuitComponent
-from pyaedt.modules.Boundary import CurrentSinSource
-from pyaedt.modules.Boundary import Excitations
-from pyaedt.modules.Boundary import PowerIQSource
-from pyaedt.modules.Boundary import PowerSinSource
-from pyaedt.modules.Boundary import Sources
-from pyaedt.modules.Boundary import VoltageDCSource
-from pyaedt.modules.Boundary import VoltageFrequencyDependentSource
-from pyaedt.modules.Boundary import VoltageSinSource
-from pyaedt.modules.SetupTemplates import SetupKeys
-from pyaedt.modules.SolveSetup import SetupCircuit
-
-
-class FieldAnalysisCircuit(Analysis):
-    """FieldCircuitAnalysis class.
-
-    This class is for circuit analysis setup in Nexxim.
-
-    It is automatically initialized by a call from an application,
-    such as HFSS or Q3D. See the application function for its
-    parameter definitions.
+
+
+class TwinBuilder(AnalysisTwinBuilder, object):
+    """Provides the Twin Builder application interface.
 
     Parameters
     ----------
+    projectname : str, optional
+        Name of the project to select or the full path to the project
+        or AEDTZ archive to open.  The default is ``None``, in which
+        case an attempt is made to get an active project. If no
+        projects are present, an empty project is created.
+    designname : str, optional
+        Name of the design to select. The default is ``None``, in
+        which case an attempt is made to get an active design. If no
+        designs are present, an empty design is created.
+    solution_type : str, optional
+        Solution type to apply to the design. The default is
+        ``None``, in which case the default type is applied.
+    setup_name : str, optional
+        Name of the setup to use as the nominal. The default is
+        ``None``, in which case the active setup is used or
+        nothing is used.
+    specified_version : str, int, float, optional
+        Version of AEDT to use. The default is ``None``, in which
+        case the active setup or latest installed version is
+        used.
+        Examples of input values are ``232``, ``23.2``,``2023.2``,``"2023.2"``.
+    non_graphical : bool, optional
+        Whether to launch AEDT in non-graphical mode. The default
+        is ``False``, in which case AEDT is launched in graphical mode.
+        This parameter is ignored when a script is launched within AEDT.
+    new_desktop_session : bool, optional
+        Whether to launch an instance of AEDT in a new thread, even if
+        another instance of the ``specified_version`` is active on the
+        machine.  The default is ``False``.
+    close_on_exit : bool, optional
+        Whether to release AEDT on exit. The default is ``False``.
+    student_version : bool, optional
+        Whether to open the AEDT student version. The default is ``False``.
+    machine : str, optional
+        Machine name to connect the oDesktop session to. This works only in 2022 R2
+        or later. The remote server must be up and running with the command
+        `"ansysedt.exe -grpcsrv portnum"`. If the machine is `"localhost"`,
+        the server also starts if not present.
+    port : int, optional
+        Port number on which to start the oDesktop communication on an already existing server.
+        This parameter is ignored when creating a new server. It works only in 2022 R2 or later.
+        The remote server must be up and running with command `"ansysedt.exe -grpcsrv portnum"`.
+    aedt_process_id : int, optional
+        Process ID for the instance of AEDT to point PyAEDT at. The default is
+        ``None``. This parameter is only used when ``new_desktop_session = False``.
+
+    Examples
+    --------
+    Create an instance of Twin Builder and connect to an existing
+    Maxwell design or create a new Maxwell design if one does not
+    exist.
+
+    >>> from pyaedt import TwinBuilder
+    >>> app = TwinBuilder()
+
+    Create a instance of Twin Builder and link to a project named
+    ``"projectname"``. If this project does not exist, create one with
+    this name.
+
+    >>> app = TwinBuilder(projectname)
+
+    Create an instance of Twin Builder and link to a design named
+    ``"designname"`` in a project named ``"projectname"``.
 
+    >>> app = TwinBuilder(projectname, designame)
+
+    Create an instance of Twin Builder and open the specified
+    project, which is named ``"myfile.aedt"``.
+
+    >>> app = TwinBuilder("myfile.aedt")
     """
 
     def __init__(
         self,
-        application,
-        projectname,
-        designname,
-        solution_type,
+        projectname=None,
+        designname=None,
+        solution_type=None,
         setup_name=None,
         specified_version=None,
         non_graphical=False,
         new_desktop_session=False,
         close_on_exit=False,
         student_version=False,
         machine="",
         port=0,
         aedt_process_id=None,
     ):
-        Analysis.__init__(
+        """Constructor."""
+        AnalysisTwinBuilder.__init__(
             self,
-            application,
+            "Twin Builder",
             projectname,
             designname,
             solution_type,
             setup_name,
             specified_version,
             non_graphical,
             new_desktop_session,
             close_on_exit,
             student_version,
             machine,
             port,
             aedt_process_id,
         )
 
-        self._modeler = None
-        self._post = None
-        self._internal_excitations = None
-        self._internal_sources = None
-        if not settings.lazy_load:
-            self._modeler = self.modeler
-            self._post = self.post
+    def _init_from_design(self, *args, **kwargs):
+        self.__init__(*args, **kwargs)
 
     @pyaedt_function_handler()
-    def delete_setup(self, setupname):
-        """Delete a setup.
+    def create_schematic_from_netlist(self, file_to_import):
+        """Create a circuit schematic from an HSpice net list.
+
+        Supported currently are:
+
+        * R
+        * L
+        * C
+        * Diodes
+        * Bjts
+        * Discrete components with syntax ``Uxxx net1 net2 ... netn modname``
 
         Parameters
         ----------
-        setupname : str
-            Name of the setup.
+        file_to_import : str
+            Full path to the HSpice file.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
-        References
-        ----------
-
-        >>> oModule.RemoveSimSetup
         """
-        if setupname in self.existing_analysis_setups:
-            self.oanalysis.RemoveSimSetup([setupname])
-            for s in self.setups:
-                if s.name == setupname:
-                    self.setups.remove(s)
-            return True
-        return False
+        xpos = 0
+        ypos = 0
+        delta = 0.0508
+        use_instance = True
+        with open_file(file_to_import, "r") as f:
+            for line in f:
+                mycomp = None
+                fields = line.split(" ")
+                name = fields[0]
+                if fields[0][0] == "R":
+                    value = fields[3][fields[3].find("=") + 1 :].strip()
+                    mycomp = self.modeler.schematic.create_resistor(
+                        name, value, [xpos, ypos], use_instance_id_netlist=use_instance
+                    )
+                elif fields[0][0] == "L":
+                    value = fields[3][fields[3].find("=") + 1 :].strip()
+                    mycomp = self.modeler.schematic.create_inductor(
+                        name, value, [xpos, ypos], use_instance_id_netlist=use_instance
+                    )
+                elif fields[0][0] == "C":
+                    value = fields[3][fields[3].find("=") + 1 :].strip()
+                    mycomp = self.modeler.schematic.create_capacitor(
+                        name, value, [xpos, ypos], use_instance_id_netlist=use_instance
+                    )
+                elif fields[0][0] == "Q":
+                    if len(fields) == 4 and fields[0][0] == "Q":
+                        value = fields[3].strip()
+                        mycomp = self.modeler.schematic.create_npn(
+                            fields[0], value, [xpos, ypos], use_instance_id_netlist=use_instance
+                        )
+                        value = None
+                elif fields[0][0] == "D":
+                    value = fields[3][fields[3].find("=") + 1 :].strip()
+                    mycomp = self.modeler.schematic.create_diode(
+                        name, [xpos, ypos], use_instance_id_netlist=use_instance
+                    )
+                if mycomp:
+                    id = 1
+                    for pin in mycomp.pins:
+                        if pin.name == "CH" or pin.name == fields[0][0]:
+                            continue
+                        pos = pin.location
+                        if pos[0] < xpos:
+                            angle = 0.0
+                        else:
+                            angle = math.pi
+                        self.modeler.schematic.create_page_port(fields[id], [pos[0], pos[1]], angle)
+                        id += 1
+                    ypos += delta
+                    if ypos > 0.254:
+                        xpos += delta
+                        ypos = 0
+        return True
 
     @pyaedt_function_handler()
-    def push_down(self, component_name):
-        """Push-down to the child component and reinitialize the Circuit object.
+    def set_end_time(self, expression):
+        """Set the end time.
 
         Parameters
         ----------
-        component_name : str or :class:`pyaedt.modeler.cad.object3d.circuit.CircuitComponent`
-            Component to initialize.
-
-        Returns
-        -------
-        bool
-            ``True`` when successful, ``False`` when failed.
-        """
-        out_name = ""
-        if isinstance(component_name, CircuitComponent):
-            out_name = self.design_name + ":" + component_name.component_info["RefDes"]
-        elif "U" == component_name[0]:
-            out_name = self.design_name + ":" + component_name
-        elif ":" not in component_name:
-            for v in self.modeler.components.components:
-                if component_name == v.composed_name.split(";")[0].split("@")[1]:
-                    out_name = self.design_name + ":" + v.component_info["RefDes"]
-        else:
-            out_name = component_name
-        try:
-            self.oproject.SetActiveDesign(out_name)
-            self.__init__(projectname=self.project_name, designname=out_name)
-        except Exception:  # pragma: no cover
-            return False
-        return True
+        expression :
 
-    @pyaedt_function_handler()
-    def pop_up(self):
-        """Pop-up to parent Circuit design and reinitialize Circuit object.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
-        """
-        try:
-            parent_name = self.odesign.GetName().split(";")[1].split("/")[0]
-            self.oproject.SetActiveDesign(parent_name)
-            self.__init__(projectname=self.project_name, designname=parent_name)
-        except Exception:
-            return False
-        return True
-
-    @property
-    def post(self):
-        """PostProcessor.
-
-        Returns
-        -------
-        :class:`pyaedt.modules.AdvancedPostProcessing.CircuitPostProcessor`
-            PostProcessor object.
-        """
-        if self._post is None:
-            self.logger.reset_timer()
-            from pyaedt.modules.PostProcessor import CircuitPostProcessor
-
-            self._post = CircuitPostProcessor(self)
-            self.logger.info_timer("Post class has been initialized!")
-
-        return self._post
-
-    @property
-    def existing_analysis_sweeps(self):
-        """Analysis setups.
-
-        References
-        ----------
-
-        >>> oModule.GetAllSolutionSetups"""
-        return self.existing_analysis_setups
-
-    @property
-    def existing_analysis_setups(self):
-        """Analysis setups.
-
-        References
-        ----------
-
-        >>> oModule.GetAllSolutionSetups"""
-        setups = self.oanalysis.GetAllSolutionSetups()
-        return setups
-
-    @property
-    def nominal_sweep(self):
-        """Nominal sweep."""
-        if self.existing_analysis_setups:
-            return self.existing_analysis_setups[0]
-        else:
-            return ""
-
-    @property
-    def modeler(self):
-        """Modeler object."""
-        if self._modeler is None:
-            self.logger.reset_timer()
-            from pyaedt.modeler.schematic import ModelerNexxim
-
-            self._modeler = ModelerNexxim(self)
-            self.logger.info_timer("Modeler class has been initialized!")
-
-        return self._modeler
-
-    @property
-    def setup_names(self):
-        """Setup names.
-
-        References
-        ----------
-
-        >>> oModule.GetAllSolutionSetups"""
-        return self.oanalysis.GetAllSolutionSetups()
-
-    @property
-    def source_names(self):
-        """Get all source names.
-
-        Returns
-        -------
-        list
-            List of source names.
-
-        References
-        ----------
-
-        >>> oDesign.GetChildObject("Excitations").GetChildNames()
-        """
-        return list(self.odesign.GetChildObject("Excitations").GetChildNames())
-
-    @property
-    def source_objects(self):
-        """Get all source objects.
-
-        Returns
-        -------
-        list
-            List of source objects.
-        """
-        return [self.sources[name] for name in self.sources]
-
-    @property
-    def sources(self):
-        """Get all sources.
-
-        Returns
-        -------
-        List of :class:`pyaedt.modules.Boundary.Sources`
-            List of sources.
-
-        """
-        props = {}
-        if not self._internal_sources:
-            for source in self.source_names:
-                props[source] = Sources(self, source)
-                if props[source].source_type == "PowerSin":
-                    props[source] = PowerSinSource(self, source)
-                elif props[source].source_type == "PowerIQ":
-                    props[source] = PowerIQSource(self, source)
-                elif props[source].source_type == "VoltageFrequencyDependent":
-                    props[source] = VoltageFrequencyDependentSource(self, source)
-                elif props[source].source_type == "VoltageDC":
-                    props[source] = VoltageDCSource(self, source)
-                elif props[source].source_type == "VoltageSin":
-                    props[source] = VoltageSinSource(self, source)
-                elif props[source].source_type == "CurrentSin":
-                    props[source] = CurrentSinSource(self, source)
-            self._internal_sources = props
-        else:
-            props = self._internal_sources
-            if not sorted(list(props.keys())) == sorted(self.source_names):
-                a = set(str(x) for x in props.keys())
-                b = set(str(x) for x in self.source_names)
-                if len(a) == len(b):
-                    unmatched_new_name = list(b - a)[0]
-                    unmatched_old_name = list(a - b)[0]
-                    props[unmatched_new_name] = props[unmatched_old_name]
-                    del props[unmatched_old_name]
-                else:
-                    for old_source in props.keys():
-                        if old_source not in self.source_names:
-                            del props[old_source]
-                            break
-
-        return props
-
-    @property
-    def excitation_names(self):
-        """List of port names.
-
-        Returns
-        -------
-        list
-            List of excitation names.
 
         References
         ----------
 
-        >>> oModule.GetAllPorts
+        >>> oDesign.ChangeProperty
         """
-        ports = [p.replace("IPort@", "").split(";")[0] for p in self.modeler.oeditor.GetAllPorts() if "IPort@" in p]
-        return ports
-
-    @property
-    def excitation_objets(self):
-        """List of port objects.
-
-        Returns
-        -------
-        list
-            List of port objects.
-        """
-        return [self.excitations[name] for name in self.excitations]
-
-    @property
-    def excitations(self):
-        """Get all ports.
-
-        Returns
-        -------
-        list
-            List of ports.
-
-        """
-        props = {}
-        if not self._internal_excitations:
-            for port in self.excitation_names:
-                props[port] = Excitations(self, port)
-            self._internal_excitations = props
-        else:
-            props = self._internal_excitations
-            if not sorted(list(props.keys())) == sorted(self.excitation_names):
-                a = set(str(x) for x in props.keys())
-                b = set(str(x) for x in self.excitation_names)
-                if len(a) == len(b):
-                    unmatched_new_name = list(b - a)[0]
-                    unmatched_old_name = list(a - b)[0]
-                    props[unmatched_new_name] = props[unmatched_old_name]
-                    del props[unmatched_old_name]
-                else:
-                    if len(a) > len(b):
-                        for old_port in props.keys():
-                            if old_port not in self.excitation_names:
-                                del props[old_port]
-                                return props
-                    else:
-                        for new_port in self.excitation_names:
-                            if new_port not in props.keys():
-                                props[new_port] = Excitations(self, new_port)
-        return props
-
-    @property
-    def get_all_sparameter_list(self, excitation_names=[]):
-        """List of all S parameters for a list of excitations.
-
-        Parameters
-        ----------
-        excitation_names : list, optional
-            List of excitations. The default value is ``[]``, in which case
-            the S parameters for all excitations are to be provided.
-            For example, ``["1", "2"]``.
-
-        Returns
-        -------
-        list of str
-            List of strings representing the S parameters of the excitations.
-            For example, ``"S(1,1)", "S(1,2)", "S(2,2)"``.
-
-        """
-        if not excitation_names:
-            excitation_names = list(self.excitations.keys())
-        spar = []
-        k = 0
-        for i in excitation_names:
-            k = excitation_names.index(i)
-            while k < len(excitation_names):
-                spar.append("S({},{})".format(i, excitation_names[k]))
-                k += 1
-        return spar
+        self.set_sim_setup_parameter("Tend", expression)
+        return True
 
     @pyaedt_function_handler()
-    def get_all_return_loss_list(self, excitation_names=None, excitation_name_prefix=""):
-        """Retrieve a list of all return losses for a list of exctitations.
+    def set_hmin(self, expression):
+        """Set hmin.
 
         Parameters
         ----------
-        excitation_names : list, optional
-            List of excitations. The default is ``None``, in which case
-            the return losses for all excitations are to be provided.
-            For example ``["1", "2"]``.
-        excitation_name_prefix : string, optional
-             Prefix to add to the excitation names. The default is ``""``,
-
-        Returns
-        -------
-        list of str
-            List of strings representing the return losses of the excitations.
-            For example ``["S(1, 1)", S(2, 2)]``.
-
-        References
-        ----------
-
-        >>> oEditor.GetAllPorts
-        """
-        if excitation_names == None:
-            excitation_names = []
+        expression :
 
-        if not excitation_names:
-            excitation_names = list(self.excitations.keys())
-        if excitation_name_prefix:
-            excitation_names = [i for i in excitation_names if excitation_name_prefix.lower() in i.lower()]
-        spar = []
-        for i in excitation_names:
-            spar.append("S({},{})".format(i, i))
-        return spar
-
-    @pyaedt_function_handler()
-    def get_all_insertion_loss_list(self, trlist=None, reclist=None, tx_prefix="", rx_prefix=""):
-        """Retrieve a list of all insertion losses from two lists of excitations (driver and receiver).
-
-        Parameters
-        ----------
-        trlist : list, optional
-            List of drivers. The default is ``[]``. For example, ``["1"]``.
-        reclist : list, optional
-            List of receivers. The default is ``[]``. The number of drivers equals
-            the number of receivers. For example, ``["2"]``.
-        tx_prefix : str, optional
-            Prefix to add to driver names. For example, ``"DIE"``. The default is ``""``.
-        rx_prefix : str, optional
-            Prefix to add to receiver names. For example, ``"BGA"``. The default is ``""``.
 
         Returns
         -------
-        list of str
-            List of strings representing insertion losses of the excitations.
-            For example, ``["S(1,2)"]``.
+        bool
+            ``True`` when successful, ``False`` when failed.
 
         References
         ----------
 
-        >>> oEditor.GetAllPorts
+        >>> oDesign.ChangeProperty
         """
-        if trlist == None:
-            trlist = []
-        if reclist == None:
-            reclist = []
-
-        spar = []
-        if not trlist:
-            trlist = [i for i in list(self.excitations.keys()) if tx_prefix in i]
-        if not reclist:
-            reclist = [i for i in list(self.excitations.keys()) if rx_prefix in i]
-        if len(trlist) != len(reclist):
-            self.logger.error("The TX and RX lists should be the same length.")
-            return False
-        for i, j in zip(trlist, reclist):
-            spar.append("S({},{})".format(i, j))
-        return spar
+        self.set_sim_setup_parameter("Hmin", expression)
+        return True
 
     @pyaedt_function_handler()
-    def get_next_xtalk_list(self, trlist=[], tx_prefix=""):
-        """Retrieve a list of all the near end XTalks from a list of excitations (driver and receiver).
+    def set_hmax(self, expression):
+        """Set hmax.
 
         Parameters
         ----------
-        trlist : list, optional
-            List of drivers. The default is ``[]``. For example,
-            ``["1", "2", "3"]``.
-        tx_prefix : str, optional
-            Prefix to add to driver names. For example, ``"DIE"``.  The default is ``""``.
+        expression :
+
 
         Returns
         -------
-        list of str
-            List of strings representing near end XTalks of the excitations.
-            For example, ``["S(1, 2)", "S(1, 3)", "S(2, 3)"]``.
+        bool
+            ``True`` when successful, ``False`` when failed.
 
         References
         ----------
 
-        >>> oEditor.GetAllPorts
+        >>> oDesign.ChangeProperty
         """
-        next_xtalks = []
-        if not trlist:
-            trlist = [i for i in list(self.excitations.keys()) if tx_prefix in i]
-        for i in trlist:
-            k = trlist.index(i) + 1
-            while k < len(trlist):
-                next_xtalks.append("S({},{})".format(i, trlist[k]))
-                k += 1
-        return next_xtalks
+        self.set_sim_setup_parameter("Hmax", expression)
+        return True
 
     @pyaedt_function_handler()
-    def get_fext_xtalk_list(self, trlist=None, reclist=None, tx_prefix="", rx_prefix="", skip_same_index_couples=True):
-        """Retrieve a list of all the far end XTalks from two lists of exctitations (driver and receiver).
+    def set_sim_setup_parameter(self, var_str, expression, analysis_name="TR"):
+        """Set simulation setup parameters.
 
         Parameters
         ----------
-        trlist : list, optional
-            List of drivers. The default is ``[]``. For example,
-            ``["1", "2"]``.
-        reclist : list, optional
-            List of receiver. The default is ``[]``. For example,
-            ``["3", "4"]``.
-        tx_prefix : str, optional
-            Prefix for driver names. For example, ``"DIE"``.  The default is ``""``.
-        rx_prefix : str, optional
-            Prefix for receiver names. For examples, ``"BGA"`` The default is ``""``.
-        skip_same_index_couples : bool, optional
-            Whether to skip driver and receiver couples with the same index position.
-            The default is ``True``, in which case the drivers and receivers
-            with the same index position are considered insertion losses and
-            excluded from the list.
+        var_str : string
+            Name of the variable.
+        expression :
+
+        analysis_name : str, optional
+            Name of the analysis. The default is ``"TR"``.
 
         Returns
         -------
-        list of str
-            List of strings representing the far end XTalks of the excitations.
-            For example, ``["S(1, 4)", "S(2, 3)"]``.
+        bool
+            ``True`` when successful, ``False`` when failed.
 
         References
         ----------
 
-        >>> oEditor.GetAllPorts
+        >>> oDesign.ChangeProperty
         """
-        fext = []
-        if trlist is None:
-            trlist = [i for i in list(self.excitations.keys()) if tx_prefix in i]
-        if reclist is None:
-            reclist = [i for i in list(self.excitations.keys()) if rx_prefix in i]
-        for i in trlist:
-            for k in reclist:
-                if not skip_same_index_couples or reclist.index(k) != trlist.index(i):
-                    fext.append("S({},{})".format(i, k))
-        return fext
-
-    @pyaedt_function_handler()
-    def get_setup(self, setupname):
-        """Retrieve the setup from the current design.
-
-        Parameters
-        ----------
-        setupname : str
-            Name of the setup.
-
-        Returns
-        -------
-        type
-            Setup object.
+        if isinstance(expression, Variable):
+            value_str = expression.evaluated_value
+        # Handle input type int/float, etc (including numeric 0)
+        elif is_number(expression):
+            value_str = str(expression)
+        else:
+            value_str = expression
 
-        """
-        setup = SetupCircuit(self, self.solution_type, setupname, isnewsetup=False)
-        if setup.props:
-            self.active_setup = setupname
-        return setup
+        self._odesign.ChangeProperty(
+            [
+                "NAME:AllTabs",
+                [
+                    "NAME:BaseElementTab",
+                    ["NAME:PropServers", analysis_name],
+                    ["NAME:ChangedProps", ["NAME:" + var_str, "Value:=", value_str]],
+                ],
+            ]
+        )
+        return True
 
-    @pyaedt_function_handler()
-    def create_setup(self, setupname="MySetupAuto", setuptype=None, **kwargs):
-        """Create a setup.
+    @pyaedt_function_handler(setup_name="setup", sweep_name="sweep")
+    def add_q3d_dynamic_component(
+        self,
+        source_project,
+        source_design_name,
+        setup,
+        sweep,
+        coupling_matrix_name,
+        model_depth="1meter",
+        maximum_order=10000,
+        error_tolerance=0.005,
+        z_ref=50,
+        state_space_dynamic_link_type=None,
+        component_name=None,
+        save_project=True,
+    ):
+        """Add a Q2D or Q3D dynamic component to a Twin Builder design.
 
         Parameters
         ----------
-        setupname : str, optional
-            Name of the new setup. The default is ``"MySetupAuto"``.
-        setuptype : str, optional
-            Type of the setup. The default is ``None``, in which case
-            the default type is applied.
-        **kwargs : dict, optional
-            Extra arguments to set up the circuit.
-            Available keys depend on the setup chosen.
-            For more information, see
-            :doc:`../SetupTemplatesCircuit`.
-
+        source_project : str
+            Source project name or project path.
+        source_design_name : str
+            Source design name.
+        setup : str
+            Setup name.
+        sweep : str
+            Sweep name.
+        coupling_matrix_name : str
+            Coupling matrix name.
+        model_depth : str, optional
+            2D model depth specified as value with unit.
+            To be provided if design is Q2D.
+            The default value is ``1meter``
+        maximum_order : float, optional
+            The Maximum Order value specifies the highest order state space
+            system that you can choose while fitting to represent the system behavior.
+            A lower order may lead to less accuracy but faster simulation.
+            The default value is ``10000``.
+        error_tolerance : float, optional
+            Error Tolerance sets the error tolerance for S-Matrix fitting.
+            The default value is ``0.005``.
+        z_ref : float, optional
+            Sets the value of the Z (ref) in ohms.
+            The default value is ``50``.
+        state_space_dynamic_link_type : str, optional
+            Q3D state space dynamic link type.
+            Possible options are:
+                - ``S`` for S parameters link type.
+                - ``RLGC`` for RLGC Parameters link type.
+                - ``EQ`` for Equivalent Circuit.
+            The default value is ``RLGC``.
+        component_name : str, optional
+            Component name.
+            If not provided a generic name with prefix "SimpQ3DData" will be given.
+        save_project : bool, optional
+            Save project after use.
+            The default value is ``True``.
 
         Returns
         -------
-        :class:`pyaedt.modules.SolveSetup.SetupCircuit`
-            Setup object.
+        :class:`pyaedt.modeler.cad.object3dcircuit.CircuitComponent` or bool
+            Circuit component object if successful or ``False`` if fails.
 
         References
         ----------
 
-        >>> oModule.AddLinearNetworkAnalysis
-        >>> oModule.AddDCAnalysis
-        >>> oModule.AddTransient
-        >>> oModule.AddQuickEyeAnalysis
-        >>> oModule.AddVerifEyeAnalysis
-        >>> oModule.AddAMIAnalysis
-
+        >>> oComponentManager.AddDynamicNPortData
 
         Examples
         --------
 
-        >>> from pyaedt import Circuit
-        >>> app = Circuit()
-        >>> app.create_setup(setupname="Setup1", setuptype=app.SETUPS.NexximLNA, Data="LINC 0GHz 4GHz 501")
-        """
-        if setuptype is None:
-            setuptype = self.design_solutions.default_setup
-        elif setuptype in SetupKeys.SetupNames:
-            setuptype = SetupKeys.SetupNames.index(setuptype)
-        name = self.generate_unique_setup_name(setupname)
-        setup = SetupCircuit(self, setuptype, name)
-        tmp_setups = self.setups
-        setup.create()
-        setup.auto_update = False
-
-        if "props" in kwargs:
-            for el in kwargs["props"]:
-                setup.props[el] = kwargs["props"][el]
-        for arg_name, arg_value in kwargs.items():
-            if arg_name == "props":
-                continue
-            if setup[arg_name] is not None:
-                setup[arg_name] = arg_value
-        setup.auto_update = True
-        setup.update()
-        self._setups = tmp_setups + [setup]
-        return setup
+        Create an instance of Twin Builder.
+
+        >>> from pyaedt import TwinBuilder
+        >>> tb = TwinBuilder()
+
+        Add a Q2D dynamic link component.
+
+        >>> tb.add_q3d_dynamic_component("Q2D_ArmouredCableExample", "2D_Extractor_Cable", "MySetupAuto", "sweep1",
+        ...                              "Original","100mm")
+        >>> tb.release_desktop()
+        """
+        dkp = self.desktop_class
+        is_loaded = False
+        if os.path.isfile(source_project):
+            project_path = source_project
+            project_name = os.path.splitext(os.path.basename(source_project))[0]
+            if project_name in dkp.project_list():
+                app = dkp[[project_name, source_design_name]]
+            else:
+                app = dkp.load_project(project_path, source_design_name)
+                is_loaded = True
+        elif source_project in self.project_list:
+            project_name = source_project
+            project_path = os.path.join(self.project_path, project_name + ".aedt")
+            app = dkp[[source_project, source_design_name]]
+        else:
+            raise ValueError("Invalid project name or path provided.")
+        if app is None:  # pragma: no cover
+            raise ValueError("Invalid project or design name.")
+        setup_name = setup
+        setup = [s for s in app.setups if s.name == setup_name]
+        if not setup:
+            raise ValueError("Invalid setup in selected design.")
+        else:
+            sweeps = [s for s in app.get_sweeps(setup_name) if s == sweep]
+            if sweeps:  # pragma: no cover
+                coupling_solution_name = "{} : {}".format(setup_name, sweep)
+            else:  # pragma: no cover
+                raise ValueError("Invalid sweep name.")
+        if not [m for m in app.matrices if m.name == coupling_matrix_name]:
+            raise ValueError("Invalid matrix name.")
+        if not component_name:
+            component_name = generate_unique_name("SimpQ3DData")
+        var = app.available_variations.nominal_w_values_dict
+        props = ["NAME:Properties"]
+        for k, v in var.items():
+            props.append("paramProp:=")
+            props.append([k, v])
+        port_info_list_A = []
+        port_info_list_B = []
+        # check design_type if Q2D
+        if app.design_type == "2D Extractor":
+            props.append("paramProp:=")
+            props.append(["COMPONENT_DEPTH", model_depth])
+            is_3d = False
+            is_depth_needed = True
+            value, unit = decompose_variable_value(model_depth)
+            if not is_number(value) and not unit:
+                raise TypeError("Model depth must be provided as a string with value and unit.")
+            design_type = "Q2D"
+            signal_list = [k for k, v in app.excitation_objects.items() if v.type == "SignalLine"]
+            for signal in signal_list:
+                port_info_list_A.append("OnePortInfo:=")
+                port_info_list_B.append("OnePortInfo:=")
+                list_A = [signal + "_" + signal + "_A", -1, signal + ":" + signal + "_A"]
+                list_B = [signal + "_" + signal + "_B", -1, signal + ":" + signal + "_B"]
+                port_info_list_A.append(list_A)
+                port_info_list_B.append(list_B)
+        else:
+            is_3d = True
+            design_type = "Q3D"
+            is_depth_needed = False
+            for net in app.nets:
+                sources = app.net_sources(net)
+                sinks = app.net_sinks(net)
+                if sources:
+                    for source in sources:
+                        port_info_list_A.append("OnePortInfo:=")
+                        port_info_list_A.append([net + "_" + source, -1, net + ":" + source])
+                else:
+                    port_info_list_A.append("OnePortInfo:=")
+                    port_info_list_A.append([net + "_", -1, net + ":"])
+                if sinks:
+                    for sink in sinks:
+                        port_info_list_B.append("OnePortInfo:=")
+                        port_info_list_B.append([net + "_" + sink, -1, net + ":" + sink])
+                else:
+                    port_info_list_B.append("OnePortInfo:=")
+                    port_info_list_B.append([net + "_", -1, net + ":"])
+        if port_info_list_A and port_info_list_B:
+            port_info_list = ["NAME:PortInfo"]
+            port_info_list.extend(port_info_list_A)
+            port_info_list.extend(port_info_list_B)
+        if not state_space_dynamic_link_type or state_space_dynamic_link_type == "RLGC":
+            if dkp.aedt_version_id >= "2024.1":
+                state_space_dynamic_link_type = "Q3DRLGCLink"
+            else:  # pragma: no cover
+                state_space_dynamic_link_type = "{}RLGCTBLink".format(design_type)
+            q3d_model_type = 1
+            ref_pin_style = 5
+            enforce_passivity = False
+            maximum_order = ""
+        elif state_space_dynamic_link_type == "S":
+            state_space_dynamic_link_type = "{}SParamLink".format(design_type)
+            q3d_model_type = 1
+            ref_pin_style = 3
+            enforce_passivity = True
+        elif state_space_dynamic_link_type == "EQ":
+            state_space_dynamic_link_type = "{}SmlLink".format(design_type)
+            q3d_model_type = 0
+            ref_pin_style = 3
+            enforce_passivity = True
+        else:
+            raise TypeError("Link type is not valid.")
+        self.o_component_manager.AddDynamicNPortData(
+            [
+                "NAME:ComponentData",
+                "ComponentDataType:=",
+                "SimpQ3DData",
+                "name:=",
+                component_name,
+                "filename:=",
+                project_path,
+                "numberofports:=",
+                2 * len(app.excitations),
+                "Is3D:=",
+                is_3d,
+                "IsWBLink:=",
+                False,
+                "WBSystemId:=",
+                "",
+                "CouplingDesignName:=",
+                source_design_name,
+                "CouplingSolutionName:=",
+                coupling_solution_name,
+                "CouplingMatrixName:=",
+                coupling_matrix_name,
+                "SaveProject:=",
+                save_project,
+                "CloseProject:=",
+                False,
+                "StaticLink:=",
+                False,
+                "CouplingType:=",
+                state_space_dynamic_link_type,
+                "VariationKey:=",
+                "",
+                "NewToOldMap:=",
+                [],
+                "OldToNewMap:=",
+                [],
+                "ModelText:=",
+                "",
+                "SolvedVariationKey:=",
+                "",
+                "EnforcePassivity:=",
+                enforce_passivity,
+                "MaxNumPoles:=",
+                str(maximum_order),
+                "ErrTol:=",
+                str(error_tolerance),
+                "SSZref:=",
+                "{}ohm".format(z_ref),
+                "IsDepthNeeded:=",
+                is_depth_needed,
+                "Mw2DDepth:=",
+                model_depth,
+                "IsScaleNeeded:=",
+                False,
+                "MwScale:=",
+                "1",
+                "RefPinStyle:=",
+                ref_pin_style,
+                "Q3DModelType:=",
+                q3d_model_type,
+                "SaveDataSSOptions:=",
+                "",
+                props,
+                port_info_list,
+            ]
+        )
+
+        component = self.modeler.schematic.create_component(component_library="", component_name=component_name)
+        if component:
+            if is_loaded:
+                app.close_project(save_project=False)
+            return component
+        else:  # pragma: no cover
+            raise ValueError("Error in creating the component.")
```

### Comparing `pyaedt-0.8.7/pyaedt/application/AnalysisRMxprt.py` & `pyaedt-0.8.8/pyaedt/application/AnalysisRMxprt.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/application/AnalysisTwinBuilder.py` & `pyaedt-0.8.8/pyaedt/application/AnalysisTwinBuilder.py`

 * *Files 4% similar despite different names*

```diff
@@ -116,42 +116,42 @@
             from pyaedt.modules.PostProcessor import CircuitPostProcessor
 
             self._post = CircuitPostProcessor(self)
             self.logger.info_timer("Post class has been initialized!")
 
         return self._post
 
-    @pyaedt_function_handler()
-    def create_setup(self, setupname="MySetupAuto", setuptype=None, **kwargs):
+    @pyaedt_function_handler(setupname="name", setuptype="setup_type")
+    def create_setup(self, name="MySetupAuto", setup_type=None, **kwargs):
         """Create a setup.
 
         Parameters
         ----------
-        setupname : str, optional
+        name : str, optional
             Name of the setup. The default is ``"MySetupAuto"``.
-        setuptype : str
+        setup_type : str
             Type of the setup. The default is ``None``, in which case the default
             type is applied.
         **kwargs : dict, optional
             Extra arguments to set up the circuit.
             Available keys depend on the setup chosen.
             For more information, see
             :doc:`../SetupTemplatesCircuit`.
 
         Returns
         -------
         :class:`pyaedt.modules.SolveSetup.SetupCircuit`
             Setup object.
         """
-        if setuptype is None:
-            setuptype = self.design_solutions.default_setup
-        elif setuptype in SetupKeys.SetupNames:
-            setuptype = SetupKeys.SetupNames.index(setuptype)
-        name = self.generate_unique_setup_name(setupname)
-        setup = SetupCircuit(self, setuptype, name)
+        if setup_type is None:
+            setup_type = self.design_solutions.default_setup
+        elif setup_type in SetupKeys.SetupNames:
+            setup_type = SetupKeys.SetupNames.index(setup_type)
+        name = self.generate_unique_setup_name(name)
+        setup = SetupCircuit(self, setup_type, name)
         tmp_setups = self.setups
         setup.create()
         setup.auto_update = False
 
         if "props" in kwargs:
             for el in kwargs["props"]:
                 setup.props[el] = kwargs["props"][el]
```

### Comparing `pyaedt-0.8.7/pyaedt/application/Design.py` & `pyaedt-0.8.8/pyaedt/application/Design.py`

 * *Files 1% similar despite different names*

```diff
@@ -319,14 +319,22 @@
         elif "Boundaries" in self.get_oo_name(self.odesign):
             bb = self.get_oo_name(self.odesign, "Boundaries")
         if "GetHybridRegions" in self.oboundary.__dir__():
             hybrid_regions = self.oboundary.GetHybridRegions()
             for region in hybrid_regions:
                 bb.append(region)
                 bb.append("FE-BI")
+        current_excitations = []
+        current_excitation_types = []
+        if "GetExcitations" in self.oboundary.__dir__():
+            ee = list(self.oboundary.GetExcitations())
+            current_excitations = [i.split(":")[0] for i in ee[::2]]
+            current_excitation_types = ee[1::2]
+            ff = [i.split(":")[0] for i in ee]
+            bb.extend(ff)
 
         # Parameters and Motion definitions
         if self.design_type in ["Maxwell 3D", "Maxwell 2D"]:
             maxwell_parameters = list(self.get_oo_name(self.odesign, "Parameters"))
             for parameter in maxwell_parameters:
                 bb.append(parameter)
                 bb.append("MaxwellParameters")
@@ -356,15 +364,20 @@
                             ):
                                 boundarytype = thermal_boundaries[component_boundary]["BoundType"]
                                 bb.append(component_boundary)
                                 bb.append(boundarytype)
 
         current_boundaries = bb[::2]
         current_types = bb[1::2]
-
+        check_boundaries = list(current_boundaries[:]) + list(self.ports[:]) + self.excitations[:]
+        if "nets" in dir(self):
+            check_boundaries += self.nets
+        for k in list(self._boundaries.keys())[:]:
+            if k not in check_boundaries:
+                del self._boundaries[k]
         for boundary, boundarytype in zip(current_boundaries, current_types):
             if boundary in self._boundaries:
                 continue
             if boundarytype == "MaxwellParameters":
                 maxwell_parameter_type = self.get_oo_property_value(
                     self.odesign, "Parameters\\{}".format(boundary), "Type"
                 )
@@ -374,20 +387,20 @@
                 maxwell_motion_type = self.get_oo_property_value(self.odesign, "Model\\{}".format(boundary), "Type")
 
                 self._boundaries[boundary] = BoundaryObject(self, boundary, boundarytype=maxwell_motion_type)
             elif boundarytype == "Network":
                 self._boundaries[boundary] = NetworkObject(self, boundary)
             else:
                 self._boundaries[boundary] = BoundaryObject(self, boundary, boundarytype=boundarytype)
-
-        excitations = self.design_excitations
-        for exc in excitations:
-            if not self._boundaries or exc.name not in list(self._boundaries.keys()):
-                self._boundaries[exc.name] = exc
-
+        try:
+            for k, v in zip(current_excitations, current_excitation_types):
+                if k not in self._boundaries:
+                    self._boundaries[k] = BoundaryObject(self, k, boundarytype=v)
+        except Exception:
+            pass
         return list(self._boundaries.values())
 
     @property
     def boundaries_by_type(self):
         """Design boundaries by type.
 
         Returns
@@ -399,79 +412,38 @@
             if bound.type in _dict_out:
                 _dict_out[bound.type].append(bound)
             else:
                 _dict_out[bound.type] = [bound]
         return _dict_out
 
     @property
-    def excitations_by_type(self):
-        """Design excitations by type.
-
-        Returns
-        -------
-        dict
-            Dictionary of excitations.
-        """
-        _dict_out = {}
-        for bound in self.design_excitations:
-            if bound.type in _dict_out:
-                _dict_out[bound.type].append(bound)
-            else:
-                _dict_out[bound.type] = [bound]
-        return _dict_out
-
-    @property
-    def design_excitations(self):
+    def ports(self):
         """Design excitations.
 
         Returns
         -------
         list
-            List of :class:`pyaedt.modules.Boundary.BoundaryObject`.
+            Port names.
         """
-        design_excitations = {}
+        design_excitations = []
 
         if "GetExcitations" in self.oboundary.__dir__():
             ee = list(self.oboundary.GetExcitations())
-            current_boundaries = [i.split(":")[0] for i in ee[::2]]
             current_types = ee[1::2]
             for i in set(current_types):
                 new_port = []
                 if "GetExcitationsOfType" in self.oboundary.__dir__():
                     new_port = list(self.oboundary.GetExcitationsOfType(i))
                 if new_port:
-                    current_boundaries = current_boundaries + new_port
+                    design_excitations += new_port
                     current_types = current_types + [i] * len(new_port)
-
-            for boundary, boundarytype in zip(current_boundaries, current_types):
-                design_excitations[boundary] = BoundaryObject(self, boundary, boundarytype=boundarytype)
-                if (
-                    design_excitations[boundary].object_properties
-                    and design_excitations[boundary].object_properties.props["Type"] == "Terminal"
-                ):  # pragma: no cover
-                    props_terminal = OrderedDict()
-                    props_terminal["TerminalResistance"] = design_excitations[boundary].object_properties.props[
-                        "Terminal Renormalizing Impedance"
-                    ]
-                    props_terminal["ParentBndID"] = design_excitations[boundary].object_properties.props["Port Name"]
-                    design_excitations[boundary] = BoundaryObject(
-                        self, boundary, props=props_terminal, boundarytype="Terminal"
-                    )
+            return design_excitations
 
         elif "GetAllPortsList" in self.oboundary.__dir__() and self.design_type in ["HFSS 3D Layout Design"]:
-            for port in self.oboundary.GetAllPortsList():
-                if port in self._boundaries:
-                    continue
-                bound = self._update_port_info(port)
-                if bound:
-                    design_excitations[port] = bound
-
-        if design_excitations:
-            return list(design_excitations.values())
-
+            return self.oboundary.GetAllPortsList()
         return []
 
     @property
     def odesktop(self):
         """AEDT instance containing all projects and designs.
 
         Examples
@@ -536,16 +508,15 @@
             settings._project_properties[os.path.normpath(self.project_file)] = load_entire_aedt_file(self.project_file)
             self._logger.info("aedt file load time {}".format(time.time() - start))
         elif (
             os.path.normpath(self.project_file) not in settings._project_properties
             and settings.remote_rpc_session
             and settings.remote_rpc_session.filemanager.pathexists(self.project_file)
         ):
-            local_path = os.path.join(settings.remote_rpc_session_temp_folder, os.path.split(self.project_file)[-1])
-            file_path = check_and_download_file(local_path, self.project_file)
+            file_path = check_and_download_file(self.project_file)
             try:
                 settings._project_properties[os.path.normpath(self.project_file)] = load_entire_aedt_file(file_path)
             except Exception:
                 pass
             self._logger.info("aedt file load time {}".format(time.time() - start))
         if os.path.normpath(self.project_file) in settings._project_properties:
             return settings._project_properties[os.path.normpath(self.project_file)]
@@ -628,24 +599,29 @@
             return name
 
     @design_name.setter
     def design_name(self, new_name):
         if ";" in new_name:
             new_name = new_name.split(";")[1]
 
-        self.odesign.RenameDesignInstance(self.design_name, new_name)
-        timeout = 5.0
-        timestep = 0.1
-        while new_name not in [
-            i.GetName() if ";" not in i.GetName() else i.GetName().split(";")[1]
-            for i in list(self._oproject.GetDesigns())
-        ]:
-            time.sleep(timestep)
-            timeout -= timestep
-            assert timeout >= 0
+        # If new_name is the name of an existing design, set the current
+        # design to this design.
+        if new_name in self.design_list:
+            self.set_active_design(new_name)
+        else:  # Otherwise rename the current design.
+            self.odesign.RenameDesignInstance(self.design_name, new_name)
+            timeout = 5.0
+            timestep = 0.1
+            while new_name not in [
+                i.GetName() if ";" not in i.GetName() else i.GetName().split(";")[1]
+                for i in list(self._oproject.GetDesigns())
+            ]:
+                time.sleep(timestep)
+                timeout -= timestep
+                assert timeout >= 0
 
     @property
     def design_list(self):
         """Design list.
 
         Returns
         -------
@@ -1562,15 +1538,15 @@
         -------
         str
             String concatenating the value and unit.
 
         """
         if units is None:
             units = self.modeler.model_units
-        if type(value) is str:
+        if isinstance(value, str):
             try:
                 float(value)
                 val = "{0}{1}".format(value, units)
             except Exception:
                 val = value
         else:
             val = "{0}{1}".format(value, units)
@@ -3303,14 +3279,16 @@
         elif design_type == "Icepak":
             new_design = self._oproject.InsertDesign("Icepak", unique_design_name, "SteadyState TemperatureAndFlow", "")
         elif design_type == "Circuit Design":
             new_design = self._oproject.InsertDesign(design_type, unique_design_name, "None", "")
         else:
             if design_type == "HFSS" and self._aedt_version < "2021.2":
                 new_design = self._oproject.InsertDesign(design_type, unique_design_name, "DrivenModal", "")
+            elif design_type == "HFSS" and self._aedt_version < "2024.1":
+                new_design = self._oproject.InsertDesign(design_type, unique_design_name, "HFSS Modal Network", "")
             else:
                 new_design = self._oproject.InsertDesign(
                     design_type, unique_design_name, self.default_solution_type, ""
                 )
         if new_design is None:  # pragma: no cover
             new_design = self.oproject.SetActiveDesign(unique_design_name)
             if new_design is None:
```

### Comparing `pyaedt-0.8.7/pyaedt/application/JobManager.py` & `pyaedt-0.8.8/pyaedt/application/JobManager.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/application/Variables.py` & `pyaedt-0.8.8/pyaedt/application/Variables.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/application/aedt_objects.py` & `pyaedt-0.8.8/pyaedt/application/aedt_objects.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/application/design_solutions.py` & `pyaedt-0.8.8/pyaedt/application/design_solutions.py`

 * *Files 0% similar despite different names*

```diff
@@ -6,15 +6,15 @@
     "Maxwell 2D": "Magnetostatic",
     "Maxwell 3D": "Magnetostatic",
     "Twin Builder": "TR",
     "Circuit Design": "NexximLNA",
     "Maxwell Circuit": "",
     "2D Extractor": "Open",
     "Q3D Extractor": "Q3D Extractor",
-    "HFSS": "HFSS Modal Network",
+    "HFSS": "HFSS Terminal Network",
     "Icepak": "SteadyState",
     "RMxprtSolution": "GRM",
     "ModelCreation": "GRM",
     "HFSS 3D Layout Design": "HFSS3DLayout",
     "Mechanical": "Thermal",
     "EMIT": "EMIT",
 }
@@ -757,35 +757,35 @@
         else:
             self._solution_options[self.solution_type]["name"] = self._solution_options[self.solution_type][
                 "name"
             ].replace("Composite", "Network")
         self._composite = val
         self.solution_type = self.solution_type
 
-    @pyaedt_function_handler()
-    def set_auto_open(self, enable=True, boundary_type="Radiation"):
-        """Set Hfss auto open type.
+    @pyaedt_function_handler(boundary_type="opening_type")
+    def set_auto_open(self, enable=True, opening_type="Radiation"):
+        """Set HFSS auto open type.
 
         Parameters
         ----------
         enable : bool, optional
-            Either to enable or not auto open. The default is ``True``.
-        boundary_type : str, optional
-            Boundary Type to be used with auto open. Default is `"Radiation"`.
+            Whether to enable auto open. The default is ``True``.
+        opening_type : str, optional
+            Boundary type to use with auto open. The default is `"Radiation"`.
 
         Returns
         -------
         bool
         """
         if self._aedt_version < "2021.2":
             return False
         options = ["NAME:Options", "EnableAutoOpen:=", enable]
         if enable:
             options.append("BoundaryType:=")
-            options.append(boundary_type)
+            options.append(opening_type)
         self._solution_options[self.solution_type]["options"] = options
         self.solution_type = self.solution_type
         return True
 
 
 class Maxwell2DDesignSolution(DesignSolution, object):
     def __init__(self, odesign, design_type, aedt_version):
```

### Comparing `pyaedt-0.8.7/pyaedt/circuit.py` & `pyaedt-0.8.8/pyaedt/circuit.py`

 * *Files 11% similar despite different names*

```diff
@@ -7,31 +7,33 @@
 import math
 import os
 import re
 import shutil
 
 from pyaedt import Hfss3dLayout
 from pyaedt.application.AnalysisNexxim import FieldAnalysisCircuit
+from pyaedt.application.analysis_hf import ScatteringMethods
 from pyaedt.generic import ibis_reader
 from pyaedt.generic.DataHandlers import from_rkm_to_aedt
+from pyaedt.generic.constants import unit_converter
 from pyaedt.generic.filesystem import search_files
 from pyaedt.generic.general_methods import generate_unique_name
 from pyaedt.generic.general_methods import open_file
 from pyaedt.generic.general_methods import pyaedt_function_handler
 from pyaedt.modules.Boundary import CurrentSinSource
 from pyaedt.modules.Boundary import PowerIQSource
 from pyaedt.modules.Boundary import PowerSinSource
 from pyaedt.modules.Boundary import Sources
 from pyaedt.modules.Boundary import VoltageDCSource
 from pyaedt.modules.Boundary import VoltageFrequencyDependentSource
 from pyaedt.modules.Boundary import VoltageSinSource
 from pyaedt.modules.CircuitTemplates import SourceKeys
 
 
-class Circuit(FieldAnalysisCircuit, object):
+class Circuit(FieldAnalysisCircuit, ScatteringMethods):
     """Provides the Circuit application interface.
 
     Parameters
     ----------
     projectname : str, optional
         Name of the project to select or the full path to the project
         or AEDTZ archive to open.  The default is ``None``, in which
@@ -144,15 +146,15 @@
             new_desktop_session,
             close_on_exit,
             student_version,
             machine,
             port,
             aedt_process_id,
         )
-
+        ScatteringMethods.__init__(self, self)
         self.onetwork_data_explorer = self._desktop.GetTool("NdExplorer")
 
     def _init_from_design(self, *args, **kwargs):
         self.__init__(*args, **kwargs)
 
     def _get_number_from_string(self, stringval):
         value = stringval[stringval.find("=") + 1 :].strip().replace("{", "").replace("}", "").replace(",", ".")
@@ -800,59 +802,19 @@
             "NoiseModelOption:=",
             "External",
         ]
         self.odesign.ImportData(arg, "", True)
         self.logger.info("Touchstone file was correctly imported into %s", self.design_name)
         return portnames
 
-    @pyaedt_function_handler()
-    def export_touchstone(
-        self, setup_name=None, sweep_name=None, file_name=None, variations=None, variations_value=None
-    ):
-        """Export the Touchstone file to a local folder.
-
-        Parameters
-        ----------
-        setup_name : str, optional
-            Name of the setup that has been solved.
-        sweep_name : str, optional
-            Name of the sweep that has been solved.
-        file_name : str, optional
-            Full path and name for the Touchstone file.
-            The default is ``None``, in which case the file is exported to the working directory.
-        variations : list, optional
-            List of all parameter variations. For example, ``["$AmbientTemp", "$PowerIn"]``.
-            The default is ``None``.
-        variations_value : list, optional
-            List of all parameter variation values. For example, ``["22cel", "100"]``.
-            The default is ``None``.
-
-        Returns
-        -------
-        str
-            File name when successful, ``False`` when failed.
-
-        References
-        ----------
-
-        >>> oDesign.ExportNetworkData
-        """
-        return self._export_touchstone(
-            setup_name=setup_name,
-            sweep_name=sweep_name,
-            file_name=file_name,
-            variations=variations,
-            variations_value=variations_value,
-        )
-
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(designname="design", setupname="setup")
     def export_fullwave_spice(
         self,
-        designname=None,
-        setupname=None,
+        design=None,
+        setup=None,
         is_solution_file=False,
         filename=None,
         passivity=False,
         causality=False,
         renormalize=False,
         impedance=50,
         error=0.5,
@@ -862,18 +824,18 @@
         Export a full wave HSpice file using NDE.
 
         .. warning::
           This method doesn't work.
 
         Parameters
         ----------
-        designname : str, optional
+        design : str, optional
             Name of the design or the full path to the solution file if it is an imported file.
             The default is ``None``.
-        setupname : str, optional
+        setup : str, optional
             Name of the setup if it is a design. The default is ``None``.
         is_solution_file : bool, optional
             Whether it is an imported solution file. The default is ``False``.
         filename : str, optional
             Full path and name for exporting the HSpice file.
             The default is ``None``, in which case the file is exported to the working directory.
         passivity : bool, optional
@@ -896,28 +858,28 @@
             Name of the HSpice file if the export is successful.
 
         References
         ----------
 
         >>> oDesign.ExportFullWaveSpice
         """
-        if not designname:
-            designname = self.design_name
+        if not design:
+            design = self.design_name
         if not filename:
             filename = os.path.join(self.working_directory, self.design_name + ".sp")
         if is_solution_file:
-            setupname = designname
-            designname = ""
+            setup = design
+            design = ""
         else:
-            if not setupname:
-                setupname = self.nominal_sweep
+            if not setup:
+                setup = self.nominal_sweep
         self.onetwork_data_explorer.ExportFullWaveSpice(
-            designname,
+            design,
             is_solution_file,
-            setupname,
+            setup,
             "",
             [],
             [
                 "NAME:SpiceData",
                 "SpiceType:=",
                 "HSpice",
                 "EnforcePassivity:=",
@@ -1015,53 +977,18 @@
         if variation_dict:
             for el in variation_dict:
                 variations[el] = [variation_dict[el]]
         dif = None
         if differential_pairs:
             dif = "Differential Pairs"
         return self.post.create_report(
-            curvenames, solution_name, variations=variations, plotname=plot_name, context=dif, subdesign_id=subdesign_id
+            curvenames, solution_name, variations=variations, context=dif, subdesign_id=subdesign_id
         )
 
     @pyaedt_function_handler()
-    def get_touchstone_data(self, setup_name=None, variation_dict=None):
-        """
-        Return a Touchstone data plot.
-
-        Parameters
-        ----------
-        setup_name : str, optional
-            Name of the solution. The default value is ``None``.
-        variation_dict : dict, optional
-            Dictionary of variation names. The default value is ``None``.
-
-        Returns
-        -------
-        :class:`pyaedt.generic.touchstone_parser.TouchstoneData`
-           Class containing all requested data.
-
-        References
-        ----------
-
-        >>> oModule.GetSolutionDataPerVariation
-        """
-        from pyaedt.generic.touchstone_parser import TouchstoneData
-
-        if not setup_name:
-            setup_name = self.existing_analysis_sweeps[0]
-
-        s_parameters = []
-        expression = self.get_traces_for_plot(category="S")
-        sol_data = self.post.get_solution_data(expression, setup_name, variations=variation_dict)
-        for i in range(sol_data.number_of_variations):
-            sol_data.set_active_variation(i)
-            s_parameters.append(TouchstoneData(solution_data=sol_data))
-        return s_parameters
-
-    @pyaedt_function_handler()
     def push_excitations(self, instance_name, thevenin_calculation=False, setup_name="LinearFrequency"):
         """Push excitations for a linear frequency setup.
 
         Parameters
         ----------
         instance_name : str
             Name of the instance.
@@ -1233,16 +1160,16 @@
         ----------
 
         >>> oDesign.UpdateSources
         """
 
         source_v = self.create_source(source_type="VoltageSin")
         for port in ports:
-            self.excitations[port].enabled_sources.append(source_v.name)
-            self.excitations[port].update()
+            self.excitation_objects[port].enabled_sources.append(source_v.name)
+            self.excitation_objects[port].update()
         return source_v
 
     @pyaedt_function_handler()
     def assign_current_sinusoidal_excitation_to_ports(self, ports):
         """Assign a current sinusoidal excitation to circuit ports.
 
         Parameters
@@ -1258,16 +1185,16 @@
         References
         ----------
 
         >>> oDesign.UpdateSources
         """
         source_i = self.create_source(source_type="CurrentSin")
         for port in ports:
-            self.excitations[port].enabled_sources.append(source_i.name)
-            self.excitations[port].update()
+            self.excitation_objects[port].enabled_sources.append(source_i.name)
+            self.excitation_objects[port].update()
         return source_i
 
     @pyaedt_function_handler()
     def assign_power_sinusoidal_excitation_to_ports(self, ports):
         """Assign a power sinusoidal excitation to circuit ports.
 
         Parameters
@@ -1283,16 +1210,16 @@
         References
         ----------
 
         >>> oDesign.UpdateSources
         """
         source_p = self.create_source(source_type="PowerSin")
         for port in ports:
-            self.excitations[port].enabled_sources.append(source_p.name)
-            self.excitations[port].update()
+            self.excitation_objects[port].enabled_sources.append(source_p.name)
+            self.excitation_objects[port].update()
         return source_p
 
     @pyaedt_function_handler()
     def assign_voltage_frequency_dependent_excitation_to_ports(self, ports, filepath):
         """Assign a frequency dependent excitation to circuit ports from a frequency dependent source (.fds format).
 
         Parameters
@@ -1312,23 +1239,23 @@
 
         >>> oDesign.UpdateSources
         """
         if not os.path.exists(filepath) or os.path.splitext(filepath)[1] != ".fds":
             self.logger.error("Introduced file is not correct. Check path and format.")
             return False
 
-        if not all(elem in self.excitation_names for elem in ports):
+        if not all(elem in self.excitations for elem in ports):
             self.logger.error("Defined ports do not exist")
             return False
 
         source_freq = self.create_source(source_type="VoltageFrequencyDependent")
         source_freq.fds_filename = filepath
         for port in ports:
-            self.excitations[port].enabled_sources.append(source_freq.name)
-            self.excitations[port].update()
+            self.excitation_objects[port].enabled_sources.append(source_freq.name)
+            self.excitation_objects[port].update()
         return source_freq
 
     @pyaedt_function_handler()
     def set_differential_pair(
         self,
         positive_terminal,
         negative_terminal,
@@ -1437,15 +1364,15 @@
             return False
         return True
 
     @pyaedt_function_handler()
     def load_diff_pairs_from_file(self, filename):
         """Load differtential pairs definition from a file.
 
-        You can use the the ``save_diff_pairs_to_file`` method to obtain the file format.
+        You can use the ``save_diff_pairs_to_file`` method to obtain the file format.
         New definitions are added only if they are compatible with the existing definitions in the project.
 
         Parameters
         ----------
         filename : str
             Full qualified name of the file containing the differential pairs definition.
 
@@ -1683,7 +1610,418 @@
         active_project = hfss.odesktop.SetActiveProject(hfss.project_name)
         active_project.CopyDesign(hfss.design_name)
         active_project = self.odesktop.SetActiveProject(self.project_name)
         active_project.Paste()
         hfss_3d_layout_model = self.modeler.schematic.add_subcircuit_3dlayout(hfss.design_name)
         hfss.close_project(save_project=False)
         return hfss_3d_layout_model
+
+    @pyaedt_function_handler()
+    def create_tdr_schematic_from_snp(
+        self,
+        touchstone,
+        probe_pins,
+        probe_ref_pins=None,
+        termination_pins=None,
+        differential=True,
+        rise_time=30,
+        use_convolution=True,
+        analyze=True,
+        design_name="LNA",
+    ):
+        """Create a schematic from a Touchstone file and automatically setup a TDR transient analysis.
+
+        Parameters
+        ----------
+        touchstone : str
+            Full path to the sNp file.
+        probe_pins : list
+            Pins to attach to the probe components.
+        probe_ref_pins : list, optional
+            Reference pins to attach to probe components. The default is ``None``.
+            This parameter is valid only in differential TDR probes.
+        termination_pins : list, optional
+            Pins to terminate. The default is ``None``.
+        differential : bool, optional
+            Whether the buffers are differential. The default is ``True``. If ``False``, the
+            pins are single ended.
+        rise_time : float, int, optional
+            Rise time of the input pulse in picoseconds. The default is ``30``.
+        use_convolution : bool, optional
+            Whether to use convolution for the Touchstone file. The default is ``True``.
+            If ``False``, state-space is used.
+        analyze : bool
+             Whether to automatically assign differential pairs. The default is ``False``.
+        design_name : str, optional
+            New schematic name. The default is ``"LNA"``.
+
+        Returns
+        -------
+
+        """
+        if design_name in self.design_list:
+            self.logger.warning("Design already exists. renaming.")
+            design_name = generate_unique_name(design_name)
+        self.insert_design(design_name)
+        if isinstance(touchstone, type(Hfss3dLayout)):
+            touchstone_path = touchstone.export_touchstone()
+        else:
+            touchstone_path = touchstone
+
+        sub = self.modeler.components.create_touchstone_component(touchstone_path)
+        center_x = sub.location[0]
+        center_y = sub.location[1]
+        left = 0
+        delta_y = -1 * sub.location[1] - 2000 - 50 * len(probe_pins)
+        if differential:
+            tdr_probe = self.modeler.components.components_catalog["TDR_Differential_Ended"]
+        else:
+            tdr_probe = self.modeler.components.components_catalog["TDR_Single_Ended"]
+        tdr_probe_names = []
+        for i, probe_pin in enumerate(probe_pins):
+            pos_y = unit_converter(delta_y - left * 1000, input_units="mil", output_units=self.modeler.schematic_units)
+            left += 1
+            new_tdr_comp = tdr_probe.place("Tdr_probe", [center_x, center_y + pos_y], angle=-90)
+            try:
+                if isinstance(probe_pin, int):
+                    p_pin = probe_pin
+                    if differential:
+                        n_pin = probe_ref_pins[i]
+                else:
+                    p_pin = [k for k in sub.pins if k.name == probe_pin][0]
+                    if differential:
+                        n_pin = [k for k in sub.pins if k.name == probe_ref_pins[i]][0]
+            except IndexError:
+                self.logger.error("Failed to retrieve the pins.")
+                return False
+            for pin in sub.pins:
+                if not termination_pins or (pin.name in termination_pins):
+                    loc = pin.location
+                    loc1 = unit_converter(1500, input_units="mil", output_units=self.modeler.schematic_units)
+                    if loc[0] < center_x:
+                        p1 = self.modeler.components.create_interface_port(
+                            name=pin.name, location=[loc[0] - loc1, loc[1]]
+                        )
+                    else:
+                        p1 = self.modeler.components.create_interface_port(
+                            name=pin.name, location=[loc[0] + loc1, loc[1]]
+                        )
+                    p1.pins[0].connect_to_component(pin, use_wire=True)
+
+            _, first, second = new_tdr_comp.pins[0].connect_to_component(p_pin)
+            self.modeler.move(first, [0, 100], "mil")
+            if second.pins[0].location[0] > center_x:
+                self.modeler.move(second, [1000, 0], "mil")
+            else:
+                self.modeler.move(second, [-1000, 0], "mil")
+            if differential:
+                _, first, second = new_tdr_comp.pins[1].connect_to_component(n_pin)
+                self.modeler.move(first, [0, -100], "mil")
+                if second.pins[0].location[0] > center_x:
+                    self.modeler.move(second, [1000, 0], "mil")
+                else:
+                    self.modeler.move(second, [-1000, 0], "mil")
+            new_tdr_comp.parameters["Pulse_repetition"] = "{}ms".format(rise_time * 1e5)
+            new_tdr_comp.parameters["Rise_time"] = "{}ps".format(rise_time)
+            if differential:
+                tdr_probe_names.append("O(A{}:zdiff)".format(new_tdr_comp.id))
+            else:
+                tdr_probe_names.append("O(A{}:zl)".format(new_tdr_comp.id))
+
+        setup = self.create_setup(name="Transient_TDR", setup_type=self.SETUPS.NexximTransient)
+        setup.props["TransientData"] = ["{}ns".format(rise_time / 4), "{}ns".format(rise_time * 1000)]
+        if use_convolution:
+            self.oanalysis.AddAnalysisOptions(
+                [
+                    "NAME:DataBlock",
+                    "DataBlockID:=",
+                    8,
+                    "Name:=",
+                    "Nexxim Options",
+                    [
+                        "NAME:ModifiedOptions",
+                        "ts_convolution:=",
+                        True,
+                    ],
+                ]
+            )
+            setup.props["OptionName"] = "Nexxim Options"
+        if analyze:
+            self.analyze()
+            for trace in tdr_probe_names:
+                self.post.create_report(trace)
+        return True, tdr_probe_names
+
+    @pyaedt_function_handler()
+    def create_lna_schematic_from_snp(
+        self,
+        touchstone,
+        start_frequency=0,
+        stop_frequency=30,
+        auto_assign_diff_pairs=False,
+        separation=".",
+        pattern=None,
+        analyze=True,
+        design_name="LNA",
+    ):
+        """Create a schematic from a Touchstone file and automatically set up an LNA analysis.
+
+        This method optionally assigns differential pairs automatically based on name pattern.
+
+        Parameters
+        ----------
+        touchstone : str
+            Full path to the sNp file.
+        start_frequency : int, float, optional
+            Start frequency in GHz of the LNA setup. The default is ``0``.
+        stop_frequency  : int, float, optional
+            Stop frequency in GHz of the LNA setup. The default is ``30``.
+        auto_assign_diff_pairs : bool
+            Whether to automatically assign differential pairs. The default is ``False``.
+        separation : str, optional
+            Character to use to separate port names. The default is ``"."``.
+        pattern : list, optional
+            Port name pattern. The default is ``["component", "pin", "net"]``.
+        analyze : bool
+             Whether to automatically assign differential pairs. The default is ``False``.
+        design_name : str, optional
+            New schematic name. The default is ``"LNA"``.
+
+        Returns
+        -------
+        (bool, list, list)
+            First argument is ``True`` if succeeded.
+            Second and third argument are respectively names of the differential and common mode pairs.
+        """
+        if pattern is None:
+            pattern = ["component", "pin", "net"]
+        if design_name in self.design_list:
+            self.logger.warning("Design already exists. renaming.")
+            design_name = generate_unique_name(design_name)
+        self.insert_design(design_name)
+        if isinstance(touchstone, type(Hfss3dLayout)):
+            touchstone_path = touchstone.export_touchstone()
+        else:
+            touchstone_path = touchstone
+
+        sub = self.modeler.components.create_touchstone_component(touchstone_path)
+
+        ports = []
+        center = sub.location[0]
+        left = 0
+        right = 0
+        start = 1500
+        for pin in sub.pins:
+            loc = pin.location
+            if loc[0] < center:
+                delta = unit_converter(start + left * 200, input_units="mil", output_units=self.modeler.schematic_units)
+                new_loc = [loc[0] - delta, loc[1]]
+                left += 1
+            else:
+                delta = unit_converter(
+                    start + right * 200, input_units="mil", output_units=self.modeler.schematic_units
+                )
+                new_loc = [loc[0] + delta, loc[1]]
+                right += 1
+            port = self.modeler.components.create_interface_port(name=pin.name, location=new_loc)
+            port.pins[0].connect_to_component(component_pin=pin, use_wire=True)
+            ports.append(port)
+        diff_pairs = []
+        comm_pairs = []
+        if auto_assign_diff_pairs:
+            for pin in ports:
+                pin_name = pin.name.split(separation)
+                if pin_name[-1][-1] == "P":
+                    component = pin_name[pattern.index("component")]
+                    net = pin_name[pattern.index("net")]
+                    for neg_pin in ports:
+                        neg_pin_name = neg_pin.name.split(separation)
+                        component_neg = neg_pin_name[pattern.index("component")]
+
+                        net_neg = neg_pin_name[pattern.index("net")]
+
+                        if component_neg == component and net_neg != net and net_neg[:-1] == net[:-1]:
+                            self.set_differential_pair(
+                                positive_terminal=pin.name,
+                                negative_terminal=neg_pin.name,
+                                common_name="COMMON_{}_{}".format(component, net),
+                                diff_name="{}_{}".format(component, net),
+                                common_ref_z=25,
+                                diff_ref_z=100,
+                                active=True,
+                            )
+                            diff_pairs.append("{}_{}".format(component, net))
+                            comm_pairs.append("COMMON_{}_{}".format(component, net))
+                            break
+        setup1 = self.create_setup()
+        setup1.props["SweepDefinition"]["Data"] = "LINC {}GHz {}GHz 1001".format(start_frequency, stop_frequency)
+        if analyze:
+            self.analyze()
+        return True, diff_pairs, comm_pairs
+
+    @pyaedt_function_handler()
+    def create_ami_schematic_from_snp(
+        self,
+        touchstone,
+        ibis_ami,
+        component_name,
+        tx_buffer_name,
+        rx_buffer_name,
+        tx_pins,
+        tx_refs,
+        rx_pins,
+        rx_refs,
+        use_ibis_buffer=True,
+        differential=True,
+        bit_pattern=None,
+        unit_interval=None,
+        use_convolution=True,
+        analyze=False,
+        design_name="AMI",
+    ):
+        """Create a schematic from a Touchstone file and automatically set up an IBIS-AMI analysis.
+
+        Parameters
+        ----------
+        touchstone : str
+            Full path to the sNp file.
+        ibis_ami : str
+            Full path to the IBIS file.
+        component_name : str
+            Component name in the IBIS file to assign to components.
+        tx_buffer_name : str
+            Transmission buffer name.
+        rx_buffer_name : str
+            Receiver buffer name
+        tx_pins : list
+            Pins to assign the transmitter IBIS.
+        tx_refs : list
+            Reference pins to assign the transmitter IBIS. This parameter is only used in
+            a differential configuration.
+        rx_pins : list
+            Pins to assign the receiver IBIS.
+        rx_refs : list
+            Reference pins to assign the receiver IBIS. This parameter is only used
+            in a differential configuration.
+        use_ibis_buffer : bool, optional
+            Whether to use the IBIS buffer. The default is ``True``. If ``False``, pins are used.
+        differential : bool, optional
+            Whether the buffers are differential. The default is ``True``. If ``False``,
+            the buffers are single-ended.
+        bit_pattern : str, optional
+            IBIS bit pattern.
+        unit_interval : str, optional
+            Unit interval of the bit pattern.
+        use_convolution : bool, optional
+            Whether to use convolution for the Touchstone file. The default is
+            ``True``. If ``False``, state-space is used.
+        analyze : bool
+             Whether to automatically assign differential pairs. The default is ``False``.
+        design_name : str, optional
+            New schematic name. The default is ``"LNA"``.
+
+
+        Returns
+        -------
+        (bool, list, list)
+            First argument is ``True`` if successful.
+            Second and third arguments are respectively the names of the tx and rx mode probes.
+        """
+        if design_name in self.design_list:
+            self.logger.warning("Design already exists. renaming.")
+            design_name = generate_unique_name(design_name)
+        self.insert_design(design_name)
+        if isinstance(touchstone, type(Hfss3dLayout)):
+            touchstone_path = touchstone.export_touchstone()
+        else:
+            touchstone_path = touchstone
+
+        sub = self.modeler.components.create_touchstone_component(touchstone_path)
+        center_x = sub.location[0]
+        center_y = sub.location[1]
+        left = 0
+        delta_y = -1 * sub.location[1] - 2000 - 50 * len(tx_pins)
+        ibis = self.get_ibis_model_from_file(ibis_ami, is_ami=True)
+        tx_eye_names = []
+        rx_eye_names = []
+        for j in range(len(tx_pins)):
+            pos_x = unit_converter(2000, input_units="mil", output_units=self.modeler.schematic_units)
+            pos_y = unit_converter(delta_y - left * 800, input_units="mil", output_units=self.modeler.schematic_units)
+            left += 1
+
+            p_pin1 = [i for i in sub.pins if i.name == tx_pins[j]][0]
+            p_pin2 = [i for i in sub.pins if i.name == rx_pins[j]][0]
+            if differential:
+                n_pin1 = [i for i in sub.pins if i.name == tx_refs[j]][0]
+                n_pin2 = [i for i in sub.pins if i.name == rx_refs[j]][0]
+
+            if use_ibis_buffer:
+                buf = [k for k in ibis.components[component_name].buffer.keys() if k.startswith(tx_buffer_name + "_")]
+                if differential:
+                    buf = [k for k in buf if k.endswith("diff")]
+                tx = ibis.components[component_name].buffer[buf[0]].insert(center_x - pos_x, center_y + pos_y)
+                buf = [k for k in ibis.components[component_name].buffer.keys() if k.startswith(rx_buffer_name + "_")]
+                if differential:
+                    buf = [k for k in buf if k.endswith("diff")]
+                rx = ibis.components[component_name].buffer[buf[0]].insert(center_x + pos_x, center_y + pos_y, 180)
+            else:
+                buf = [k for k in ibis.components[component_name].pins.keys() if k.startswith(tx_buffer_name + "_")]
+                if differential:
+                    buf = [k for k in buf if k.endswith("diff")]
+                tx = ibis.components[component_name].pins[buf[0]].insert(center_x - pos_x, center_y + pos_y)
+                buf = [k for k in ibis.components[component_name].pins.keys() if k.startswith(rx_buffer_name + "_")]
+                if differential:
+                    buf = [k for k in buf if k.endswith("diff")]
+                rx = ibis.components[component_name].pins[buf[0]].insert(center_x + pos_x, center_y + pos_y, 180)
+
+            tx_eye_names.append(tx.parameters["probe_name"])
+            rx_eye_names.append(rx.parameters["source_name"])
+            _, first, second = tx.pins[0].connect_to_component(p_pin1, page_port_angle=180)
+            self.modeler.move(first, [0, 100], "mil")
+            if second.pins[0].location[0] > center_x:
+                self.modeler.move(second, [1000, 0], "mil")
+            else:
+                self.modeler.move(second, [-1000, 0], "mil")
+            _, first, second = rx.pins[0].connect_to_component(p_pin2, page_port_angle=0)
+            self.modeler.move(first, [0, -100], "mil")
+            if second.pins[0].location[0] > center_x:
+                self.modeler.move(second, [1000, 0], "mil")
+            else:
+                self.modeler.move(second, [-1000, 0], "mil")
+            if differential:
+                _, first, second = tx.pins[1].connect_to_component(n_pin1, page_port_angle=180)
+                self.modeler.move(first, [0, -100], "mil")
+                if second.pins[0].location[0] > center_x:
+                    self.modeler.move(second, [1000, 0], "mil")
+                else:
+                    self.modeler.move(second, [-1000, 0], "mil")
+                _, first, second = rx.pins[1].connect_to_component(n_pin2, page_port_angle=0)
+                self.modeler.move(first, [0, 100], "mil")
+                if second.pins[0].location[0] > center_x:
+                    self.modeler.move(second, [1000, 0], "mil")
+                else:
+                    self.modeler.move(second, [-1000, 0], "mil")
+            if unit_interval:
+                tx.parameters["UIorBPSValue"] = unit_interval
+            if bit_pattern:
+                tx.parameters["BitPattern"] = "random_bit_count=2.5e3 random_seed=1"
+
+        setup_ami = self.create_setup("AMI", "NexximAMI")
+        if use_convolution:
+            self.oanalysis.AddAnalysisOptions(
+                [
+                    "NAME:DataBlock",
+                    "DataBlockID:=",
+                    8,
+                    "Name:=",
+                    "Nexxim Options",
+                    [
+                        "NAME:ModifiedOptions",
+                        "ts_convolution:=",
+                        True,
+                    ],
+                ]
+            )
+            setup_ami.props["OptionName"] = "Nexxim Options"
+        if analyze:
+            setup_ami.analyze()
+        return True, tx_eye_names, rx_eye_names
```

### Comparing `pyaedt-0.8.7/pyaedt/common_rpc.py` & `pyaedt-0.8.8/pyaedt/common_rpc.py`

 * *Files 1% similar despite different names*

```diff
@@ -115,17 +115,19 @@
     "__exit__",
     "__next__",
     "__format__",
 }
 
 
 def pyaedt_service_manager(port=17878, aedt_version=None, student_version=False):
-    """Starts an RPyC server on CPython and listens on a specified port.
+    """Starts the PyAEDT service manager using RPyC server on CPython.
 
-    This method must run on a server machine.
+    This method, which must run on a server machine, is used as a service on the
+    server machine to listen on a dedicated port for inbound requests to launch
+    a new server connection and launch AEDT.
 
     Parameters
     ----------
     port : int, optional
         Port that the RPyC server is to listen on.
     aedt_version : str, optional
         Version of Aedt to instantiate with server. Default is latest available version installed on the machine.
@@ -248,31 +250,32 @@
     signal.signal(signal.SIGTERM, lambda signum, frame: t.close())
 
     t.start()
 
 
 def create_session(server_name, client_port=None, launch_aedt_on_server=False, aedt_port=None, non_graphical=True):
     """
-    Connect to an existing AEDT server session.
+    Connect to an existing AEDT server session and create a new client session from it.
 
     Parameters
     ----------
     server_name : str
         Name of the remote machine to connect to.
     client_port : int
         Port that the RPyC server will run.
     launch_aedt_on_server : bool, optional
         Either if the method has to start AEDT after the connection is established or not. Default is  `False`.
     aedt_port : int, optional
         Aedt Grpc port on server.
     non_graphical : bool, optional
         Aedt Non Graphical Flag.
+
     Returns
     -------
-    RPyC object.
+    RPyC client object.
     """
     try:
         client = rpyc.connect(
             server_name,
             settings.remote_rpc_service_manager_port,
             config={"allow_public_attrs": True, "sync_request_timeout": None},
         )
@@ -310,15 +313,15 @@
     server_name : str
         Name of the remote machine to connect to.
     aedt_client_port : int
         Port that the RPyC server is running on inside AEDT.
 
     Returns
     -------
-    RPyC object.
+    RPyC client object.
     """
     try:
         client = rpyc.connect(
             server_name, aedt_client_port, config={"allow_public_attrs": True, "sync_request_timeout": None}
         )
         client.root.redirect(sys.stdout)
         client.filemanager = FileManagement(client)
```

### Comparing `pyaedt-0.8.7/pyaedt/desktop.py` & `pyaedt-0.8.8/pyaedt/desktop.py`

 * *Files 1% similar despite different names*

```diff
@@ -36,14 +36,15 @@
     import subprocessdotnet as subprocess
 else:
     import subprocess
 
 from pyaedt import __version__
 from pyaedt import pyaedt_function_handler
 from pyaedt.generic.desktop_sessions import _desktop_sessions
+from pyaedt.generic.desktop_sessions import _edb_sessions
 from pyaedt.generic.general_methods import active_sessions
 from pyaedt.generic.general_methods import com_active_sessions
 from pyaedt.generic.general_methods import get_string_version
 from pyaedt.generic.general_methods import grpc_active_sessions
 from pyaedt.generic.general_methods import inside_desktop
 from pyaedt.generic.general_methods import is_ironpython
 from pyaedt.generic.general_methods import open_file
@@ -466,14 +467,15 @@
                 del _desktop_sessions[sessions[0]]
                 pyaedt_logger.info("Initializing new Desktop session.")
                 return object.__new__(cls)
         else:
             pyaedt_logger.info("Initializing new Desktop session.")
             return object.__new__(cls)
 
+    @pyaedt_function_handler()
     def __init__(
         self,
         specified_version=None,
         non_graphical=False,
         new_desktop_session=True,
         close_on_exit=True,
         student_version=False,
@@ -931,21 +933,32 @@
             self.logger.info(launch_msg)
             import pyaedt.generic.grpc_plugin as python_grpc_wrapper
 
             if _desktop_sessions:
                 last_session = list(_desktop_sessions.values())[-1]
                 all_desktop = [i for i in last_session.odesktop.GetRunningInstancesMgr().GetAllRunningInstances()]
                 for desktop in all_desktop:
-                    if port and desktop.GetGrpcServerPort() == port:
-                        self.isoutsideDesktop = True
-                        self.odesktop = desktop
-                        self.aedt_process_id = self.odesktop.GetProcessID()
-                        self.is_grpc_api = True
-                        last_session.parent_desktop_id.append(self.aedt_process_id)
-                        return True
+                    try:
+                        if port and desktop.GetGrpcServerPort() == port:
+                            self.isoutsideDesktop = True
+                            self.odesktop = desktop
+                            self.aedt_process_id = self.odesktop.GetProcessID()
+                            self.is_grpc_api = True
+                            last_session.parent_desktop_id.append(self.aedt_process_id)
+                            return True
+                    except:
+                        messages = desktop.GetMessages("", "", 0)
+                        for message in messages:
+                            if " GRPC server running on port: " in message and str(port) in message:
+                                self.isoutsideDesktop = True
+                                self.odesktop = desktop
+                                self.aedt_process_id = self.odesktop.GetProcessID()
+                                self.is_grpc_api = True
+                                last_session.parent_desktop_id.append(self.aedt_process_id)
+                                return True
             if new_session:
                 self.launched_by_pyaedt = new_session
             oapp = python_grpc_wrapper.CreateAedtApplication(machine, port, non_graphical, new_session)
         if oapp:
 
             self.isoutsideDesktop = True
             self.odesktop = oapp.GetAppDesktop()
@@ -1456,26 +1469,36 @@
 
         """
         self.logger.oproject = None
         self.logger.odesign = None
         if os.getenv("PYAEDT_DOC_GENERATION", "False").lower() in ("true", "1", "t"):  # pragma: no cover
             close_projects = True
             close_on_exit = True
+
+        for edb_object in _edb_sessions:
+            try:
+                edb_object.close()
+            except Exception:
+                self.logger.warning("Failed to close Edb object.")
+
         if close_projects:
             projects = self.odesktop.GetProjectList()
             for project in projects:
                 try:
                     self.odesktop.CloseProject(project)
                 except Exception:  # pragma: no cover
                     self.logger.warning("Failed to close Project {}".format(project))
         result = _close_aedt_application(self, close_on_exit, self.aedt_process_id, self.is_grpc_api)
         if not result:
             self.logger.error("Error releasing desktop.")
             return False
-        self.logger.info("Desktop has been released")
+        if close_on_exit:
+            self.logger.info("Desktop has been released and closed.")
+        else:
+            self.logger.info("Desktop has been released.")
         del _desktop_sessions[self.aedt_process_id]
         props = [a for a in dir(self) if not a.startswith("__")]
         for a in props:
             self.__dict__.pop(a, None)
 
         self.odesktop = None
         gc.collect()
@@ -1628,15 +1651,15 @@
         -------
         bool
             ``True`` when successful, ``False`` when failed.
         """
         try:
             self.odesktop.SetRegistryFromFile(registry_file)
             if make_active:
-                with open(registry_file, "r") as f:
+                with open_file(registry_file, "r") as f:
                     for line in f:
                         stripped_line = line.strip()
                         if "ConfigName" in stripped_line:
                             config_name = stripped_line.split("=")
                         elif "DesignType" in stripped_line:
                             design_type = stripped_line.split("=")
                             break
@@ -1776,16 +1799,16 @@
         files_to_copy = ["Run_PyAEDT_Toolkit_Script"]
         executable_version_agnostic = sys.executable
         for file_name in files_to_copy:
             src = os.path.join(pathname, "misc", file_name + ".py_build")
             dst = os.path.join(tool_dir, file_name.replace("_", " ") + ".py")
             if not os.path.isfile(src):
                 raise FileNotFoundError("File not found: {}".format(src))
-            with open(src, "r") as build_file:
-                with open(dst, "w") as out_file:
+            with open_file(src, "r") as build_file:
+                with open_file(dst, "w") as out_file:
                     self.logger.info("Building to " + dst)
                     build_file_data = build_file.read()
                     build_file_data = (
                         build_file_data.replace("##TOOLKIT_REL_LIB_DIR##", toolkit_rel_lib_dir)
                         .replace("##PYTHON_EXE##", executable_version_agnostic)
                         .replace("##PYTHON_SCRIPT##", dest_script_path)
                     )
@@ -2080,18 +2103,18 @@
         command = os.path.join(self.install_path, "common", "AnsysCloudCLI", "AnsysCloudCli.exe")
 
         if job_name:
             command = [command, "jobinfo", "-j", job_name]
         elif job_id:
             command = [command, "jobinfo", "-i", job_id]
         cloud_info = os.path.join(tempfile.gettempdir(), generate_unique_name("job_info"))
-        with open(cloud_info, "w") as outfile:
+        with open_file(cloud_info, "w") as outfile:
             subprocess.Popen(" ".join(command), stdout=outfile).wait()
         out = {}
-        with open(cloud_info, "r") as infile:
+        with open_file(cloud_info, "r") as infile:
             lines = infile.readlines()
             for i in lines:
                 if ":" in i.strip():
                     strp = i.strip().split(":")
                     out[strp[0]] = ":".join(strp[1:])
         return out
 
@@ -2186,19 +2209,19 @@
         ...                        results_folder='via_gsg_results')
         >>> d.release_desktop(False,False)
         """
         command = os.path.join(self.install_path, "common", "AnsysCloudCLI", "AnsysCloudCli.exe")
         ver = self.aedt_version_id.replace(".", "R")
         command = [command, "getQueues", "-p", "AEDT", "-v", ver, "--details"]
         cloud_info = os.path.join(tempfile.gettempdir(), generate_unique_name("cloud_info"))
-        with open(cloud_info, "w") as outfile:
+        with open_file(cloud_info, "w") as outfile:
             subprocess.Popen(" ".join(command), stdout=outfile).wait()
 
         dict_out = {}
-        with open(cloud_info, "r") as infile:
+        with open_file(cloud_info, "r") as infile:
             lines = infile.readlines()
             for i in range(len(lines)):
                 line = lines[i].strip()
                 if line.endswith(ver):
                     split_line = line.split("_")
                     if split_line[1] == region:
                         name = "{} {}".format(split_line[0], split_line[3])
```

### Comparing `pyaedt-0.8.7/pyaedt/downloads.py` & `pyaedt-0.8.8/pyaedt/downloads.py`

 * *Files 11% similar despite different names*

```diff
@@ -3,14 +3,15 @@
 import os
 import shutil
 import tempfile
 import zipfile
 
 from pyaedt.generic.general_methods import is_ironpython
 from pyaedt.generic.general_methods import is_linux
+from pyaedt.generic.general_methods import pyaedt_function_handler
 from pyaedt.generic.general_methods import settings
 from pyaedt.misc import list_installed_ansysem
 
 if is_ironpython:
     import urllib
 else:
     import urllib.request
@@ -21,31 +22,33 @@
 
 
 def delete_downloads():
     """Delete all downloaded examples to free space or update the files."""
     shutil.rmtree(EXAMPLES_PATH, ignore_errors=True)
 
 
-def _get_file_url(directory, filename=None):
-    if not filename:
+@pyaedt_function_handler(filename="name")
+def _get_file_url(directory, name=None):
+    if not name:
         return EXAMPLE_REPO + "/".join([directory])
     else:
-        return EXAMPLE_REPO + "/".join([directory, filename])
+        return EXAMPLE_REPO + "/".join([directory, name])
 
 
-def _retrieve_file(url, filename, directory, destination=None, local_paths=None):
+@pyaedt_function_handler(filename="name")
+def _retrieve_file(url, name, directory, destination=None, local_paths=None):
     """Download a file from a URL."""
 
     if local_paths is None:
         local_paths = []
 
     # First check if file has already been downloaded
     if not destination:
         destination = EXAMPLES_PATH
-    local_path = os.path.join(destination, directory, os.path.basename(filename))
+    local_path = os.path.join(destination, directory, os.path.basename(name))
     local_path_no_zip = local_path.replace(".zip", "")
     if os.path.isfile(local_path_no_zip) or os.path.isdir(local_path_no_zip):
         local_paths.append(local_path_no_zip)
 
     # grab the correct url retriever
     if not is_ironpython:
         urlretrieve = urllib.request.urlretrieve
@@ -102,26 +105,28 @@
 
     if not destination:
         destination = EXAMPLES_PATH
     if directory.startswith("pyaedt/"):
         local_path = os.path.join(destination, directory[7:])
     else:
         local_path = os.path.join(destination, directory)
+    # Ensure that "/" is parsed as a path delimiter.
+    local_path = os.path.join(*local_path.split("/"))
 
     if is_ironpython:
         return False
     _get_dir = _get_file_url(directory)
     with urllib.request.urlopen(_get_dir) as response:  # nosec
         data = response.read().decode("utf-8").split("\n")
 
     if not os.path.isdir(local_path):
         try:
             os.mkdir(local_path)
         except FileNotFoundError:
-            os.makedirs(local_path)
+            os.makedirs(local_path)  # Create directory recursively if the path doesn't exist.
 
     try:
         tree = [i for i in data if '"payload"' in i][0]
         b = re.search(r'>({"payload".+)</script>', tree)
         itemsfromjson = json.loads(b.group(1))
         items = itemsfromjson["payload"]["tree"]["items"]
         for item in items:
@@ -130,28 +135,29 @@
             else:
                 dir_folder = os.path.split(item["path"])
                 _download_file(dir_folder[0], dir_folder[1], destination, local_paths)
     except Exception:
         return False
 
 
-def _download_file(directory, filename=None, destination=None, local_paths=None):
+@pyaedt_function_handler(filename="name")
+def _download_file(directory, name=None, destination=None, local_paths=None):
     if local_paths is None:
         local_paths = []
-    if not filename:
+    if not name:
         if not directory.startswith("pyaedt/"):
             directory = "pyaedt/" + directory
         _retrieve_folder(EXAMPLE_REPO, directory, destination, local_paths)
     else:
         if directory.startswith("pyaedt/"):
-            url = _get_file_url(directory, filename)
+            url = _get_file_url(directory, name)
             directory = directory[7:]
         else:
-            url = _get_file_url("pyaedt/" + directory, filename)
-        _retrieve_file(url, filename, directory, destination, local_paths)
+            url = _get_file_url("pyaedt/" + directory, name)
+        _retrieve_file(url, name, directory, destination, local_paths)
     if settings.remote_rpc_session:
         remote_path = os.path.join(settings.remote_rpc_session_temp_folder, os.path.split(local_paths[-1])[-1])
         if not settings.remote_rpc_session.filemanager.pathexists(settings.remote_rpc_session_temp_folder):
             settings.remote_rpc_session.filemanager.makedirs(settings.remote_rpc_session_temp_folder)
         settings.remote_rpc_session.filemanager.upload(local_paths[-1], remote_path)
         local_paths[-1] = remote_path
     return local_paths[-1]
@@ -724,46 +730,52 @@
         local_path = os.path.join(destination, os.path.join("twin_builder", file_name))
         if os.path.exists(local_path):
             os.unlink(local_path)
     _download_file("pyaedt/twin_builder", file_name, destination)
     return os.path.join(destination, "twin_builder")
 
 
-def download_file(directory, filename=None, destination=None):
+@pyaedt_function_handler(filename="name")
+def download_file(directory, name=None, destination=None):
     """
-    Download file from directory.
+    Download a file or files from the online examples repository.
 
-    Files are downloaded to a destination. If filename is not specified, the full directory will be downloaded.
+    Files are downloaded from the
+    :ref:`example-data<https://github.com/ansys/example-data/tree/master/pyaedt>`_ repository
+    to a local destination. If ``name`` is not specified, the full directory path
+    will be copied to the local drive.
 
     Parameters
     ----------
     directory : str
-        Directory name.
-    filename : str, optional
-        File name to download. The default is all files inside directory.
+        Directory name in the Ansys ``example-data`` repository. If the ``pyaed/`` prefix
+        is not part of ``directory`` it will be prepended.
+    name : str, optional
+        File name to download. By default all files in ``directory``
+        will be downloaded.
     destination : str, optional
-        Path where files will be downloaded. Default is user temp folder.
+        Path where the files will be saved locally. Default is the user temp folder.
 
     Returns
     -------
     str
-        Path to the example file.
+        Path to the local example file or folder.
 
     Examples
     --------
     Download an example result file and return the path of the file.
 
     >>> import pyaedt
     >>> path = pyaedt.downloads.download_file("motorcad", "IPM_Vweb_Hairpin.mot")
     >>> path
     'C:/Users/user/AppData/local/temp/PyAEDTExamples/motorcad'
     """
     local_paths = []
-    _download_file(directory, filename, destination, local_paths)
-    if filename:
+    _download_file(directory, name, destination, local_paths)
+    if name:
         return list(set(local_paths))[0]
     else:
         if not destination:
             destination = EXAMPLES_PATH
         destination_dir = os.path.join(destination, directory)
         return destination_dir
```

### Comparing `pyaedt-0.8.7/pyaedt/emit.py` & `pyaedt-0.8.8/pyaedt/emit.py`

 * *Files 7% similar despite different names*

```diff
@@ -26,18 +26,14 @@
     designname : str, optional
         Name of the design to select. The default is ``None``, in which case
         an attempt is made to get an active design. If no designs are
         present, an empty design is created.
     solution_type : str, optional
         Solution type to apply to the design. The default is ``None``, in which
         case the default type is applied.
-    setup_name : str, optional
-        Name of the setup to use as the nominal. The default is
-        ``None``, in which case the active setup is used or
-        nothing is used.
     specified_version : str, int, float, optional
         Version of AEDT to use. The default is ``None``, in which case
         the active setup is used or the latest installed version is
         used.
         Examples of input values are ``232``, ``23.2``,``2023.2``,``"2023.2"``.
     non_graphical : bool, optional
         Whether to launch AEDT in non-graphical mode. The default
@@ -81,39 +77,38 @@
     >>> rad1 = aedtapp.modeler.components.create_component("Bluetooth")
     >>> ant1 = aedtapp.modeler.components.create_component("Antenna")
     >>> if rad1 and ant1:
     >>>     ant1.move_and_connect_to(rad1)
 
     Once the schematic is generated, the ``Emit`` object can be analyzed to generate
     a revision. Each revision is added as an element of the ``Emit`` object member's
-    revisions_list.
+    ``Results.revisions`` list.
 
-    >>> aedtapp.analyze()
+    >>> revision = aedtapp.results.analyze()
 
     A revision within PyAEDT is analogous to a revision in AEDT. An interaction domain must
     be defined and then used as the input to the run command used on that revision.
 
-    >>> domain = aedtapp.interaction_domain()
+    >>> domain = aedtapp.results.interaction_domain()
     >>> domain.rx_radio_name = "UE - HandHeld"
-    >>> interaction = aedtapp.revisions_list[0].run(domain)
+    >>> interaction = revision.run(domain)
 
     The output of the run command is an ``interaction`` object. This object summarizes the interaction data
     that is defined in the interaction domain.
 
     >>> instance = interaction.worst_instance(ResultType.SENSITIVITY)
     >>> val = instance.value(ResultType.SENSITIVITY)
     >>> print("Worst-case sensitivity for Rx '{}' is {}dB.".format(domain.rx_radio_name, val))
     """
 
     def __init__(
         self,
         projectname=None,
         designname=None,
         solution_type=None,
-        setup_name=None,
         specified_version=None,
         non_graphical=False,
         new_desktop_session=True,
         close_on_exit=True,
         student_version=False,
         machine="",
         port=0,
@@ -211,15 +206,15 @@
         """
         if self.__emit_api_enabled:
             ver = self._emit_api.get_version(detailed)
             return ver
 
     @pyaedt_function_handler()
     def set_units(self, unit_type, unit_value):
-        """Set units for the component.
+        """Set units for the EMIT design.
 
         Parameters
         ----------
         unit_type : str
             System of units.
         unit_value : str
             Units to use.
@@ -273,15 +268,15 @@
             ut = emit_unit_type_string_to_enum(unit_type)
             self._emit_api.set_units(ut, unit_value)
             self._units[unit_type] = unit_value
         return True
 
     @pyaedt_function_handler()
     def get_units(self, unit_type=""):
-        """Get units for the component.
+        """Get units for the EMIT design.
 
         Parameters
         ----------
         unit_type : str, optional
             System of units: options are power, frequency,
             length, time, voltage, data rate, or resistance.
             The default is ``None`` which uses the units
```

### Comparing `pyaedt-0.8.7/pyaedt/emit_core/Couplings.py` & `pyaedt-0.8.8/pyaedt/emit_core/Couplings.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/emit_core/__init__.py` & `pyaedt-0.8.8/pyaedt/emit_core/__init__.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/emit_core/emit_constants.py` & `pyaedt-0.8.8/pyaedt/emit_core/emit_constants.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/emit_core/results/results.py` & `pyaedt-0.8.8/pyaedt/emit_core/results/results.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/emit_core/results/revision.py` & `pyaedt-0.8.8/pyaedt/emit_core/results/revision.py`

 * *Files 1% similar despite different names*

```diff
@@ -433,15 +433,14 @@
         """
         power_matrix = []
         all_colors = []
 
         # Get project results and radios
         modeRx = TxRxMode.RX
         modeTx = TxRxMode.TX
-        mode_power = ResultType.POWER_AT_RX
         tx_interferer = InterfererType().TRANSMITTERS
         rx_radios = self.get_receiver_names()
         tx_radios = self.get_interferer_names(tx_interferer)
         radios = self.emit_project.modeler.components.get_radios()
 
         for tx_radio in tx_radios:
             rx_powers = []
@@ -493,17 +492,15 @@
                                     max_power = 200
                                 else:
                                     # other warnings (e.g. no path from Tx to Rx,
                                     # no power received, error in configuration, etc)
                                     # should just be skipped
                                     continue
                             else:
-                                tx_prob = (
-                                    instance.get_largest_problem_type(ResultType.EMI).replace(" ", "").split(":")[1]
-                                )
+                                tx_prob = instance.get_largest_emi_problem_type().replace(" ", "").split(":")[1]
                                 power = instance.get_value(ResultType.EMI)
                             if (
                                 rx_start_freq - rx_channel_bandwidth / 2
                                 <= tx_freq
                                 <= rx_stop_freq + rx_channel_bandwidth / 2
                             ):
                                 rx_prob = "In-band"
@@ -517,15 +514,15 @@
                             else:
                                 in_filters = True
 
                             # Save the worst case interference values
                             if power > max_power and in_filters:
                                 max_power = power
                                 largest_rx_prob = rx_prob
-                                prob = instance.get_largest_problem_type(ResultType.EMI)
+                                prob = instance.get_largest_emi_problem_type()
                                 largest_tx_prob = prob.replace(" ", "").split(":")
 
                 if max_power > -200:
                     rx_powers.append(max_power)
 
                     if largest_tx_prob[-1] == "TxFundamental" and largest_rx_prob == "In-band":
                         rx_colors.append("red")
```

### Comparing `pyaedt-0.8.7/pyaedt/generic/Ansys.png` & `pyaedt-0.8.8/pyaedt/generic/Ansys.png`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/generic/AnsysTemplate.json` & `pyaedt-0.8.8/pyaedt/generic/AnsysTemplate.json`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/generic/DataHandlers.py` & `pyaedt-0.8.8/pyaedt/generic/DataHandlers.py`

 * *Files 2% similar despite different names*

```diff
@@ -113,15 +113,15 @@
                 arg_out.append([i for i in v])
         elif isinstance(v, (OrderedDict, dict)):
             arg = ["NAME:" + k]
             _dict2arg(v, arg)
             arg_out.append(arg)
         elif v is None:
             arg_out.append(["NAME:" + k])
-        elif type(v) is list and len(v) > 0 and isinstance(v[0], (OrderedDict, dict)):
+        elif isinstance(v, list) and len(v) > 0 and isinstance(v[0], (OrderedDict, dict)):
             for el in v:
                 arg = ["NAME:" + k]
                 _dict2arg(el, arg)
                 arg_out.append(arg)
 
         else:
             arg_out.append(k + ":=")
@@ -313,15 +313,15 @@
             try:
                 error_message += " {}".format(element_list)
             except Exception:
                 pass
             raise Exception(error_message)
 
         if only_string:
-            non_string_entries = [x for x in element_list if type(x) is not str]
+            non_string_entries = [x for x in element_list if not isinstance(x, str)]
             assert not non_string_entries, "Invalid list entries {} are not a string!".format(non_string_entries)
 
     return element_list
 
 
 @pyaedt_function_handler()
 def string_list(element_list):
@@ -528,22 +528,22 @@
          - ``True`` is returned  if the input is ``"true"``, ``"1"``,
            `"yes"``, or ``"y"``,
          - ``False`` is returned if the input is ``"false"``, ``"no"``,
            ``"n``,  or ``"0"``.
          - Otherwise, the input value is passed through the method unchanged.
 
     """
-    if type(s) == str:
+    if isinstance(s, str):
         if s.lower() in ["true", "yes", "y", "1"]:
             return True
         elif s.lower() in ["false", "no", "n", "0"]:
             return False
         else:
             return s
-    elif type(s) == int:
+    elif isinstance(s, int):
         return False if s == 0 else True
 
 
 @pyaedt_function_handler()
 def from_rkm_to_aedt(code):
     """
```

### Comparing `pyaedt-0.8.7/pyaedt/generic/LoadAEDTFile.py` & `pyaedt-0.8.8/pyaedt/generic/LoadAEDTFile.py`

 * *Files 1% similar despite different names*

```diff
@@ -413,15 +413,15 @@
                     _decode_subkey(line, save_dict[keyword])
             else:  # decode key
                 _decode_subkey(line, save_dict[keyword])
         _count += 1
     # recompose value if list
     if saved_value:
         # makes the value a list, if it's not already
-        if type(saved_value) is not list:
+        if not isinstance(saved_value, list):
             saved_value = [saved_value]
         saved_value.append(save_dict[keyword])
         save_dict[keyword] = saved_value
     return _count
 
 
 def _read_aedt_file(filename):
```

### Comparing `pyaedt-0.8.7/pyaedt/generic/ami.json` & `pyaedt-0.8.8/pyaedt/generic/ami.json`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/generic/clr_module.py` & `pyaedt-0.8.8/pyaedt/generic/clr_module.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/generic/compliance.py` & `pyaedt-0.8.8/pyaedt/generic/compliance.py`

 * *Files 1% similar despite different names*

```diff
@@ -449,15 +449,15 @@
                 start = False
             if group and report_type in ["frequency", "time"]:
                 local_config["expressions"] = {trace: {} for trace in traces}
                 image_name = name
                 sw_name = self._get_sweep_name(_design, local_config.get("solution_name", None))
                 _design.logger.info(f"Creating report {name}")
                 aedt_report = _design.post.create_report_from_configuration(
-                    input_dict=local_config, solution_name=sw_name
+                    report_settings=local_config, solution_name=sw_name
                 )
                 if not aedt_report:  # pragma: no cover
                     _design.logger.error(f"Failed to create report {name}")
                     continue
                 aedt_report.hide_legend()
                 time.sleep(1)
                 if _design.post.export_report_to_jpg(self._output_folder, aedt_report.plot_name):
@@ -500,15 +500,15 @@
             else:
                 for trace in traces:
                     local_config["expressions"] = {trace: {}}
                     image_name = name + f"_{trace}"
                     sw_name = self._get_sweep_name(_design, local_config.get("solution_name", None))
                     _design.logger.info(f"Creating report {name} for trace {trace}")
                     aedt_report = _design.post.create_report_from_configuration(
-                        input_dict=local_config, solution_name=sw_name
+                        report_settings=local_config, solution_name=sw_name
                     )
                     if report_type != "contour eye diagram":
                         aedt_report.hide_legend()
                     time.sleep(1)
                     out = _design.post.export_report_to_jpg(self._output_folder, aedt_report.plot_name)
                     time.sleep(1)
                     if out:
@@ -555,15 +555,15 @@
                                 _design.logger.info("Checking eye violations")
                                 table = self._add_contour_eye_diagram_violations(
                                     aedt_report, pdf_report, image_name, local_config
                                 )
                             write_csv(os.path.join(self._output_folder, f"{name}{trace}_pass_fail.csv"), table)
 
                         if report_type in ["eye diagram", "statistical eye"]:
-                            _design.logger.info(f"Adding eye measurements")
+                            _design.logger.info("Adding eye measurements.")
                             table = self._add_eye_measurement(aedt_report, pdf_report, image_name)
                             write_csv(os.path.join(self._output_folder, f"{name}{trace}_eye_meas.csv"), table)
                         if self.local_config.get("delete_after_export", True):
                             aedt_report.delete()
                         _design.logger.info(f"Successfully parsed report {name} for trace {trace}")
 
                     else:  # pragma: no cover
@@ -598,15 +598,15 @@
                 table_out = [["ERL", "Value", "Pass/Fail"]]
                 traces = template_report.traces
                 trace_pins = template_report.trace_pins
                 for trace_name, trace_pin in zip(traces, trace_pins):
                     spisim.touchstone_file = _design.export_touchstone()
                     if not isinstance(trace_pin[0], int):
                         try:
-                            ports = list(_design.excitations.keys())
+                            ports = list(_design.excitations)
                             thrus4p = [ports.index(i) for i in trace_pin]
                             trace_pin = thrus4p
                         except IndexError:
                             _design.logger.error("Port not found.")
                     erl_value = spisim.compute_erl(specify_through_ports=trace_pin, config_file=config_file)
                     if erl_value:
                         table_out.append([trace_name, erl_value, "PASS" if pass_fail_criteria else "FAIL"])
@@ -687,14 +687,15 @@
         pass_fail_table = [["Pass Fail Criteria", "Test Result"]]
         sols = report.get_solution_data()
         if not sols:  # pragma: no cover
             msg = "Failed to get Solution Data. Check if the design is solved or the report data are correct."
             self._desktop_class.logger.error(msg)
             return
         mag_data = {i: k for i, k in sols.full_matrix_real_imag[0][sols.expressions[0]].items() if k > 0}
+        # mag_data is a dictionary. The key isa tuple (__AMPLITUDE, __UI), and the value is the eye value.
         mystr = "Eye Mask Violation:"
         result_value = "PASS"
         points_to_check = [i[::-1] for i in local_config["eye_mask"]["points"]]
         points_to_check = [[i[0] for i in points_to_check], [i[1] for i in points_to_check]]
         num_failed = 0
         min_x = min(points_to_check[0])
         max_x = max(points_to_check[0])
@@ -707,21 +708,22 @@
                 result_value = "FAIL"
                 num_failed += 1
                 # break
         font_table.append([None, [255, 0, 0]] if result_value == "FAIL" else ["", None])
         if result_value == "FAIL":
             result_value = f"FAIL on {num_failed} points."
         pass_fail_table.append([mystr, result_value])
-
+        result_value = "PASS"
         if local_config["eye_mask"]["enable_limits"]:
             mystr = "Upper/Lower Mask Violation:"
             for point in mag_data:
+                # checking if amplitude is overcoming limits.
                 if (
-                    point[1] > local_config["eye_mask"]["upper_limit"]
-                    or point[1] < local_config["eye_mask"]["lower_limit"]
+                    point[0] > local_config["eye_mask"]["upper_limit"]
+                    or point[0] < local_config["eye_mask"]["lower_limit"]
                 ):
                     result_value = "FAIL"
                     break
             font_table.append([None, [255, 0, 0]] if result_value == "FAIL" else ["", None])
             pass_fail_table.append([mystr, result_value])
         if not self._use_portrait:
             pdf_report.add_section()
```

### Comparing `pyaedt-0.8.7/pyaedt/generic/configurations.py` & `pyaedt-0.8.8/pyaedt/generic/configurations.py`

 * *Files 0% similar despite different names*

```diff
@@ -12,14 +12,15 @@
 from pyaedt import get_pyaedt_app
 from pyaedt import is_ironpython
 from pyaedt.application.Variables import decompose_variable_value
 from pyaedt.generic.DataHandlers import _arg2dict
 from pyaedt.generic.LoadAEDTFile import load_keyword_in_aedt_file
 from pyaedt.generic.general_methods import GrpcApiError
 from pyaedt.generic.general_methods import generate_unique_name
+from pyaedt.generic.general_methods import open_file
 from pyaedt.generic.general_methods import pyaedt_function_handler
 from pyaedt.generic.general_methods import read_configuration_file
 from pyaedt.generic.general_methods import write_configuration_file
 from pyaedt.modeler.cad.Modeler import CoordinateSystem
 from pyaedt.modeler.cad.components_3d import UserDefinedComponent
 from pyaedt.modeler.geometry_operators import GeometryOperators
 from pyaedt.modules.Boundary import BoundaryObject
@@ -902,15 +903,15 @@
                 if v.get("RenormImp", None):
                     p1["RenormImp"] = v["RenormImp"]
                 modes[k] = p1
             bound.auto_update = False
             bound.props["Modes"] = BoundaryProps(bound, modes)
             bound.auto_update = True
         if bound.create():
-            self._app.boundaries.append(bound)
+            self._app._boundaries[bound.name] = bound
             if props["BoundType"] in ["Coil Terminal", "Coil", "CoilTerminal"]:
                 winding_name = ""
                 for b in self._app.boundaries:
                     if b.props.get("ID", 999) == props.get("ParentBndID", -1):
                         winding_name = b.name
                         break
                 if winding_name:
@@ -946,15 +947,15 @@
                 if not self.options.skip_import_if_exists:
                     setup_el.props = props
                     setup_el.update()
                 return True
         if self._app.design_type == "Q3D Extractor":
             setup = self._app.create_setup(name, props=props)
         else:
-            setup = self._app.create_setup(name, setuptype=props["SetupType"], props=props)
+            setup = self._app.create_setup(name, setup_type=props["SetupType"], props=props)
         if setup:
             self._app.logger.info("Setup {} added.".format(name))
             return True
         else:
             self._app.logger.warning("Failed to add Setup {} ".format(name))
             return False
 
@@ -1228,15 +1229,15 @@
         dict_out["general"]["design_name"] = self._app.design_name
         dict_out["general"]["date"] = datetime.now().strftime("%d/%m/%Y %H:%M:%S")
         dict_out["general"]["object_mapping"] = {}
         dict_out["general"]["output_variables"] = {}
         if list(self._app.output_variables):
             oo_out = os.path.join(tempfile.gettempdir(), generate_unique_name("oo") + ".txt")
             self._app.ooutput_variable.ExportOutputVariables(oo_out)
-            with open(oo_out, "r") as f:
+            with open_file(oo_out, "r") as f:
                 lines = f.readlines()
                 for line in lines:
                     line_split = line.split(" ")
                     try:
                         dict_out["general"]["output_variables"][line_split[0]] = line.split("'")[1]
                     except IndexError:
                         pass
```

### Comparing `pyaedt-0.8.7/pyaedt/generic/constants.py` & `pyaedt-0.8.8/pyaedt/generic/constants.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/generic/design_types.py` & `pyaedt-0.8.8/pyaedt/generic/design_types.py`

 * *Files 0% similar despite different names*

```diff
@@ -398,15 +398,14 @@
     )
 
 
 def Emit(
     projectname=None,
     designname=None,
     solution_type=None,
-    setup_name=None,
     specified_version=None,
     non_graphical=False,
     new_desktop_session=False,
     close_on_exit=False,
     student_version=False,
     machine="",
     port=0,
@@ -424,18 +423,14 @@
     designname : str, optional
         Name of the design to select. The default is ``None``, in which case
         an attempt is made to get an active design. If no designs are
         present, an empty design is created.
     solution_type : str, optional
         Solution type to apply to the design. The default is ``None``, in which
         case the default type is applied.
-    setup_name : str, optional
-        Name of the setup to use as the nominal. The default is
-        ``None``, in which case the active setup is used or
-        nothing is used.
     specified_version : str, int, float, optional
         Version of AEDT to use. The default is ``None``, in which case
         the active setup is used or the latest installed version is
         used.
         Examples of input values are ``232``, ``23.2``,``2023.2``,``"2023.2"``.
     non_graphical : bool, optional
         Whether to launch AEDT in non-graphical mode. The default
@@ -507,15 +502,14 @@
     """
     from pyaedt.emit import Emit as app
 
     return app(
         projectname=projectname,
         designname=designname,
         solution_type=solution_type,
-        setup_name=setup_name,
         specified_version=specified_version,
         non_graphical=non_graphical,
         new_desktop_session=new_desktop_session,
         close_on_exit=close_on_exit,
         student_version=student_version,
         machine=machine,
         port=port,
@@ -1766,27 +1760,31 @@
     -------
     :def :`pyaedt.Hfss`
         Any of the Pyaedt App initialized.
     """
     from pyaedt.generic.desktop_sessions import _desktop_sessions
 
     odesktop = None
+    process_id = None
     if desktop:
         odesktop = desktop.odesktop
+        process_id = desktop.aedt_process_id
     elif _desktop_sessions and project_name:
         for desktop in list(_desktop_sessions.values()):
             if project_name in list(desktop.project_list()):
                 odesktop = desktop.odesktop
                 break
     elif _desktop_sessions:
         odesktop = list(_desktop_sessions.values())[-1]
     elif "oDesktop" in dir(sys.modules["__main__"]):  # ironpython
         odesktop = sys.modules["__main__"].oDesktop  # ironpython
     else:
         raise AttributeError("No Desktop Present.")
+    if not process_id:
+        process_id = odesktop.GetProcessID()
     if project_name and project_name not in odesktop.GetProjectList():
         raise AttributeError("Project  {} doesn't exist in current desktop.".format(project_name))
     if not project_name:
         oProject = odesktop.GetActiveProject()
     else:
         oProject = odesktop.SetActiveProject(project_name)
     if not oProject:
@@ -1804,9 +1802,9 @@
         oDesign = oProject.SetActiveDesign(design_name)
     if not oDesign:
         raise AttributeError("No design is present.")
     design_type = oDesign.GetDesignType()
     if design_type in list(app_map.keys()):
         version = odesktop.GetVersion().split(".")
         v = ".".join([version[0], version[1]])
-        return app_map[design_type](project_name, design_name, specified_version=v)
+        return app_map[design_type](project_name, design_name, specified_version=v, aedt_process_id=process_id)
     return None
```

### Comparing `pyaedt-0.8.7/pyaedt/generic/filesystem.py` & `pyaedt-0.8.8/pyaedt/generic/filesystem.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/generic/general_methods.py` & `pyaedt-0.8.8/pyaedt/generic/general_methods.py`

 * *Files 1% similar despite different names*

```diff
@@ -194,75 +194,101 @@
     elif "netref.__builtin__.list" in str(type(arg)):
         return "list"
     elif "netref.__builtin__.dict" in str(type(arg)):
         return "dict"
     return ""
 
 
-def _function_handler_wrapper(user_function):
+def raise_exception(e):
+    if not settings.enable_error_handler:
+        if settings.release_on_exception:
+            from pyaedt.generic.desktop_sessions import _desktop_sessions
+
+            for v in list(_desktop_sessions.values())[:]:
+                v.release_desktop(v.launched_by_pyaedt, v.launched_by_pyaedt)
+        raise e
+    else:
+        return False
+
+
+def _function_handler_wrapper(user_function, **deprecated_kwargs):
+
     def wrapper(*args, **kwargs):
-        if not settings.enable_error_handler:
-            result = user_function(*args, **kwargs)
-            return result
-        else:
-            try:
-                settings.time_tick = time.time()
-                out = user_function(*args, **kwargs)
-                if settings.enable_debug_logger or settings.enable_debug_edb_logger:
-                    _log_method(user_function, args, kwargs)
-                return out
-            except MethodNotSupportedError:
-                message = "This method is not supported in current AEDT design type."
-                if settings.enable_screen_logs:
-                    pyaedt_logger.error("**************************************************************")
-                    pyaedt_logger.error(
-                        "PyAEDT error on method {}:  {}. Check again".format(user_function.__name__, message)
-                    )
-                    pyaedt_logger.error("**************************************************************")
-                    pyaedt_logger.error("")
-                if settings.enable_file_logs:
-                    settings.error(message)
-                return False
-            except GrpcApiError:
-                _exception(sys.exc_info(), user_function, args, kwargs, "AEDT grpc API call Error")
-                return False
-            except BaseException:
-                _exception(sys.exc_info(), user_function, args, kwargs, str(sys.exc_info()[1]).capitalize())
-                return False
+
+        if deprecated_kwargs and kwargs:
+            deprecate_kwargs(user_function.__name__, kwargs, deprecated_kwargs)
+        try:
+            settings.time_tick = time.time()
+            out = user_function(*args, **kwargs)
+            if settings.enable_debug_logger or settings.enable_debug_edb_logger:
+                _log_method(user_function, args, kwargs)
+            return out
+        except MethodNotSupportedError as e:
+            message = "This method is not supported in current AEDT design type."
+            if settings.enable_screen_logs:
+                pyaedt_logger.error("**************************************************************")
+                pyaedt_logger.error(
+                    "PyAEDT error on method {}:  {}. Check again".format(user_function.__name__, message)
+                )
+                pyaedt_logger.error("**************************************************************")
+                pyaedt_logger.error("")
+            if settings.enable_file_logs:
+                settings.error(message)
+            raise_exception(e)
+        except GrpcApiError as e:
+            _exception(sys.exc_info(), user_function, args, kwargs, "AEDT grpc API call Error")
+            raise_exception(e)
+        except BaseException as e:
+            _exception(sys.exc_info(), user_function, args, kwargs, str(sys.exc_info()[1]).capitalize())
+            raise_exception(e)
 
     return wrapper
 
 
-def pyaedt_function_handler(direct_func=None):
+def deprecate_kwargs(func_name, kwargs, aliases):
+    """Use helper function for deprecating function arguments."""
+    for alias, new in aliases.items():
+        if alias in kwargs:
+            if new in kwargs:
+                msg = "{} received both {} and {} as arguments!\n".format(func_name, alias, new)
+                msg += "{} is deprecated, use {} instead.".format(alias, new)
+                raise TypeError(msg)
+            pyaedt_logger.warning(
+                '`{}` is deprecated as an argument to `{}`; use" f" `{}` instead.'.format(alias, func_name, new)
+            )
+            kwargs[new] = kwargs.pop(alias)
+
+
+def pyaedt_function_handler(direct_func=None, **deprecated_kwargs):
     """Provides an exception handler, logging mechanism, and argument converter for client-server
     communications.
 
     This method returns the function itself if correctly executed. Otherwise, it returns ``False``
     and displays errors.
 
     """
     if callable(direct_func):
         user_function = direct_func
-        wrapper = _function_handler_wrapper(user_function)
+        wrapper = _function_handler_wrapper(user_function, **deprecated_kwargs)
         return update_wrapper(wrapper, user_function)
     elif direct_func is not None:
         raise TypeError("Expected first argument to be a callable, or None")
 
     def decorating_function(user_function):
-        wrapper = _function_handler_wrapper(user_function)
+        wrapper = _function_handler_wrapper(user_function, **deprecated_kwargs)
         return update_wrapper(wrapper, user_function)
 
     return decorating_function
 
 
 @pyaedt_function_handler()
 def check_numeric_equivalence(a, b, relative_tolerance=1e-7):
     """Check if two numeric values are equivalent to within a relative tolerance.
 
-    Paraemters
+    Parameters
     ----------
     a : int, float
         Reference value to compare to.
     b : int, float
         Secondary value for the comparison.
     relative_tolerance : float, optional
         Relative tolerance for the equivalence test. The difference is relative to the first value.
@@ -277,35 +303,40 @@
         reldiff = abs(a - b) / a
     else:
         reldiff = abs(b)
     return True if reldiff < relative_tolerance else False
 
 
 @pyaedt_function_handler()
-def check_and_download_file(local_path, remote_path, overwrite=True):
+def _check_path(path_to_check):
+    return path_to_check.replace("\\", "/") if path_to_check[0] != "\\" else path_to_check
+
+
+@pyaedt_function_handler()
+def check_and_download_file(remote_path, overwrite=True):
     """Check if a file is remote and either download it or return the path.
 
     Parameters
     ----------
-    local_path : str
-        Local path to save the file to.
     remote_path : str
         Path to the remote file.
     overwrite : bool, optional
-        Whether to overwrite the file if it already exits locally.
+        Whether to overwrite the file if it already exists locally.
         The default is ``True``.
 
     Returns
     -------
     str
     """
     if settings.remote_rpc_session:
-        remote_path = remote_path.replace("\\", "/") if remote_path[0] != "\\" else remote_path
-        settings.remote_rpc_session.filemanager.download_file(remote_path, local_path, overwrite=overwrite)
-        return local_path
+        remote_path = _check_path(remote_path)
+        local_path = os.path.join(settings.remote_rpc_session_temp_folder, os.path.split(remote_path)[-1])
+        if settings.remote_rpc_session.filemanager.pathexists(remote_path):
+            settings.remote_rpc_session.filemanager.download_file(remote_path, local_path, overwrite=overwrite)
+            return local_path
     return remote_path
 
 
 def check_if_path_exists(path):
     """Check whether a path exists or not local or remote machine (for remote sessions only).
 
     Parameters
@@ -329,58 +360,75 @@
     Parameters
     ----------
     local_path : str
         Local path to save the folder to.
     remote_path : str
         Path to the remote folder.
     overwrite : bool, optional
-        Whether to overwrite the folder if it already exits locally.
+        Whether to overwrite the folder if it already exists locally.
         The default is ``True``.
 
     Returns
     -------
     str
     """
     if settings.remote_rpc_session:
         remote_path = remote_path.replace("\\", "/") if remote_path[0] != "\\" else remote_path
         settings.remote_rpc_session.filemanager.download_folder(remote_path, local_path, overwrite=overwrite)
         return local_path
     return remote_path
 
 
-def open_file(file_path, file_options="r"):
+def open_file(file_path, file_options="r", encoding=None, override_existing=True):
     """Open a file and return the object.
 
     Parameters
     ----------
     file_path : str
         Full absolute path to the file (either local or remote).
     file_options : str, optional
         Options for opening the file.
+    encoding : str, optional
+        Name of the encoding used to decode or encode the file.
+        The default is ``None``, which means a platform-dependent encoding is used. You can
+        specify any encoding supported by Python.
+    override_existing : bool, optional
+        Whether to override an existing file if opening a file in write mode on a remote
+        machine. The default is ``True``.
 
     Returns
     -------
     object
         Opened file.
     """
+    if is_ironpython:
+        return open(file_path, file_options)
+
+    file_path = str(file_path)
     file_path = file_path.replace("\\", "/") if file_path[0] != "\\" else file_path
+
     dir_name = os.path.dirname(file_path)
     if "r" in file_options:
         if os.path.exists(file_path):
-            return open(file_path, file_options)
+            return open(file_path, file_options, encoding=encoding)
         elif settings.remote_rpc_session and settings.remote_rpc_session.filemanager.pathexists(
             file_path
         ):  # pragma: no cover
             local_file = os.path.join(tempfile.gettempdir(), os.path.split(file_path)[-1])
             settings.remote_rpc_session.filemanager.download_file(file_path, local_file)
-            return open(local_file, file_options)
+            return open(local_file, file_options, encoding=encoding)
     elif os.path.exists(dir_name):
-        return open(file_path, file_options)
+        return open(file_path, file_options, encoding=encoding)
     elif settings.remote_rpc_session and settings.remote_rpc_session.filemanager.pathexists(dir_name):
-        return settings.remote_rpc_session.open_file(file_path, file_options)
+        if "w" in file_options:
+            return settings.remote_rpc_session.create_file(
+                file_path, file_options, encoding=encoding, override=override_existing
+            )
+        else:
+            return settings.remote_rpc_session.open_file(file_path, file_options, encoding=encoding)
     else:
         settings.logger.error("The file or folder %s does not exist", dir_name)
 
 
 @pyaedt_function_handler()
 def read_configuration_file(file_path):
     """Parse a file and return the information in a list or dictionary.
@@ -417,15 +465,15 @@
         Full path to the JSON file.
 
     Returns
     -------
     dict
     """
     json_data = {}
-    with open(fn) as json_file:
+    with open_file(fn) as json_file:
         try:
             json_data = json.load(json_file)
         except json.JSONDecodeError as e:  # pragma: no cover
             error = "Error reading json: {} at line {}".format(e.msg, e.lineno)
             settings.logger.error(error)
     return json_data
 
@@ -816,15 +864,15 @@
 
 def is_array(a):
     try:
         v = list(ast.literal_eval(a))
     except (ValueError, TypeError, NameError, SyntaxError):
         return False
     else:
-        if type(v) is list:
+        if isinstance(v, list):
             return True
         else:
             return False
 
 
 def is_project_locked(project_path):
     """Check if an AEDT project lock file exists.
@@ -835,14 +883,19 @@
         Path for the AEDT project.
 
     Returns
     -------
     bool
         ``True`` when successful, ``False`` when failed.
     """
+    if settings.remote_rpc_session:
+        if settings.remote_rpc_session.filemanager.pathexists(project_path + ".lock"):
+            return True
+        else:
+            return False
     return check_if_path_exists(project_path + ".lock")
 
 
 @pyaedt_function_handler()
 def remove_project_lock(project_path):
     """Check if an AEDT project exists and try to remove the lock file.
 
@@ -855,14 +908,17 @@
         Path for the AEDT project.
 
     Returns
     -------
     bool
         ``True`` when successful, ``False`` when failed.
     """
+    if settings.remote_rpc_session and settings.remote_rpc_session.filemanager.pathexists(project_path + ".lock"):
+        settings.remote_rpc_session.filemanager.unlink(project_path + ".lock")
+        return True
     if os.path.exists(project_path + ".lock"):
         os.remove(project_path + ".lock")
     return True
 
 
 @pyaedt_function_handler()
 def read_csv(filename, encoding="utf-8"):
@@ -876,14 +932,15 @@
             File encoding for the CSV file. The default is ``"utf-8"``.
 
     Returns
     -------
     list
 
     """
+    filename = check_and_download_file(filename)
 
     lines = []
     with codecs.open(filename, "rb", encoding) as csvfile:
         reader = csv.reader(csvfile, delimiter=",")
         for row in reader:
             lines.append(row)
     return lines
@@ -901,14 +958,15 @@
             File encoding for the CSV file. The default is ``"utf-8"``.
 
     Returns
     -------
     :class:`pandas.DataFrame`
 
     """
+    filename = check_and_download_file(filename)
     try:
         import pandas as pd
 
         return pd.read_csv(filename, encoding=encoding, header=0, na_values=".")
     except ImportError:
         pyaedt_logger.error("Pandas is not available. Install it.")
         return None
@@ -943,14 +1001,15 @@
             Full path and name for the XLSX file.
 
     Returns
     -------
     list
 
     """
+    filename = check_and_download_file(filename)
     try:
         import pandas as pd
 
         lines = pd.read_excel(filename)
         return lines
     except ImportError:
         lines = []
@@ -1107,25 +1166,25 @@
 
 
 @pyaedt_function_handler()
 def _create_json_file(json_dict, full_json_path):
     if not os.path.exists(os.path.dirname(full_json_path)):
         os.makedirs(os.path.dirname(full_json_path))
     if not is_ironpython:
-        with open(full_json_path, "w") as fp:
+        with open_file(full_json_path, "w") as fp:
             json.dump(json_dict, fp, indent=4)
     else:
         temp_path = full_json_path.replace(".json", "_temp.json")
-        with open(temp_path, "w") as fp:
+        with open_file(temp_path, "w") as fp:
             json.dump(json_dict, fp, indent=4)
-        with open(temp_path, "r") as file:
+        with open_file(temp_path, "r") as file:
             filedata = file.read()
         filedata = filedata.replace("True", "true")
         filedata = filedata.replace("False", "false")
-        with open(full_json_path, "w") as file:
+        with open_file(full_json_path, "w") as file:
             file.write(filedata)
         os.remove(temp_path)
     return True
 
 
 @pyaedt_function_handler()
 def write_configuration_file(dict_in, full_path):
@@ -1605,15 +1664,15 @@
 
     Returns
     -------
     str
         Out xml file.
     """
     result = []
-    with open(tech_path) as f:
+    with open_file(tech_path) as f:
         vals = list(CSS4_COLORS.values())
         id_layer = 0
         for line in f:
             line_split = line.split()
             if len(line_split) == 5:
                 layerID, layer_name, _, elevation, layer_height = line.split()
                 x = '      <Layer Color="{}" GDSIIVia="{}" Name="{}" TargetLayer="{}" Thickness="{}"'.format(
@@ -1626,15 +1685,15 @@
                 x += ' Type="conductor"/>'
                 result.append(x)
                 id_layer += 1
             elif len(line_split) > 1 and "UNIT" in line_split[0]:
                 unit = line_split[1]
     if not control_path:
         control_path = os.path.splitext(tech_path)[0] + ".xml"
-    with open(control_path, "w") as f:
+    with open_file(control_path, "w") as f:
         f.write('<?xml version="1.0" encoding="UTF-8" standalone="no" ?>\n')
         f.write('    <c:Control xmlns:c="http://www.ansys.com/control" schemaVersion="1.0">\n')
         f.write("\n")
         f.write('      <Stackup schemaVersion="1.0">\n')
         f.write('        <Layers LengthUnit="{}">\n'.format(unit))
         for res in result:
             f.write(res + "\n")
@@ -1933,15 +1992,15 @@
     -------
     bool
 
     """
     product_list_path = os.path.join(install_path, "config", "ProductList.txt")
     if os.path.isfile(product_list_path):
         try:
-            with open(product_list_path, "r") as f:
+            with open_file(product_list_path, "r") as f:
                 install_version = f.readline().strip()[-6:]
                 if install_version == long_version:
                     return True
         except Exception:
             pass
     return False
```

### Comparing `pyaedt-0.8.7/pyaedt/generic/grpc_plugin.py` & `pyaedt-0.8.8/pyaedt/generic/grpc_plugin.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/generic/grpc_plugin_dll.py` & `pyaedt-0.8.8/pyaedt/generic/grpc_plugin_dll.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/generic/ibis_reader.py` & `pyaedt-0.8.8/pyaedt/generic/ibis_reader.py`

 * *Files 0% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 import re
 import traceback
 
 import pyaedt
 from pyaedt.aedt_logger import pyaedt_logger as logger
 from pyaedt.generic.general_methods import check_and_download_file
 from pyaedt.generic.general_methods import check_if_path_exists
-from pyaedt.generic.settings import settings
+from pyaedt.generic.general_methods import open_file
 
 
 class Component:
     """Component extracted from ibis model."""
 
     def __init__(self):
         self._name = None
@@ -795,19 +795,16 @@
         """
 
         if not check_if_path_exists(self._filename):
             raise Exception("{} does not exist.".format(self._filename))
 
         ibis_name = pyaedt.generic.general_methods.get_filename_without_extension(self._filename)
         ibis = Ibis(ibis_name, self._circuit)
-        if settings.remote_rpc_session_temp_folder:
-            local_path = os.path.join(settings.remote_rpc_session_temp_folder, os.path.split(self._filename)[-1])
-            file_to_open = check_and_download_file(local_path, self._filename)
-        else:
-            file_to_open = self._filename
+
+        check_and_download_file(self._filename)
 
         # Read *.ibis file.
         ibis_info = ibis_parsing(self._filename)
         component_selector = [ibis_info[item] for item in ibis_info if "component" in item]
 
         self.read_component(ibis, component_selector)
 
@@ -895,21 +892,18 @@
                         #     model.ModelType = model_spec[iStart:].strip()
                     elif is_started_with(model_spec.lower(), "c_comp"):
                         model.c_comp = model_spec.split()[1:]
 
                     elif is_started_with(model_spec.lower(), "enable ", True):
                         model.enable = model_spec.split()[-1].strip()
 
-            model_info_lower = {key.lower(): value for key, value in model_info.items()}
-
             if "gnd clamp" in [key.lower() for key in model_info.keys()]:
                 model.clamp = True
             if "algorithmic model" in [key.lower() for key in model_info.keys()]:
                 matching_key = next((key for key in model_info.keys() if "algorithmic model" in key.lower()), None)
-                ami_info = model_info[matching_key][matching_key].split()
                 model.ami = model_info[matching_key][matching_key].split()
                 ibis.AMI = True
             else:
                 ibis.AMI = False
 
             ibis.models.append(model)
 
@@ -1218,19 +1212,15 @@
         """
 
         if not check_if_path_exists(self._filename):
             raise Exception("{} does not exist.".format(self._filename))
 
         ami_name = pyaedt.generic.general_methods.get_filename_without_extension(self._filename)
         ibis = AMI(ami_name, self._circuit)
-        if settings.remote_rpc_session_temp_folder:
-            local_path = os.path.join(settings.remote_rpc_session_temp_folder, os.path.split(self._filename)[-1])
-            file_to_open = check_and_download_file(local_path, self._filename)
-        else:
-            file_to_open = self._filename
+        check_and_download_file(self._filename)
 
         # Read *.ibis file.
         ibis_info = ibis_parsing(self._filename)
         component_selector = [ibis_info[item] for item in ibis_info if "component" in item]
 
         self.read_component(ibis, component_selector)
 
@@ -1338,18 +1328,18 @@
     Parameters
     ----------
     file : str
         File name to parse.
     """
     ibis = {}
     # OPEN AND READ IBIS FILE
-    with open(file, "r") as fp:
+    with open_file(file, "r") as fp:
         ibis_data = list(enumerate(fp))
 
-    with open(os.path.join(os.path.dirname(os.path.abspath(__file__)), "ibis_v7.json"), "r") as f:
+    with open_file(os.path.join(os.path.dirname(os.path.abspath(__file__)), "ibis_v7.json"), "r") as f:
         ibis_ref = json.load(f)
     ibis_ref = lowercase_json(ibis_ref)
 
     # FOR EACH LINE
     try:
         level = -1
         key_iter = [0, 0, 0, 0]
```

### Comparing `pyaedt-0.8.7/pyaedt/generic/ibis_v7.json` & `pyaedt-0.8.8/pyaedt/generic/ibis_v7.json`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/generic/near_field_import.py` & `pyaedt-0.8.8/pyaedt/generic/near_field_import.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/generic/pdf.py` & `pyaedt-0.8.8/pyaedt/generic/pdf.py`

 * *Files 1% similar despite different names*

```diff
@@ -4,14 +4,15 @@
 import os
 
 from fpdf import FPDF
 from fpdf import FontFace
 
 from pyaedt import __version__
 from pyaedt.generic.constants import unit_converter
+from pyaedt.generic.general_methods import open_file
 
 
 @dataclass
 class ReportSpec:
     """Data class containing all report template specifications."""
 
     document_prefix: str = "ANSS"
@@ -73,15 +74,15 @@
 
         template_file : str
             Path to the json template file.
         """
         if template_file:
             self.report_specs.template_name = template_file
         if os.path.exists(self.report_specs.template_name):
-            with open(self.report_specs.template_name, "r") as f:
+            with open_file(self.report_specs.template_name, "r") as f:
                 tdata = json.load(f)
             self.report_specs = ReportSpec(**tdata)
 
     def __add_cover_page(self):
         self.add_page("P" if self.use_portrait else "L")
         self.set_font(self.report_specs.font.lower(), "b", self.report_specs.cover_subtitle_font_size)
         self.y += 40
@@ -254,18 +255,17 @@
             stats = design.modeler.edb.get_statistics()
             msg = f"The layout has {stats.num_capacitors} capacitors, {stats.num_resistors} resistors,"
             msg += f"{stats.num_inductors} inductors. The design size is {stats.layout_size}."
             self.add_text(msg)
             msg = f"Furthermore, the layout has {stats.num_nets} nets, {stats.num_traces} traces,"
             msg += f" {stats.num_vias} vias. The stackup total thickness is {stats.stackup_thickness}."
             image_path = os.path.join(design.working_directory, "model.jpg")
-            design.modeler.edb.nets.plot(
-                save_plot=image_path,
-            )
-            self.add_image(image_path, "Model Image")
+            design.modeler.edb.nets.plot(save_plot=image_path)
+            if os.path.exists(image_path):
+                self.add_image(image_path, "Model Image")
         elif design.design_type in ["Circuit Design"]:
             msg = f"The schematic has {len(design.modeler.components.components)} components."
             self.add_text(msg)
 
         if design.setups:
             msg = f"The design has {len(design.setups)} simulation setups."
             self.add_text(msg)
@@ -570,15 +570,15 @@
         self.underline = False
         self.y += 10
         self.set_font(self.report_specs.font, size=12)
 
         for section in self._outline:
             link = self.add_link()
             self.set_link(link, page=section.page_number)
-            string1 = f'{" " * section.level * 2} {section.name}'
+            string1 = f'{" " * section.level * 2} {section.name}'[:70]
             string2 = f"Page {section.page_number}"
             self.set_x(self.l_margin * 2)
             self.cell(
                 w=self.epw - self.l_margin - self.r_margin,
                 h=self.font_size,
                 text=string1,
                 new_x="LMARGIN",
```

### Comparing `pyaedt-0.8.7/pyaedt/generic/plot.py` & `pyaedt-0.8.8/pyaedt/generic/plot.py`

 * *Files 1% similar despite different names*

```diff
@@ -441,15 +441,15 @@
             label = "Trace " + str(label_id)
         if isinstance(plo_obj[0], np.ndarray):
             x = plo_obj[0]
             y = plo_obj[1]
         else:
             x = np.array([i for i, j in zip(plo_obj[0], plo_obj[1]) if j])
             y = np.array([i for i in plo_obj[1] if i])
-        ax.plot(x, y, label=label)
+        ax.plot(x, y)
         label_id += 1
 
     ax.set(xlabel=xlabel, ylabel=ylabel, title=title)
     if show_legend:
         ax.legend()
 
     if snapshot_path:
@@ -1512,22 +1512,27 @@
             )
             self.pv.add_text("Next", position=(50.0, self.pv.window_size[1]), font_size=size // 3, color="grey")
             self.pv.button_widgets.insert(
                 0, self.pv.button_widgets.pop(self.pv.button_widgets.index(self.pv.button_widgets[-1]))
             )
 
     @pyaedt_function_handler()
-    def plot(self, export_image_path=None):
+    def plot(self, export_image_path=None, show=True):
         """Plot the current available Data. With `s` key a screenshot is saved in export_image_path or in tempdir.
 
         Parameters
         ----------
 
-        export_image_path : str
-            Path to image to save.
+        export_image_path : str, optional
+            Path to image to save. Default is None
+        show : bool, optional
+            Whether to display the pyvista plot.
+            When False, a :class::pyvista.Plotter object is created
+            and assigned to the pv property so that it can be
+            modified further. Default is True.
 
         Returns
         -------
         bool
         """
         self.pv = pv.Plotter(notebook=self.is_notebook, off_screen=self.off_screen, window_size=self.windows_size)
         self.pv.enable_ssao()
@@ -1641,17 +1646,17 @@
                 path_image, "{}{}{}".format(root_name, datetime.now().strftime("%Y_%M_%d_%H-%M-%S"), format)
             )
             self.pv.screenshot(exp, return_img=False)
 
         self.pv.add_key_event("s", s_callback)
         if export_image_path:
             self.pv.show(screenshot=export_image_path, full_screen=True)
-        elif self.is_notebook:  # pragma: no cover
+        elif show and self.is_notebook:  # pragma: no cover
             self.pv.show()  # pragma: no cover
-        else:
+        elif show:
             self.pv.show(full_screen=True)  # pragma: no cover
 
         self.image_file = export_image_path
         return True
 
     @pyaedt_function_handler()
     def clean_cache_and_files(self, remove_objs=True, remove_fields=True, clean_cache=False):
```

### Comparing `pyaedt-0.8.7/pyaedt/generic/python_optimizers.py` & `pyaedt-0.8.8/pyaedt/generic/python_optimizers.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/generic/report_file_parser.py` & `pyaedt-0.8.8/pyaedt/generic/report_file_parser.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/generic/settings.py` & `pyaedt-0.8.8/pyaedt/generic/settings.py`

 * *Files 1% similar despite different names*

```diff
@@ -20,14 +20,15 @@
         self._enable_debug_edb_logger = False
         self._enable_debug_grpc_api_logger = False
         self._enable_debug_methods_argument_logger = False
         self._enable_debug_geometry_operator_logger = False
         self._enable_debug_internal_methods_logger = False
         self._enable_debug_logger = False
         self._enable_error_handler = True
+        self._release_on_exception = True
         self._aedt_version = None
         self._aedt_install_dir = None
         self._use_multi_desktop = False
         self.remote_api = False
         self._use_grpc_api = None
         self.formatter = None
         self.remote_rpc_session = None
@@ -69,14 +70,28 @@
         self._number_of_grpc_api_retries = 6
         self._retry_n_times_time_interval = 0.1
         self._wait_for_license = False
         self.__lazy_load = True
         self.__objects_lazy_load = False
 
     @property
+    def release_on_exception(self):
+        """
+
+        Returns
+        -------
+
+        """
+        return self._release_on_exception
+
+    @release_on_exception.setter
+    def release_on_exception(self, value):
+        self._release_on_exception = value
+
+    @property
     def objects_lazy_load(self):
         """Flag for enabling and disabling the lazy load.
         The default is ``True``.
 
         Returns
         -------
         bool
```

### Comparing `pyaedt-0.8.7/pyaedt/generic/spisim.py` & `pyaedt-0.8.8/pyaedt/generic/spisim.py`

 * *Files 2% similar despite different names*

```diff
@@ -11,14 +11,15 @@
 
 from pyaedt import generate_unique_folder_name
 from pyaedt import generate_unique_name
 from pyaedt import is_linux
 from pyaedt import pyaedt_function_handler
 from pyaedt import settings
 from pyaedt.generic.general_methods import env_value
+from pyaedt.generic.general_methods import open_file
 from pyaedt.misc import current_version
 from pyaedt.misc.spisim_com_configuration_files.com_parameters import COMParametersVer3p4
 
 
 class SpiSim:
     """Provides support to SpiSim batch mode."""
 
@@ -69,26 +70,26 @@
         else:
             out_processing = os.path.join(generate_unique_folder_name(), generate_unique_name("spsim_out") + ".txt")
 
         my_env = os.environ.copy()
         my_env.update(settings.aedt_environment_variables)
         if is_linux:  # pragma: no cover
             command.append("&")
-            with open(out_processing, "w") as outfile:
+            with open_file(out_processing, "w") as outfile:
                 subprocess.Popen(command, env=my_env, stdout=outfile, stderr=outfile).wait()  # nosec
         else:
-            with open(out_processing, "w") as outfile:
+            with open_file(out_processing, "w") as outfile:
                 subprocess.Popen(" ".join(command), env=my_env, stdout=outfile, stderr=outfile).wait()  # nosec
         return out_processing
 
     @pyaedt_function_handler()
     def _get_output_parameter_from_result(self, out_file, parameter_name):
         if parameter_name == "ERL":
             try:
-                with open(out_file, "r") as infile:
+                with open_file(out_file, "r") as infile:
                     lines = infile.read()
                     parmDat = lines.split("[ParmDat]:", 1)[1]
                     for keyValu in parmDat.split(","):
                         dataAry = keyValu.split("=")
                         if dataAry[0].strip().lower() == parameter_name.lower():
                             return float(dataAry[1].strip().split()[0])
                 self.logger.error(
@@ -96,15 +97,15 @@
                 )  # pragma: no cover
                 return False  # pragma: no cover
             except IndexError:
                 self.logger.error("Failed to compute {}. Check input parameters and retry".format(parameter_name))
                 return False
         elif parameter_name == "COM":
             try:
-                with open(out_file, "r") as infile:
+                with open_file(out_file, "r") as infile:
                     txt = infile.read()
                 i = 0
                 com_results = []
                 while True:
                     m = re.search(r"Case {}: Calculated COM = (.*?),".format(i), txt)
                     if m:
                         com_results.append(float(m.groups()[0]))
@@ -197,15 +198,15 @@
             "INPVOLT": 1.0,
             "TRSTIME": "10p",
             "SIGBETA": 1.7e9,
             "REFLRHO": 0.18,
             "NCYCLES": 1000,
         }
         if config_file:
-            with open(config_file, "r") as fp:
+            with open_file(config_file, "r") as fp:
                 lines = fp.readlines()
                 for line in lines:
                     if not line.startswith("#") and "=" in line:
                         split_line = [i.strip() for i in line.split("=")]
                         cfg_dict[split_line[0]] = split_line[1]
 
         self.touchstone_file = self.touchstone_file.replace("\\", "/")
@@ -235,15 +236,15 @@
         cfg_dict["INPVOLT"] = input_amplitude if input_amplitude is not None else cfg_dict["INPVOLT"]
         cfg_dict["TRSTIME"] = transition_time if transition_time is not None else cfg_dict["TRSTIME"]
         cfg_dict["SIGBETA"] = signal_loss_factor if signal_loss_factor is not None else cfg_dict["SIGBETA"]
         cfg_dict["REFLRHO"] = permitted_reflection if permitted_reflection is not None else cfg_dict["REFLRHO"]
         cfg_dict["NCYCLES"] = reflections_length if reflections_length is not None else cfg_dict["NCYCLES"]
 
         new_cfg_file = os.path.join(self.working_directory, "spisim_erl.cfg").replace("\\", "/")
-        with open(new_cfg_file, "w") as fp:
+        with open_file(new_cfg_file, "w") as fp:
             for k, v in cfg_dict.items():
                 fp.write("# {}: {}\n".format(k, k))
                 fp.write("{} = {}\n".format(k, v))
         retries = 3
         trynumb = 0
         while trynumb < retries:
             out_processing = self._compute_spisim(
@@ -367,15 +368,15 @@
         return COMParametersVer3p4(standard).export(file_path)
 
 
 def detect_encoding(file_path, expected_pattern="", re_flags=0):
     """Check encoding of a file."""
     for encoding in ("utf-8", "utf_16_le", "cp1252", "cp1250", "shift_jis"):
         try:
-            with open(file_path, "r", encoding=encoding) as f:
+            with open_file(file_path, "r", encoding=encoding) as f:
                 lines = f.read()
                 f.seek(0)
         except UnicodeDecodeError:
             # This encoding didn't work, let's try again
             continue
         else:
             if len(lines) == 0:
```

### Comparing `pyaedt-0.8.7/pyaedt/generic/touchstone_parser.py` & `pyaedt-0.8.8/pyaedt/generic/touchstone_parser.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/hfss.py` & `pyaedt-0.8.8/pyaedt/hfss.py`

 * *Files 6% similar despite different names*

```diff
@@ -6,14 +6,15 @@
 from collections import OrderedDict
 import math
 import os
 import tempfile
 import warnings
 
 from pyaedt.application.Analysis3D import FieldAnalysis3D
+from pyaedt.application.analysis_hf import ScatteringMethods
 from pyaedt.generic.DataHandlers import _dict2arg
 from pyaedt.generic.DataHandlers import str_to_bool
 from pyaedt.generic.constants import INFINITE_SPHERE_TYPE
 from pyaedt.generic.general_methods import generate_unique_name
 from pyaedt.generic.general_methods import open_file
 from pyaedt.generic.general_methods import parse_excitation_file
 from pyaedt.generic.general_methods import pyaedt_function_handler
@@ -26,15 +27,15 @@
 from pyaedt.modules.Boundary import BoundaryObject
 from pyaedt.modules.Boundary import FarFieldSetup
 from pyaedt.modules.Boundary import NativeComponentObject
 from pyaedt.modules.Boundary import NearFieldSetup
 from pyaedt.modules.SetupTemplates import SetupKeys
 
 
-class Hfss(FieldAnalysis3D, object):
+class Hfss(FieldAnalysis3D, ScatteringMethods):
     """Provides the HFSS application interface.
 
     This class allows you to create an interactive instance of HFSS and
     connect to an existing HFSS design or create a new HFSS design if
     one does not exist.
 
     Parameters
@@ -188,14 +189,15 @@
             new_desktop_session,
             close_on_exit,
             student_version,
             machine,
             port,
             aedt_process_id,
         )
+        ScatteringMethods.__init__(self, self)
         self._field_setups = []
         self.component_array = {}
         self.component_array_names = list(self.get_oo_name(self.odesign, "Model"))
         for component_array in self.component_array_names:
             self.component_array[component_array] = ComponentArray(self, component_array)
 
     def _init_from_design(self, *args, **kwargs):
@@ -266,40 +268,40 @@
         """
         return self.design_solutions.composite
 
     @composite.setter
     def composite(self, value):
         self.design_solutions.composite = value
 
-    @pyaedt_function_handler()
-    def set_auto_open(self, enable=True, boundary_type="Radiation"):
+    @pyaedt_function_handler(boundary_type="opening_type")
+    def set_auto_open(self, enable=True, opening_type="Radiation"):
         """Set the HFSS auto open type.
 
         Parameters
         ----------
         enable : bool, optional
             Whether to enable the HFSS auto open option. The default is ``True``.
-        boundary_type : str, optional
+        opening_type : str, optional
             Boundary type to use with auto open. Options are ``"Radiation"``,
             ``"FEBI"``, and ``"PML"``. The default is ``"Radiation"``.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         Examples
         --------
         Enable auto open type for the PML boundary.
 
-        >>> hfss.set_auto_open(True, "PML")
+        >>> hfss.set_auto_open(True,"PML")
         """
-        if enable and boundary_type not in ["Radiation", "FEBI", "PML"]:
+        if enable and opening_type not in ["Radiation", "FEBI", "PML"]:
             raise AttributeError("Wrong boundary type. Check Documentation for valid inputs")
-        return self.design_solutions.set_auto_open(enable=enable, boundary_type=boundary_type)
+        return self.design_solutions.set_auto_open(enable=enable, opening_type=opening_type)
 
     @pyaedt_function_handler()
     def _get_unique_source_name(self, source_name, root_name):
         if not source_name:
             source_name = generate_unique_name(root_name)
         elif source_name in self.excitations or source_name + ":1" in self.excitations:
             source_name = generate_unique_name(source_name)
@@ -356,23 +358,24 @@
             self._boundaries[bound.name] = bound
             self.logger.info("Boundary %s %s has been correctly created.", boundary_type, name)
             return bound
         self.logger.error("Error in boundary creation for %s %s.", boundary_type, name)
 
         return result
 
-    @pyaedt_function_handler()
-    def _create_lumped_driven(self, objectname, int_line_start, int_line_stop, impedance, portname, renorm, deemb):
+    @pyaedt_function_handler(objectname="assignment", portname="port_name")
+    def _create_lumped_driven(self, assignment, int_line_start, int_line_stop, impedance, port_name, renorm, deemb):
+        assignment = self.modeler.convert_to_selections(assignment, True)
         start = [str(i) + self.modeler.model_units for i in int_line_start]
         stop = [str(i) + self.modeler.model_units for i in int_line_stop]
         props = OrderedDict({})
-        if isinstance(objectname, str):
-            props["Objects"] = [objectname]
+        if isinstance(assignment[0], str):
+            props["Objects"] = assignment
         else:
-            props["Faces"] = [objectname]
+            props["Faces"] = assignment
         props["DoDeembed"] = deemb
         props["RenormalizeAllTerminals"] = renorm
         if renorm:
             props["Modes"] = OrderedDict(
                 {
                     "Mode1": OrderedDict(
                         {
@@ -399,36 +402,36 @@
                         }
                     )
                 }
             )
         props["ShowReporterFilter"] = False
         props["ReporterFilter"] = [True]
         props["Impedance"] = str(impedance) + "ohm"
-        return self._create_boundary(portname, props, "Lumped Port")
+        return self._create_boundary(port_name, props, "Lumped Port")
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(objectname="assignment", portname="port_name")
     def _create_port_terminal(
         self,
-        objectname,
+        assignment,
         int_line_stop,
-        portname,
+        port_name,
         renorm=True,
         deembed=None,
         iswaveport=False,
         impedance=None,
         terminals_rename=True,
     ):
         ref_conductors = self.modeler.convert_to_selections(int_line_stop, True)
         props = OrderedDict()
-        props["Faces"] = int(objectname)
+        props["Faces"] = int(assignment)
         props["IsWavePort"] = iswaveport
         props["ReferenceConductors"] = ref_conductors
         props["RenormalizeModes"] = True
         ports = list(self.oboundary.GetExcitationsOfType("Terminal"))
-        boundary = self._create_boundary(portname, props, "AutoIdentify")
+        boundary = self._create_boundary(port_name, props, "AutoIdentify")
         if boundary:
             new_ports = list(self.oboundary.GetExcitationsOfType("Terminal"))
             terminals = [i for i in new_ports if i not in ports]
             for count, terminal in enumerate(terminals, start=1):
                 props_terminal = OrderedDict()
                 props_terminal["TerminalResistance"] = "50ohm"
                 props_terminal["ParentBndID"] = boundary.name
@@ -464,15 +467,15 @@
                         ],
                     ]
                     try:
                         self.odesign.ChangeProperty(properties)
                     except Exception:  # pragma: no cover
                         self.logger.warning("Failed to change normalization.")
                 if terminals_rename:
-                    new_name = portname + "_T" + str(count)
+                    new_name = port_name + "_T" + str(count)
                     terminal_name = new_name
                     properties = [
                         "NAME:AllTabs",
                         [
                             "NAME:HfssTab",
                             ["NAME:PropServers", "BoundarySetup:" + terminal],
                             ["NAME:ChangedProps", ["NAME:Name", "Value:=", new_name]],
@@ -485,15 +488,15 @@
                 bound = BoundaryObject(self, terminal_name, props_terminal, "Terminal")
                 self._boundaries[terminal_name] = bound
 
             if iswaveport:
                 boundary.type = "Wave Port"
             else:
                 boundary.type = "Lumped Port"
-            props["Faces"] = [objectname]
+            props["Faces"] = [assignment]
             if iswaveport:
                 props["NumModes"] = 1
                 props["UseLineModeAlignment"] = 1
             if deembed is None:
                 props["DoDeembed"] = False
                 if iswaveport:
                     props["DeembedDist"] = self.modeler._arg_with_dim(0)
@@ -507,17 +510,17 @@
             boundary.auto_update = False
             boundary.props.update(props)
             boundary.auto_update = True
             boundary.update()
 
         return boundary
 
-    @pyaedt_function_handler()
-    def _create_circuit_port(self, edgelist, impedance, name, renorm, deemb, renorm_impedance=""):
-        edgelist = self.modeler.convert_to_selections(edgelist, True)
+    @pyaedt_function_handler(edgelist="assignment")
+    def _create_circuit_port(self, assignment, impedance, name, renorm, deemb, renorm_impedance=""):
+        edgelist = self.modeler.convert_to_selections(assignment, True)
         props = OrderedDict(
             {
                 "Edges": edgelist,
                 "Impedance": str(impedance) + "ohm",
                 "DoDeembed": deemb,
                 "RenormalizeAllTerminals": renorm,
             }
@@ -532,54 +535,52 @@
             else:
                 renorm_imp = "0ohm"
             props["RenormImp"] = renorm_imp
         else:
             props["TerminalIDList"] = []
         return self._create_boundary(name, props, "Circuit Port")
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(objectname="assignment", portname="port_name")
     def _create_waveport_driven(
         self,
-        objectname,
+        assignment,
         int_line_start=None,
         int_line_stop=None,
         impedance=50,
-        portname="",
+        port_name="",
         renorm=True,
         nummodes=1,
         deemb_distance=0,
     ):
         start = None
         stop = None
         if int_line_start and int_line_stop:  # Allow non-numeric arguments
             start = [str(i) + self.modeler.model_units if type(i) in (int, float) else i for i in int_line_start]
             stop = [str(i) + self.modeler.model_units if type(i) in (int, float) else i for i in int_line_stop]
             useintline = True
         else:
             useintline = False
 
         props = OrderedDict({})  # Used to create the argument to pass to native api: oModule.AssignWavePort()
-        if isinstance(objectname, int):  # Assumes a Face ID is passed in objectname
-            props["Faces"] = [objectname]
-        elif isinstance(objectname, list):  # Assume [x, y, z] point is passed in objectname
-            props["Faces"] = self.modeler.get_faceid_from_position(objectname)
+        if isinstance(assignment, int):  # Assumes a Face ID is passed in objectname
+            props["Faces"] = [assignment]
+        elif isinstance(assignment, list):  # Assume [x, y, z] point is passed in objectname
+            props["Faces"] = self.modeler.get_faceid_from_position(assignment)
         else:
-            props["Objects"] = [objectname]
+            props["Objects"] = [assignment]
         props["NumModes"] = nummodes
         props["UseLineModeAlignment"] = False
 
         if deemb_distance != 0:
             props["DoDeembed"] = True
             props["DeembedDist"] = self.modeler._arg_with_dim(deemb_distance)
         else:
             props["DoDeembed"] = False
         props["RenormalizeAllTerminals"] = renorm
         modes = OrderedDict({})
-        arg2 = []
-        arg2.append("NAME:Modes")
         i = 1
         report_filter = []
         while i <= nummodes:
             if i == 1:
                 mode = OrderedDict({})
                 mode["ModeNum"] = i
                 mode["UseIntLine"] = useintline
@@ -602,66 +603,83 @@
                 modes["Mode" + str(i)] = mode
             report_filter.append(True)
             i += 1
         props["Modes"] = modes
         props["ShowReporterFilter"] = False
         props["ReporterFilter"] = report_filter
         props["UseAnalyticAlignment"] = False
-        return self._create_boundary(portname, props, "Wave Port")
+        return self._create_boundary(port_name, props, "Wave Port")
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(
+        obj="assignment",
+        mat="material",
+        cond="conductivity",
+        perm="permittivity",
+        usethickness="use_thickness",
+        isinfgnd="is_infinite_ground",
+        istwoside="is_two_side",
+        isInternal="is_internal",
+        issheelElement="is_shell_element",
+        usehuray="use_huray",
+    )
     def assign_coating(
         self,
-        obj,
-        mat=None,
-        cond=58000000,
-        perm=1,
-        usethickness=False,
+        assignment,
+        material=None,
+        conductivity=58000000,
+        permittivity=1,
+        use_thickness=False,
         thickness="0.1mm",
         roughness="0um",
-        isinfgnd=False,
-        istwoside=False,
-        isInternal=True,
-        issheelElement=False,
-        usehuray=False,
+        is_infinite_ground=False,
+        is_two_side=False,
+        is_internal=True,
+        is_shell_element=False,
+        use_huray=False,
         radius="0.5um",
         ratio="2.9",
+        name=None,
     ):
         """Assign finite conductivity to one or more objects or faces of a given material.
 
         Parameters
         ----------
-        obj : str or list
+        assignment : str or list
             One or more objects or faces to assign finite conductivity to.
-        mat : str, optional
+        material : str, optional
             Material to use. The default is ``None``.
-        cond : float, optional
-            If no material is provided, a conductivity value must be supplied. The default is ``58000000``.
-        perm : float, optional
-            If no material is provided, a permittivity value must be supplied. The default is ``1``.
-        usethickness : bool, optional
+        conductivity : float, optional
+            Conductivity. The default is ``58000000``.
+            If no material is provided, a value must be supplied.
+        permittivity : float, optional
+            Permittivity. The default is ``1``. If no
+            material is provided, a value must be supplied.
+        use_thickness : bool, optional
             Whether to use thickness. The default is ``False``.
         thickness : str, optional
             Thickness value if ``usethickness=True``. The default is ``"0.1mm"``.
         roughness : str, optional
             Roughness value  with units. The default is ``"0um"``.
-        isinfgnd : bool, optional
+        is_infinite_ground : bool, optional
             Whether the finite conductivity is an infinite ground. The default is ``False``.
-        istwoside : bool, optional
+        is_two_side : bool, optional
             Whether the finite conductivity is two-sided. The default is ``False``.
-        isInternal : bool, optional
+        is_internal : bool, optional
             Whether the finite conductivity is internal. The default is ``True``.
-        issheelElement : bool, optional
+        is_shell_element : bool, optional
+            Whether the finite conductivity is a shell element.
             The default is ``False``.
-        usehuray : bool, optional
-            Whether to use an Huray coefficient. The default is ``False``.
+        use_huray : bool, optional
+            Whether to use a Huray coefficient. The default is ``False``.
         radius : str, optional
             Radius value if ``usehuray=True``. The default is ``"0.5um"``.
         ratio : str, optional
             Ratio value if ``usehuray=True``. The default is ``"2.9"``.
+        name : str
+            Name of the boundary.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject`
             Boundary object.
 
         References
@@ -670,28 +688,29 @@
         >>> oModule.AssignFiniteCond
 
         Examples
         --------
 
         Create two cylinders in the XY working plane and assign a copper coating of 0.2 mm to the inner cylinder and
         outer face.
+
         >>> from pyaedt import Hfss
         >>> hfss = Hfss()
         >>> origin = hfss.modeler.Position(0, 0, 0)
         >>> inner = hfss.modeler.create_cylinder(
         ...     hfss.PLANE.XY, origin, 3, 200, 0, "inner"
         ... )
         >>> outer = hfss.modeler.create_cylinder(
         ...     hfss.PLANE.XY, origin, 4, 200, 0, "outer"
         ... )
-        >>> coat = hfss.assign_coating(["inner", outer.faces[2].id], "copper", usethickness=True, thickness="0.2mm")
+        >>> coat = hfss.assign_coating(["inner", outer.faces[2].id], "copper", use_thickness=True, thickness="0.2mm")
 
         """
 
-        userlst = self.modeler.convert_to_selections(obj, True)
+        userlst = self.modeler.convert_to_selections(assignment, True)
         lstobj = []
         lstface = []
         for selection in userlst:
             if selection in self.modeler.model_objects:
                 lstobj.append(selection)
             elif isinstance(selection, int) and self.modeler._find_object_from_face_id(selection):
                 lstface.append(selection)
@@ -704,70 +723,68 @@
         if lstobj:
             listobjname = listobjname + "_" + "_".join(lstobj)
             props["Objects"] = lstobj
         if lstface:
             props["Faces"] = lstface
             lstface = [str(i) for i in lstface]
             listobjname = listobjname + "_" + "_".join(lstface)
-        if mat:
-            if self.materials[mat]:
+        if material:
+            if self.materials[material]:
                 props["UseMaterial"] = True
-                props["Material"] = self.materials[mat].name
+                props["Material"] = self.materials[material].name
             else:
                 return False
         else:
             props["UseMaterial"] = False
-            props["Conductivity"] = str(cond)
-            props["Permeability"] = str(str(perm))
-        props["UseThickness"] = usethickness
-        if usethickness:
+            props["Conductivity"] = str(conductivity)
+            props["Permeability"] = str(str(permittivity))
+        props["UseThickness"] = use_thickness
+        if use_thickness:
             props["Thickness"] = thickness
-        if usehuray:
+        if use_huray:
             props["Radius"] = str(radius)
             props["Ratio"] = str(ratio)
             props["InfGroundPlane"] = False
         else:
             props["Roughness"] = roughness
-            props["InfGroundPlane"] = isinfgnd
-        props["IsTwoSided"] = istwoside
+            props["InfGroundPlane"] = is_infinite_ground
+        props["IsTwoSided"] = is_two_side
 
-        if istwoside:
-            props["IsShellElement"] = issheelElement
+        if is_two_side:
+            props["IsShellElement"] = is_shell_element
         else:
-            props["IsInternal"] = isInternal
-        return self._create_boundary("Coating_" + listobjname[1:], props, "Finite Conductivity")
-
-    # TODO: Extract name and type from **kwargs to pass them to create_setup() as setuptype and setupname
+            props["IsInternal"] = is_internal
+        if not name:
+            name = "Coating_" + listobjname[1:]
+        return self._create_boundary(name, props, "Finite Conductivity")
 
-    @pyaedt_function_handler()
-    def create_setup(self, setupname="MySetupAuto", setuptype=None, **kwargs):
+    @pyaedt_function_handler(setupname="name", setuptype="setup_type")
+    def create_setup(self, name="MySetupAuto", setup_type=None, **kwargs):
         """Create an analysis setup for HFSS.
-        Optional arguments are passed along with ``setuptype`` and ``setupname``.  Keyword
-        names correspond to the ``setuptype``
-        corresponding to the native AEDT API.  The list of
-        keywords here is not exhaustive.
+        Optional arguments are passed along with ``setup_type`` and ``name``. Keyword
+        names correspond to the ``setup_type`` corresponding to the native AEDT API.
+        The list of keywords here is not exhaustive.
 
         .. note::
            This method overrides the ``Analysis.setup()`` method for the HFSS app.
 
         Parameters
         ----------
-        setuptype : str, optional
-            Type of the setup. Based on the solution type, options are
+        name : str, optional
+            Name of the setup. The default is ``"Setup1"``.
+        setup_type : str, optional
+            Type of the setup, which is based on the solution type. Options are
             ``"HFSSDrivenAuto"``, ``"HFSSDrivenDefault"``, ``"HFSSEigen"``, ``"HFSSTransient"``,
             and ``"HFSSSBR"``. The default is ``"HFSSDrivenAuto"``.
-        setupname : str, optional
-            Name of the setup. The default is ``"Setup1"``.
         **kwargs : dict, optional
             Extra arguments to set up the circuit.
             Available keys depend on the setup chosen.
             For more information, see
             :doc:`../SetupTemplatesHFSS`.
 
-
         Returns
         -------
         :class:`pyaedt.modules.SolveSetup.SetupHFSS`, :class:`pyaedt.modules.SolveSetup.SetupHFSSAuto`
             3D Solver Setup object.
 
         References
         ----------
@@ -775,22 +792,22 @@
         >>> oModule.InsertSetup
 
         Examples
         --------
 
         >>> from pyaedt import Hfss
         >>> hfss = Hfss()
-        >>> hfss.create_setup(setupname="Setup1", setuptype="HFSSDriven", Frequency="10GHz")
+        >>> hfss.create_setup(name="Setup1",setup_type="HFSSDriven",Frequency="10GHz")
 
         """
-        if setuptype is None:
-            setuptype = self.design_solutions.default_setup
-        elif setuptype in SetupKeys.SetupNames:
-            setuptype = SetupKeys.SetupNames.index(setuptype)
-        setup = self._create_setup(setupname=setupname, setuptype=setuptype)
+        if setup_type is None:
+            setup_type = self.design_solutions.default_setup
+        elif setup_type in SetupKeys.SetupNames:
+            setup_type = SetupKeys.SetupNames.index(setup_type)
+        setup = self._create_setup(name=name, setup_type=setup_type)
         setup.auto_update = False
         for arg_name, arg_value in kwargs.items():
             if setup[arg_name] is not None:
                 if arg_name == "MultipleAdaptiveFreqsSetup":
                     setup[arg_name].delete_all()
                     if isinstance(arg_value, list):
                         for i in arg_value:
@@ -801,48 +818,50 @@
                     setup.props["SolveType"] = "MultiFrequency"
                 else:
                     setup[arg_name] = arg_value
         setup.auto_update = True
         setup.update()
         return setup
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(
+        setupname="setup", unit="units", freqstart="start_frequency", freqstop="stop_frequency", sweepname="name"
+    )
     def create_linear_count_sweep(
         self,
-        setupname,
-        unit,
-        freqstart,
-        freqstop,
+        setup,
+        units,
+        start_frequency,
+        stop_frequency,
         num_of_freq_points=None,
-        sweepname=None,
+        name=None,
         save_fields=True,
         save_rad_fields=False,
         sweep_type="Discrete",
         interpolation_tol=0.5,
         interpolation_max_solutions=250,
     ):
         """Create a sweep with a specified number of points.
 
         Parameters
         ----------
-        setupname : str
+        setup : str
             Name of the setup.
-        unit : str
+        units : str
             Unit of the frequency. For example, ``"MHz"`` or ``"GHz"``.
-        freqstart : float
+        start_frequency : float
             Starting frequency of the sweep, such as ``1``.
-        freqstop : float
+        stop_frequency : float
             Stopping frequency of the sweep.
         num_of_freq_points : int
             Number of frequency points in the range.
             The default is ``401`` for ``sweep_type = "Interpolating"``. The defaults
             are "Fast"`` and ``5`` for ``sweep_type = ""Discrete"``.
-        sweepname : str, optional
+        name : str, optional
             Name of the sweep. The default is ``None``, in which
-            case the default name is automatically assigned.
+            case a name is automatically assigned.
         save_fields : bool, optional
             Whether to save the fields. The default is ``True``.
         save_rad_fields : bool, optional
             Whether to save the radiating fields. The default is ``False``.
         sweep_type : str, optional
             Type of the sweep. Options are ``"Fast"``, ``"Interpolating"``,
             and ``"Discrete"``. The default is ``"Discrete"``.
@@ -866,18 +885,15 @@
         Examples
         --------
 
         Create a setup named ``"LinearCountSetup"`` and use it in a linear count sweep
         named ``"LinearCountSweep"``.
 
         >>> setup = hfss.create_setup("LinearCountSetup")
-        >>> linear_count_sweep = hfss.create_linear_count_sweep(setupname="LinearCountSetup",
-        ...                                                     sweepname="LinearCountSweep",
-        ...                                                     unit="MHz", freqstart=1.1e3,
-        ...                                                     freqstop=1200.1, num_of_freq_points=1658)
+        >>> linear_count_sweep = hfss.create_linear_count_sweep(,,,
         >>> type(linear_count_sweep)
         <class 'pyaedt.modules.SetupTemplates.SweepHFSS'>
 
         """
         if sweep_type in ["Interpolating", "Fast"]:
             if num_of_freq_points == None:
                 num_of_freq_points = 401
@@ -885,77 +901,78 @@
             if num_of_freq_points == None:
                 num_of_freq_points = 5
         else:
             raise AttributeError(
                 "Invalid value for `sweep_type`. The value must be 'Discrete', 'Interpolating', or 'Fast'."
             )
 
-        if sweepname is None:
-            sweepname = generate_unique_name("Sweep")
+        if name is None:
+            name = generate_unique_name("Sweep")
 
-        if setupname not in self.setup_names:
+        if setup not in self.setup_names:
             return False
         for s in self.setups:
-            if s.name == setupname:
+            if s.name == setup:
                 setupdata = s
-                if sweepname in [sweep.name for sweep in setupdata.sweeps]:
-                    oldname = sweepname
-                    sweepname = generate_unique_name(oldname)
-                    self.logger.warning(
-                        "Sweep %s is already present. Sweep has been renamed in %s.", oldname, sweepname
-                    )
-                sweepdata = setupdata.add_sweep(sweepname, sweep_type)
+                if name in [sweep.name for sweep in setupdata.sweeps]:
+                    oldname = name
+                    name = generate_unique_name(oldname)
+                    self.logger.warning("Sweep %s is already present. Sweep has been renamed in %s.", oldname, name)
+                sweepdata = setupdata.add_sweep(name, sweep_type)
                 if not sweepdata:
                     return False
                 sweepdata.props["RangeType"] = "LinearCount"
-                sweepdata.props["RangeStart"] = str(freqstart) + unit
-                sweepdata.props["RangeEnd"] = str(freqstop) + unit
+                sweepdata.props["RangeStart"] = str(start_frequency) + units
+                sweepdata.props["RangeEnd"] = str(stop_frequency) + units
                 sweepdata.props["RangeCount"] = num_of_freq_points
                 sweepdata.props["Type"] = sweep_type
                 if sweep_type == "Interpolating":
                     sweepdata.props["InterpTolerance"] = interpolation_tol
                     sweepdata.props["InterpMaxSolns"] = interpolation_max_solutions
                     sweepdata.props["InterpMinSolns"] = 0
                     sweepdata.props["InterpMinSubranges"] = 1
                 sweepdata.props["SaveFields"] = save_fields
                 sweepdata.props["SaveRadFields"] = save_rad_fields
                 sweepdata.update()
-                self.logger.info("Linear count sweep {} has been correctly created.".format(sweepname))
+                self.logger.info("Linear count sweep {} has been correctly created.".format(name))
                 return sweepdata
         return False
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(
+        setupname="setup", freqstart="start_frequency", freqstop="stop_frequency", sweepname="name"
+    )
     def create_linear_step_sweep(
         self,
-        setupname,
+        setup,
         unit,
-        freqstart,
-        freqstop,
+        start_frequency,
+        stop_frequency,
         step_size,
-        sweepname=None,
+        name=None,
         save_fields=True,
         save_rad_fields=False,
         sweep_type="Discrete",
     ):
         """Create a sweep with a specified frequency step.
 
         Parameters
         ----------
-        setupname : str
+        setup : str
             Name of the setup.
         unit : str
             Unit of the frequency. For example, ``"MHz"`` or ``"GHz"``.
-        freqstart : float
+        start_frequency : float
             Starting frequency of the sweep.
-        freqstop : float
+        stop_frequency : float
             Stopping frequency of the sweep.
         step_size : float
             Frequency size of the step.
-        sweepname : str, optional
-            Name of the sweep. The default is ``None``.
+        name : str, optional
+            Name of the sweep. The default is ``None``, in
+            which case a name is automatically assigned.
         save_fields : bool, optional
             Whether to save fields. The default is ``True``.
         save_rad_fields : bool, optional
             Whether to save radiating fields. The default is ``False``.
         sweep_type : str, optional
             Type of the sweep. Options are ``"Discrete"``,``"Interpolating"`` and
             ``"Fast"``. The default is ``"Discrete"``.
@@ -973,68 +990,70 @@
         Examples
         --------
 
         Create a setup named ``"LinearStepSetup"`` and use it in a linear step sweep
         named ``"LinearStepSweep"``.
 
         >>> setup = hfss.create_setup("LinearStepSetup")
-        >>> linear_step_sweep = hfss.create_linear_step_sweep(setupname="LinearStepSetup",
-        ...                                                   sweepname="LinearStepSweep",
-        ...                                                   unit="MHz", freqstart=1.1e3,
-        ...                                                   freqstop=1200.1, step_size=153.8)
+        >>> linear_step_sweep = hfss.create_linear_step_sweep(setup="LinearStepSetup", unit="MHz",
+        ...                                                   start_frequency=1.1e3, stop_frequency=1200.1,
+        ...                                                   step_size=153.8)
         >>> type(linear_step_sweep)
         <class 'pyaedt.modules.SetupTemplates.SweepHFSS'>
 
         """
         if sweep_type not in ["Discrete", "Interpolating", "Fast"]:
             raise AttributeError(
                 "Invalid value for `sweep_type`. The value must be 'Discrete', 'Interpolating', or 'Fast'."
             )
-        if sweepname is None:
-            sweepname = generate_unique_name("Sweep")
+        if name is None:
+            sweep_name = generate_unique_name("Sweep")
+        else:
+            sweep_name = name
 
-        if setupname not in self.setup_names:
+        if setup not in self.setup_names:
             return False
         for s in self.setups:
-            if s.name == setupname:
+            if s.name == setup:
                 return s.create_linear_step_sweep(
                     unit=unit,
-                    freqstart=freqstart,
-                    freqstop=freqstop,
+                    start_frequency=start_frequency,
+                    stop_frequency=stop_frequency,
                     step_size=step_size,
-                    sweepname=sweepname,
+                    name=sweep_name,
                     save_fields=save_fields,
                     save_rad_fields=save_rad_fields,
                     sweep_type=sweep_type,
                 )
         return False
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(setupname="setup", sweepname="name")
     def create_single_point_sweep(
         self,
-        setupname,
+        setup,
         unit,
         freq,
-        sweepname=None,
+        name=None,
         save_single_field=True,
         save_fields=False,
         save_rad_fields=False,
     ):
         """Create a sweep with a single frequency point.
 
         Parameters
         ----------
-        setupname : str
+        setup : str
             Name of the setup.
         unit : str
             Unit of the frequency. For example, ``"MHz"`` or ``"GHz"``.
         freq : float, list
             Frequency of the single point or list of frequencies to create distinct single points.
-        sweepname : str, optional
-            Name of the sweep. The default is ``None``.
+        name : str, optional
+            Name of the sweep. The default is ``None``, in
+            which case a name is automatically assigned.
         save_single_field : bool, list, optional
             Whether to save the fields of the single point. The default is ``True``.
             If a list is specified, the length must be the same as the list of frequencies.
         save_fields : bool, optional
             Whether to save fields for all points and subranges defined in the sweep.
             The default is ``False``.
         save_rad_fields : bool, optional
@@ -1053,97 +1072,101 @@
         Examples
         --------
 
         Create a setup named ``"LinearStepSetup"`` and use it in a single point sweep
         named ``"SinglePointSweep"``.
 
         >>> setup = hfss.create_setup("LinearStepSetup")
-        >>> single_point_sweep = hfss.create_single_point_sweep(setupname="LinearStepSetup",
-        ...                                                   sweepname="SinglePointSweep",
-        ...                                                   unit="MHz", freq=1.1e3)
+        >>> single_point_sweep = hfss.create_single_point_sweep(setup="LinearStepSetup",unit="MHz",freq=1.1e3)
         >>> type(single_point_sweep)
         <class 'pyaedt.modules.SetupTemplates.SweepHFSS'>
 
         """
-        if sweepname is None:
-            sweepname = generate_unique_name("SinglePoint")
+        if name is None:
+            sweep_name = generate_unique_name("SinglePoint")
+        else:
+            sweep_name = name
 
         if isinstance(save_single_field, list):
             if not isinstance(freq, list) or len(save_single_field) != len(freq):
                 raise AttributeError("The length of save_single_field must be the same as the frequency length.")
 
         add_subranges = False
         if isinstance(freq, list):
             if not freq:
                 raise AttributeError("Frequency list is empty. Specify at least one frequency point.")
-            freq0 = freq.pop(0)
+            _ = freq.pop(0)
             if freq:
                 add_subranges = True
-        else:
-            freq0 = freq
 
         if isinstance(save_single_field, list):
-            save0 = save_single_field.pop(0)
+            _ = save_single_field.pop(0)
         else:
             save0 = save_single_field
             if add_subranges:
                 save_single_field = [save0] * len(freq)
 
-        if setupname not in self.setup_names:
+        if setup not in self.setup_names:
             return False
         for s in self.setups:
-            if s.name == setupname:
+            if s.name == setup:
                 return s.create_single_point_sweep(
                     unit=unit,
                     freq=freq,
-                    sweepname=sweepname,
+                    name=sweep_name,
                     save_single_field=save_single_field,
                     save_fields=save_fields,
                     save_rad_fields=save_rad_fields,
                 )
         return False
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(source_object="assignment", solution="setup", fieldtype="field_type", source_name="name")
     def create_sbr_linked_antenna(
         self,
-        source_object,
+        assignment,
         target_cs="Global",
-        solution=None,
-        fieldtype="nearfield",
+        setup=None,
+        field_type="nearfield",
         use_composite_ports=False,
         use_global_current=True,
-        current_conformance="Disable",
+        current_conformance=False,
         thin_sources=True,
         power_fraction="0.95",
         visible=True,
+        name=None,
     ):
         """Create a linked antennas.
 
         Parameters
         ----------
-        source_object : pyaedt.Hfss
+        assignment : pyaedt.Hfss
             Source object.
         target_cs : str, optional
             Target coordinate system. The default is ``"Global"``.
-        solution : optional
-            The default is ``None``.
-        fieldtype : str, optional
+        setup : optional
+            Name of the setup. The default is ``None``, in which
+            case a name is automatically assigned.
+        field_type : str, optional
+            Field type. The options are ``"nearfield"`` and ``"farfield"``.
             The default is ``"nearfield"``.
         use_composite_ports : bool, optional
             Whether to use composite ports. The default is ``False``.
         use_global_current : bool, optional
             Whether to use the global current. The default is ``True``.
-        current_conformance, str optional
-            The default is ``"Disable"``.
+        current_conformance : bool, optional
+            Whether to enable current conformance. The default is ``False``.
         thin_sources : bool, optional
-             The default is ``True``.
+             Whether to enable thin sources. The default is ``True``.
         power_fraction : str, optional
              The default is ``"0.95"``.
         visible : bool, optional.
-            Visualize source objects in target design. The default is ``True``.
+            Whether to make source objects in the target design visible. The default is ``True``.
+        name : str, optional
+            Name of the source.
+            The default is ``None`` in which case a name is automatically assigned.
 
         References
         ----------
 
         >>> oEditor.InsertNativeComponent
 
         Examples
@@ -1151,59 +1174,65 @@
         >>> from pyaedt import Hfss
         >>> target_project = "my/path/to/targetProject.aedt"
         >>> source_project = "my/path/to/sourceProject.aedt"
         >>> target = Hfss(projectname=target_project, solution_type="SBR+",
         ...               specified_version="2021.2", new_desktop_session=False)  # doctest: +SKIP
         >>> source = Hfss(projectname=source_project, designname="feeder",
         ...               specified_version="2021.2", new_desktop_session=False)  # doctest: +SKIP
-        >>> target.create_sbr_linked_antenna(source, target_cs="feederPosition",
-        ...                                  fieldtype="farfield")  # doctest: +SKIP
+        >>> target.create_sbr_linked_antenna(source,target_cs="feederPosition",field_type="farfield")  # doctest: +SKIP
 
         """
         if self.solution_type != "SBR+":
             self.logger.error("Native components only apply to the SBR+ solution.")
             return False
-        compName = source_object.design_name
-        uniquename = generate_unique_name(compName)
-        if source_object.project_name == self.project_name:
+
+        if name is None:
+            uniquename = generate_unique_name(assignment.design_name)
+        else:
+            uniquename = generate_unique_name(name)
+
+        if assignment.project_name == self.project_name:
             project_name = "This Project*"
         else:
-            project_name = os.path.join(source_object.project_path, source_object.project_name + ".aedt")
-        design_name = source_object.design_name
-        if not solution:
-            solution = source_object.nominal_adaptive
+            project_name = os.path.join(assignment.project_path, assignment.project_name + ".aedt")
+        design_name = assignment.design_name
+        if not setup:
+            setup = assignment.nominal_adaptive
         params = OrderedDict({})
-        pars = source_object.available_variations.nominal_w_values_dict
+        pars = assignment.available_variations.nominal_w_values_dict
         for el in pars:
             params[el] = pars[el]
         native_props = OrderedDict(
             {
                 "Type": "Linked Antenna",
                 "Unit": self.modeler.model_units,
                 "Is Parametric Array": False,
                 "Project": project_name,
                 "Product": "HFSS",
                 "Design": design_name,
-                "Soln": solution,
+                "Soln": setup,
                 "Params": params,
                 "ForceSourceToSolve": True,
                 "PreservePartnerSoln": True,
                 "PathRelativeTo": "TargetProject",
-                "FieldType": fieldtype,
+                "FieldType": field_type,
                 "UseCompositePort": use_composite_ports,
                 "SourceBlockageStructure": OrderedDict({"NonModelObject": []}),
             }
         )
-        if fieldtype == "nearfield":
+        if field_type == "nearfield":
             native_props["UseGlobalCurrentSrcOption"] = use_global_current
-            native_props["Current Source Conformance"] = current_conformance
+            if current_conformance:
+                native_props["Current Source Conformance"] = "Enable"
+            else:
+                native_props["Current Source Conformance"] = "Disable"
             native_props["Thin Sources"] = thin_sources
             native_props["Power Fraction"] = power_fraction
         if visible:
-            native_props["VisualizationObjects"] = source_object.modeler.solid_names
+            native_props["VisualizationObjects"] = assignment.modeler.solid_names
         return self._create_native_component(
             "Linked Antenna", target_cs, self.modeler.model_units, native_props, uniquename
         )
 
     @pyaedt_function_handler()
     def _create_native_component(
         self, antenna_type, target_cs=None, model_units=None, parameters_dict=None, antenna_name=None
@@ -1400,47 +1429,47 @@
             "Short Dipole": 1,
             "Small Loop": 2,
             "Wire Dipole": 5,
             "Wire Monopole": 6,
             "File Based Antenna": 8,
         }
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(model_units="units", parameters_dict="parameters", antenna_name="name")
     def create_sbr_antenna(
         self,
         antenna_type=SbrAntennas.ConicalHorn,
         target_cs=None,
-        model_units=None,
-        parameters_dict=None,
+        units=None,
+        parameters=None,
         use_current_source_representation=False,
         is_array=False,
-        antenna_name=None,
+        name=None,
     ):
         """Create a parametric beam antennas in SBR+.
 
         Parameters
         ----------
         antenna_type : str, `SbrAntennas.ConicalHorn`
             Name of the antennas type. The enumerator ``SbrAntennas`` can also be used.
             The default is ``"SbrAntennas.Conical Horn"``.
         target_cs : str, optional
             Target coordinate system. The default is ``None``, in which case
             the active coodiante system is used.
-        model_units : str, optional
+        units : str, optional
             Model units to apply to the object. The default is
             ``None``, in which case the active modeler units are applied.
-        parameters_dict : dict, optional
+        parameters : dict, optional
             Dictionary of parameters. The default is ``None``.
         use_current_source_representation : bool, optional
             Whether to use the current source representation. The default is ``False``.
         is_array : bool, optional
-            The default is ``False``.
-        antenna_name : str, optional
+            Whether to define an array. The default is ``False``.
+        name : str, optional
             Name of the 3D component. The default is ``None``, in which case the
-            name is auto-generated based on the antennas type.
+            name is auto-generated based on the antenna type.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.NativeComponentObject`
             NativeComponentObject object.
 
         References
@@ -1450,17 +1479,15 @@
 
         Examples
         --------
         >>> from pyaedt import Hfss
         >>> hfss = Hfss(solution_type="SBR+")  # doctest: +SKIP
         PyAEDT INFO: Added design 'HFSS_IPO' of type HFSS.
         >>> parm = {"polarization": "Vertical"}  # doctest: +SKIP
-        >>> par_beam = hfss.create_sbr_antenna(hfss.SbrAntennas.ShortDipole,
-        ...                                    parameters_dict=parm,
-        ...                                    antenna_name="TX1")  # doctest: +SKIP
+        >>> par_beam = hfss.create_sbr_antenna(hfss.SbrAntennas.ShortDipole,parameters=parm,name="TX1")
 
         """
         if self.solution_type != "SBR+":
             self.logger.error("This native component only applies to a SBR+ solution.")
             return False
         if target_cs is None:
             target_cs = self.modeler.oeditor.GetActiveCoordinateSystem()
@@ -1508,53 +1535,53 @@
             parameters_defaults["Array Weight Type"] = 3
             parameters_defaults["Array Beam Angle Theta"] = "0deg"
             parameters_defaults["Array Weight Edge TaperX"] = -200
             parameters_defaults["Array Weight Edge TaperY"] = -200
             parameters_defaults["Array Weight Cosine Exp"] = 1
             parameters_defaults["Array Differential Pattern Type"] = 0
             if is_array:
-                antenna_name = generate_unique_name("pAntArray")
-        if parameters_dict:
-            for el, value in parameters_dict.items():
+                name = generate_unique_name("pAntArray")
+        if parameters:
+            for el, value in parameters.items():
                 parameters_defaults[el] = value
-        return self._create_native_component(antenna_type, target_cs, model_units, parameters_defaults, antenna_name)
+        return self._create_native_component(antenna_type, target_cs, units, parameters_defaults, name)
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(ffd_full_path="far_field_data", model_units="units", antenna_name="name")
     def create_sbr_file_based_antenna(
         self,
-        ffd_full_path,
+        far_field_data,
         antenna_size="1mm",
         antenna_impedance="50ohm",
         representation_type="Far Field",
         target_cs=None,
-        model_units=None,
-        antenna_name=None,
+        units=None,
+        name=None,
     ):
-        """Create a linked antennas.
+        """Create a linked antenna.
 
         Parameters
         ----------
-        ffd_full_path : str
+        far_field_data : str
             Full path to the FFD file.
         antenna_size : str, optional
             Antenna size with units. The default is ``"1mm"``.
         antenna_impedance : str, optional
             Antenna impedance with units. The default is ``"50ohm"``.
         representation_type : str, optional
             Type of the antennas. Options are ``"Far Field"`` and ``"Near Field"``.
             The default is ``"Far Field"``.
         target_cs : str, optional
             Target coordinate system. The default is ``None``, in which case the
             active coordinate system is used.
-        model_units : str, optional
+        units : str, optional
             Model units to apply to the object. The default is
             ``None``, in which case the active modeler units are applied.
-        antenna_name : str, optional
+        name : str, optional
             Name of the 3D component. The default is ``None``, in which case
-            the name is auto-generated based on the antennas type.
+            the name is auto-generated based on the antenna type.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.NativeComponentObject`
 
         References
         ----------
@@ -1576,21 +1603,21 @@
             target_cs = self.modeler.oeditor.GetActiveCoordinateSystem()
 
         par_dicts = OrderedDict(
             {
                 "Size": antenna_size,
                 "MatchedPortImpedance": antenna_impedance,
                 "Representation": representation_type,
-                "ExternalFile": ffd_full_path,
+                "ExternalFile": far_field_data,
             }
         )
-        if not antenna_name:
-            antenna_name = generate_unique_name(os.path.basename(ffd_full_path).split(".")[0])
+        if not name:
+            name = generate_unique_name(os.path.basename(far_field_data).split(".")[0])
 
-        return self._create_native_component("File Based Antenna", target_cs, model_units, par_dicts, antenna_name)
+        return self._create_native_component("File Based Antenna", target_cs, units, par_dicts, name)
 
     @pyaedt_function_handler()
     def set_sbr_txrx_settings(self, txrx_settings):
         """Set SBR+ TX RX antennas settings.
 
         Parameters
         ----------
@@ -1613,198 +1640,61 @@
         id_ = 0
         props = OrderedDict({})
         for el, val in txrx_settings.items():
             props["Tx/Rx List " + str(id_)] = OrderedDict({"Tx Antenna": el, "Rx Antennas": txrx_settings[el]})
             id_ += 1
         return self._create_boundary("SBRTxRxSettings", props, "SBRTxRxSettings")
 
-    @pyaedt_function_handler()
-    def create_circuit_port_between_objects(
-        self, startobj, endobject, axisdir=0, impedance=50, portname=None, renorm=True, renorm_impedance=50, deemb=False
-    ):
-        """Create a circuit port taking the closest edges of two objects.
-
-        .. deprecated:: 0.6.70
-        Use :func:`circuit_port` method instead.
-
-        Parameters
-        ----------
-        startobj :
-            Starting object for the integration line.
-        endobject :
-            Ending object for the integration line.
-        axisdir : int or :class:`pyaedt.application.Analysis.Analysis.AxisDir`, optional
-            Position of the port. It should be one of the values for ``Application.AxisDir``,
-            which are: ``XNeg``, ``YNeg``, ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``.
-            The default is ``Application.AxisDir.XNeg``.
-        impedance : float, optional
-            Port impedance. The default is ``50``.
-        portname : str, optional
-            Name of the port. The default is ``None``.
-        renorm : bool, optional
-            Whether to renormalize the mode. The default is ``True``.
-        renorm_impedance : float or str, optional
-            Renormalize impedance. The default is ``50``.
-        deemb : bool, optional
-            Whether to deembed the port. The default is ``False``.
-
-        Returns
-        -------
-        :class:`pyaedt.modules.Boundary.BoundaryObject`
-            Boundary object.
-
-        References
-        ----------
-
-        >>> oModule.AssignCircuitPort
-
-        Examples
-        --------
-
-        Create two boxes for creating a circuit port named ``'CircuitExample'``.
-
-        >>> box1 = hfss.modeler.create_box([0, 0, 80], [10, 10, 5],
-        ...                                "BoxCircuit1", "copper")
-        >>> box2 = hfss.modeler.create_box([0, 0, 100], [10, 10, 5],
-        ...                                "BoxCircuit2", "copper")
-        >>> hfss.create_circuit_port_between_objects("BoxCircuit1", "BoxCircuit2",
-        ...                                          hfss.AxisDir.XNeg, 50,
-        ...                                          "CircuitExample", True, 50, False)
-        'CircuitExample'
-
-        """
-        warnings.warn("Use :func:`circuit_port` method instead.", DeprecationWarning)
-        return self.circuit_port(
-            signal=startobj,
-            reference=endobject,
-            port_location=axisdir,
-            impedance=impedance,
-            name=portname,
-            renormalize=renorm,
-            renorm_impedance=renorm_impedance,
-            deembed=deemb,
-        )
-
-    @pyaedt_function_handler()
-    def create_lumped_port_between_objects(
-        self, startobj, endobject, axisdir=0, impedance=50, portname=None, renorm=True, deemb=False, port_on_plane=True
-    ):
-        """Create a lumped port taking the closest edges of two objects.
-
-        .. deprecated:: 0.6.70
-        Use :func:`lumped_port` method instead.
-
-        Parameters
-        ----------
-        startobj :
-            Starting object for the integration line.
-        endobject :
-            Ending object for the integration line.
-        axisdir : int or :class:`pyaedt.application.Analysis.Analysis.AxisDir`, optional
-            Position of the port. It should be one of the values for ``Application.AxisDir``,
-            which are: ``XNeg``, ``YNeg``, ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``.
-            The default is ``Application.AxisDir.XNeg``.
-        impedance : float, optional
-            Port impedance. The default is ``50``.
-        portname : str, optional
-            Name of the port. The default is ``None``.
-        renorm : bool, optional
-            Whether to renormalize the mode. The default is ``True``.
-        deemb : bool, optional
-            Whether to deembed the port. The default is ``False``.
-        port_on_plane : bool, optional
-            Whether to create the source on the plane orthogonal to ``AxisDir``.
-            The default is ``True``.
-
-        Returns
-        -------
-        :class:`pyaedt.modules.Boundary.BoundaryObject`
-            Boundary object.
-
-        References
-        ----------
-
-        >>> oModule.AssignLumpedPort
-
-        Examples
-        --------
-
-        Create two boxes that will be used to create a lumped port
-        named ``'LumpedPort'``.
-
-        >>> box1 = hfss.modeler.create_box([0, 0, 50], [10, 10, 5],
-        ...                                "BoxLumped1","copper")
-        >>> box2 = hfss.modeler.create_box([0, 0, 60], [10, 10, 5],
-        ...                                "BoxLumped2", "copper")
-        >>> hfss.create_lumped_port_between_objects("BoxLumped1", "BoxLumped2",
-        ...                                         hfss.AxisDir.XNeg, 50,
-        ...                                         "LumpedPort", True, False)
-        PyAEDT INFO: Connection Correctly created
-        'LumpedPort'
-
-        """
-        warnings.warn("Use :func:`lumped_port` method instead.", DeprecationWarning)
-        return self.lumped_port(
-            signal=startobj,
-            reference=endobject,
-            create_port_sheet=True,
-            port_on_plane=port_on_plane,
-            integration_line=axisdir,
-            impedance=impedance,
-            name=portname,
-            renormalize=renorm,
-            deembed=deemb,
-        )
-
-    @pyaedt_function_handler()
-    def create_spiral_lumped_port(self, start_object, end_object, port_width=None):
+    @pyaedt_function_handler(start_object="assignment", end_object="reference", port_width="width")
+    def create_spiral_lumped_port(self, assignment, reference, width=None, name=None):
         """Create a spiral lumped port between two adjacent objects.
 
         The two objects must have two adjacent, parallel, and identical faces.
         The faces must be a polygon (not a circle).
         The closest faces must be aligned with the main planes of the reference system.
 
         Parameters
         ----------
-        start_object : str or int or :class:`pyaedt.modeler.cad.object3d.Object3d`
+        assignment : str or int or :class:`pyaedt.modeler.cad.object3d.Object3d`
             First solid connected to the spiral port.
-
-        end_object : str or int or :class:`pyaedt.modeler.cad.object3d.Object3d`
+        reference : str or int or :class:`pyaedt.modeler.cad.object3d.Object3d`
             Second object connected to the spiral port.
-
-        port_width : float, optional
+        width : float, optional
             Width of the spiral port.
-            If not specified the width will be calculated based on the object dimensions.
+            If a width is not specified, it is calculated based on the object dimensions.
             The default is ``None``.
+        name : str, optional
+            Port name.  The default is ``None``.
+
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject`
             Boundary object.
 
         Examples
         --------
         >>> aedtapp = Hfss()
         >>> aedtapp.insert_design("Design_Terminal_2")
         >>> aedtapp.solution_type = "Terminal"
         >>> box1 = aedtapp.modeler.create_box([-100, -100, 0], [200, 200, 5], name="gnd2z", matname="copper")
         >>> box2 = aedtapp.modeler.create_box([-100, -100, 20], [200, 200, 25], name="sig2z", matname="copper")
         >>> aedtapp.modeler.fit_all()
-        >>> portz = aedtapp.create_spiral_lumped_port(box1, box2)
+        >>> portz = aedtapp.create_spiral_lumped_port(box1,box2)
         """
         if not "Terminal" in self.solution_type:
             raise Exception("This method can be used only in Terminal solutions.")
-        start_object = self.modeler.convert_to_selections(start_object)
-        end_object = self.modeler.convert_to_selections(end_object)
+        assignment = self.modeler.convert_to_selections(assignment)
+        reference = self.modeler.convert_to_selections(reference)
 
         # find the closest faces (based on face center)
         closest_distance = 1e9
         closest_faces = []
-        for face1 in self.modeler[start_object].faces:
-            for face2 in self.modeler[end_object].faces:
+        for face1 in self.modeler[assignment].faces:
+            for face2 in self.modeler[reference].faces:
                 facecenter_distance = GeometryOperators.points_distance(face1.center, face2.center)
                 if facecenter_distance <= closest_distance:
                     closest_distance = facecenter_distance
                     closest_faces = [face1, face2]
 
         # check if the faces are parallel
         if not GeometryOperators.is_collinear(closest_faces[0].normal, closest_faces[1].normal):
@@ -1825,43 +1715,43 @@
             raise AttributeError("The closest faces of the two objects must be identical in shape.")
 
         # evaluate the vector to move from face0 to the middle distance between the faces
         move_vector = GeometryOperators.v_sub(closest_faces[1].center, closest_faces[0].center)
         move_vector_mid = GeometryOperators.v_prod(0.5, move_vector)
 
         # fmt: off
-        if port_width:
-            spiral_width = port_width
+        if width:
+            spiral_width = width
             filling = 1.5
         else:
             # get face bounding box
             face_bb = [1e15, 1e15, 1e15, -1e15, -1e15, -1e15]
             for i in range(3):
                 for v in closest_faces[0].vertices:
                     face_bb[i] = min(face_bb[i], v.position[i])
-                    face_bb[i+3] = max(face_bb[i+3], v.position[i])
+                    face_bb[i + 3] = max(face_bb[i + 3], v.position[i])
             # get the ratio in 2D
-            bb_dim = [abs(face_bb[i]-face_bb[i+3]) for i in range(3) if abs(face_bb[i]-face_bb[i+3]) > 1e-12]
-            bb_ratio = max(bb_dim)/min(bb_dim)
+            bb_dim = [abs(face_bb[i] - face_bb[i + 3]) for i in range(3) if abs(face_bb[i] - face_bb[i + 3]) > 1e-12]
+            bb_ratio = max(bb_dim) / min(bb_dim)
             if bb_ratio > 2:
                 spiral_width = min(bb_dim) / 12
-                filling = -0.2828*bb_ratio**2 + 3.4141*bb_ratio - 4.197
+                filling = -0.2828 * bb_ratio ** 2 + 3.4141 * bb_ratio - 4.197
                 print(filling)
             else:
                 vertex_coordinates = []
                 for v in closest_faces[0].vertices:
                     vertex_coordinates.append(v.position)
                 segments_lengths = []
                 for vc in vertex_coordinates:
                     segments_lengths.append(GeometryOperators.points_distance(vc, closest_faces[0].center))
                 spiral_width = min(segments_lengths) / 15
                 filling = 1.5
         # fmt: on
-
-        name = generate_unique_name("P", n=3)
+        if not name:
+            name = generate_unique_name("P", n=3)
 
         spiral = self.modeler.create_spiral_on_face(closest_faces[0], spiral_width, filling_factor=filling)
         spiral.name = name
         spiral.move(move_vector_mid)
         spiral_center = GeometryOperators.get_mid_point(closest_faces[0].center, closest_faces[1].center)
 
         # get the polyline center point (before width operation). They need to be moved as well.
@@ -1903,15 +1793,15 @@
             orient = "X" if (dx < dy) else "Y"
 
         poly1 = self.modeler.create_polyline(
             p1_down,
             xsection_type="Line",
             xsection_orient=orient,
             xsection_width=closest_distance / 2,
-            name=start_object + "_sheet",
+            name=assignment + "_sheet",
         )
 
         # create second polyline to join spiral with conductor face
         dx = abs(p2_up[0][0] - p2_up[1][0])
         dy = abs(p2_up[0][1] - p2_up[1][1])
         dz = abs(p2_up[0][2] - p2_up[1][2])
         if plane == "X":
@@ -1921,47 +1811,50 @@
         else:
             orient = "X" if (dx < dy) else "Y"
         poly2 = self.modeler.create_polyline(
             p2_up,
             xsection_type="Line",
             xsection_orient=orient,
             xsection_width=closest_distance / 2,
-            name=end_object + "_sheet",
+            name=reference + "_sheet",
         )
 
         # assign pec to created polylines
-        self.assign_perfecte_to_sheets(poly1, sourcename=start_object)
-        self.assign_perfecte_to_sheets(poly2, sourcename=end_object)
+        self.assign_perfecte_to_sheets(poly1, name=assignment)
+        self.assign_perfecte_to_sheets(poly2, name=reference)
 
         # create lumped port on spiral
         port = self.lumped_port(spiral, reference=[poly2.name], name=name)
 
         return port
 
-    @pyaedt_function_handler()
-    def create_voltage_source_from_objects(self, startobj, endobject, axisdir=0, sourcename=None, source_on_plane=True):
+    @pyaedt_function_handler(startobj="assignment", endobject="reference", sourcename="name", axisdir="start_direction")
+    def create_voltage_source_from_objects(
+        self, assignment, reference, start_direction=0, name=None, source_on_plane=True
+    ):
         """Create a voltage source taking the closest edges of two objects.
 
         Parameters
         ----------
-        startobj :
-            Starting object for the integration line.
-        endobject :
-            Ending object for the integration line.
-        axisdir : int or :class:`pyaedt.application.Analysis.Analysis.AxisDir`, optional
-            Position of the port. It should be one of the values for
-            ``Application.AxisDir``, which are: ``XNeg``, ``YNeg``,
-            ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``.  The default
-            is ``Application.AxisDir.XNeg``.
-        sourcename : str, optional
+        assignment : str or int or :class:`pyaedt.modeler.cad.object3d.Object3d`
+            First object connected to the voltage source.
+        reference : str or int or :class:`pyaedt.modeler.cad.object3d.Object3d`
+            Second object connected to the voltage source.
+        start_direction : int or :class:`pyaedt.application.Analysis.Analysis.AxisDir`, optional
+            Start direction for the port location.
+            It should be one of the values for ``Application.AxisDir``, which are: ``XNeg``, ``YNeg``,
+            ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``.
+             The default is ``Application.AxisDir.XNeg``.
+        name : str, optional
             Name of the source. The default is ``None``.
         source_on_plane : bool, optional
             Whether to create the source on the plane orthogonal to
             ``AxisDir``. The default is ``True``.
 
+
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject`
             Boundary object.
 
         References
         ----------
@@ -1973,50 +1866,52 @@
 
         Create two boxes for creating a voltage source named ``'VoltageSource'``.
 
         >>> box1 = hfss.modeler.create_box([30, 0, 0], [40, 10, 5],
         ...                                "BoxVolt1", "copper")
         >>> box2 = hfss.modeler.create_box([30, 0, 10], [40, 10, 5],
         ...                                "BoxVolt2", "copper")
-        >>> v1 = hfss.create_voltage_source_from_objects("BoxVolt1", "BoxVolt2",
-        ...                                         hfss.AxisDir.XNeg,
-        ...                                         "VoltageSource")
+        >>> v1 = hfss.create_voltage_source_from_objects("BoxVolt1","BoxVolt2",hfss.AxisDir.XNeg,"VoltageSource")
         PyAEDT INFO: Connection Correctly created
-
         """
 
-        if not self.modeler.does_object_exists(startobj) or not self.modeler.does_object_exists(endobject):
+        if not self.modeler.does_object_exists(assignment) or not self.modeler.does_object_exists(reference):
             self.logger.error("One or both objects doesn't exists. Check and retry")
             return False
         if self.solution_type in ["Modal", "Terminal", "Transient Network"]:
             sheet_name, point0, point1 = self.modeler._create_sheet_from_object_closest_edge(
-                startobj, endobject, axisdir, source_on_plane
+                assignment, reference, start_direction, source_on_plane
             )
-            sourcename = self._get_unique_source_name(sourcename, "Voltage")
-            return self.create_source_excitation(sheet_name, point0, point1, sourcename, sourcetype="Voltage")
+            name = self._get_unique_source_name(name, "Voltage")
+            return self.create_source_excitation(sheet_name, point0, point1, name, source_type="Voltage")
         return False  # pragma: no cover
 
-    @pyaedt_function_handler()
-    def create_current_source_from_objects(self, startobj, endobject, axisdir=0, sourcename=None, source_on_plane=True):
+    @pyaedt_function_handler(startobj="assignment", endobject="reference", sourcename="name", axisdir="start_direction")
+    def create_current_source_from_objects(
+        self, assignment, reference, start_direction=0, name=None, source_on_plane=True
+    ):
         """Create a current source taking the closest edges of two objects.
 
         Parameters
         ----------
-        startobj :
-            Starting object for the integration line.
-        endobject :
-            Ending object for the integration line.
-        axisdir : int or :class:`pyaedt.application.Analysis.Analysis.AxisDir`, optional
-            Position of the port. It should be one of the values for ``Application.AxisDir``,
-            which are: ``XNeg``, ``YNeg``, ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``.
-            The default is ``Application.AxisDir.XNeg``.
-        sourcename : str, optional
+        assignment : str or int or :class:`pyaedt.modeler.cad.object3d.Object3d`
+            First object connected to the current source.
+        reference : str or int or :class:`pyaedt.modeler.cad.object3d.Object3d`
+            Second object connected to the current source.
+        start_direction : int or :class:`pyaedt.application.Analysis.Analysis.AxisDir`, optional
+            Start direction for the port location.
+            It should be one of the values for ``Application.AxisDir``, which are: ``XNeg``, ``YNeg``,
+            ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``.
+             The default is ``Application.AxisDir.XNeg``.
+        name : str, optional
             Name of the source. The default is ``None``.
         source_on_plane : bool, optional
-            Whether to create the source on the plane orthogonal to ``axisdir``. The default is ``True``.
+            Whether to create the source on the plane orthogonal to
+            the start direction. The default is ``True``.
+
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject`
             Boundary object.
 
         References
@@ -2029,189 +1924,97 @@
 
         Create two boxes for creating a current source named ``'CurrentSource'``.
 
         >>> box1 = hfss.modeler.create_box([30, 0, 20], [40, 10, 5],
         ...                                "BoxCurrent1", "copper")
         >>> box2 = hfss.modeler.create_box([30, 0, 30], [40, 10, 5],
         ...                                "BoxCurrent2", "copper")
-        >>> i1 = hfss.create_current_source_from_objects("BoxCurrent1", "BoxCurrent2",
-        ...                                         hfss.AxisDir.XPos,
-        ...                                         "CurrentSource")
+        >>> i1 = hfss.create_current_source_from_objects("BoxCurrent1","BoxCurrent2",hfss.AxisDir.XPos,"CurrentSource")
         PyAEDT INFO: Connection created 'CurrentSource' correctly.
-
         """
 
-        if not self.modeler.does_object_exists(startobj) or not self.modeler.does_object_exists(endobject):
+        if not self.modeler.does_object_exists(assignment) or not self.modeler.does_object_exists(reference):
             self.logger.error("One or both objects do not exist. Check and retry.")
             return False
         if self.solution_type in ["Modal", "Terminal", "Transient Network"]:
             sheet_name, point0, point1 = self.modeler._create_sheet_from_object_closest_edge(
-                startobj, endobject, axisdir, source_on_plane
+                assignment, reference, start_direction, source_on_plane
             )
-            sourcename = self._get_unique_source_name(sourcename, "Current")
-            return self.create_source_excitation(sheet_name, point0, point1, sourcename, sourcetype="Current")
+            name = self._get_unique_source_name(name, "Current")
+            return self.create_source_excitation(sheet_name, point0, point1, name, source_type="Current")
         return False  # pragma: no cover
 
-    @pyaedt_function_handler()
-    def create_source_excitation(self, sheet_name, point1, point2, sourcename, sourcetype="Voltage"):
+    @pyaedt_function_handler(sheet_name="assignment", sourcename="name", sourcetype="source_type")
+    def create_source_excitation(self, assignment, point1, point2, name, source_type="Voltage"):
         """Create a source excitation.
 
         Parameters
         ----------
-        sheet_name : str
+        assignment : str
             Name of the sheet.
-        point1 :
-
-        point2 :
-
-        sourcename : str
+        point1 : list
+            First point of the source excitation.
+        point2 : list
+            Second point of the source excitation.
+        name : str
             Name of the source.
-
-        sourcetype : str, optional
+        source_type : str, optional
             Type of the source. The default is ``"Voltage"``.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject`
             Boundary object.
 
         References
         ----------
 
         >>> oModule.AssignVoltage
         >>> oModule.AssignCurrent
         """
 
-        props = OrderedDict({"Objects": [sheet_name], "Direction": OrderedDict({"Start": point1, "End": point2})})
-        return self._create_boundary(sourcename, props, sourcetype)
-
-    @pyaedt_function_handler()
-    def create_wave_port_between_objects(
-        self,
-        startobj,
-        endobject,
-        axisdir=0,
-        impedance=50,
-        nummodes=1,
-        portname=None,
-        renorm=True,
-        deembed_dist=0,
-        port_on_plane=True,
-        add_pec_cap=False,
-    ):
-        """Create a waveport taking the closest edges of two objects.
-
-        .. deprecated:: 0.6.62
-           Use :func:`wave_port` metho instead.
-
-        Parameters
-        ----------
-        startobj :
-            Starting object for the integration line.
-        endobject :
-            Ending object for the integration line.
-        axisdir : int or :class:`pyaedt.application.Analysis.Analysis.AxisDir`, optional
-            Position of the port. It should be one of the values for ``Application.AxisDir``,
-            which are: ``XNeg``, ``YNeg``, ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``.
-            The default is ``Application.AxisDir.XNeg``.
-        impedance : float, optional
-            Port impedance. The default is ``50``.
-        nummodes : int, optional
-            Number of modes. The default is ``1``.
-        portname : str, optional
-            Name of the port. The default is ``None``.
-        renorm : bool, optional
-            Whether to renormalize the mode. The default is ``True``.
-        deembed_dist : float, optional
-            Deembed distance in millimeters. The default is ``0``,
-            in which case deembed is disabled.
-        port_on_plane : bool, optional
-            Whether to create the port on the plane orthogonal to ``AxisDir``. The default is ``True``.
-        add_pec_cap : bool, optional
-             The default is ``False``.
-
-        Returns
-        -------
-        :class:`pyaedt.modules.Boundary.BoundaryObject`
-            Boundary object.
-
-        References
-        ----------
-
-        >>> oModule.AssignWavePort
-
-        Examples
-        --------
-
-        Create two boxes that will be used to create a wave port
-        named ``'Wave Port'``.
+        props = OrderedDict({"Objects": [assignment], "Direction": OrderedDict({"Start": point1, "End": point2})})
+        return self._create_boundary(name, props, source_type)
 
-        >>> box1 = hfss.modeler.create_box([0,0,0], [10,10,5],
-        ...                                           "BoxWave1", "copper")
-        >>> box2 = hfss.modeler.create_box([0, 0, 10], [10, 10, 5],
-        ...                                           "BoxWave2", "copper")
-        >>> wave_port = hfss.create_wave_port_between_objects("BoxWave1", "BoxWave2",
-        ...                                                   hfss.AxisDir.XNeg, 50, 1,
-        ...                                                   "Wave Port", False)
-        PyAEDT INFO: Connection Correctly created
-
-        """
-        warnings.warn(
-            "`create_wave_port_between_objects` is deprecated. Use `wave_port` property instead.", DeprecationWarning
-        )
-        return self.wave_port(
-            signal=startobj,
-            reference=endobject,
-            integration_line=axisdir,
-            create_port_sheet=True,
-            impedance=impedance,
-            num_modes=nummodes,
-            name=portname,
-            renormalize=renorm,
-            deembed=deembed_dist,
-            port_on_plane=port_on_plane,
-            add_pec_cap=add_pec_cap,
-        )
-
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(face="assignment", nummodes="modes", portname="name", renorm="renormalize")
     def create_floquet_port(
         self,
-        face,
+        assignment,
         lattice_origin=None,
         lattice_a_end=None,
         lattice_b_end=None,
-        nummodes=2,
-        portname=None,
-        renorm=True,
-        deembed_dist=0,
+        modes=2,
+        name=None,
+        renormalize=True,
+        deembed_distance=0,
         reporter_filter=True,
         lattice_cs="Global",
     ):
         """Create a floquet port on a face.
 
         Parameters
         ----------
-        face :
+        assignment :
             Face or sheet to apply the floquet port to.
         lattice_origin : list
             List of ``[x,y,z]`` coordinates for the lattice A-B origin. The default is ``None``,
             in which case the method tries to compute the A-B automatically.
         lattice_a_end : list
             List of ``[x,y,z]`` coordinates for the lattice A end point. The default is ``None``,
             in which case the method tries to compute the A-B automatically.
         lattice_b_end : list
             List of ``[x,y,z]`` coordinates for the lattice B end point. The default is ``None``,
             in which case the method tries to compute the A-B automatically.
-        nummodes : int, optional
+        modes : int, optional
             Number of modes. The default is ``2``.
-        portname : str, optional
+        name : str, optional
             Name of the port. The default is ``None``.
-        renorm : bool, optional
+        renormalize : bool, optional
             Whether to renormalize the mode. The default is ``True``.
-        deembed_dist : float, str, optional
+        deembed_distance : float, str, optional
             Deembed distance in millimeters. The default is ``0``,
             in which case deembed is disabled.
         reporter_filter : bool, list of bool
             Whether to include modes in the report. The default is ``True``. If a single
             Boolean value is specified, it applies to all modes. If a list of Boolean values is specified, it applies
             to each mode in the list. A list must have ``nummodes`` elements.
         lattice_cs : str, optional
@@ -2224,38 +2027,38 @@
 
 
         References
         ----------
 
         >>> oModule.AssignFloquetPort
         """
-        face_id = self.modeler.convert_to_selections(face, True)
+        face_id = self.modeler.convert_to_selections(assignment, True)
         props = OrderedDict({})
         if isinstance(face_id[0], int):
             props["Faces"] = face_id
         else:
             props["Objects"] = face_id
 
-        props["NumModes"] = nummodes
-        if deembed_dist:
+        props["NumModes"] = modes
+        if deembed_distance:
             props["DoDeembed"] = True
-            props["DeembedDist"] = self.modeler._arg_with_dim(deembed_dist)
+            props["DeembedDist"] = self.modeler._arg_with_dim(deembed_distance)
         else:
             props["DoDeembed"] = False
             props["DeembedDist"] = "0mm"
-        props["RenormalizeAllTerminals"] = renorm
+        props["RenormalizeAllTerminals"] = renormalize
         props["Modes"] = OrderedDict({})
-        for i in range(1, 1 + nummodes):
+        for i in range(1, 1 + modes):
             props["Modes"]["Mode{}".format(i)] = OrderedDict({})
             props["Modes"]["Mode{}".format(i)]["ModeNum"] = i
             props["Modes"]["Mode{}".format(i)]["UseIntLine"] = False
             props["Modes"]["Mode{}".format(i)]["CharImp"] = "Zpi"
         props["ShowReporterFilter"] = True
         if isinstance(reporter_filter, bool):
-            props["ReporterFilter"] = [reporter_filter for i in range(nummodes)]
+            props["ReporterFilter"] = [reporter_filter for i in range(modes)]
         else:
             props["ReporterFilter"] = reporter_filter
         if not lattice_a_end or not lattice_origin or not lattice_b_end:
             result, output = self.modeler._find_perpendicular_points(face_id[0])
             lattice_origin = output[0]
             lattice_a_end = output[1]
             lattice_b_end = output[2]
@@ -2263,33 +2066,33 @@
         props["LatticeAVector"]["Coordinate System"] = lattice_cs
         props["LatticeAVector"]["Start"] = lattice_origin
         props["LatticeAVector"]["End"] = lattice_a_end
         props["LatticeBVector"] = OrderedDict({})
         props["LatticeBVector"]["Coordinate System"] = lattice_cs
         props["LatticeBVector"]["Start"] = lattice_origin
         props["LatticeBVector"]["End"] = lattice_b_end
-        if not portname:
-            portname = generate_unique_name("Floquet")
-        return self._create_boundary(portname, props, "Floquet Port")
+        if not name:
+            name = generate_unique_name("Floquet")
+        return self._create_boundary(name, props, "Floquet Port")
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(face_couple="assignment", pair_name="name")
     def assign_lattice_pair(
         self,
-        face_couple,
+        assignment,
         reverse_v=False,
         phase_delay="UseScanAngle",
         phase_delay_param1="0deg",
         phase_delay_param2="0deg",
-        pair_name=None,
+        name=None,
     ):
         """Assign a lattice pair to a couple of faces.
 
         Parameters
         ----------
-        face_couple : list
+        assignment : list
             List of two faces to assign the lattice pair to.
         reverse_v : bool, optional
             Whether to reverse the V vector. The default is `False`.
         phase_delay : str, optional
             Phase delay approach. Options are ``"UseScanAngle"``,
             ``"UseScanUV"``, and ``"InputPhaseDelay"``. The default is
             ``"UseScanAngle"``.
@@ -2305,52 +2108,52 @@
         phase_delay_param2 :  str, optional
             Value for the second phase delay parameter, which depends on the approach:
 
             - Theta angle if the approach is "``UseScanAngle"``.
             - V value if the approach is ``"UseScanUV"``.
 
             The default is ``0deg``.
-        pair_name : str, optional
+        name : str, optional
             Boundary name.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject`
             Boundary object.
 
         References
         ----------
 
         >>> oModule.AssignLatticePair
         """
         props = OrderedDict({})
-        face_id = self.modeler.convert_to_selections(face_couple, True)
+        face_id = self.modeler.convert_to_selections(assignment, True)
         props["Faces"] = face_id
         props["ReverseV"] = reverse_v
 
         props["PhaseDelay"] = phase_delay
         if phase_delay == "UseScanAngle":
             props["Phi"] = phase_delay_param1
             props["Theta"] = phase_delay_param2
         elif phase_delay == "UseScanUV":
             props["ScanU"] = phase_delay_param1
             props["ScanV"] = phase_delay_param2
         else:
             props["Phase"] = phase_delay_param1
-        if not pair_name:
-            pair_name = generate_unique_name("LatticePair")
-        return self._create_boundary(pair_name, props, "Lattice Pair")
+        if not name:
+            name = generate_unique_name("LatticePair")
+        return self._create_boundary(name, props, "Lattice Pair")
 
-    @pyaedt_function_handler()
-    def auto_assign_lattice_pairs(self, object_to_assign, coordinate_system="Global", coordinate_plane="XY"):
+    @pyaedt_function_handler(object_to_assign="assignment")
+    def auto_assign_lattice_pairs(self, assignment, coordinate_system="Global", coordinate_plane="XY"):
         """Assign lattice pairs to a geometry automatically.
 
         Parameters
         ----------
-        object_to_assign : str, Object3d
+        assignment : str, :class:`pyaedt.modeler.cad.object3d.Object3d`
             Object to assign a lattice to.
         coordinate_system : str, optional
             Coordinate system to look for the lattice on.
         coordinate_plane : str, optional
             Plane to look for the lattice on. Options are ``"XY"``, ``"XZ"``, and
             ``"YZ"``. The default is ``"XY"``.
 
@@ -2360,42 +2163,44 @@
             List of created pair names.
 
         References
         ----------
 
         >>> oModule.AutoIdentifyLatticePair
         """
-        objectname = self.modeler.convert_to_selections(object_to_assign, True)
+        objectname = self.modeler.convert_to_selections(assignment, True)
         boundaries = list(self.oboundary.GetBoundaries())
         self.oboundary.AutoIdentifyLatticePair("{}:{}".format(coordinate_system, coordinate_plane), objectname[0])
         boundaries = [i for i in list(self.oboundary.GetBoundaries()) if i not in boundaries]
         bounds = [i for i in boundaries if boundaries.index(i) % 2 == 0]
         return bounds
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(
+        face="assignment", primary_name="primary", coord_name="coordinate_system", secondary_name="name"
+    )
     def assign_secondary(
         self,
-        face,
-        primary_name,
+        assignment,
+        primary,
         u_start,
         u_end,
         reverse_v=False,
         phase_delay="UseScanAngle",
         phase_delay_param1="0deg",
         phase_delay_param2="0deg",
-        coord_name="Global",
-        secondary_name=None,
+        coordinate_system="Global",
+        name=None,
     ):
         """Assign the secondary boundary condition.
 
         Parameters
         ----------
-        face : int, FacePrimitive
+        assignment : int, FacePrimitive
             Face to assign the lattice pair to.
-        primary_name : str
+        primary : str
             Name of the primary boundary to couple.
         u_start : list
             List of ``[x,y,z]`` values for the starting point of the U vector.
         u_end : list
             List of ``[x,y,z]`` values for the ending point of the U vector.
         reverse_v : bool, optional
             Whether to reverse the V vector. The default is ``False``.
@@ -2414,102 +2219,104 @@
         phase_delay_param2 :  str, optional
             Value for the second phase delay parameter, which depends on the approach:
 
             - Theta angle if the approach is "``UseScanAngle"``.
             - V value if the approach is ``"UseScanUV"``.
 
             The default is ``0deg``.
-        coord_name : str, optional
+        coordinate_system : str, optional
             Name of the coordinate system for U coordinates.
-        secondary_name : str, optional
-            Name of the boundary. The default is ``None``.
+        name : str, optional
+            Name of the boundary. The default is ``None``,
+            in which case a name is automatically assigned.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject`
             Boundary object.
 
         References
         ----------
 
         >>> oModule.AssignSecondary
         """
         props = OrderedDict({})
-        face_id = self.modeler.convert_to_selections(face, True)
+        face_id = self.modeler.convert_to_selections(assignment, True)
         if isinstance(face_id[0], str):
             props["Objects"] = face_id
 
         else:
             props["Faces"] = face_id
 
         props["CoordSysVector"] = OrderedDict({})
-        props["CoordSysVector"]["Coordinate System"] = coord_name
+        props["CoordSysVector"]["Coordinate System"] = coordinate_system
         props["CoordSysVector"]["Origin"] = u_start
         props["CoordSysVector"]["UPos"] = u_end
         props["ReverseV"] = reverse_v
 
-        props["Primary"] = primary_name
+        props["Primary"] = primary
         props["PhaseDelay"] = phase_delay
         if phase_delay == "UseScanAngle":
             props["Phi"] = phase_delay_param1
             props["Theta"] = phase_delay_param2
         elif phase_delay == "UseScanUV":
             props["ScanU"] = phase_delay_param1
             props["ScanV"] = phase_delay_param2
         else:
             props["Phase"] = phase_delay_param1
-        if not secondary_name:
-            secondary_name = generate_unique_name("Secondary")
-        return self._create_boundary(secondary_name, props, "Secondary")
+        if not name:
+            name = generate_unique_name("Secondary")
+        return self._create_boundary(name, props, "Secondary")
 
-    @pyaedt_function_handler()
-    def assign_primary(self, face, u_start, u_end, reverse_v=False, coord_name="Global", primary_name=None):
+    @pyaedt_function_handler(face="assignment", coord_name="coordinate_system", primary_name="name")
+    def assign_primary(self, assignment, u_start, u_end, reverse_v=False, coordinate_system="Global", name=None):
         """Assign the primary boundary condition.
 
         Parameters
         ----------
-        face : int, FacePrimitive
+        assignment : int, FacePrimitive
             Face to assign the lattice pair to.
         u_start : list
             List of ``[x,y,z]`` values for the starting point of the U vector.
         u_end : list
             List of ``[x,y,z]`` values for the ending point of the U vector.
         reverse_v : bool, optional
             Whether to reverse the V vector. The default is `False`.
-        coord_name : str, optional
+        coordinate_system : str, optional
             Name of the coordinate system for the U coordinates. The
             default is ``"Global"``.
-        primary_name : str, optional
-            Name of the boundary. The default is ``None``.  # TODO: Add names of allowed values to docstring.
+        name : str, optional
+            Name of the boundary. The default is ``None``,
+            in which case a name is automatically assigned.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject`
             Boundary object.
 
         References
         ----------
 
         >>> oModule.AssignPrimary
         """
         props = OrderedDict({})
-        face_id = self.modeler.convert_to_selections(face, True)
+        face_id = self.modeler.convert_to_selections(assignment, True)
         if isinstance(face_id[0], str):
             props["Objects"] = face_id
 
         else:
             props["Faces"] = face_id
         props["ReverseV"] = reverse_v
         props["CoordSysVector"] = OrderedDict({})
-        props["CoordSysVector"]["Coordinate System"] = coord_name
+        props["CoordSysVector"]["Coordinate System"] = coordinate_system
         props["CoordSysVector"]["Origin"] = u_start
         props["CoordSysVector"]["UPos"] = u_end
-        if not primary_name:
-            primary_name = generate_unique_name("Primary")
-        return self._create_boundary(primary_name, props, "Primary")
+        if not name:
+            name = generate_unique_name("Primary")
+        return self._create_boundary(name, props, "Primary")
 
     def _create_pec_cap(self, sheet_name, obj_name, pecthick):
         """Create a PEC object to back a wave port.
 
 
         Parameters
         ----------
@@ -2552,129 +2359,46 @@
             self.odesign.Undo()
             self.modeler.cleanup_objects()
             out_obj = self.modeler.thicken_sheet(obj, -pecthick, False)
 
         out_obj.material_name = "pec"
         return True
 
-    @pyaedt_function_handler()
-    def create_wave_port_microstrip_between_objects(
-        self,
-        startobj,
-        endobject,
-        axisdir=0,
-        impedance=50,
-        nummodes=1,
-        portname=None,
-        renorm=True,
-        deembed_dist=0,
-        vfactor=3,
-        hfactor=5,
-    ):
-        """Create a waveport taking the closest edges of two objects.
-
-        .. deprecated:: 0.6.62
-            `create_wave_port_microstrip_between_objects` is deprecated. Use `wave_port` property instead.
-
-        Parameters
-        ----------
-        startobj :
-            Starting object for the integration line. This is typically the reference plane.
-        endobject :
-            Ending object for the integration line.
-        axisdir : int or :class:`pyaedt.application.Analysis.Analysis.AxisDir`, optional
-            Position of the port. It should be one of the values for ``Application.AxisDir``,
-            which are: ``XNeg``, ``YNeg``, ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``.
-            The default is ``Application.AxisDir.XNeg``.
-        impedance : float, optional
-            Port impedance. The default is ``50``.
-        nummodes : int, optional
-            Number of modes. The default is ``1``.
-        portname : str, optional
-            Name of the port. The default is ``None``.
-        renorm : bool, optional
-            Whether to renormalize the mode. The default is ``True``.
-        deembed_dist : float, optional
-            Deembed distance in millimeters. The default is ``0``,
-            in which case deembed is disabled.
-        vfactor : int, optional
-            Port vertical factor. The default is ``3``.
-        hfactor : int, optional
-            Port horizontal factor. The default is ``5``.
-
-        Returns
-        -------
-        :class:`pyaedt.modules.Boundary.BoundaryObject`
-            Port object.
-
-        References
-        ----------
-
-        >>> oModule.AssignWavePort
-
-        Examples
-        --------
-
-        Create a wave port supported by a microstrip line.
-
-        >>> ms = hfss.modeler.create_box([4, 5, 0], [1, 100, 0.2],
-        ...                               name="MS1", matname="copper")
-        >>> sub = hfss.modeler.create_box([0, 5, -2], [20, 100, 2],
-        ...                               name="SUB1", matname="FR4_epoxy")
-        >>> gnd = hfss.modeler.create_box([0, 5, -2.2], [20, 100, 0.2],
-        ...                               name="GND1", matname="FR4_epoxy")
-        >>> port = hfss.create_wave_port_microstrip_between_objects("GND1", "MS1",
-        ...                                                         portname="MS1",
-        ...                                                         axisdir=1)
-        PyAEDT INFO: Connection correctly created.
-
-        """
-        warnings.warn(
-            "`create_wave_port_microstrip_between_objects` is deprecated. Use `wave_port` property instead.",
-            DeprecationWarning,
-        )
-        return self.wave_port(
-            signal=startobj,
-            reference=endobject,
-            integration_line=axisdir,
-            create_port_sheet=True,
-            impedance=impedance,
-            num_modes=nummodes,
-            name=portname,
-            renormalize=renorm,
-            deembed=deembed_dist,
-            is_microstrip=True,
-            vfactor=vfactor,
-            hfactor=hfactor,
-        )
-
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(
+        startobj="assignment",
+        endobj="reference",
+        sourcename="name",
+        is_infinite_gnd="is_infinite_ground",
+        bound_on_plane="is_boundary_on_plane",
+        axisdir="start_direction",
+    )
     def create_perfecte_from_objects(
-        self, startobj, endobject, axisdir=0, sourcename=None, is_infinite_gnd=False, bound_on_plane=True
+        self, assignment, reference, start_direction=0, name=None, is_infinite_ground=False, is_boundary_on_plane=True
     ):
         """Create a Perfect E taking the closest edges of two objects.
 
         Parameters
         ----------
-        startobj :
+        assignment : str or int or :class:`pyaedt.modeler.cad.object3d.Object3d`
             Starting object for the integration line.
-        endobject :
+        reference :  str or int or :class:`pyaedt.modeler.cad.object3d.Object3d`
            Ending object for the integration line.
-        axisdir : int or :class:`pyaedt.application.Analysis.Analysis.AxisDir`, optional
-            Position of the port. It should be one of the values for
+        start_direction : int or :class:`pyaedt.application.Analysis.Analysis.AxisDir`, optional
+            Start direction for the boundary location. It should be one of the values for
             ``Application.AxisDir``, which are: ``XNeg``, ``YNeg``,
             ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``.  The default
             is ``Application.AxisDir.XNeg``.
-        sourcename : str, optional
-            Perfect E name. The default is ``None``.
-        is_infinite_gnd : bool, optional
+        name : str, optional
+            Perfect E name. The default is ``None``, in which
+            case a name is automatically assigned.
+        is_infinite_ground : bool, optional
             Whether the Perfect E is an infinite ground. The default is ``False``.
-        bound_on_plane : bool, optional
+        is_boundary_on_plane : bool, optional
             Whether to create the Perfect E on the plane orthogonal to
-            ``AxisDir``. The default is ``True``.
+            the axis direction. The default is ``True``.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject` or bool
             Boundary object if successful, ``False`` otherwise.
 
         References
@@ -2687,55 +2411,64 @@
 
         Create two boxes for creating a Perfect E named ``'PerfectE'``.
 
         >>> box1 = hfss.modeler.create_box([0,0,0], [10,10,5],
         ...                                "perfect1", "Copper")
         >>> box2 = hfss.modeler.create_box([0, 0, 10], [10, 10, 5],
         ...                                "perfect2", "copper")
-        >>> perfect_e = hfss.create_perfecte_from_objects("perfect1", "perfect2",
-        ...                                               hfss.AxisDir.ZNeg, "PerfectE")
+        >>> perfect_e = hfss.create_perfecte_from_objects("perfect1","perfect2",hfss.AxisDir.ZNeg,"PerfectE")
         PyAEDT INFO: Connection Correctly created
         >>> type(perfect_e)
         <class 'pyaedt.modules.Boundary.BoundaryObject'>
 
         """
 
-        if not self.modeler.does_object_exists(startobj) or not self.modeler.does_object_exists(endobject):
+        if not self.modeler.does_object_exists(assignment) or not self.modeler.does_object_exists(reference):
             self.logger.error("One or both objects do not exist. Check and retry.")
             return False
         if self.solution_type in ["Modal", "Terminal", "Transient Network"]:
             sheet_name, point0, point1 = self.modeler._create_sheet_from_object_closest_edge(
-                startobj, endobject, axisdir, bound_on_plane
+                assignment, reference, start_direction, is_boundary_on_plane
             )
 
-            if not sourcename:
-                sourcename = generate_unique_name("PerfE")
-            elif sourcename in self.modeler.get_boundaries_name():
-                sourcename = generate_unique_name(sourcename)
-            return self.create_boundary(self.BoundaryType.PerfectE, sheet_name, sourcename, is_infinite_gnd)
+            if not name:
+                name = generate_unique_name("PerfE")
+            elif name in self.modeler.get_boundaries_name():
+                name = generate_unique_name(name)
+            return self.create_boundary(self.BoundaryType.PerfectE, sheet_name, name, is_infinite_ground)
         return False
 
-    @pyaedt_function_handler()
-    def create_perfecth_from_objects(self, startobj, endobject, axisdir=0, sourcename=None, bound_on_plane=True):
+    @pyaedt_function_handler(
+        startobj="assignment",
+        endobject="reference",
+        sourcename="name",
+        bound_on_plane="is_boundary_on_plane",
+        axisdir="start_direction",
+    )
+    def create_perfecth_from_objects(
+        self, assignment, reference, start_direction=0, name=None, is_boundary_on_plane=True
+    ):
         """Create a Perfect H taking the closest edges of two objects.
 
         Parameters
         ----------
-        startobj :
+        assignment : str or int or :class:`pyaedt.modeler.cad.object3d.Object3d`
             Starting object for the integration line.
-        endobject :
+        reference : str or int or :class:`pyaedt.modeler.cad.object3d.Object3d`
             Ending object for the integration line.
-        axisdir : int or :class:`pyaedt.application.Analysis.Analysis.AxisDir`, optional
-            Position of the port. It should be one of the values for ``Application.AxisDir``,
+        start_direction : int or :class:`pyaedt.application.Analysis.Analysis.AxisDir`, optional
+            Start direction for the boundary location. It should be one of the values for ``Application.AxisDir``,
             which are: ``XNeg``, ``YNeg``, ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``.
             The default is ``Application.AxisDir.XNeg``.
-        sourcename : str, optional
-            Perfect H name. The default is ``None``.
-        bound_on_plane : bool, optional
-            Whether to create the Perfect H on the plane orthogonal to ``AxisDir``. The default is ``True``.
+        name : str, optional
+            Perfect H name. The default is ``None``,
+             in which case a name is automatically assigned.
+        is_boundary_on_plane : bool, optional
+            Whether to create the Perfect H on the plane
+            orthogonal to the axis direction. The default is ``True``.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject` or bool
             Boundary object if successful, ``False`` otherwise.
 
         References
@@ -2748,142 +2481,169 @@
 
         Create two boxes for creating a Perfect H named ``'PerfectH'``.
 
         >>> box1 = hfss.modeler.create_box([0,0,20], [10,10,5],
         ...                                "perfect1", "Copper")
         >>> box2 = hfss.modeler.create_box([0, 0, 30], [10, 10, 5],
         ...                                "perfect2", "copper")
-        >>> perfect_h = hfss.create_perfecth_from_objects("perfect1", "perfect2",
-        ...                                               hfss.AxisDir.ZNeg, "Perfect H")
+        >>> perfect_h = hfss.create_perfecth_from_objects("perfect1","perfect2",hfss.AxisDir.ZNeg,"Perfect H")
         PyAEDT INFO: Connection Correctly created
         >>> type(perfect_h)
         <class 'pyaedt.modules.Boundary.BoundaryObject'>
 
         """
 
-        if not self.modeler.does_object_exists(startobj) or not self.modeler.does_object_exists(endobject):
+        if not self.modeler.does_object_exists(assignment) or not self.modeler.does_object_exists(reference):
             self.logger.error("One or both objects do not exist. Check and retry.")
             return False
         if self.solution_type in ["Modal", "Terminal", "Transient Network"]:
             sheet_name, point0, point1 = self.modeler._create_sheet_from_object_closest_edge(
-                startobj, endobject, axisdir, bound_on_plane
+                assignment, reference, start_direction, is_boundary_on_plane
             )
 
-            if not sourcename:
-                sourcename = generate_unique_name("PerfH")
-            elif sourcename in self.modeler.get_boundaries_name():
-                sourcename = generate_unique_name(sourcename)
-            return self.create_boundary(self.BoundaryType.PerfectH, sheet_name, sourcename)
+            if not name:
+                name = generate_unique_name("PerfH")
+            elif name in self.modeler.get_boundaries_name():
+                name = generate_unique_name(name)
+            return self.create_boundary(self.BoundaryType.PerfectH, sheet_name, name)
         return None
 
-    @pyaedt_function_handler()
-    def sar_setup(self, Tissue_object_List_ID=-1, TissueMass=1, MaterialDensity=1, voxel_size=1, Average_SAR_method=0):
+    @pyaedt_function_handler(
+        Tissue_object_List_ID="assignment",
+        TissueMass="tissue_mass",
+        MaterialDensity="material_density",
+        Average_SAR_method="average_sar_method",
+    )
+    def sar_setup(self, assignment=-1, tissue_mass=1, material_density=1, voxel_size=1, average_sar_method=0):
         """Define SAR settings.
 
         Parameters
         ----------
-        Tissue_object_List_ID : int, optional
-           The default is ``-1`` to not specify the object.
-        TissueMass : float, optional
-            The default is ``1``.
-        MaterialDensity : optional
-            The default is ``1``.
+        assignment : int, optional
+           Object ID. The default is ``-1`` to not specify the object.
+        tissue_mass : float, optional
+            Mass of tissue in grams. The default is ``1``.
+        material_density : optional
+            Density of material in gram/cm^3. The default is ``1``.
         voxel_size : optional
-            The default is ``1``.
-        Average_SAR_method : optional
+            Size of a voxel in millimeters. The default is ``1``.
+        average_sar_method : optional
+            SAR method. There are two options, ``0`` for IEEE Standard 1528 and ``1`` for the standard Ansys method.
             The default is ``0``.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         References
         ----------
 
         >>> oDesign.SARSetup
         """
-        self.odesign.SARSetup(TissueMass, MaterialDensity, Tissue_object_List_ID, voxel_size, Average_SAR_method)
-        self.logger.info("SAR Settings correctly applied.")
+        self.odesign.SARSetup(tissue_mass, material_density, assignment, voxel_size, average_sar_method)
+        self.logger.info("SAR settings are correctly applied.")
         return True
 
-    @pyaedt_function_handler()
-    def create_open_region(self, Frequency="1GHz", Boundary="Radiation", ApplyInfiniteGP=False, GPAXis="-z"):
+    @pyaedt_function_handler(
+        Frequency="frequency", Boundary="boundary", ApplyInfiniteGP="apply_infinite_ground", GPAXis="gp_axis"
+    )
+    def create_open_region(self, frequency="1GHz", boundary="Radiation", apply_infinite_ground=False, gp_axis="-z"):
         """Create an open region on the active editor.
 
         Parameters
         ----------
-        Frequency : str, optional
+        frequency : str, optional
             Frequency with units. The default is ``"1GHz"``.
-        Boundary : str, optional
+        boundary : str, optional
             Type of the boundary. The default is ``"Radiation"``.
-        ApplyInfiniteGP : bool, optional
+        apply_infinite_ground : bool, optional
             Whether to apply an infinite ground plane. The default is ``False``.
-        GPAXis : str, optional
-            The default is ``"-z"``.
+        gp_axis : str, optional
+            Open region direction. The default is ``"-z"``.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         References
         ----------
 
         >>> oModule.CreateOpenRegion
         """
-        vars = ["NAME:Settings", "OpFreq:=", Frequency, "Boundary:=", Boundary, "ApplyInfiniteGP:=", ApplyInfiniteGP]
-        if ApplyInfiniteGP:
+        vars = [
+            "NAME:Settings",
+            "OpFreq:=",
+            frequency,
+            "Boundary:=",
+            boundary,
+            "ApplyInfiniteGP:=",
+            apply_infinite_ground,
+        ]
+        if apply_infinite_ground:
             vars.append("Direction:=")
-            vars.append(GPAXis)
+            vars.append(gp_axis)
 
         self.omodelsetup.CreateOpenRegion(vars)
         self.logger.info("Open Region correctly created.")
+        self.save_project()
         return True
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(
+        startobj="assignment",
+        endobj="reference",
+        sourcename="name",
+        rlctype="rlc_type",
+        Rvalue="resistance",
+        Lvalue="inductance",
+        Cvalue="capacitance",
+        bound_on_plane="is_boundary_on_plane",
+        axisdir="start_direction",
+    )
     def create_lumped_rlc_between_objects(
         self,
-        startobj,
-        endobject,
-        axisdir=0,
-        sourcename=None,
-        rlctype="Parallel",
-        Rvalue=None,
-        Lvalue=None,
-        Cvalue=None,
-        bound_on_plane=True,
+        assignment,
+        reference,
+        start_direction=0,
+        name=None,
+        rlc_type="Parallel",
+        resistance=None,
+        inductance=None,
+        capacitance=None,
+        is_boundary_on_plane=True,
     ):
         """Create a lumped RLC taking the closest edges of two objects.
 
         Parameters
         ----------
-        startobj :
+        assignment :
             Starting object for the integration line.
-        endobject :
+        reference :
             Ending object for the integration line.
-        axisdir : int or :class:`pyaedt.application.Analysis.Analysis.AxisDir`, optional
-            Position of the port. It should be one of the values for ``Application.AxisDir``,
+        start_direction : int or :class:`pyaedt.application.Analysis.Analysis.AxisDir`, optional
+            Start direction for the boundary location.. It should be one of the values for ``Application.AxisDir``,
             which are: ``XNeg``, ``YNeg``, ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``.
             The default is ``Application.AxisDir.XNeg``.
-        sourcename : str, optional
-            Perfect H name. The default is ``None``.
-        rlctype : str, optional
+        name : str, optional
+            Perfect H name. The default is ``None``, in which
+            case a name is automatically assigned.
+        rlc_type : str, optional
             Type of the RLC. Options are ``"Parallel"`` and ``"Serial"``.
             The default is ``"Parallel"``.
-        Rvalue : optional
+        resistance : optional
             Resistance value in ohms. The default is ``None``,
             in which case this parameter is disabled.
-        Lvalue : optional
+        inductance : optional
             Inductance value in H. The default is ``None``,
             in which case this parameter is disabled.
-        Cvalue : optional
+        capacitance : optional
             Capacitance value in F. The default is ``None``,
             in which case this parameter is disabled.
-        bound_on_plane : bool, optional
+        is_boundary_on_plane : bool, optional
             Whether to create the boundary on the plane orthogonal
             to ``AxisDir``. The default is ``True``.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject` or bool
             Boundary object if successful, ``False`` otherwise.
@@ -2898,86 +2658,93 @@
 
         Create two boxes for creating a lumped RLC named ``'LumpedRLC'``.
 
         >>> box1 = hfss.modeler.create_box([0, 0, 50], [10, 10, 5],
         ...                                           "rlc1", "copper")
         >>> box2 = hfss.modeler.create_box([0, 0, 60], [10, 10, 5],
         ...                                           "rlc2", "copper")
-        >>> rlc = hfss.create_lumped_rlc_between_objects("rlc1", "rlc2", hfss.AxisDir.XPos,
-        ...                                              "Lumped RLC", Rvalue=50,
-        ...                                              Lvalue=1e-9, Cvalue = 1e-6)
+        >>> rlc = hfss.create_lumped_rlc_between_objects("rlc1","rlc2",hfss.AxisDir.XPos,"Lumped RLC",resistance=50,
+        ...                                              inductance=1e-9, capacitance=1e-6)
         PyAEDT INFO: Connection Correctly created
 
         """
 
-        if not self.modeler.does_object_exists(startobj) or not self.modeler.does_object_exists(endobject):
+        if not self.modeler.does_object_exists(assignment) or not self.modeler.does_object_exists(reference):
             self.logger.error("One or both objects do not exist. Check and retry.")
             return False
-        if self.solution_type in ["Modal", "Terminal", "Transient Network"] and (Rvalue or Lvalue or Cvalue):
+        if self.solution_type in ["Modal", "Terminal", "Transient Network"] and (
+            resistance or inductance or capacitance
+        ):
             sheet_name, point0, point1 = self.modeler._create_sheet_from_object_closest_edge(
-                startobj, endobject, axisdir, bound_on_plane
+                assignment, reference, start_direction, is_boundary_on_plane
             )
 
-            if not sourcename:
-                sourcename = generate_unique_name("Lump")
-            elif sourcename in self.modeler.get_boundaries_name():
-                sourcename = generate_unique_name(sourcename)
+            if not name:
+                name = generate_unique_name("Lump")
+            elif name in self.modeler.get_boundaries_name():
+                name = generate_unique_name(name)
             start = [str(i) + self.modeler.model_units for i in point0]
             stop = [str(i) + self.modeler.model_units for i in point1]
 
             props = OrderedDict()
             props["Objects"] = [sheet_name]
             props["CurrentLine"] = OrderedDict({"Start": start, "End": stop})
-            props["RLC Type"] = rlctype
-            if Rvalue:
+            props["RLC Type"] = rlc_type
+            if resistance:
                 props["UseResist"] = True
-                props["Resistance"] = str(Rvalue) + "ohm"
-            if Lvalue:
+                props["Resistance"] = str(resistance) + "ohm"
+            if inductance:
                 props["UseInduct"] = True
-                props["Inductance"] = str(Lvalue) + "H"
-            if Cvalue:
+                props["Inductance"] = str(inductance) + "H"
+            if capacitance:
                 props["UseCap"] = True
-                props["Capacitance"] = str(Cvalue) + "farad"
+                props["Capacitance"] = str(capacitance) + "farad"
 
-            return self._create_boundary(sourcename, props, "Lumped RLC")
+            return self._create_boundary(name, props, "Lumped RLC")
         return False
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(
+        startobj="start_assignment",
+        endobject="end_assignment",
+        axisdir="start_direction",
+        sourcename="source_name",
+        is_infground="is_infinite_ground",
+    )
     def create_impedance_between_objects(
         self,
-        startobj,
-        endobject,
-        axisdir=0,
-        sourcename=None,
+        start_assignment,
+        end_assignment,
+        start_direction=0,
+        source_name=None,
         resistance=50,
         reactance=0,
-        is_infground=False,
+        is_infinite_ground=False,
         bound_on_plane=True,
     ):
         """Create an impedance taking the closest edges of two objects.
 
         Parameters
         ----------
-        startobj :
+        start_assignment : str or int or :class:`pyaedt.modeler.cad.object3d.Object3d`
             Starting object for the integration line.
-        endobject :
+        end_assignment : str or int or :class:`pyaedt.modeler.cad.object3d.Object3d`
             Ending object for the integration line.
-        axisdir : int or :class:`pyaedt.application.Analysis.Analysis.AxisDir`, optional
-            Position of the port. It should be one of the values for ``Application.AxisDir``,
+        start_direction : int or :class:`pyaedt.application.Analysis.Analysis.AxisDir`, optional
+            Start direction for the boundary location. It should be one of the values for ``Application.AxisDir``,
             which are: ``XNeg``, ``YNeg``, ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``.
             The default is ``Application.AxisDir.XNeg``.
-        sourcename : str, optional
+        source_name : str, optional
             Name of the impedance. The default is ``None``.
         resistance : float, optional
             Resistance value in ohms. The default is ``50``. If ``None``,
             this parameter is disabled.
         reactance : optional
             Reactance value in ohms. The default is ``0``. If ``None``,
             this parameter is disabled.
-        is_infground : bool, optional
+        is_infinite_ground : bool, optional
             Whether the impendance is an infinite ground. The default is ``False``.
         bound_on_plane : bool, optional
             Whether to create the impedance on the plane orthogonal to ``AxisDir``.
             The default is ``True``.
 
         Returns
         -------
@@ -3000,73 +2767,85 @@
         ...                                           "box2", "copper")
         >>> impedance = hfss.create_impedance_between_objects("box1", "box2", hfss.AxisDir.XPos,
         ...                                                   "ImpedanceExample", 100, 50)
         PyAEDT INFO: Connection Correctly created
 
         """
 
-        if not self.modeler.does_object_exists(startobj) or not self.modeler.does_object_exists(endobject):
+        if not self.modeler.does_object_exists(start_assignment) or not self.modeler.does_object_exists(end_assignment):
             self.logger.error("One or both objects do not exist. Check and retry.")
             return False
         if self.solution_type in ["Modal", "Terminal", "Transient Network"]:
             sheet_name, point0, point1 = self.modeler._create_sheet_from_object_closest_edge(
-                startobj, endobject, axisdir, bound_on_plane
+                start_assignment, end_assignment, start_direction, bound_on_plane
             )
 
-            if not sourcename:
-                sourcename = generate_unique_name("Imped")
-            elif sourcename in self.modeler.get_boundaries_name():
-                sourcename = generate_unique_name(sourcename)
+            if not source_name:
+                source_name = generate_unique_name("Imped")
+            elif source_name in self.modeler.get_boundaries_name():
+                source_name = generate_unique_name(source_name)
             props = OrderedDict(
                 {
                     "Objects": [sheet_name],
                     "Resistance": str(resistance),
                     "Reactance": str(reactance),
-                    "InfGroundPlane": is_infground,
+                    "InfGroundPlane": is_infinite_ground,
                 }
             )
-            return self._create_boundary(sourcename, props, "Impedance")
+            return self._create_boundary(source_name, props, "Impedance")
         return False
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(sheet_name="assignment", boundary_name="name", is_inifinite_gnd="is_inifinite_ground")
     def create_boundary(
-        self, boundary_type=BoundaryType.PerfectE, sheet_name=None, boundary_name="", is_infinite_gnd=False
+        self, boundary_type=BoundaryType.PerfectE, assignment=None, name=None, is_inifinite_ground=False
     ):
-        """Create a boundary given specific inputs.
+        """Assign a boundary condition to a sheet or surface. This method is generally
+           used by other methods in the ``Hfss`` class such as the :meth:``Hfss.assign_febi``
+           or :meth:``Hfss.assign_radiation_boundary_to_faces`` method.
 
         Parameters
         ----------
-        boundary_type : str, optional
-            Boundary type object. Options are ``"Perfect E"``, ``"Perfect H"``, ``"Aperture"``, and
-            ``"Radiation"``. The default is ``PerfectE``.
-        sheet_name : in, str, or list, optional
-            Name of the sheet. It can be an integer (face ID), a string (sheet), or a list of integers
-            and strings. The default is ``None``.
-        boundary_name : str, optional
-            Name of the boundary. The default is ``""``.
-        is_infinite_gnd : bool, optional
+        boundary_type : int, optional
+            Type of boundary condition to assign to a sheet or surface. The
+            default is ``Hfss.BoundaryType.PerfectE``. Options are the properties of the
+            :class:``Hfss.BoundaryType`` class. For example:
+
+                - ``Hfss.BoundaryType.PerfectE``
+                - ``Hfss.BoundaryType.PerfectH``
+                - ``Hfss.BoundaryType.Radiation``
+                - ``Hfss.BoundaryType.Impedance``
+                - ``Hfss.BoundaryType.LumpedRLC``
+                - ``Hfss.BoundaryType.FEBI``
+
+        assignment : int, str, or list, optional
+            Name of the sheet or face to assign the boundary condition to. The
+            default is ``None``. You can provide an integer (face ID), a string (sheet),
+            or a list of integers and strings.
+        name : str, optional
+            Name of the boundary. The default is ``None``.
+        is_inifinite_ground : bool, optional
             Whether the boundary is an infinite ground. The default is ``False``.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject`
             Boundary object.
 
         """
 
         props = {}
-        sheet_name = self.modeler.convert_to_selections(sheet_name, True)
-        if type(sheet_name) is list:
-            if type(sheet_name[0]) is str:
-                props["Objects"] = sheet_name
+        assignment = self.modeler.convert_to_selections(assignment, True)
+        if type(assignment) is list:
+            if type(assignment[0]) is str:
+                props["Objects"] = assignment
             else:
-                props["Faces"] = sheet_name
+                props["Faces"] = assignment
 
         if boundary_type == self.BoundaryType.PerfectE:
-            props["InfGroundPlane"] = is_infinite_gnd
+            props["InfGroundPlane"] = is_inifinite_ground
             boundary_type = "Perfect E"
         elif boundary_type == self.BoundaryType.PerfectH:
             boundary_type = "Perfect H"
         elif boundary_type == self.BoundaryType.Aperture:
             boundary_type = "Aperture"
         elif boundary_type == self.BoundaryType.Radiation:
             props["IsFssReference"] = False
@@ -3076,15 +2855,15 @@
             props["IsLinkedRegion"] = False
             props["Type"] = "SBR+"
             boundary_type = "Hybrid"
         elif boundary_type == self.BoundaryType.FEBI:
             boundary_type = "FE-BI"
         else:
             return None
-        return self._create_boundary(boundary_name, props, boundary_type)
+        return self._create_boundary(name, props, boundary_type)
 
     @pyaedt_function_handler()
     def _get_reference_and_integration_points(self, sheet, axisdir, obj_name=None):
         if isinstance(sheet, int):
             objID = [sheet]
             sheet = obj_name
         else:
@@ -3118,258 +2897,28 @@
         int_start = None
         int_stop = None
         if min_point != max_point:
             int_start = min_point
             int_stop = max_point
         return refid, int_start, int_stop
 
-    @pyaedt_function_handler()
-    def create_wave_port_from_sheet(
-        self,
-        sheet,
-        deemb=0,
-        axisdir=None,
-        impedance=50,
-        nummodes=1,
-        portname=None,
-        renorm=True,
-        terminal_references=None,
-    ):
-        """Create a waveport on sheet objects created starting from sheets.
-
-        .. deprecated:: 0.6.62
-            `create_wave_port_from_sheet` is deprecated. Use `wave_port` property instead.
-
-        Parameters
-        ----------
-        sheet : str or int or list or :class:`pyaedt.modeler.cad.object3d.Object3d`
-            Name of the sheet.
-        deemb : float, optional
-            Deembedding value distance in model units. The default is ``0``.
-        axisdir : int or :class:`pyaedt.application.Analysis.Analysis.AxisDir`, optional
-            Position of the port. It is used to auto evaluate the integration line.
-            If set to ``None`` the integration line is not defined.
-            It should be one of the values for ``Application.AxisDir``,
-            which are: ``XNeg``, ``YNeg``, ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``.
-            The default is ``None`` and no integration line is defined.
-        impedance : float, optional
-            Port impedance. The default is ``50``.
-        nummodes : int, optional
-            Number of modes. The default is ``1``.
-        portname : str, optional
-            Name of the port. The default is ``None``.
-        renorm : bool, optional
-            Whether to renormalize the mode. The default is ``True``.
-        terminal_references : list, optional
-            For a driven-terminal simulation, list of conductors for port terminal definitions.
-
-        Returns
-        -------
-        :class:`pyaedt.modules.Boundary.BoundaryObject`
-            Boundary object.
-
-        References
-        ----------
-
-        >>> oModule.AssignWavePort
-
-        Examples
-        --------
-
-        Create a circle sheet for creating a wave port named ``'WavePortFromSheet'``.
-
-        >>> origin_position = hfss.modeler.Position(0, 0, 0)
-        >>> circle = hfss.modeler.create_circle(hfss.PLANE.YZ,
-        ...                                                origin_position, 10, name="WaveCircle")
-        >>> hfss.solution_type = "Modal"
-        >>> port = hfss.create_wave_port_from_sheet(circle, 5, hfss.AxisDir.XNeg, 40, 2,
-        ...                                         "WavePortFromSheet", True)
-        >>> port[0].name
-        'WavePortFromSheet'
-
-        """
-        warnings.warn(
-            "`create_wave_port_from_sheet` is deprecated. Use `wave_port` property instead.", DeprecationWarning
-        )
-        return self.wave_port(
-            signal=sheet,
-            reference=terminal_references,
-            integration_line=axisdir,
-            create_port_sheet=False,
-            impedance=impedance,
-            num_modes=nummodes,
-            name=portname,
-            renormalize=renorm,
-            deembed=deemb,
-        )
-
-    @pyaedt_function_handler()
-    def create_wave_port(
-        self,
-        port_item,  # Item to use for wave port creation
-        int_start,
-        int_stop,
-        deemb=0,
-        axisdir=None,
-        impedance=50,
-        nummodes=1,
-        portname=None,
-        renorm=True,
-        terminal_references=None,
-    ):
-        """Assign a wave port to a face given a point on the face.
-
-        .. deprecated:: 0.6.62
-            `create_wave_port` is deprecated. Use `wave_port` property instead.
-
-        Parameters
-        ----------
-        port_item : list, int
-            Item for defining where to create the port.
-            If a list is passed, then Cartesian [x,y,z] coordinates of a point on the face are
-            expected. If an integer is passed, it is assumed to be a face ID.
-        deemb : float, optional
-            Deembedding value distance in model units. The default is ``0``.
-        axisdir : int or :class:`pyaedt.application.Analysis.Analysis.AxisDir`, optional
-            Position of the port. This parameter is used to automatically evaluate
-            the integration line. The default is ``None``, in which case no integration
-            line is defined. This parameter should be set to one of the values
-            for ``Application.AxisDir``,  which are: ``XNeg``, ``YNeg``, ``ZNeg``,
-            ``XPos``, ``YPos``, and ``ZPos``.
-
-        impedance : float, optional
-            Port impedance. The default is ``50``.
-        nummodes : int, optional
-            Number of modes. The default is ``1``.
-        portname : str, optional
-            Name of the port. The default is ``None``.
-        renorm : bool, optional
-            Whether to renormalize the mode. The default is ``True``.
-        terminal_references : list, optional
-            For a driven-terminal simulation, list of conductors for port terminal definitions.
-
-        Returns
-        -------
-        :class:`pyaedt.modules.Boundary.BoundaryObject`
-            Boundary object.
-
-        References
-        ----------
-
-        >>> oModule.AssignWavePort
-
-        Examples
-        --------
-
-        Create a circle sheet for creating a wave port named ``'WavePortFromSheet'``.
-
-        >>> hfss.modeler.model_units("in")
-        >>> hfss.modeler.create_box([-0.2, -0.45, -1], [0.4, 0.9, 2], name="Xband_WG", matname="vacuum")
-        >>> setup = hfss.create_setup("Setup1")
-        >>> setup["Frequency"] = "10GHz"
-        >>> ports = [ hfss.create_wave_port([0, "a/2", "-wg_len/2"], portname="Port1", deembed=False),
-        >>>  ...      hfss.create_wave_port([0, "a/2", "wg_len/2"], portname="Port2", deembed=False) ]
-        >>> [print(name) for p.name in ports]
-
-        """
-        warnings.warn("`create_wave_port` is deprecated. Use `wave_port` property instead.", DeprecationWarning)
-        return self.wave_port(
-            signal=port_item,
-            reference=terminal_references,
-            integration_line=[int_start, int_stop],
-            create_port_sheet=True,
-            impedance=impedance,
-            num_modes=nummodes,
-            name=portname,
-            renormalize=renorm,
-            deembed=deemb,
-        )
-
-    @pyaedt_function_handler()
-    def create_lumped_port_to_sheet(
-        self, sheet_name, axisdir=0, impedance=50, portname=None, renorm=True, deemb=False, reference_object_list=[]
-    ):
-        """Create a lumped port taking one sheet.
-
-        .. deprecated:: 0.6.62
-            `create_lumped_port_to_sheet` is deprecated. Use `lumped` property instead.
-
-        Parameters
-        ----------
-        sheet_name : str
-            Name of the sheet.
-        axisdir : int, :class:`pyaedt.application.Analysis.Analysis.AxisDir` or list, optional
-            Direction of the integration line. It should be one of the values for ``Application.AxisDir``,
-            which are: ``XNeg``, ``YNeg``, ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``. It also accepts the list
-            of the start point and end point with the format [[xstart, ystart, zstart], [xend, yend, zend]].
-            The default is ``Application.AxisDir.XNeg``.
-        impedance : float, optional
-            Port impedance. The default is ``50``.
-        portname : str, optional
-            Name of the port. The default is ``None``.
-        renorm : bool, optional
-            Whether to renormalize the mode. The default is ``True``.
-        deemb : bool, optional
-            Whether to deembed the port. The default is ``False``.
-        reference_object_list : list, optional
-            For a driven terminal solution only, a list of reference conductors. The default is ``[]``.
-
-        Returns
-        -------
-        :class:`pyaedt.modules.Boundary.BoundaryObject`
-            Boundary object.
-
-        References
-        ----------
-
-        >>> oModule.AssignLumpedPort
-
-        Examples
-        --------
-
-        Create a rectangle sheet for creating a lumped port named ``'LumpedPortFromSheet'``.
-
-        >>> rectangle = hfss.modeler.create_rectangle(hfss.PLANE.XY,
-        ...                                                      [0, 0, 0], [10, 2], name="lump_port",
-        ...                                                      matname="copper")
-        >>> h1 = hfss.create_lumped_port_to_sheet(rectangle.name, hfss.AxisDir.XNeg, 50,
-        ...                                  "LumpedPortFromSheet", True, False)
-        >>> h2 = hfss.create_lumped_port_to_sheet(rectangle.name, [rectangle.bottom_edge_x.midpoint,
-        ...                                     rectangle.bottom_edge_y.midpoint], 50, "LumpedPortFromSheet", True,
-        ...                                     False)
-
-        """
-        warnings.warn(
-            "`create_lumped_port_to_sheet` is deprecated. Use `lumped_port` property instead.", DeprecationWarning
-        )
-        return self.lumped_port(
-            signal=sheet_name,
-            reference=reference_object_list,
-            integration_line=axisdir,
-            create_port_sheet=False,
-            impedance=impedance,
-            name=portname,
-            renormalize=renorm,
-            deembed=deemb,
-        )
-
-    @pyaedt_function_handler()
-    def assign_voltage_source_to_sheet(self, sheet_name, axisdir=0, sourcename=None):
+    @pyaedt_function_handler(sheet_name="assignment", sourcename="name", axisdir="start_direction")
+    def assign_voltage_source_to_sheet(self, assignment, start_direction=0, name=None):
         """Create a voltage source taking one sheet.
 
         Parameters
         ----------
-        sheet_name : str
+        assignment : str
             Name of the sheet to apply the boundary to.
-        axisdir : int, :class:`pyaedt.application.Analysis.Analysis.AxisDir` or list, optional
+        start_direction : int, :class:`pyaedt.application.Analysis.Analysis.AxisDir` or list, optional
             Direction of the integration line. It should be one of the values for ``Application.AxisDir``,
             which are: ``XNeg``, ``YNeg``, ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``. It also accepts the list
             of the start point and end point with the format [[xstart, ystart, zstart], [xend, yend, zend]]
             The default is ``Application.AxisDir.XNeg``.
-        sourcename : str, optional
+        name : str, optional
             Name of the source. The default is ``None``.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject`
             Boundary object.
 
@@ -3382,48 +2931,47 @@
         --------
 
         Create a sheet and assign to it some voltage.
 
         >>> sheet = hfss.modeler.create_rectangle(hfss.PLANE.XY,
         ...                                                  [0, 0, -70], [10, 2], name="VoltageSheet",
         ...                                                  matname="copper")
-        >>> v1 = hfss.assign_voltage_source_to_sheet(sheet.name, hfss.AxisDir.XNeg, "VoltageSheetExample")
-        >>> v2 = hfss.assign_voltage_source_to_sheet(sheet.name, [sheet.bottom_edge_x.midpoint,
-        ...                                     sheet.bottom_edge_y.midpoint], 50, "LumpedPortFromSheet", True,
-        ...                                     False)
+        >>> v1 = hfss.assign_voltage_source_to_sheet(sheet.name,hfss.AxisDir.XNeg,"VoltageSheetExample")
+        >>> v2 = hfss.assign_voltage_source_to_sheet(sheet.name,[sheet.bottom_edge_x.midpoint,
+        ...                                     sheet.bottom_edge_y.midpoint],50)
 
         """
 
         if self.solution_type in ["Modal", "Terminal", "Transient Network"]:
-            if isinstance(axisdir, list):
-                if len(axisdir) != 2 or len(axisdir[0]) != len(axisdir[1]):
+            if isinstance(start_direction, list):
+                if len(start_direction) != 2 or len(start_direction[0]) != len(start_direction[1]):
                     self.logger.error("List of coordinates is not set correctly")
                     return False
-                point0 = axisdir[0]
-                point1 = axisdir[1]
+                point0 = start_direction[0]
+                point1 = start_direction[1]
             else:
-                point0, point1 = self.modeler.get_mid_points_on_dir(sheet_name, axisdir)
-            sourcename = self._get_unique_source_name(sourcename, "Voltage")
-            return self.create_source_excitation(sheet_name, point0, point1, sourcename, sourcetype="Voltage")
+                point0, point1 = self.modeler.get_mid_points_on_dir(assignment, start_direction)
+            name = self._get_unique_source_name(name, "Voltage")
+            return self.create_source_excitation(assignment, point0, point1, name, source_type="Voltage")
         return False
 
-    @pyaedt_function_handler()
-    def assign_current_source_to_sheet(self, sheet_name, axisdir=0, sourcename=None):
+    @pyaedt_function_handler(sheet_name="assignment", sourcename="name", axisdir="start_direction")
+    def assign_current_source_to_sheet(self, assignment, start_direction=0, name=None):
         """Create a current source taking one sheet.
 
         Parameters
         ----------
-        sheet_name : str
+        assignment : str
             Name of the sheet to apply the boundary to.
-        axisdir : int, :class:`pyaedt.application.Analysis.Analysis.AxisDir` or list, optional
+        start_direction : int, :class:`pyaedt.application.Analysis.Analysis.AxisDir` or list, optional
             Direction of the integration line. It should be one of the values for ``Application.AxisDir``,
             which are: ``XNeg``, ``YNeg``, ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``. It also accepts the list
             of the start point and end point with the format [[xstart, ystart, zstart], [xend, yend, zend]]
             The default is ``Application.AxisDir.XNeg``.
-        sourcename : str, optional
+        name : str, optional
             Name of the source. The default is ``None``.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject`
             Boundary object.
 
@@ -3435,45 +2983,45 @@
         Examples
         --------
 
         Create a sheet and assign some current to it.
 
         >>> sheet = hfss.modeler.create_rectangle(hfss.PLANE.XY, [0, 0, -50],
         ...                                                  [5, 1], name="CurrentSheet", matname="copper")
-        >>> hfss.assign_current_source_to_sheet(sheet.name, hfss.AxisDir.XNeg, "CurrentSheetExample")
+        >>> hfss.assign_current_source_to_sheet(sheet.name,hfss.AxisDir.XNeg,"CurrentSheetExample")
         'CurrentSheetExample'
-        >>> c1 = hfss.assign_current_source_to_sheet(sheet.name, [sheet.bottom_edge_x.midpoint,
+        >>> c1 = hfss.assign_current_source_to_sheet(sheet.name,[sheet.bottom_edge_x.midpoint,
         ...                                     sheet.bottom_edge_y.midpoint])
 
         """
 
         if self.solution_type in ["Modal", "Terminal", "Transient Network"]:
-            if isinstance(axisdir, list):
-                if len(axisdir) != 2 or len(axisdir[0]) != len(axisdir[1]):
+            if isinstance(start_direction, list):
+                if len(start_direction) != 2 or len(start_direction[0]) != len(start_direction[1]):
                     self.logger.error("List of coordinates is not set correctly")
                     return False
-                point0 = axisdir[0]
-                point1 = axisdir[1]
+                point0 = start_direction[0]
+                point1 = start_direction[1]
             else:
-                point0, point1 = self.modeler.get_mid_points_on_dir(sheet_name, axisdir)
-            sourcename = self._get_unique_source_name(sourcename, "Current")
-            return self.create_source_excitation(sheet_name, point0, point1, sourcename, sourcetype="Current")
+                point0, point1 = self.modeler.get_mid_points_on_dir(assignment, start_direction)
+            name = self._get_unique_source_name(name, "Current")
+            return self.create_source_excitation(assignment, point0, point1, name, source_type="Current")
         return False
 
-    @pyaedt_function_handler()
-    def assign_perfecte_to_sheets(self, sheet_list, sourcename=None, is_infinite_gnd=False):
+    @pyaedt_function_handler(sheet_list="assignment", sourcename="name", is_infinite_gnd="is_infinite_ground")
+    def assign_perfecte_to_sheets(self, assignment, name=None, is_infinite_ground=False):
         """Create a Perfect E taking one sheet.
 
         Parameters
         ----------
-        sheet_list : str or list
-            Name of the sheet or list to apply the boundary to.
-        sourcename : str, optional
+        assignment : str or list
+            One or more names of the sheets to apply the boundary to.
+        name : str, optional
             Name of the Perfect E source. The default is ``None``.
-        is_infinite_gnd : bool, optional
+        is_infinite_ground : bool, optional
             Whether the Perfect E is an infinite ground. The default is ``False``.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject`
             Boundary object.
 
@@ -3485,37 +3033,37 @@
         Examples
         --------
 
         Create a sheet and use it to create a Perfect E.
 
         >>> sheet = hfss.modeler.create_rectangle(hfss.PLANE.XY, [0, 0, -90],
         ...                                       [10, 2], name="PerfectESheet", matname="Copper")
-        >>> perfect_e_from_sheet = hfss.assign_perfecte_to_sheets(sheet.name, "PerfectEFromSheet")
+        >>> perfect_e_from_sheet = hfss.assign_perfecte_to_sheets(sheet.name,"PerfectEFromSheet")
         >>> type(perfect_e_from_sheet)
         <class 'pyaedt.modules.Boundary.BoundaryObject'>
 
         """
-        sheet_list = self.modeler.convert_to_selections(sheet_list, True)
+        assignment = self.modeler.convert_to_selections(assignment, True)
         if self.solution_type in ["Modal", "Terminal", "Transient Network", "SBR+", "Eigenmode"]:
-            if not sourcename:
-                sourcename = generate_unique_name("PerfE")
-            elif sourcename in self.modeler.get_boundaries_name():
-                sourcename = generate_unique_name(sourcename)
-            return self.create_boundary(self.BoundaryType.PerfectE, sheet_list, sourcename, is_infinite_gnd)
+            if not name:
+                name = generate_unique_name("PerfE")
+            elif name in self.modeler.get_boundaries_name():
+                name = generate_unique_name(name)
+            return self.create_boundary(self.BoundaryType.PerfectE, assignment, name, is_infinite_ground)
         return None
 
-    @pyaedt_function_handler()
-    def assign_perfecth_to_sheets(self, sheet_list, sourcename=None):
+    @pyaedt_function_handler(sheet_list="assignment", sourcename="name")
+    def assign_perfecth_to_sheets(self, assignment, name=None):
         """Assign a Perfect H to sheets.
 
         Parameters
         ----------
-        sheet_list : list
+        assignment : list
             List of sheets to apply the boundary to.
-        sourcename : str, optional
+        name : str, optional
             Perfect H name. The default is ``None``.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject`
             Boundary object.
 
@@ -3527,54 +3075,69 @@
         Examples
         --------
 
         Create a sheet and use it to create a Perfect H.
 
         >>> sheet = hfss.modeler.create_rectangle(hfss.PLANE.XY, [0, 0, -90],
         ...                                       [10, 2], name="PerfectHSheet", matname="Copper")
-        >>> perfect_h_from_sheet = hfss.assign_perfecth_to_sheets(sheet.name, "PerfectHFromSheet")
+        >>> perfect_h_from_sheet = hfss.assign_perfecth_to_sheets(sheet.name,"PerfectHFromSheet")
         >>> type(perfect_h_from_sheet)
         <class 'pyaedt.modules.Boundary.BoundaryObject'>
 
         """
 
         if self.solution_type in ["Modal", "Terminal", "Transient Network", "SBR+", "Eigenmode"]:
-            if not sourcename:
-                sourcename = generate_unique_name("PerfH")
-            elif sourcename in self.modeler.get_boundaries_name():
-                sourcename = generate_unique_name(sourcename)
-            return self.create_boundary(self.BoundaryType.PerfectH, sheet_list, sourcename)
+            if not name:
+                name = generate_unique_name("PerfH")
+            elif name in self.modeler.get_boundaries_name():
+                name = generate_unique_name(name)
+            return self.create_boundary(self.BoundaryType.PerfectH, assignment, name)
         return None
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(
+        sheet_name="assignment",
+        sourcename="name",
+        rlctype="rlc_type",
+        Rvalue="resistance",
+        Lvalue="inductance",
+        Cvalue="capacitance",
+        axisdir="start_direction",
+    )
     def assign_lumped_rlc_to_sheet(
-        self, sheet_name, axisdir=0, sourcename=None, rlctype="Parallel", Rvalue=None, Lvalue=None, Cvalue=None
+        self,
+        assignment,
+        start_direction=0,
+        name=None,
+        rlc_type="Parallel",
+        resistance=None,
+        inductance=None,
+        capacitance=None,
     ):
         """Create a lumped RLC taking one sheet.
 
         Parameters
         ----------
-        sheet_name : str
+        assignment : str
             Name of the sheet to apply the boundary to.
-        axisdir : int, :class:`pyaedt.application.Analysis.Analysis.AxisDir` or list, optional
+        start_direction : int, :class:`pyaedt.application.Analysis.Analysis.AxisDir` or list, optional
             Direction of the integration line. It should be one of the values for ``Application.AxisDir``,
             which are: ``XNeg``, ``YNeg``, ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``. It also accepts the list
             of the start point and end point with the format [[xstart, ystart, zstart], [xend, yend, zend]]
             The default is ``Application.AxisDir.XNeg``.
-        sourcename : str, optional
+        name : str, optional
             Lumped RLC name. The default is ``None``.
-        rlctype : str, optional
+        rlc_type : str, optional
             Type of the RLC. Options are ``"Parallel"`` and ``"Serial"``. The default is ``"Parallel"``.
-        Rvalue : float, optional
+        resistance : float, optional
             Resistance value in ohms. The default is ``None``, in which
             case this parameter is disabled.
-        Lvalue : optional
+        inductance : float, optional
             Inductance value in Henry (H). The default is ``None``, in which
             case this parameter is disabled.
-        Cvalue : optional
+        capacitance : float, optional
             Capacitance value in  farads (F). The default is ``None``, in which
             case this parameter is disabled.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject`
             Boundary object if successful, ``False`` otherwise.
@@ -3588,75 +3151,75 @@
         --------
 
         Create a sheet and use it to create a lumped RLC.
 
         >>> sheet = hfss.modeler.create_rectangle(hfss.PLANE.XY,
         ...                                       [0, 0, -90], [10, 2], name="RLCSheet",
         ...                                        matname="Copper")
-        >>> lumped_rlc_to_sheet = hfss.assign_lumped_rlc_to_sheet(sheet.name, hfss.AxisDir.XPos,
-        ...                                                       Rvalue=50, Lvalue=1e-9,
-        ...                                                       Cvalue=1e-6)
+        >>> lumped_rlc_to_sheet = hfss.assign_lumped_rlc_to_sheet(sheet.name,hfss.AxisDir.XPos,resistance=50,
+        ...                                                       inductance=1e-9,capacitance=1e-6)
         >>> type(lumped_rlc_to_sheet)
         <class 'pyaedt.modules.Boundary.BoundaryObject'>
-        >>> h2 = hfss.assign_lumped_rlc_to_sheet(sheet.name, [sheet.bottom_edge_x.midpoint,
-        ...                                     sheet.bottom_edge_y.midpoint], Rvalue=50, Lvalue=1e-9, Cvalue=1e-6)
+        >>> h2 = hfss.assign_lumped_rlc_to_sheet(sheet.name,[sheet.bottom_edge_x.midpoint,
+        ...                                      sheet.bottom_edge_y.midpoint],resistance=50,inductance=1e-9,
+        ...                                      capacitance=1e-6)
 
         """
 
         if self.solution_type in ["Eigenmode", "Modal", "Terminal", "Transient Network", "SBR+"] and (
-            Rvalue or Lvalue or Cvalue
+            resistance or inductance or capacitance
         ):
-            if isinstance(axisdir, list):
-                if len(axisdir) != 2 or len(axisdir[0]) != len(axisdir[1]):
+            if isinstance(start_direction, list):
+                if len(start_direction) != 2 or len(start_direction[0]) != len(start_direction[1]):
                     self.logger.error("List of coordinates is not set correctly")
                     return False
-                point0 = axisdir[0]
-                point1 = axisdir[1]
+                point0 = start_direction[0]
+                point1 = start_direction[1]
             else:
-                point0, point1 = self.modeler.get_mid_points_on_dir(sheet_name, axisdir)
+                point0, point1 = self.modeler.get_mid_points_on_dir(assignment, start_direction)
 
-            if not sourcename:
-                sourcename = generate_unique_name("Lump")
-            elif sourcename in self.modeler.get_boundaries_name():
-                sourcename = generate_unique_name(sourcename)
+            if not name:
+                name = generate_unique_name("Lump")
+            elif name in self.modeler.get_boundaries_name():
+                name = generate_unique_name(name)
             start = [str(i) + self.modeler.model_units for i in point0]
             stop = [str(i) + self.modeler.model_units for i in point1]
             props = OrderedDict()
-            props["Objects"] = [sheet_name]
+            props["Objects"] = [assignment]
             props["CurrentLine"] = OrderedDict({"Start": start, "End": stop})
-            props["RLC Type"] = rlctype
-            if Rvalue:
+            props["RLC Type"] = rlc_type
+            if resistance:
                 props["UseResist"] = True
-                props["Resistance"] = str(Rvalue) + "ohm"
-            if Lvalue:
+                props["Resistance"] = str(resistance) + "ohm"
+            if inductance:
                 props["UseInduct"] = True
-                props["Inductance"] = str(Lvalue) + "H"
-            if Cvalue:
+                props["Inductance"] = str(inductance) + "H"
+            if capacitance:
                 props["UseCap"] = True
-                props["Capacitance"] = str(Cvalue) + "F"
-            return self._create_boundary(sourcename, props, "Lumped RLC")
+                props["Capacitance"] = str(capacitance) + "F"
+            return self._create_boundary(name, props, "Lumped RLC")
         return False
 
-    @pyaedt_function_handler()
-    def assign_impedance_to_sheet(self, sheet_name, sourcename=None, resistance=50, reactance=0, is_infground=False):
+    @pyaedt_function_handler(sheet_name="assignment", sourcename="name", is_infground="is_inifinite_ground")
+    def assign_impedance_to_sheet(self, assignment, name=None, resistance=50, reactance=0, is_inifinite_ground=False):
         """Create an impedance taking one sheet.
 
         Parameters
         ----------
-        sheet_name : str or list
-            Name of the sheet or list to apply the boundary to.
-        sourcename : str, optional
+        assignment : str or list
+            One or more names of the sheets to apply the boundary to.
+        name : str, optional
             Name of the impedance. The default is ``None``.
         resistance : optional
             Resistance value in ohms. The default is ``50``. If ``None``,
             this parameter is disabled.
         reactance : optional
             Reactance value in ohms. The default is ``0``. If ``None``,
             this parameter is disabled.
-        is_infground : bool, optional
+        is_inifinite_ground : bool, optional
             Whether the impedance is an infinite ground. The default is ``False``.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject`
             Boundary object if successful, ``False`` otherwise.
 
@@ -3669,69 +3232,77 @@
         --------
 
         Create a sheet and use it to create an impedance.
 
         >>> sheet = hfss.modeler.create_rectangle(hfss.PLANE.XY,
         ...                                       [0, 0, -90], [10, 2], name="ImpedanceSheet",
         ...                                        matname="Copper")
-        >>> impedance_to_sheet = hfss.assign_impedance_to_sheet(sheet.name, "ImpedanceFromSheet", 100, 50)
+        >>> impedance_to_sheet = hfss.assign_impedance_to_sheet(sheet.name,"ImpedanceFromSheet",100,50)
         >>> type(impedance_to_sheet)
         <class 'pyaedt.modules.Boundary.BoundaryObject'>
 
         """
 
         if self.solution_type in ["Modal", "Terminal", "Transient Network"]:
-            if not sourcename:
-                sourcename = generate_unique_name("Imped")
-            elif sourcename in self.modeler.get_boundaries_name():
-                sourcename = generate_unique_name(sourcename)
+            if not name:
+                name = generate_unique_name("Imped")
+            elif name in self.modeler.get_boundaries_name():
+                name = generate_unique_name(name)
 
-            objects = self.modeler.convert_to_selections(sheet_name, True)
+            objects = self.modeler.convert_to_selections(assignment, True)
 
             props = OrderedDict(
                 {
                     "Faces": objects,
                 }
             )
             if isinstance(objects[0], str):
                 props = OrderedDict(
                     {
                         "Objects": objects,
                     }
                 )
             props["Resistance"] = str(resistance)
             props["Reactance"] = str(reactance)
-            props["InfGroundPlane"] = is_infground
+            props["InfGroundPlane"] = is_inifinite_ground
 
-            return self._create_boundary(sourcename, props, "Impedance")
+            return self._create_boundary(name, props, "Impedance")
         return False
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(
+        sheet_name="assignment", sourcename="name", is_infground="is_infinite_ground", reference_cs="coordinate_system"
+    )
     def assign_impedance_to_sheet(
-        self, sheet_name, sourcename=None, resistance=50.0, reactance=0.0, is_infground=False, reference_cs="Global"
+        self,
+        assignment,
+        name=None,
+        resistance=50.0,
+        reactance=0.0,
+        is_infinite_ground=False,
+        coordinate_system="Global",
     ):
         """Create an impedance taking one sheet.
 
         Parameters
         ----------
-        sheet_name : str or list
-            Name of the sheet or list to apply the boundary to.
-        sourcename : str, optional
+        assignment : str or list
+            One or more names of the sheets to apply the boundary to.
+        name : str, optional
             Name of the impedance. The default is ``None``.
         resistance : float or list, optional
             Resistance value in ohms. The default is ``50.0``.
             If a list of four elements is passed, an anisotropic impedance is assigned with the following order,
             [``Zxx``, ``Zxy``, ``Zyx``, ``Zyy``].
         reactance : optional
             Reactance value in ohms. The default is ``0.0``.
             If a list of four elements is passed, an anisotropic impedance is assigned with the following order,
             [``Zxx``, ``Zxy``, ``Zyx``, ``Zyy``].
-        is_infground : bool, optional
+        is_infinite_ground : bool, optional
             Whether the impedance is an infinite ground. The default is ``False``.
-        reference_cs : str, optional
+        coordinate_system : str, optional
             Name of the coordinate system for the XY plane. The default is ``"Global"``.
             This parameter is only used for anisotropic impedance assignment.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject`
             Boundary object if successful, ``False`` otherwise.
@@ -3745,33 +3316,35 @@
         --------
 
         Create a sheet and use it to create an impedance.
 
         >>> sheet = hfss.modeler.create_rectangle(hfss.PLANE.XY,
         ...                                       [0, 0, -90], [10, 2], name="ImpedanceSheet",
         ...                                        matname="Copper")
-        >>> impedance_to_sheet = hfss.assign_impedance_to_sheet(sheet.name, "ImpedanceFromSheet", 100, 50)
+        >>> impedance_to_sheet = hfss.assign_impedance_to_sheet(sheet.name,"ImpedanceFromSheet",100,50)
 
         Create a sheet and use it to create an anisotropic impedance.
 
         >>> sheet = hfss.modeler.create_rectangle(hfss.PLANE.XY,
         ...                                       [0, 0, -90], [10, 2], name="ImpedanceSheet",
         ...                                        matname="Copper")
-        >>> anistropic_impedance_to_sheet = hfss.assign_impedance_to_sheet(sheet.name, "ImpedanceFromSheet",
-        ...                                                                 [377, 0, 0, 377], [0, 50, 0, 0])
+        >>> anistropic_impedance_to_sheet = hfss.assign_impedance_to_sheet(sheet.name,
+        ...                                                                "ImpedanceFromSheet",
+        ...                                                                [377, 0, 0, 377],
+        ...                                                                [0, 50, 0, 0])
 
         """
 
         if self.solution_type in ["Modal", "Terminal", "Transient Network"]:
-            if not sourcename:
-                sourcename = generate_unique_name("Imped")
-            elif sourcename in self.modeler.get_boundaries_name():
-                sourcename = generate_unique_name(sourcename)
+            if not name:
+                name = generate_unique_name("Imped")
+            elif name in self.modeler.get_boundaries_name():
+                name = generate_unique_name(name)
 
-            objects = self.modeler.convert_to_selections(sheet_name, True)
+            objects = self.modeler.convert_to_selections(assignment, True)
 
             props = OrderedDict(
                 {
                     "Faces": objects,
                 }
             )
             if isinstance(objects[0], str):
@@ -3779,62 +3352,64 @@
                     {
                         "Objects": objects,
                     }
                 )
 
             if isinstance(resistance, list) and isinstance(reactance, list):
                 if len(resistance) == 4 and len(reactance) == 4:
-                    props["UseInfiniteGroundPlane"] = is_infground
-                    props["CoordSystem"] = reference_cs
+                    props["UseInfiniteGroundPlane"] = is_infinite_ground
+                    props["CoordSystem"] = coordinate_system
                     props["HasExternalLink"] = False
                     props["ZxxResistance"] = str(resistance[0])
                     props["ZxxReactance"] = str(reactance[0])
                     props["ZxyResistance"] = str(resistance[1])
                     props["ZxyReactance"] = str(reactance[1])
                     props["ZyxResistance"] = str(resistance[2])
                     props["ZyxReactance"] = str(reactance[2])
                     props["ZyyResistance"] = str(resistance[3])
                     props["ZyyReactance"] = str(reactance[3])
                 else:
                     self.logger.error("Number of elements in resistance and reactance must be four.")
                     return False
-                return self._create_boundary(sourcename, props, "Anisotropic Impedance")
+                return self._create_boundary(name, props, "Anisotropic Impedance")
             else:
                 props["Resistance"] = str(resistance)
                 props["Reactance"] = str(reactance)
-                props["InfGroundPlane"] = is_infground
-                return self._create_boundary(sourcename, props, "Impedance")
+                props["InfGroundPlane"] = is_infinite_ground
+                return self._create_boundary(name, props, "Impedance")
         return False
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(
+        edge_signale="assignment", edge_gnd="reference", port_name="name", port_impedance="impedance"
+    )
     def create_circuit_port_from_edges(
         self,
-        edge_signal,
-        edge_gnd,
-        port_name="",
-        port_impedance="50",
+        assignment,
+        reference,
+        name="",
+        impedance="50",
         renormalize=False,
         renorm_impedance="50",
         deembed=False,
     ):
         """Create a circuit port from two edges.
         The integration line is from edge 2 to edge 1.
 
         .. deprecated:: 0.6.70
         Use :func:`circuit_port` method instead.
 
         Parameters
         ----------
-        edge_signal : int
+        assignment : int
             Edge ID of the signal.
-        edge_gnd : int
+        reference : int
             Edge ID of the ground.
-        port_name : str, optional
+        name : str, optional
             Name of the port. The default is ``""``.
-        port_impedance : int, str, or float, optional
+        impedance : int, str, or float, optional
             Impedance. The default is ``"50"``. You can also
             enter a string that looks like this: ``"50+1i*55"``.
         renormalize : bool, optional
             Whether to renormalize the mode. The default is ``False``.
             This parameter is ignored for a driven terminal.
         renorm_impedance :  str, optional
             Impedance. The default is ``50``.
@@ -3865,61 +3440,63 @@
         >>> edges1 = hfss.modeler.get_object_edges(rectangle1.id)
         >>> first_edge = edges1[0]
         >>> rectangle2 = hfss.modeler.create_rectangle(plane, [30, 10, 10], [10, 10],
         ...                                            name="rectangle2_for_port")
         >>> edges2 = hfss.modeler.get_object_edges(rectangle2.id)
         >>> second_edge = edges2[0]
         >>> hfss.solution_type = "Modal"
-        >>> hfss.create_circuit_port_from_edges(first_edge, second_edge, port_name="PortExample",
-        ...                                     port_impedance=50.1, renormalize=False,
+        >>> hfss.create_circuit_port_from_edges(first_edge,second_edge,
+        ...                                     name="PortExample",
+        ...                                     impedance=50.1,
+        ...                                     renormalize=False,
         ...                                     renorm_impedance="50")
         'PortExample'
 
         """
         warnings.warn("Use :func:`circuit_port` method instead.", DeprecationWarning)
         return self.circuit_port(
-            signal=edge_signal,
-            reference=edge_gnd,
+            assignment=assignment,
+            reference=reference,
             port_location=0,
-            impedance=port_impedance,
-            name=port_name,
+            impedance=impedance,
+            name=name,
             renormalize=renormalize,
             renorm_impedance=renorm_impedance,
             deembed=deembed,
         )
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(excitations="assignment")
     def edit_sources(
-        self, excitations, include_port_post_processing=True, max_available_power=None, use_incident_voltage=False
+        self, assignment, include_port_post_processing=True, max_available_power=None, use_incident_voltage=False
     ):
         """Set up the power loaded for HFSS postprocessing in multiple sources simultaneously.
 
         Parameters
         ----------
-        excitations : dict
+        assignment : dict
             Dictionary of input sources to modify module and phase.
             Dictionary values can be:
             - 1 value to setup 0deg as default
             - 2 values tuple or list (magnitude and phase) or
             - 3 values (magnitude, phase, and termination flag) for Terminal solution in case of incident voltage usage.
 
         Returns
         -------
         bool
 
         Examples
         --------
         >>> sources = {"Port1:1": ("0W", "0deg"), "Port2:1": ("1W", "90deg")}
-        >>> hfss.edit_sources(sources, include_port_post_processing=True)
+        >>> hfss.edit_sources(sources,include_port_post_processing=True)
 
         >>> sources = {"Box2_T1": ("0V", "0deg", True), "Box1_T1": ("1V", "90deg")}
-        >>> hfss.edit_sources(sources, max_available_power="2W", use_incident_voltage=True)
+        >>> hfss.edit_sources(sources,max_available_power="2W",use_incident_voltage=True)
         """
         data = {i: ("0W", "0deg", False) for i in self.excitations}
-        for key, value in excitations.items():
+        for key, value in assignment.items():
             data[key] = value
         setting = []
         for key, vals in data.items():
             if isinstance(vals, str):
                 power = vals
                 phase = "0deg"
             else:
@@ -3955,25 +3532,25 @@
 
         args = [argument]
         args.extend(setting)
         for arg in args:
             self.osolution.EditSources(arg)
         return True
 
-    @pyaedt_function_handler()
-    def edit_source(self, portandmode=None, powerin="1W", phase="0deg"):
+    @pyaedt_function_handler(portandmode="assignment", powerin="power")
+    def edit_source(self, assignment=None, power="1W", phase="0deg"):
         """Set up the power loaded for HFSS postprocessing.
 
         Parameters
         ----------
-        portandmode : str, optional
+        assignment : str, optional
             Port name and mode. For example, ``"Port1:1"``.
             The port name must be defined if the solution type is other than Eigenmodal. This parameter
             is ignored if the solution type is Eigenmodal.
-        powerin : str, optional
+        power : str, optional
             Power in watts (W) or the project variable to put as stored energy in the project.
             The default is ``"1W"``.
         phase : str, optional
             Phase of the excitation. The default is ``"0deg"``.
 
         Returns
         -------
@@ -3991,58 +3568,57 @@
         Create a circle sheet and use it to create a wave port.
         Set up the thermal power for this wave port.
 
         >>> sheet = hfss.modeler.create_circle(hfss.PLANE.YZ,
         ...                                    [-20, 0, 0], 10,
         ...                                    name="sheet_for_source")
         >>> hfss.solution_type = "Modal"
-        >>> wave_port = hfss.create_wave_port_from_sheet(sheet, 5, hfss.AxisDir.XNeg, 40,
-        ...                                              2, "SheetWavePort", True)
-        >>> hfss.edit_source("SheetWavePort" + ":1", "10W")
+        >>> wave_port = hfss.create_wave_port_from_sheet(sheet,5,hfss.AxisDir.XNeg,40,2,"SheetWavePort",True)
+        >>> hfss.edit_source("SheetWavePort" + ":1","10W")
         PyAEDT INFO: Setting up power to "SheetWavePort:1" = 10W
         True
 
         """
 
         if self.solution_type != "Eigenmode":
-            if portandmode is None:
+            if assignment is None:
                 self.logger.error("Port and mode must be defined for solution type {}".format(self.solution_type))
                 return False
-            self.logger.info('Setting up power to "{}" = {}'.format(portandmode, powerin))
+            self.logger.info('Setting up power to "{}" = {}'.format(assignment, power))
             self.osolution.EditSources(
                 [
                     ["IncludePortPostProcessing:=", True, "SpecifySystemPower:=", False],
-                    ["Name:=", portandmode, "Magnitude:=", powerin, "Phase:=", phase],
+                    ["Name:=", assignment, "Magnitude:=", power, "Phase:=", phase],
                 ]
             )
         else:
-            self.logger.info("Setting up power to Eigenmode = {}".format(powerin))
+            self.logger.info("Setting up power to Eigenmode = {}".format(power))
             self.osolution.EditSources(
-                [["FieldType:=", "EigenStoredEnergy"], ["Name:=", "Modes", "Magnitudes:=", [powerin]]]
+                [["FieldType:=", "EigenStoredEnergy"], ["Name:=", "Modes", "Magnitudes:=", [power]]]
             )
         return True
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(portandmode="assignment")
     def edit_source_from_file(
         self,
-        portandmode,
+        assignment,
         file_name,
         is_time_domain=True,
         x_scale=1,
         y_scale=1,
         impedance=50,
         data_format="Power",
         encoding="utf-8",
     ):
         """Edit a source from file data.
         File data is a csv containing either frequency data or time domain data that will be converted through FFT.
 
         Parameters
         ----------
-        portandmode : str
+        assignment : str
             Port name and mode. For example, ``"Port1:1"``.
             The port name must be defined if the solution type is other than Eigenmodal.
         file_name : str
             Full name of the input file.
         is_time_domain : bool, optional
             Either if the input data is Time based or Frequency Based. Frequency based data are Mag/Phase (deg).
         x_scale : float, optional
@@ -4071,16 +3647,16 @@
             x_scale=x_scale,
             y_scale=y_scale,
             impedance=impedance,
             data_format=data_format,
             encoding=encoding,
             out_mag=out,
         )
-        ds_name_mag = "ds_" + portandmode.replace(":", "_mode_") + "_Mag"
-        ds_name_phase = "ds_" + portandmode.replace(":", "_mode_") + "_Angle"
+        ds_name_mag = "ds_" + assignment.replace(":", "_mode_") + "_Mag"
+        ds_name_phase = "ds_" + assignment.replace(":", "_mode_") + "_Angle"
         if self.dataset_exists(ds_name_mag, False):
             self.design_datasets[ds_name_mag].x = freq
             self.design_datasets[ds_name_mag].y = mag
             self.design_datasets[ds_name_mag].update()
         else:
             self.create_dataset1d_design(ds_name_mag, freq, mag, xunit="Hz")
         if self.dataset_exists(ds_name_phase, False):
@@ -4091,15 +3667,15 @@
         else:
             self.create_dataset1d_design(ds_name_phase, freq, phase, xunit="Hz", yunit="deg")
         self.osolution.EditSources(
             [
                 ["IncludePortPostProcessing:=", True, "SpecifySystemPower:=", False],
                 [
                     "Name:=",
-                    portandmode,
+                    assignment,
                     "Magnitude:=",
                     "pwl({}, Freq)".format(ds_name_mag),
                     "Phase:=",
                     "pwl({}, Freq)".format(ds_name_phase),
                 ],
             ]
         )
@@ -4118,30 +3694,32 @@
         Returns
         -------
         bool
         """
         self.osolution.LoadSourceWeights(file_name)
         return True
 
-    @pyaedt_function_handler()
-    def thicken_port_sheets(self, inputlist, value, internalExtr=True, internalvalue=1):
+    @pyaedt_function_handler(
+        inputlist="assignment", internalExtr="extrude_internally", internalvalue="internal_extrusion"
+    )
+    def thicken_port_sheets(self, assignment, value, extrude_internally=True, internal_extrusion=1):
         """Create thickened sheets over a list of input port sheets.
 
         This method is built to work with the output of ``modeler.find_port_faces``.
 
         Parameters
         ----------
-        inputlist : list
+        assignment : list
             List of the sheets to thicken.
         value :
             Value in millimeters for thickening the faces.
-        internalExtr : bool, optional
-            Whether to extrude the sheets internally (vgoing into the model).
+        extrude_internally : bool, optional
+            Whether to extrude the sheets internally (going into the model).
             The default is ``True``.
-        internalvalue : optional
+        internal_extrusion : int, optional
             Value in millimeters for thickening the sheets internally if ``internalExtr=True``.
             The default is ``1``.
 
         Returns
         -------
         Dict
             For each input sheet, returns the port IDs where thickened sheets were created
@@ -4157,28 +3735,31 @@
 
         Create a circle sheet and use it to create a wave port.
         Set the thickness of this circle sheet to ``"2 mm"``.
 
         >>> sheet_for_thickness = hfss.modeler.create_circle(hfss.PLANE.YZ,
         ...                                                  [60, 60, 60], 10,
         ...                                                  name="SheetForThickness")
-        >>> port_for_thickness = hfss.create_wave_port_from_sheet(sheet_for_thickness, 5, hfss.AxisDir.XNeg,
-        ...                                                       40, 2, "WavePortForThickness", True)
-        >>> hfss.thicken_port_sheets(["SheetForThickness"], 2)
+        >>> port_for_thickness = hfss.create_wave_port_from_sheet(sheet_for_thickness,5,
+        ...                                                       hfss.AxisDir.XNeg,
+        ...                                                       40,
+        ...                                                       2,
+        ...                                                       "WavePortForThickness",True)
+        >>> hfss.thicken_port_sheets(["SheetForThickness"],2)
         PyAEDT INFO: done
         {}
 
         """
 
         tol = 1e-6
         ports_ID = {}
         aedt_bounding_box = self.modeler.get_model_bounding_box()
         aedt_bounding_dim = self.modeler.get_bounding_dimension()
         directions = {}
-        for el in inputlist:
+        for el in assignment:
             objID = self.modeler.oeditor.GetFaceIDs(el)
             faceCenter = self.modeler.oeditor.GetFaceCenter(int(objID[0]))
             directionfound = False
             l = min(aedt_bounding_dim) / 2
             while not directionfound:
                 self.modeler.oeditor.ThickenSheet(
                     ["NAME:Selections", "Selections:=", el, "NewPartsModelFlag:=", "Model"],
@@ -4200,15 +3781,15 @@
                 self._odesign.Undo()
 
                 if aedt_bounding_box != aedt_bounding_box2:
                     directions[el] = "Internal"
                     directionfound = True
                 else:
                     l = l + min(aedt_bounding_dim) / 2
-        for el in inputlist:
+        for el in assignment:
             objID = self.modeler.oeditor.GetFaceIDs(el)
             maxarea = 0
             for f in objID:
                 faceArea = self.modeler.get_face_area(int(f))
                 if faceArea > maxarea:
                     maxarea = faceArea
                     faceCenter = self.modeler.oeditor.GetFaceCenter(int(f))
@@ -4243,30 +3824,30 @@
                         #         abs(faceoriginal[0] - fc2[0]) < tol and abs(faceoriginal[1] - fc2[1]) > tol and abs(
                         #         faceoriginal[2] - fc2[2]) < tol) or (
                         #         abs(faceoriginal[0] - fc2[0]) > tol and abs(faceoriginal[1] - fc2[1]) < tol and abs(
                         #         faceoriginal[2] - fc2[2]) < tol):
                         #     ports_ID[el] = int(f)
                     except Exception:
                         pass
-            if internalExtr:
+            if extrude_internally:
                 objID2 = self.modeler.oeditor.GetFaceIDs(el)
                 for fid in objID2:
                     try:
                         faceCenter2 = self.modeler.oeditor.GetFaceCenter(int(fid))
                         if faceCenter2 == faceCenter:
                             self.modeler.oeditor.MoveFaces(
                                 ["NAME:Selections", "Selections:=", el, "NewPartsModelFlag:=", "Model"],
                                 [
                                     "NAME:Parameters",
                                     [
                                         "NAME:MoveFacesParameters",
                                         "MoveAlongNormalFlag:=",
                                         True,
                                         "OffsetDistance:=",
-                                        str(internalvalue) + "mm",
+                                        str(internal_extrusion) + "mm",
                                         "MoveVectorX:=",
                                         "0mm",
                                         "MoveVectorY:=",
                                         "0mm",
                                         "MoveVectorZ:=",
                                         "0mm",
                                         "FacesToMove:=",
@@ -4275,25 +3856,25 @@
                                 ],
                             )
                     except Exception:
                         self.logger.info("done")
                         # self.modeler_oproject.ClearMessages()
         return ports_ID
 
-    @pyaedt_function_handler()
-    def validate_full_design(self, dname=None, outputdir=None, ports=None):
+    @pyaedt_function_handler(dname="design", ouputdir="ouput_dir")
+    def validate_full_design(self, design=None, ouput_dir=None, ports=None):
         """Validate a design based on an expected value and save information to the log file.
 
 
         Parameters
         ----------
-        dname : str,  optional
+        design : str,  optional
             Name of the design to validate. The default is ``None``, in which case
             the current design is used.
-        outputdir : str, optional
+        ouput_dir : str, optional
             Directory to save the log file to. The default is ``None``,
             in which case the current project path is used.
         ports : int, optional
             Number of excitations (sum of modes) that is expected. The default is ``None``.
 
         Returns
         -------
@@ -4318,27 +3899,27 @@
         False
 
         """
 
         self.logger.info("Design validation checks.")
         validation_ok = True
         val_list = []
-        if not dname:
-            dname = self.design_name
-        if not outputdir:
-            outputdir = self.working_directory
+        if not design:
+            design = self.design_name
+        if not ouput_dir:
+            ouput_dir = self.working_directory
         pname = self.project_name
-        validation_log_file = os.path.join(outputdir, pname + "_" + dname + "_validation.log")
+        validation_log_file = os.path.join(ouput_dir, pname + "_" + design + "_validation.log")
 
         # Desktop Messages
         msg = "Desktop messages:"
         val_list.append(msg)
-        temp_msg = list(self._desktop.GetMessages(pname, dname, 0))
+        temp_msg = list(self._desktop.GetMessages(pname, design, 0))
         if temp_msg:
-            temp2_msg = [i.strip("Project: " + pname + ", Design: " + dname + ", ").strip("\r\n") for i in temp_msg]
+            temp2_msg = [i.strip("Project: " + pname + ", Design: " + design + ", ").strip("\r\n") for i in temp_msg]
             val_list.extend(temp2_msg)
 
         # Run design validation and write out the lines to the log.
         temp_dir = tempfile.gettempdir()
         temp_val_file = os.path.join(temp_dir, "val_temp.log")
         simple_val_return = self.validate_simple(temp_val_file)
         if simple_val_return == 1:
@@ -4408,32 +3989,32 @@
             val_list.append(msg)
 
         with open_file(validation_log_file, "w") as f:
             for item in val_list:
                 f.write("%s\n" % item)
         return val_list, validation_ok  # Return all the information in a list for later use.
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(plot_name="plot", sweep_name="sweep", port_names="ports", port_excited="ports_excited")
     def create_scattering(
-        self, plot_name="S Parameter Plot Nominal", sweep_name=None, port_names=None, port_excited=None, variations=None
+        self, plot="S Parameter Plot Nominal", sweep=None, ports=None, ports_excited=None, variations=None
     ):
         """Create an S-parameter report.
 
         Parameters
         ----------
-        plot_name : str, optional
+        plot : str, optional
              Name of the plot. The default is ``"S Parameter Plot Nominal"``.
-        sweep_name : str, optional
+        sweep : str, optional
              Name of the sweep. The default is ``None``.
-        port_names : list, optional
+        ports : list, optional
              List of port names. The first index, i, in S[i,j].
-             The default is ``None``. (include only self-terms)
-        port_excited : list or str, optional
+             The default is ``None``.
+        ports_excited : list or str, optional
              List of port names. The seconds index, j in S[i,j].
-             The default is ``None``. (include only self-terms)
+             The default is ``None``.
         variations : str, optional
              The default is ``None``.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
@@ -4442,51 +4023,51 @@
         ----------
 
         >>> oModule.CreateReport
 
         Examples
         --------
 
-        Create ad S-parameter plot named ``"S Parameter Plot Nominal"`` for a 3-port network.
+        Create an S-parameter plot named ``"S Parameter Plot Nominal"`` for a 3-port network.
         plotting S11, S21, S31.  The port names are ``P1``, ``P2``, and ``P3``.
 
-        >>> hfss.create_scattering(port_names=["P1", "P2", "P3"], port_excited=["P1", "P1", "P1"])
+        >>> hfss.create_scattering(ports=["P1", "P2", "P3"],ports_excited=["P1", "P1", "P1"])
         True
 
         """
 
         solution_data = "Standard"
         if "Modal" in self.solution_type:
             solution_data = "Modal Solution Data"
         elif "Terminal" in self.solution_type:
             solution_data = "Terminal Solution Data"
-        if not port_names:
-            port_names = self.excitations
-        if not port_excited:
-            port_excited = port_names
-        traces = ["dB(S(" + p + "," + q + "))" for p, q in zip(list(port_names), list(port_excited))]
+        if not ports:
+            ports = self.excitations
+        if not ports_excited:
+            ports_excited = ports
+        traces = ["dB(S(" + p + "," + q + "))" for p, q in zip(list(ports), list(ports_excited))]
         return self.post.create_report(
-            traces, sweep_name, variations=variations, report_category=solution_data, plotname=plot_name
+            traces, sweep, variations=variations, report_category=solution_data, plot_name=plot
         )
 
-    @pyaedt_function_handler()
-    def create_qfactor_report(self, project_dir, outputlist, setupname, plotname, Xaxis="X"):
+    @pyaedt_function_handler(outputlist="output", setupname="setup", plotname="name", Xaxis="x_axis")
+    def create_qfactor_report(self, project_dir, output, setup, name, x_axis="X"):
         """Export a CSV file of the EigenQ plot.
 
         Parameters
         ----------
         project_dir : str
             Directory to export the CSV file to.
-        outputlist : list
+        output : list
             Output quantity, which in this case is the Q-factor.
-        setupname : str
+        setup : str
             Name of the setup to generate the report from.
-        plotname : str
+        name : str
             Name of the plot.
-        Xaxis : str, optional
+        x_axis : str, optional
             Value for the X axis. The default is ``"X"``.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
@@ -4495,78 +4076,23 @@
 
         >>> oModule.CreateReport
 
         """
         npath = project_dir
 
         # Setup arguments list for createReport function
-        args = [Xaxis + ":=", ["All"]]
-        args2 = ["X Component:=", Xaxis, "Y Component:=", outputlist]
+        args = [x_axis + ":=", ["All"]]
+        args2 = ["X Component:=", x_axis, "Y Component:=", output]
 
         self.post.post_oreport_setup.CreateReport(
-            plotname, "Eigenmode Parameters", "Rectangular Plot", setupname + " : LastAdaptive", [], args, args2, []
+            name, "Eigenmode Parameters", "Rectangular Plot", setup + " : LastAdaptive", [], args, args2, []
         )
         return True
 
     @pyaedt_function_handler()
-    def export_touchstone(
-        self,
-        setup_name=None,
-        sweep_name=None,
-        file_name=None,
-        variations=None,
-        variations_value=None,
-        renormalization=False,
-        impedance=None,
-        comments=False,
-    ):
-        """Export the Touchstone file to a local folder.
-
-        Parameters
-        ----------
-        setup_name : str, optional
-            Name of the setup that has been solved.
-        sweep_name : str, optional
-            Name of the sweep that has been solved.
-        file_name : str, optional
-            Full path and name for the Touchstone file.
-            The default is ``None``, in which case the file is exported to the working directory.
-        variations : list, optional
-            List of all parameter variations. For example, ``["$AmbientTemp", "$PowerIn"]``.
-            The default is ``None``.
-        variations_value : list, optional
-            List of all parameter variation values. For example, ``["22cel", "100"]``.
-            The default is ``None``.
-        renormalization : bool, optional
-            Perform renormalization before export.
-            The default is ``False``.
-        impedance : float, optional
-            Real impedance value in ohm, for renormalization, if not specified considered 50 ohm.
-            The default is ``None``.
-        comments : bool, optional
-            Include Gamma and Impedance values in comments.
-            The default is ``False``.
-
-        Returns
-        -------
-        bool
-            ``True`` when successful, ``False`` when failed.
-        """
-        return self._export_touchstone(
-            setup_name=setup_name,
-            sweep_name=sweep_name,
-            file_name=file_name,
-            variations=variations,
-            variations_value=variations_value,
-            renormalization=renormalization,
-            impedance=impedance,
-            comments=comments,
-        )
-
-    @pyaedt_function_handler()
     def set_export_touchstone(self, activate, export_dir=""):
         """Set automatic export of the Touchstone file after simulation.
 
         Parameters
         ----------
         activate : bool
             Whether to export the Touchstone file after simulation finishes.
@@ -4594,24 +4120,24 @@
         elif not activate:
             settings.append("NAME:Design Settings Data")
             settings.append("Export After Simulation:=")
             settings.append(False)
         self.odesign.SetDesignSettings(settings)
         return True
 
-    @pyaedt_function_handler()
-    def assign_radiation_boundary_to_objects(self, obj_names, boundary_name=""):
+    @pyaedt_function_handler(obh_names="assignment", boundary_name="name")
+    def assign_radiation_boundary_to_objects(self, assignment, name=None):
         """Assign a radiation boundary to one or more objects (usually airbox objects).
 
         Parameters
         ----------
-        obj_names : str or list or int or :class:`pyaedt.modeler.cad.object3d.Object3d`
+        assignment : str or list or int or :class:`pyaedt.modeler.cad.object3d.Object3d`
             One or more object names or IDs.
-        boundary_name : str, optional
-            Name of the boundary. The default is ``""``.
+        name : str, optional
+            Name of the boundary. The default is ``None``, in which case a name is automatically assigned.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject`
             Boundary object.
 
         References
@@ -4628,33 +4154,34 @@
         ...                                         name="Radiation_box")
         >>> radiation = hfss.assign_radiation_boundary_to_objects("Radiation_box")
         >>> type(radiation)
         <class 'pyaedt.modules.Boundary.BoundaryObject'>
 
         """
 
-        object_list = self.modeler.convert_to_selections(obj_names, return_list=True)
-        if boundary_name:
-            rad_name = boundary_name
+        object_list = self.modeler.convert_to_selections(assignment, return_list=True)
+        if name:
+            rad_name = name
         else:
             rad_name = generate_unique_name("Rad_")
         return self.create_boundary(self.BoundaryType.Radiation, object_list, rad_name)
 
-    @pyaedt_function_handler()
-    def assign_hybrid_region(self, obj_names, boundary_name="", hybrid_region="SBR+"):
+    @pyaedt_function_handler(obj_names="assignment", boundary_name="name")
+    def assign_hybrid_region(self, assignment, name=None, hybrid_region="SBR+"):
         """Assign a hybrid region to one or more objects.
 
         Parameters
         ----------
-        obj_names : str or list or int or :class:`pyaedt.modeler.cad.object3d.Object3d`
+        assignment : str or list or int or :class:`pyaedt.modeler.cad.object3d.Object3d`
             One or more object names or IDs.
-        boundary_name : str, optional
-            Name of the boundary. The default is ``""``.
+        name : str, optional
+            Name of the boundary. The default is ``None``, in which case a name is automatically assigned.
         hybrid_region : str, optional
-            Hybrid region to assign. Options are ``"SBR+"``, ``"IE"``, ``"PO"``. The default is `"SBR+"``.
+            Hybrid region to assign. The default is `"SBR+"``. Options are ``"IE"``, ``"PO"``
+            and ``"SBR+"``.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject`
             Boundary object.
 
         References
@@ -4671,34 +4198,34 @@
         ...                                         name="Radiation_box")
         >>> sbr_box = hfss.assign_hybrid_region("Radiation_box")
         >>> type(sbr_box)
         <class 'pyaedt.modules.Boundary.BoundaryObject'>
 
         """
 
-        object_list = self.modeler.convert_to_selections(obj_names, return_list=True)
-        if boundary_name:
-            region_name = boundary_name
+        object_list = self.modeler.convert_to_selections(assignment, return_list=True)
+        if name:
+            region_name = name
         else:
             region_name = generate_unique_name("Hybrid_")
         bound = self.create_boundary(self.BoundaryType.Hybrid, object_list, region_name)
         if hybrid_region != "SBR+":
             bound.props["Type"] = hybrid_region
         return bound
 
-    @pyaedt_function_handler()
-    def assign_febi(self, obj_names, boundary_name=""):
+    @pyaedt_function_handler(obj_names="assignment", boundary_name="name")
+    def assign_febi(self, assignment, name=None):
         """Assign an FE-BI region to one or more objects.
 
         Parameters
         ----------
-        obj_names : str or list or int or :class:`pyaedt.modeler.cad.object3d.Object3d`
+        assignment : str or list or int or :class:`pyaedt.modeler.cad.object3d.Object3d`
             One or more object names or IDs.
-        boundary_name : str, optional
-            Name of the boundary. The default is ``""``, in which case a name is automatically assigned.
+        name : str, optional
+            Name of the boundary. The default is ``None``, in which case a name is automatically assigned.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject`
             Boundary object.
 
         References
@@ -4715,33 +4242,33 @@
         ...                                         name="Radiation_box")
         >>> febi_box = hfss.assign_febi("Radiation_box")
         >>> type(febi_box)
         <class 'pyaedt.modules.Boundary.BoundaryObject'>
 
         """
 
-        object_list = self.modeler.convert_to_selections(obj_names, return_list=True)
-        if boundary_name:
-            region_name = boundary_name
+        object_list = self.modeler.convert_to_selections(assignment, return_list=True)
+        if name:
+            region_name = name
         else:
             region_name = generate_unique_name("FEBI_")
         bound = self.create_boundary(self.BoundaryType.FEBI, object_list, region_name)
 
         return bound
 
-    @pyaedt_function_handler()
-    def assign_radiation_boundary_to_faces(self, faces_id, boundary_name=""):
+    @pyaedt_function_handler(faces_id="assignment", boundary_name="name")
+    def assign_radiation_boundary_to_faces(self, assignment, name=None):
         """Assign a radiation boundary to one or more faces.
 
         Parameters
         ----------
-        faces_id :
+        assignment :
             Face ID to assign the boundary condition to.
-        boundary_name : str, optional
-            Name of the boundary. The default is ``""``.
+        name : str, optional
+            Name of the boundary. The default is ``None``.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject`
             Boundary object.
 
         References
@@ -4759,17 +4286,17 @@
         ...                                         name="RadiationForFaces")
         >>> ids = [i.id for i in hfss.modeler["RadiationForFaces"].faces]
         >>> radiation = hfss.assign_radiation_boundary_to_faces(ids)
         >>> type(radiation)
         <class 'pyaedt.modules.Boundary.BoundaryObject'>
 
         """
-        faces_list = self.modeler.convert_to_selections(faces_id, True)
-        if boundary_name:
-            rad_name = boundary_name
+        faces_list = self.modeler.convert_to_selections(assignment, True)
+        if name:
+            rad_name = name
         else:
             rad_name = generate_unique_name("Rad_")
         return self.create_boundary(self.BoundaryType.Radiation, faces_list, rad_name)
 
     @pyaedt_function_handler()
     def _create_sbr_doppler_setup(
         self,
@@ -4813,46 +4340,46 @@
         if setup_type != "PulseDoppler":
             setup1.props["IncludeRangeVelocityCouplingEffect"] = include_coupling_effects
             setup1.props["SbrRangeDopplerA/DSamplingRate"] = self.modeler._arg_with_dim(doppler_ad_sampling_rate, "MHz")
         setup1.update()
         setup1.auto_update = True
         return setup1
 
-    @pyaedt_function_handler()
-    def _create_sbr_doppler_sweep(self, setupname, time_var, tstart, tstop, tsweep, parametric_name):
+    @pyaedt_function_handler(setupname="setup")
+    def _create_sbr_doppler_sweep(self, setup, time_var, tstart, tstop, tsweep, parametric_name):
         time_start = self.modeler._arg_with_dim(tstart, "s")
         time_sweep = self.modeler._arg_with_dim(tsweep, "s")
         time_stop = self.modeler._arg_with_dim(tstop, "s")
         sweep_range = "LIN {} {} {}".format(time_start, time_stop, time_sweep)
         return self.parametrics.add(
-            time_var, tstart, time_stop, tsweep, "LinearStep", setupname, parametricname=parametric_name
+            time_var, tstart, time_stop, tsweep, "LinearStep", setup, parametricname=parametric_name
         )
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(time_var="time_variable", setup_name="setup")
     def create_sbr_chirp_i_doppler_setup(
         self,
-        time_var=None,
+        time_variable=None,
         sweep_time_duration=0,
         center_freq=76.5,
         resolution=1,
         period=200,
         velocity_resolution=0.4,
         min_velocity=-20,
         max_velocity=20,
         ray_density_per_wavelength=0.2,
         max_bounces=5,
         include_coupling_effects=False,
         doppler_ad_sampling_rate=20,
-        setup_name=None,
+        setup=None,
     ):
-        """Create an SBR+ Chirp I Setup.
+        """Create an SBR+ Chirp I setup.
 
         Parameters
         ----------
-        time_var : str, optional
+        time_variable : str, optional
             Name of the time variable. The default is ``None``, in which case
             a search for the first time variable is performed.
         sweep_time_duration : float, optional
             Duration for the sweep time. The default is ``0.`` If a value greater
             than ``0`` is specified, a parametric sweep is created.
         center_freq : float, optional
             Center frequency in gigahertz (GHz). The default is ``76.5``.
@@ -4871,15 +4398,15 @@
         max_bounces : int, optional
             Maximum number of bounces. The default is ``5``.
         include_coupling_effects : float, optional
             Whether to include coupling effects. The default is ``False``.
         doppler_ad_sampling_rate : float, optional
             Doppler AD sampling rate to use if ``include_coupling_effects``
             is ``True``. The default is ``20``.
-        setup_name : str, optional
+        setup : str, optional
             Name of the setup. The default is ``None``, in which case the active setup is used.
 
         Returns
         -------
         tuple
             The tuple contains: (:class:`pyaedt.modules.SolveSetup.Setup`,
             :class:`pyaedt.modules.DesignXPloration.ParametericsSetups.Optimetrics`).
@@ -4889,75 +4416,75 @@
 
         >>> oModule.InsertSetup
 
         """
         if self.solution_type != "SBR+":
             self.logger.error("Method applies only to the SBR+ solution.")
             return False, False
-        if not setup_name:
-            setup_name = generate_unique_name("ChirpI")
+        if not setup:
+            setup = generate_unique_name("ChirpI")
             parametric_name = generate_unique_name("PulseSweep")
         else:
-            parametric_name = generate_unique_name(setup_name)
+            parametric_name = generate_unique_name(setup)
 
-        if not time_var:
+        if not time_variable:
             for var_name, var in self.variable_manager.independent_variables.items():
                 if var.unit_system == "Time":
-                    time_var = var_name
+                    time_variable = var_name
                     break
-            if not time_var:
+            if not time_variable:
                 self.logger.error(
                     "No time variable is found. Set up or explicitly assign a time variable to the method."
                 )
                 raise ValueError("No time variable is found.")
         setup = self._create_sbr_doppler_setup(
             "ChirpI",
-            time_var=time_var,
+            time_var=time_variable,
             center_freq=center_freq,
             resolution=resolution,
             period=period,
             velocity_resolution=velocity_resolution,
             min_velocity=min_velocity,
             max_velocity=max_velocity,
             ray_density_per_wavelength=ray_density_per_wavelength,
             max_bounces=max_bounces,
             include_coupling_effects=include_coupling_effects,
             doppler_ad_sampling_rate=doppler_ad_sampling_rate,
-            setup_name=setup_name,
+            setup_name=setup,
         )
         if sweep_time_duration > 0:
             sweeptime = math.ceil(300000000 / (2 * center_freq * 1000000000 * velocity_resolution) * 1000) / 1000
             sweep = self._create_sbr_doppler_sweep(
-                setup.name, time_var, 0, sweep_time_duration, sweeptime, parametric_name
+                setup.name, time_variable, 0, sweep_time_duration, sweeptime, parametric_name
             )
             return setup, sweep
         return setup, False
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(time_var="time_variable", setup_name="setup")
     def create_sbr_chirp_iq_doppler_setup(
         self,
-        time_var=None,
+        time_variable=None,
         sweep_time_duration=0,
         center_freq=76.5,
         resolution=1,
         period=200,
         velocity_resolution=0.4,
         min_velocity=-20,
         max_velocity=20,
         ray_density_per_wavelength=0.2,
         max_bounces=5,
         include_coupling_effects=False,
         doppler_ad_sampling_rate=20,
-        setup_name=None,
+        setup=None,
     ):
-        """Create an SBR+ Chirp IQ Setup.
+        """Create an SBR+ Chirp IQ setup.
 
         Parameters
         ----------
-        time_var : str, optional
+        time_variable : str, optional
             Name of the time variable. The default is ``None``, in which case
             a search for the first time variable is performed.
         sweep_time_duration : float, optional
             Duration of the sweep time. The default is ``0``. If a value greater
             than ``0`` is specified, a parametric sweep is created.
         center_freq : float, optional
             Center frequency in gighertz (GHz). The default is ``76.5``.
@@ -4976,15 +4503,15 @@
         max_bounces : int, optional
             Maximum number of bounces. The default is ``5``.
         include_coupling_effects : float, optional
             Whether to include coupling effects. The default is ``False``.
         doppler_ad_sampling_rate : float, optional
             Doppler AD sampling rate to use if ``include_coupling_effects`` is
             ``True``. The default is ``20``.
-        setup_name : str, optional
+        setup : str, optional
             Name of the setup. The default is ``None``, in which case the active
             setup is used.
 
         Returns
         -------
         tuple
             The tuple contains: (:class:`pyaedt.modules.SolveSetup.Setup`,
@@ -4994,75 +4521,75 @@
         ----------
 
         >>> oModule.InsertSetup
         """
         if self.solution_type != "SBR+":
             self.logger.error("Method applies only to the SBR+ solution.")
             return False, False
-        if not setup_name:
-            setup_name = generate_unique_name("ChirpIQ")
+        if not setup:
+            setup = generate_unique_name("ChirpIQ")
             parametric_name = generate_unique_name("PulseSweep")
         else:
-            parametric_name = generate_unique_name(setup_name)
-        if not time_var:
+            parametric_name = generate_unique_name(setup)
+        if not time_variable:
             for var_name, var in self.variable_manager.independent_variables.items():
                 if var.unit_system == "Time":
-                    time_var = var_name
+                    time_variable = var_name
                     break
-            if not time_var:
+            if not time_variable:
                 raise ValueError("No Time Variable Found")
         setup = self._create_sbr_doppler_setup(
             "ChirpIQ",
-            time_var=time_var,
+            time_var=time_variable,
             center_freq=center_freq,
             resolution=resolution,
             period=period,
             velocity_resolution=velocity_resolution,
             min_velocity=min_velocity,
             max_velocity=max_velocity,
             ray_density_per_wavelength=ray_density_per_wavelength,
             max_bounces=max_bounces,
             include_coupling_effects=include_coupling_effects,
             doppler_ad_sampling_rate=doppler_ad_sampling_rate,
-            setup_name=setup_name,
+            setup_name=setup,
         )
         if sweep_time_duration > 0:
             sweeptime = math.ceil(300000000 / (2 * center_freq * 1000000000 * velocity_resolution) * 1000) / 1000
             sweep = self._create_sbr_doppler_sweep(
-                setup.name, time_var, 0, sweep_time_duration, sweeptime, parametric_name
+                setup.name, time_variable, 0, sweep_time_duration, sweeptime, parametric_name
             )
             return setup, sweep
         return setup, False
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(time_var="time_variable", center_freq="frequency", setup_name="setup")
     def create_sbr_pulse_doppler_setup(
         self,
-        time_var=None,
+        time_variable=None,
         sweep_time_duration=0,
-        center_freq=76.5,
+        frequency=76.5,
         resolution=1,
         period=200,
         velocity_resolution=0.4,
         min_velocity=-20,
         max_velocity=20,
         ray_density_per_wavelength=0.2,
         max_bounces=5,
-        setup_name=None,
+        setup=None,
     ):
         """Create an SBR+ pulse Doppler setup.
 
         Parameters
         ----------
-        time_var : str, optional
+        time_variable : str, optional
             Name of the time variable. The default is ``None``, in which case
             a search for the first time variable is performed.
         sweep_time_duration : float, optional
             Duration of the sweep time. The default is ``0``. If a value greater
             than ``0`` is specified, a parametric sweep is created.
-        center_freq : float, optional
+        frequency : float, optional
             Center frequency in gigahertz (GHz). The default is ``76.5``.
         resolution : float, optional
             Doppler resolution in meters (m). The default is ``1``.
         period : float, optional
             Period of analysis in meters (m). The default is ``200``.
         velocity_resolution : float, optional
             Doppler velocity resolution in meters per second (m/s).
@@ -5073,15 +4600,15 @@
         max_velocity : str, optional
             Maximum Doppler velocity in meters per second (m/s). The default
             is ``20``.
         ray_density_per_wavelength : float, optional
             Doppler ray density per wavelength. The default is ``0.2``.
         max_bounces : int, optional
             Maximum number of bounces. The default is ``5``.
-        setup_name : str, optional
+        setup : str, optional
             Name of the setup. The default is ``None``, in which case the active
             setup is used.
 
         Returns
         -------
         tuple
             The tuple contains: (:class:`pyaedt.modules.SolveSetup.Setup`,
@@ -5091,53 +4618,53 @@
         ----------
 
         >>> oModule.InsertSetup
         """
         if self.solution_type != "SBR+":
             self.logger.error("Method Applies only to SBR+ Solution.")
             return False, False
-        if not setup_name:
-            setup_name = generate_unique_name("PulseSetup")
+        if not setup:
+            setup = generate_unique_name("PulseSetup")
             parametric_name = generate_unique_name("PulseSweep")
         else:
-            parametric_name = generate_unique_name(setup_name)
+            parametric_name = generate_unique_name(setup)
 
-        if not time_var:
+        if not time_variable:
             for var_name, var in self.variable_manager.independent_variables.items():
                 if var.unit_system == "Time":
-                    time_var = var_name
+                    time_variable = var_name
                     break
-            if not time_var:
+            if not time_variable:
                 raise ValueError("No Time Variable Found")
         setup = self._create_sbr_doppler_setup(
             "PulseDoppler",
-            time_var=time_var,
-            center_freq=center_freq,
+            time_var=time_variable,
+            center_freq=frequency,
             resolution=resolution,
             period=period,
             velocity_resolution=velocity_resolution,
             min_velocity=min_velocity,
             max_velocity=max_velocity,
             ray_density_per_wavelength=ray_density_per_wavelength,
             max_bounces=max_bounces,
-            setup_name=setup_name,
+            setup_name=setup,
         )
         if sweep_time_duration > 0:
-            sweeptime = math.ceil(300000000 / (2 * center_freq * 1000000000 * velocity_resolution) * 1000) / 1000
+            sweeptime = math.ceil(300000000 / (2 * frequency * 1000000000 * velocity_resolution) * 1000) / 1000
             sweep = self._create_sbr_doppler_sweep(
-                setup.name, time_var, 0, sweep_time_duration, sweeptime, parametric_name
+                setup.name, time_variable, 0, sweep_time_duration, sweeptime, parametric_name
             )
             return setup, sweep
         return setup, False
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(radar_name="name")
     def create_sbr_radar_from_json(
-        self, radar_file, radar_name, offset=[0, 0, 0], speed=0.0, use_relative_cs=False, relative_cs_name=None
+        self, radar_file, name, offset=None, speed=0.0, use_relative_cs=False, relative_cs_name=None
     ):
-        """Create an SBR+ radar from a JSON file.
+        """Create an SBR+ radar setup from a JSON file.
 
         Example of input JSON file:
 
           .. code-block:: json
 
             {
                 "name": "Example_1Tx_1Rx",
@@ -5169,15 +4696,15 @@
                 }
             }
 
         Parameters
         ----------
         radar_file : str
             Path to the directory with the radar file.
-        radar_name : str
+        name : str
             Name of the radar file.
         offset : list, optional
             Offset relative to the global coordinate system.
         speed : float, optional
             Radar movement speed relative to the global coordinate system if greater than ``0``.
         use_relative_cs : bool, optional
             Whether to use the relative coordinate system. The default is ``False``.
@@ -5194,24 +4721,26 @@
         ----------
         AEDT API Commands.
 
         >>> oEditor.CreateRelativeCS
         >>> oModule.SetSBRTxRxSettings
         >>> oEditor.CreateGroup
         """
+        if offset is None:
+            offset = [0, 0, 0]
         from pyaedt.modeler.advanced_cad.actors import Radar
 
         self.modeler._initialize_multipart()
         if self.solution_type != "SBR+":
             self.logger.error("Method applies only to SBR+ solution.")
             return False
         use_motion = abs(speed) > 0.0
         r = Radar(
             radar_file,
-            name=radar_name,
+            name=name,
             motion=use_motion,
             offset=offset,
             speed=speed,
             use_relative_cs=(use_relative_cs or use_motion),
             relative_cs_name=relative_cs_name,
         )
         r.insert(self, abs(speed) > 0)
@@ -5535,30 +5064,30 @@
             props["CoordSystem"] = "Global"
         bound = NearFieldSetup(self, name, props, "NearFieldRectangle")
         if bound.create():
             self.field_setups.append(bound)
             return bound
         return False
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(line="assignment")
     def insert_near_field_line(
         self,
-        line,
+        assignment,
         points=1000,
         custom_radiation_faces=None,
         name=None,
     ):
         """Create a near field line.
 
         .. note::
            This method is not supported by HFSS ``EigenMode`` and ``CharacteristicMode`` solution types.
 
         Parameters
         ----------
-        line : str
+        assignment : str
             Polyline name.
         points : float, str, optional
             Number of points. The default value is ``1000``.
         custom_radiation_faces : str, optional
             List of radiation faces to use for far field computation. The default is ``None``.
         name : str, optional
             Name of the sphere. The default is ``None``.
@@ -5575,15 +5104,15 @@
         props = OrderedDict({"UseCustomRadiationSurface": custom_radiation_faces is not None})
         if custom_radiation_faces:
             props["CustomRadiationSurface"] = custom_radiation_faces
         else:
             props["CustomRadiationSurface"] = ""
 
         props["NumPts"] = points
-        props["Line"] = line
+        props["Line"] = assignment
 
         bound = NearFieldSetup(self, name, props, "NearFieldLine")
         if bound.create():
             self.field_setups.append(bound)
             return bound
         return False
 
@@ -5626,45 +5155,52 @@
         if thin_sources:
             arg.append("Power Fraction:=")
             arg.append(str(power_fraction))
         self.oboundary.EditGlobalCurrentSourcesOption(arg)
         self.logger.info("SBR+ current source options correctly applied.")
         return True
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(
+        positive_terminal="assignment",
+        negative_terminal="reference",
+        common_name="common_mode",
+        diff_name="differential_mode",
+        common_ref="common_reference",
+        diff_ref_z="differential_reference",
+    )
     def set_differential_pair(
         self,
-        positive_terminal,
-        negative_terminal,
-        common_name=None,
-        diff_name=None,
-        common_ref_z=25,
-        diff_ref_z=100,
+        assignment,
+        reference,
+        common_mode=None,
+        differential_mode=None,
+        common_reference=25,
+        differential_reference=100,
         active=True,
         matched=False,
     ):
         """Add a differential pair definition.
 
         Differential pairs can be defined only in Terminal and Transient solution types.
         The differential pair is created from an existing port definition having at least two
         terminals.
 
         Parameters
         ----------
-        positive_terminal : str
+        assignment : str
             Name of the terminal to use as the positive terminal.
-        negative_terminal : str
+        reference : str
             Name of the terminal to use as the negative terminal.
-        common_name : str, optional
+        common_mode : str, optional
             Name for the common mode. The default is ``None``, in which case a unique name is assigned.
-        diff_name : str, optional
+        differential_mode : str, optional
             Name for the differential mode. The default is ``None``, in which case a unique name is assigned.
-        common_ref_z : float, optional
+        common_reference : float, optional
             Reference impedance for the common mode in ohms. The default is ``25``.
-        diff_ref_z : float, optional
+        differential_reference : float, optional
             Reference impedance for the differential mode in ohms. The default is ``100``.
         active : bool, optional
             Whether the differential pair is active. The default is ``True``.
         matched : bool, optional
             Whether the differential pair is matched. The default is ``False``.
 
         Returns
@@ -5677,24 +5213,26 @@
         >>> oModule.EditDiffPairs
         """
 
         if self.solution_type not in ["Transient Network", "Terminal"]:  # pragma: no cover
             raise AttributeError("Differential pairs can be defined only in Terminal and Transient solution types.")
 
         props = OrderedDict()
-        props["PosBoundary"] = positive_terminal
-        props["NegBoundary"] = negative_terminal
-        if not common_name:
+        props["PosBoundary"] = assignment
+        props["NegBoundary"] = reference
+        if not common_mode:
             common_name = generate_unique_name("Comm")
+        else:
+            common_name = common_mode
         props["CommonName"] = common_name
-        props["CommonRefZ"] = str(common_ref_z) + "ohm"
-        if not diff_name:
-            diff_name = generate_unique_name("Diff")
-        props["DiffName"] = diff_name
-        props["DiffRefZ"] = str(diff_ref_z) + "ohm"
+        props["CommonRefZ"] = str(common_reference) + "ohm"
+        if not differential_mode:
+            differential_mode = generate_unique_name("Diff")
+        props["DiffName"] = differential_mode
+        props["DiffRefZ"] = str(differential_reference) + "ohm"
         props["IsActive"] = active
         props["UseMatched"] = matched
         arg = ["NAME:" + generate_unique_name("Pair")]
         _dict2arg(props, arg)
 
         arg2 = ["NAME:EditDiffPairs", arg]
 
@@ -5710,25 +5248,25 @@
         self.oboundary.EditDiffPairs(arg2)
 
         if len(self.oboundary.GetDiffPairs()) == num_old_pairs + 1:
             return True
         else:
             return False
 
-    @pyaedt_function_handler()
-    def add_3d_component_array_from_json(self, json_file, array_name=None):
-        """Add or edit a new 3D component array from a JSON file or TOML file.
+    @pyaedt_function_handler(array_name="name", json_file="input_data")
+    def add_3d_component_array_from_json(self, input_data, name=None):
+        """Add or edit a 3D component array from a JSON file or TOML file.
         The 3D component is placed in the layout if it is not present.
 
         Parameters
         ----------
-        json_file : str, dict
+        input_data : str, dict
             Full path to either the JSON file or dictionary containing the array information.
-        array_name : str, optional
-            Name of the boundary to create or edit.
+        name : str, optional
+             Name of the boundary to add or edit.
 
         Returns
         -------
         class:`pyaedt.modeler.cad.component_array.ComponentArray`
 
         Examples
         --------
@@ -5765,22 +5303,22 @@
         >>> from pyaedt import Hfss
         >>> from pyaedt.generic.general_methods import read_configuration_file
         >>> hfss_app = Hfss()
         >>> dict_in = read_configuration_file(r"path\\to\\json_file")
         >>> component_array = hfss_app.add_3d_component_array_from_json(dict_in)
         """
         self.hybrid = True
-        if isinstance(json_file, dict):
-            json_dict = json_file
+        if isinstance(input_data, dict):
+            json_dict = input_data
         else:
-            json_dict = read_configuration_file(json_file)
-        if not array_name and self.omodelsetup.IsArrayDefined():
-            array_name = self.omodelsetup.GetArrayNames()[0]
-        elif not array_name:
-            array_name = generate_unique_name("Array")
+            json_dict = read_configuration_file(input_data)
+        if not name and self.omodelsetup.IsArrayDefined():
+            name = self.omodelsetup.GetArrayNames()[0]
+        elif not name:
+            name = generate_unique_name("Array")
 
         cells_names = {}
         cells_color = {}
         cells_active = []
         cells_rotation = {}
         cells_post = {}
         for k, v in json_dict["cells"].items():
@@ -5819,17 +5357,17 @@
         secondary_lattice = json_dict.get("secondarylattice", None)
         if not primary_lattice:
             primary_lattice = self.omodelsetup.GetLatticeVectors()[0]
         if not secondary_lattice:
             secondary_lattice = self.omodelsetup.GetLatticeVectors()[1]
 
         args = [
-            "NAME:" + array_name,
+            "NAME:" + name,
             "Name:=",
-            array_name,
+            name,
             "UseAirObjects:=",
             json_dict.get("useairobjects", True),
             "RowPrimaryBnd:=",
             primary_lattice,
             "ColumnPrimaryBnd:=",
             secondary_lattice,
             "RowDimension:=",
@@ -5880,38 +5418,38 @@
             # Save project, because coordinate system information can not be obtained from AEDT API
             self.save_project()
             self.omodelsetup.EditArray(args)
         else:
             self.omodelsetup.AssignArray(args)
             # Save project, because coordinate system information can not be obtained from AEDT API
             self.save_project()
-            self.component_array[array_name] = ComponentArray(self, array_name)
-        self.component_array_names = [array_name]
-        return self.component_array[array_name]
+            self.component_array[name] = ComponentArray(self, name)
+        self.component_array_names = [name]
+        return self.component_array[name]
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(setup_name="setup", sphere_name="sphere")
     def get_antenna_ffd_solution_data(
         self,
         frequencies,
-        setup_name=None,
-        sphere_name=None,
+        setup=None,
+        sphere=None,
         variations=None,
         overwrite=True,
     ):
         """Export antennas parameters to Far Field Data (FFD) files and return the ``FfdSolutionDataExporter`` object.
 
         For phased array cases, only one phased array is calculated.
 
         Parameters
         ----------
         frequencies : float, list
             Frequency value or list of frequencies to compute far field data.
-        setup_name : str, optional
+        setup : str, optional
             Name of the setup to use. The default is ``None,`` in which case ``nominal_adaptive`` is used.
-        sphere_name : str, optional
+        sphere : str, optional
             Infinite sphere to use. The default is ``None``, in which case an existing sphere is used or a new
             one is created.
         variations : dict, optional
             Variation dictionary.
         overwrite : bool, optional
             Whether to overwrite FFD files. The default is ``True``.
 
@@ -5920,40 +5458,40 @@
         :class:`pyaedt.modules.solutions.FfdSolutionDataExporter`
             SolutionData object.
         """
         from pyaedt.modules.solutions import FfdSolutionDataExporter
 
         if not variations:
             variations = self.available_variations.nominal_w_values_dict_w_dependent
-        if not setup_name:
-            setup_name = self.nominal_adaptive
-        if sphere_name:
+        if not setup:
+            setup = self.nominal_adaptive
+        if sphere:
             names = [i.name for i in self.field_setups]
-            if sphere_name in names:
-                self.logger.info("Far field sphere %s is assigned", sphere_name)
+            if sphere in names:
+                self.logger.info("Far field sphere %s is assigned", sphere)
 
             else:
                 self.insert_infinite_sphere(
-                    x_start=0, x_stop=180, x_step=5, y_start=-180, y_stop=180, y_step=5, name=sphere_name
+                    x_start=0, x_stop=180, x_step=5, y_start=-180, y_stop=180, y_step=5, name=sphere
                 )
-                self.logger.info("Far field sphere %s is created.", sphere_name)
+                self.logger.info("Far field sphere %s is created.", sphere)
         elif self.field_setups:
-            sphere_name = self.field_setups[0].name
-            self.logger.info("No far field sphere is defined. Using %s", sphere_name)
+            sphere = self.field_setups[0].name
+            self.logger.info("No far field sphere is defined. Using %s", sphere)
         else:
-            sphere_name = "Infinite Sphere1"
+            sphere = "Infinite Sphere1"
             self.insert_infinite_sphere(
-                x_start=0, x_stop=180, x_step=5, y_start=-180, y_stop=180, y_step=5, name=sphere_name
+                x_start=0, x_stop=180, x_step=5, y_start=-180, y_stop=180, y_step=5, name=sphere
             )
-            self.logger.info("Far field sphere %s is created.", setup_name)
+            self.logger.info("Far field sphere %s is created.", setup)
 
         return FfdSolutionDataExporter(
             self,
-            sphere_name=sphere_name,
-            setup_name=setup_name,
+            sphere_name=sphere,
+            setup_name=setup,
             frequencies=frequencies,
             variations=variations,
             overwrite=overwrite,
         )
 
     @pyaedt_function_handler()
     def set_material_threshold(self, threshold=100000):
@@ -5971,25 +5509,25 @@
         """
         try:
             self.odesign.SetSolveInsideThreshold(threshold)
             return True
         except Exception:
             return False
 
-    @pyaedt_function_handler()
-    def assign_symmetry(self, entity_list, symmetry_name=None, is_perfect_e=True):
+    @pyaedt_function_handler(entity_list="assignment", simmetry_name="name")
+    def assign_symmetry(self, assignment, name=None, is_perfect_e=True):
         """Assign symmetry to planar entities.
 
         Parameters
         ----------
-        entity_list : list
+        assignment : list
             List of IDs or :class:`pyaedt.modeler.Object3d.FacePrimitive`.
-        symmetry_name : str, optional
+        name : str, optional
             Name of the boundary.
-            If not provided it's automatically generated.
+            If a name is not provided, one is automatically generated.
         is_perfect_e : bool, optional
             Type of symmetry plane the boundary represents: Perfect E or Perfect H.
             The default value is ``True`` (Perfect E).
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject`
@@ -6014,25 +5552,25 @@
 
         """
         try:
             if self.solution_type not in ["Modal", "Eigenmode"]:
                 self.logger.error("Symmetry is only available with 'Modal' and 'Eigenmode' solution types.")
                 return False
 
-            if symmetry_name is None:
-                symmetry_name = generate_unique_name("Symmetry")
+            if name is None:
+                name = generate_unique_name("Symmetry")
 
-            if not isinstance(entity_list, list):
+            if not isinstance(assignment, list):
                 self.logger.error("Entities have to be provided as a list.")
                 return False
 
-            entity_list = self.modeler.convert_to_selections(entity_list, True)
+            assignment = self.modeler.convert_to_selections(assignment, True)
 
-            props = OrderedDict({"Name": symmetry_name, "Faces": entity_list, "IsPerfectE": is_perfect_e})
-            return self._create_boundary(symmetry_name, props, "Symmetry")
+            props = OrderedDict({"Name": name, "Faces": assignment, "IsPerfectE": is_perfect_e})
+            return self._create_boundary(name, props, "Symmetry")
         except Exception:
             return False
 
     @pyaedt_function_handler()
     def set_impedance_multiplier(self, multiplier):
         # type: (float) -> bool
         """Set impedance multiplier.
@@ -6103,17 +5641,17 @@
 
         """
 
         if not self.desktop_class.is_grpc_api:  # pragma: no cover
             self.logger.warning("Set phase center is not supported by AEDT COM API. Set phase center manually.")
             return False
 
-        port_names = []
-        for exc in self.design_excitations:
-            port_names.append(exc.name)
+        port_names = self.ports[::]
+        # for exc in self.design_excitations:
+        #     port_names.append(exc.name)
 
         if not port_names:  # pragma: no cover
             return False
 
         if not coordinate_system:
             coordinate_system = ["<-Port Location->"] * len(port_names)
         elif not isinstance(coordinate_system, list):
@@ -6129,121 +5667,76 @@
 
         try:
             self.oboundary.SetPhaseCenterPerPort(arg)
         except Exception:
             return False
         return True
 
-    @pyaedt_function_handler()
-    def get_touchstone_data(self, setup_name, sweep_name=None, variation_dict=None):
-        """
-        Return a Touchstone data plot.
-
-        Parameters
-        ----------
-        setup_name : list
-            List of the curves to plot.
-        sweep_name : str, optional
-            Name of the solution. The default value is ``None``.
-        variation_dict : dict, optional
-            Dictionary of variation names. The default value is ``None``.
-
-        Returns
-        -------
-        :class:`pyaedt.generic.touchstone_parser.TouchstoneData`
-           Class containing all requested data.
-
-        References
-        ----------
-
-        >>> oModule.GetSolutionDataPerVariation
-        """
-        from pyaedt.generic.touchstone_parser import TouchstoneData
-
-        if not setup_name:
-            setup_name = self.setups[0].name
-
-        if not sweep_name:
-            for setup in self.setups:
-                if setup.name == setup_name:
-                    sweep_name = setup.sweeps[0].name
-        s_parameters = []
-        solution = "{} : {}".format(setup_name, sweep_name)
-        expression = self.get_traces_for_plot(category="S")
-        sol_data = self.post.get_solution_data(expression, solution, variations=variation_dict)
-        for i in range(sol_data.number_of_variations):
-            sol_data.set_active_variation(i)
-            s_parameters.append(TouchstoneData(solution_data=sol_data))
-        return s_parameters
-
-    @pyaedt_function_handler()
-    def parse_hdm_file(self, filename):
+    @pyaedt_function_handler(filename="file_name")
+    def parse_hdm_file(self, file_name):
         """Parse an HFSS SBR+ or Creeping Waves ``hdm`` file.
 
         Parameters
         ----------
-        filename : str
-            File to parse.
+        file_name : str
+            Name of the file to parse.
 
         Returns
         -------
         :class:`pyaedt.modules.hdm_parser.Parser`
         """
 
         from pyaedt.sbrplus.hdm_parser import Parser
 
-        if os.path.exists(filename):
-            return Parser(filename).parse_message()
+        if os.path.exists(file_name):
+            return Parser(file_name).parse_message()
         return False
 
-    @pyaedt_function_handler()
-    def get_hdm_plotter(self, filename=None):
-        """Get the ``HDMPlotter``.
+    @pyaedt_function_handler(filename="file_name")
+    def get_hdm_plotter(self, file_name=None):
+        """Get the  HDM plotter``.
 
         Parameters
         ----------
-        filename : str, optional
+        file_name : str, optional
 
 
         Returns
         -------
         :class:`pyaedt.sbrplus.plot.HDMPlotter`
 
         """
         from pyaedt.sbrplus.plot import HDMPlotter
 
         hdm = HDMPlotter()
-        files = self.post.export_model_obj(
-            export_as_single_objects=True,
-            air_objects=False,
-        )
+        files = self.post.export_model_obj(export_as_single_objects=True, air_objects=False)
         for file in files:
             hdm.add_cad_model(file[0], file[1], file[2], self.modeler.model_units)
-        hdm.add_hdm_bundle_from_file(filename)
+        hdm.add_hdm_bundle_from_file(file_name)
         return hdm
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(signal="assignment")
     def circuit_port(
         self,
-        signal,
+        assignment,
         reference,
         port_location=0,
         impedance=50,
         name=None,
         renormalize=True,
         renorm_impedance=50,
         deembed=False,
     ):
         """Create a circuit port from two objects.
 
         The integration line is from edge 2 to edge 1.
 
         Parameters
         ----------
-        signal : int or :class:`pyaedt.modeler.cad.object3d.Object3d` or
+        assignment : int or :class:`pyaedt.modeler.cad.object3d.Object3d` or
          :class:`pyaedt.modeler.cad.FacePrimitive`or :class:`pyaedt.modeler.cad.EdgePrimitive`
             Signal object.
         reference : int or :class:`pyaedt.modeler.cad.object3d.Object3d` or
          :class:`pyaedt.modeler.cad.FacePrimitive`or :class:`pyaedt.modeler.cad.EdgePrimitive`
             Reference object.
         port_location : int or :class:`pyaedt.application.Analysis.Analysis.AxisDir`, optional
             Position of the port when an object different from an edge is provided.
@@ -6287,52 +5780,54 @@
         >>> edges1 = hfss.modeler.get_object_edges(rectangle1.id)
         >>> first_edge = edges1[0]
         >>> rectangle2 = hfss.modeler.create_rectangle(plane, [30, 10, 10], [10, 10],
         ...                                            name="rectangle2_for_port")
         >>> edges2 = hfss.modeler.get_object_edges(rectangle2.id)
         >>> second_edge = edges2[0]
         >>> hfss.solution_type = "Modal"
-        >>> hfss.circuit_port(first_edge, second_edge, name="PortExample",
-        ...                   impedance=50.1, renormalize=False,
+        >>> hfss.circuit_port(first_edge,second_edge,
+        ...                   impedance=50.1,
+        ...                   name="PortExample",
+        ...                   renormalize=False,
         ...                   renorm_impedance="50")
         'PortExample'
         """
         if self.solution_type in ["Modal", "Terminal", "Transient Network"]:
-            if not self.modeler.does_object_exists(signal) or not self.modeler.does_object_exists(reference):
-                out = self.modeler.convert_to_selections([signal, reference], True)
+            if not self.modeler.does_object_exists(assignment) or not self.modeler.does_object_exists(reference):
+                out = self.modeler.convert_to_selections([assignment, reference], True)
                 if isinstance(out[0], str) or isinstance(out[1], str):
                     self.logger.error("Failed to create circuit port.")
                     return False
             else:
-                out, parallel = self.modeler.find_closest_edges(signal, reference, port_location)
+                out, parallel = self.modeler.find_closest_edges(assignment, reference, port_location)
             name = self._get_unique_source_name(name, "Port")
             return self._create_circuit_port(
                 out, impedance, name, renormalize, deembed, renorm_impedance=renorm_impedance
             )
         return False
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(signal="assignment")
     def lumped_port(
         self,
-        signal,
+        assignment,
         reference=None,
         create_port_sheet=False,
         port_on_plane=True,
         integration_line=0,
         impedance=50,
         name=None,
         renormalize=True,
         deembed=False,
         terminals_rename=True,
     ):
         """Create a waveport taking the closest edges of two objects.
 
         Parameters
         ----------
-        signal : str, int, list, :class:`pyaedt.modeler.cad.object3d.Object3d` or
+        assignment : str, int, list, :class:`pyaedt.modeler.cad.object3d.Object3d` or
             :class:`pyaedt.modeler.elements3d.FacePrimitive`
             Main object for port creation or starting object for the integration line.
         reference : int, list or :class:`pyaedt.modeler.cad.object3d.Object3d`
             Ending object for the integration line or reference for Terminal solution. Can be multiple objects.
         create_port_sheet : bool, optional
             Whether to create a port sheet or use given start_object as port sheet.
         integration_line : int or :class:`pyaedt.application.Analysis.Analysis.AxisDir`, optional
@@ -6365,45 +5860,43 @@
         Create two boxes that will be used to create a lumped port
         named ``'LumpedPort'``.
 
         >>> box1 = hfss.modeler.create_box([0, 0, 50], [10, 10, 5],
         ...                                "BoxLumped1","copper")
         >>> box2 = hfss.modeler.create_box([0, 0, 60], [10, 10, 5],
         ...                                "BoxLumped2", "copper")
-        >>> hfss.lumped_port("BoxLumped1", "BoxLumped2",
-        ...                  hfss.AxisDir.XNeg, 50,
-        ...                  "LumpedPort", True, False)
+        >>> hfss.lumped_port("BoxLumped1","BoxLumped2",hfss.AxisDir.XNeg,50,"LumpedPort",True,False)
         PyAEDT INFO: Connection Correctly created
         'LumpedPort'
 
         """
         if create_port_sheet:
-            signal = self.modeler.convert_to_selections(signal)
+            assignment = self.modeler.convert_to_selections(assignment)
             reference = self.modeler.convert_to_selections(reference)
-            if not self.modeler.does_object_exists(signal) or not self.modeler.does_object_exists(reference):
+            if not self.modeler.does_object_exists(assignment) or not self.modeler.does_object_exists(reference):
                 self.logger.error("One or both objects do not exist. Check and retry.")
                 return False
             sheet_name, point0, point1 = self.modeler._create_sheet_from_object_closest_edge(
-                signal, reference, integration_line, port_on_plane
+                assignment, reference, integration_line, port_on_plane
             )
         else:
-            if isinstance(signal, list):
-                objs = self.modeler.get_faceid_from_position(signal)
+            if isinstance(assignment, list):
+                objs = self.modeler.get_faceid_from_position(assignment)
                 if len(objs) == 1:
-                    signal = objs[0]
+                    assignment = objs[0]
                 elif len(objs) > 1:
-                    self.logger.warning("More than 1 face found. Getting first.")
-                    signal = objs[0]
+                    self.logger.warning("More than one face was found. Getting the first one.")
+                    assignment = objs[0]
                 else:
                     self.logger.error("No Faces found on given location.")
                     return False
-            sheet_name = self.modeler.convert_to_selections(signal, False)
+            sheet_name = self.modeler.convert_to_selections(assignment, False)
             if isinstance(integration_line, list):
                 if len(integration_line) != 2 or len(integration_line[0]) != len(integration_line[1]):
-                    self.logger.error("List of coordinates is not set correctly")
+                    self.logger.error("List of coordinates is not set correctly.")
                     return False
                 point0 = integration_line[0]
                 point1 = integration_line[1]
             else:
                 point0, point1 = self.modeler.get_mid_points_on_dir(sheet_name, integration_line)
         if self.solution_type in ["Modal", "Terminal", "Transient Network"]:
             name = self._get_unique_source_name(name, "Port")
@@ -6424,38 +5917,38 @@
                     deembed=deembed,
                     iswaveport=False,
                     impedance=impedance,
                     terminals_rename=terminals_rename,
                 )
         return False
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(signal="assignment", num_modes="modes")
     def wave_port(
         self,
-        signal,
+        assignment,
         reference=None,
         create_port_sheet=False,
         create_pec_cap=False,
         integration_line=0,
         port_on_plane=True,
-        num_modes=1,
+        modes=1,
         impedance=50,
         name=None,
         renormalize=True,
         deembed=0,
         is_microstrip=False,
         vfactor=3,
         hfactor=5,
         terminals_rename=True,
     ):
         """Create a waveport from a sheet (``start_object``) or taking the closest edges of two objects.
 
         Parameters
         ----------
-        signal : int, str, :class:`pyaedt.modeler.cad.object3d.Object3d` or
+        assignment : int, str, :class:`pyaedt.modeler.cad.object3d.Object3d` or
          :class:`pyaedt.modeler.elements3d.FacePrimitive`
             Main object for port creation or starting object for the integration line.
         reference : int, str, list or :class:`pyaedt.modeler.cad.object3d.Object3d`
             Ending object for the integration line or reference for Terminal solution. Can be multiple objects.
         create_port_sheet : bool, optional
             Whether to create a port sheet or use the start object as the surface
             to create the port. The default is ``False``.
@@ -6467,18 +5960,19 @@
             The default is ``Application.AxisDir.XNeg``.
             It can also be a list of 2 points.
         port_on_plane : bool, optional
             Whether to create the source on the plane orthogonal to ``AxisDir``.
             The default is ``True``.
         impedance : float, optional
             Port impedance. The default is ``50``.
-        num_modes : int, optional
+        modes : int, optional
             Number of modes. The default is ``1``.
         name : str, optional
-            name of the port. The default is ``None``.
+            Name of the port. The default is ``None``, in which
+            case a name is automatically assigned.
         renormalize : bool, optional
             Whether to renormalize the mode. The default is ``True``.
         deembed : float, optional
             Deembed distance in millimeters. The default is ``0``.
         is_microstrip : bool, optional
             Whether if the wave port will be created and is a microstrip port.
             The default is ``False``.
@@ -6506,49 +6000,47 @@
 
         >>> ms = hfss.modeler.create_box([4, 5, 0], [1, 100, 0.2],
         ...                               name="MS1", matname="copper")
         >>> sub = hfss.modeler.create_box([0, 5, -2], [20, 100, 2],
         ...                               name="SUB1", matname="FR4_epoxy")
         >>> gnd = hfss.modeler.create_box([0, 5, -2.2], [20, 100, 0.2],
         ...                               name="GND1", matname="FR4_epoxy")
-        >>> port = hfss.wave_port("GND1", "MS1",
-        ...                       name="MS1",
-        ...                        integration_line=1)
+        >>> port = hfss.wave_port("GND1","MS1",integration_line=1,name="MS1")
         PyAEDT INFO: Connection correctly created.
 
         """
         oname = ""
 
         if create_port_sheet:
-            if not self.modeler.does_object_exists(signal) or not self.modeler.does_object_exists(reference):
+            if not self.modeler.does_object_exists(assignment) or not self.modeler.does_object_exists(reference):
                 self.logger.error("One or both objects do not exist. Check and retry.")
                 return False
-            elif isinstance(signal, cad.elements3d.FacePrimitive):
-                port_sheet = signal.create_object()
+            elif isinstance(assignment, cad.elements3d.FacePrimitive):
+                port_sheet = assignment.create_object()
                 oname = port_sheet.name
             if is_microstrip:
                 sheet_name, int_start, int_stop = self.modeler._create_microstrip_sheet_from_object_closest_edge(
-                    signal, reference, integration_line, vfactor, hfactor
+                    assignment, reference, integration_line, vfactor, hfactor
                 )
             else:
                 sheet_name, int_start, int_stop = self.modeler._create_sheet_from_object_closest_edge(
-                    signal, reference, integration_line, port_on_plane
+                    assignment, reference, integration_line, port_on_plane
                 )
         else:
-            if isinstance(signal, list):
-                objs = self.modeler.get_faceid_from_position(signal)
+            if isinstance(assignment, list):
+                objs = self.modeler.get_faceid_from_position(assignment)
                 if len(objs) == 1:
-                    signal = objs[0]
+                    assignment = objs[0]
                 elif len(objs) > 1:
-                    self.logger.warning("More than 1 face found. Getting first.")
-                    signal = objs[0]
+                    self.logger.warning("More than one face found. Getting first.")
+                    assignment = objs[0]
                 else:
-                    self.logger.error("No Faces found on given location.")
+                    self.logger.error("No faces were found on given location.")
                     return False
-            sheet_name = self.modeler.convert_to_selections(signal, True)[0]
+            sheet_name = self.modeler.convert_to_selections(assignment, True)[0]
             if isinstance(sheet_name, int):
                 try:
                     # NOte: if isinstance(sheet_name, cad.elements3d.FacePrimitive) then
                     # the name of the 3d object is returned.
                     # TODO: Need to improve the way a FacePrimitive is handled.
                     oname = self.modeler.oeditor.GetObjectNameByFaceID(sheet_name)
                 except Exception:
@@ -6582,22 +6074,22 @@
                     #      face = pec_face.id
                     #  else:
                     face = oname
                 else:
                     face = sheet_name
                 dist = math.sqrt(self.modeler[face].faces[0].area)  # TODO: Move this into _create_pec_cap
                 if settings.aedt_version > "2022.2":
-                    self._create_pec_cap(face, signal, -dist / 10)
+                    self._create_pec_cap(face, assignment, -dist / 10)
                 else:
-                    self._create_pec_cap(face, signal, dist / 10)
+                    self._create_pec_cap(face, assignment, dist / 10)
             name = self._get_unique_source_name(name, "Port")
 
             if "Modal" in self.solution_type:
                 return self._create_waveport_driven(
-                    sheet_name, int_start, int_stop, impedance, name, renormalize, num_modes, deembed
+                    sheet_name, int_start, int_stop, impedance, name, renormalize, modes, deembed
                 )
             elif reference:
                 if isinstance(sheet_name, int):
                     faces = [sheet_name]
                 else:
                     faces = self.modeler.get_object_faces(sheet_name)
                 if deembed == 0:
@@ -6633,19 +6125,19 @@
         -------
         bool
             ``True`` when successful, ``False`` when failed.
         """
         self.oradfield.EditRadiatedPowerCalculationMethod(method)
         return True
 
-    @pyaedt_function_handler()
-    def set_mesh_fusion_settings(self, component=None, volume_padding=None, priority=None):
+    @pyaedt_function_handler(component="assignment")
+    def set_mesh_fusion_settings(self, assignment=None, volume_padding=None, priority=None):
         # type: (list|str, list, list) -> bool
 
-        """Set mesh fusion settings in Hfss.
+        """Set mesh fusion settings in HFSS.
 
         component : list, optional
             List of active 3D Components.
             The default is ``None``, in which case components are disabled.
         volume_padding : list, optional
             List of mesh envelope padding, the format is ``[+x, -x, +y, -y, +z, -z]``.
             The default is ``None``, in which case all zeros are applied.
@@ -6663,55 +6155,54 @@
         >>> oDesign.SetDoMeshAssembly
 
         Examples
         --------
 
         >>> import pyaedt
         >>> app = pyaedt.Hfss()
-        >>> app.set_mesh_fusion_settings(component=["Comp1", "Comp2"],
-         ... volume_padding=[[0,0,0,0,0,0], [0,0,5,0,0,0]],
-         ... priority=["Comp1"])
+        >>> app.set_mesh_fusion_settings(assignment=["Comp1", "Comp2"],
+        >>>                              volume_padding=[[0,0,0,0,0,0], [0,0,5,0,0,0]],priority=["Comp1"])
         """
         arg = ["NAME:AllSettings"]
         arg2 = ["NAME:MeshAssembly"]
         arg3 = ["NAME:Priority Components"]
 
-        if component and not isinstance(component, list):
-            component = [component]
+        if assignment and not isinstance(assignment, list):
+            assignment = [assignment]
 
-        if not volume_padding and component:
-            for comp in component:
+        if not volume_padding and assignment:
+            for comp in assignment:
                 if comp in self.modeler.user_defined_component_names:
                     mesh_assembly_arg = ["NAME:" + comp]
                     mesh_assembly_arg.append("MeshAssemblyBoundingVolumePadding:=")
                     mesh_assembly_arg.append(["0", "0", "0", "0", "0", "0"])
                     arg2.append(mesh_assembly_arg)
                 else:
                     self.logger.warning(comp + " does not exist.")
 
-        elif component and isinstance(volume_padding, list) and len(volume_padding) == len(component):
+        elif assignment and isinstance(volume_padding, list) and len(volume_padding) == len(assignment):
             count = 0
-            for comp in component:
+            for comp in assignment:
                 padding = [str(pad) for pad in volume_padding[count]]
                 if comp in self.modeler.user_defined_component_names:
                     mesh_assembly_arg = ["NAME:" + comp]
                     mesh_assembly_arg.append("MeshAssemblyBoundingVolumePadding:=")
                     mesh_assembly_arg.append(padding)
                     arg2.append(mesh_assembly_arg)
                 else:
                     self.logger.warning("{0} does not exist".format(str(comp)))
                 count += 1
-        elif component and isinstance(volume_padding, list) and len(volume_padding) != len(component):
+        elif assignment and isinstance(volume_padding, list) and len(volume_padding) != len(assignment):
             self.logger.error("Volume padding length is different than component list length.")
             return False
 
         if priority and not isinstance(priority, list):
             priority = [priority]
 
-        if component and priority:
+        if assignment and priority:
             for p in priority:
                 if p in self.modeler.user_defined_component_names:
                     arg3.append(p)
                 else:
                     self.logger.warning("{0} does not exist".format(str(p)))
 
         arg.append(arg2)
```

### Comparing `pyaedt-0.8.7/pyaedt/hfss3dlayout.py` & `pyaedt-0.8.8/pyaedt/hfss3dlayout.py`

 * *Files 6% similar despite different names*

```diff
@@ -6,25 +6,26 @@
 import fnmatch
 import io
 import os
 import re
 
 from pyaedt import is_ironpython
 from pyaedt.application.Analysis3DLayout import FieldAnalysis3DLayout
+from pyaedt.application.analysis_hf import ScatteringMethods
 from pyaedt.generic.general_methods import generate_unique_name
 from pyaedt.generic.general_methods import open_file
 from pyaedt.generic.general_methods import parse_excitation_file
 from pyaedt.generic.general_methods import pyaedt_function_handler
 from pyaedt.generic.general_methods import tech_to_control_file
 from pyaedt.generic.settings import settings
 from pyaedt.modeler.pcb.object3dlayout import Line3dLayout  # noqa: F401
 from pyaedt.modules.Boundary import BoundaryObject3dLayout
 
 
-class Hfss3dLayout(FieldAnalysis3DLayout):
+class Hfss3dLayout(FieldAnalysis3DLayout, ScatteringMethods):
     """Provides the HFSS 3D Layout application interface.
 
     This class inherits all objects that belong to HFSS 3D Layout, including EDB
     API queries.
 
     Parameters
     ----------
@@ -140,14 +141,15 @@
             new_desktop_session,
             close_on_exit,
             student_version,
             machine,
             port,
             aedt_process_id,
         )
+        ScatteringMethods.__init__(self, self)
 
     def _init_from_design(self, *args, **kwargs):
         self.__init__(*args, **kwargs)
 
     @pyaedt_function_handler()
     def create_edge_port(
         self,
@@ -350,24 +352,43 @@
                 ]
             )
             listnew = self.port_list
             a = [i for i in listnew if i not in listp]
             if len(a) > 0:
                 bound = self._update_port_info(a[0])
                 if bound:
-                    self.boundaries.append(bound)
-                    return self.boundaries[-1]
+                    self._boundaries[bound.name] = bound
+                    return bound
                 else:
                     return False
             else:
                 return False
         else:
             return False
 
     @pyaedt_function_handler()
+    def dissolve_component(self, component_name):
+        """Dissolve a component and remove it from 3D Layout.
+
+        Parameters
+        ----------
+        component_name : str
+            Name of the component.
+
+        Returns
+        -------
+        bool
+            ``True`` when successful, ``False`` when failed.
+
+
+        """
+        self.oeditor.DissolveComponents(["NAME:elements", component_name])
+        return True
+
+    @pyaedt_function_handler()
     def create_ports_on_component_by_nets(
         self,
         component_name,
         nets,
     ):
         """Create the ports on a component for a list of nets.
 
@@ -404,16 +425,50 @@
                 bound = self._update_port_info(port)
                 if bound:
                     self._boundaries[bound.name] = bound
                     ports.append(bound)
         return ports
 
     @pyaedt_function_handler()
+    def create_pec_on_component_by_nets(
+        self,
+        component_name,
+        nets,
+    ):
+        """Create a PEC connection on a component for a list of nets.
+
+        Parameters
+        ----------
+        component_name : str
+            Component name.
+        nets : str, list
+            Nets to include.
+
+
+        Returns
+        -------
+        bool
+            ``True`` when successful, ``False`` when failed.
+
+        References
+        ----------
+
+        >>> oEditor.CreateEdgePort
+        """
+        if isinstance(nets, list):
+            pass
+        else:
+            nets = [nets]
+        net_array = ["NAME:Nets"] + nets
+        self.oeditor.CreatePortsOnComponentsByNet(["NAME:Components", component_name], net_array, "PEC", "0", "0", "0")
+        return True
+
+    @pyaedt_function_handler()
     def create_differential_port(self, via_signal, via_reference, port_name, deembed=True):
-        """Create a new differential port.
+        """Create a differential port.
 
         Parameters
         ----------
         via_signal : str
             Signal pin.
         via_reference : float
             Reference pin.
@@ -445,16 +500,16 @@
             self.modeler.oeditor.AssignRefPort([port_name], via_reference)
             if deembed:
                 self.modeler.change_property(
                     "Excitations:{}".format(port_name), "DeembedParasiticPortInductance", deembed, "EM Design"
                 )
             bound = self._update_port_info(port_name)
             if bound:
-                self.boundaries.append(bound)
-                return self.boundaries[-1]
+                self._boundaries[bound.name] = bound
+                return bound
             else:
                 return False
         else:
             return False
 
     @pyaedt_function_handler()
     def create_coax_port(self, vianame, radial_extent=0.1, layer=None, alignment="lower"):
@@ -765,76 +820,15 @@
             solution_data = "Terminal Solution Data"
         if not port_names:
             port_names = self.excitations
         if not port_excited:
             port_excited = port_names
         traces = ["dB(S(" + p + "," + q + "))" for p, q in zip(list(port_names), list(port_excited))]
         return self.post.create_report(
-            traces, sweep_name, variations=variations, report_category=solution_data, plotname=plot_name
-        )
-
-    @pyaedt_function_handler()
-    def export_touchstone(
-        self,
-        setup_name=None,
-        sweep_name=None,
-        file_name=None,
-        variations=None,
-        variations_value=None,
-        renormalization=False,
-        impedance=None,
-        gamma_impedance_comments=False,
-    ):
-        """Export a Touchstone file.
-
-        Parameters
-        ----------
-        setup_name : str, optional
-            Name of the setup that has been solved.
-        sweep_name : str, optional
-            Name of the sweep that has been solved.
-        file_name : str, optional
-            Full path and name for the Touchstone file.
-            The default is ``None``, in which case the Touchstone file is exported to
-            the working directory.
-        variations : list, optional
-            List of all parameter variations. For example, ``["$AmbientTemp", "$PowerIn"]``.
-            The default is ``None``.
-        variations_value : list, optional
-            List of all parameter variation values. For example, ``["22cel", "100"]``.
-            The default is ``None``.
-        renormalization : bool, optional
-            Perform renormalization before export.
-            The default is ``False``.
-        impedance : float, optional
-            Real impedance value in ohm, for renormalization, if not specified considered 50 ohm.
-            The default is ``None``.
-        gamma_impedance_comments : bool, optional
-            Include Gamma and Impedance values in comments.
-            The default is ``False``.
-
-        Returns
-        -------
-        str
-            Filename when successful, ``False`` when failed.
-
-        References
-        ----------
-
-        >>> oDesign.ExportNetworkData
-        """
-        return self._export_touchstone(
-            setup_name=setup_name,
-            sweep_name=sweep_name,
-            file_name=file_name,
-            variations=variations,
-            variations_value=variations_value,
-            renormalization=renormalization,
-            impedance=impedance,
-            comments=gamma_impedance_comments,
+            traces, sweep_name, variations=variations, report_category=solution_data, plot_name=plot_name
         )
 
     @pyaedt_function_handler()
     def set_export_touchstone(self, activate, export_dir=""):
         """Export the Touchstone file automatically if the simulation is successful.
 
         Parameters
@@ -899,46 +893,49 @@
         settings.append("EnableDesignIntersectionCheck:=")
         settings.append(enable_intersections_check)
         settings.append("UseAlternativeMeshMethodsAsFallBack:=")
         settings.append(use_alternative_fallback)
         self.odesign.DesignOptions(settings, 0)
         return True
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(
+        setupname="setup", freqstart="start_frequency", freqstop="stop_frequency", sweepname="name"
+    )
     def create_linear_count_sweep(
         self,
-        setupname,
+        setup,
         unit,
-        freqstart,
-        freqstop,
+        start_frequency,
+        stop_frequency,
         num_of_freq_points,
-        sweepname=None,
+        name=None,
         save_fields=True,
         save_rad_fields_only=False,
         sweep_type="Interpolating",
         interpolation_tol_percent=0.5,
         interpolation_max_solutions=250,
         use_q3d_for_dc=False,
     ):
         """Create a sweep with the specified number of points.
 
         Parameters
         ----------
-        setupname : str
+        setup : str
             Name of the setup to attach to the sweep.
         unit : str
             Unit of the frequency. For example, ``"MHz"`` or ``"GHz"``.
-        freqstart : float
+        start_frequency : float
             Starting frequency of the sweep.
-        freqstop : float
+        stop_frequency : float
             Stopping frequency of the sweep.
         num_of_freq_points : int
             Number of frequency points in the range.
-        sweepname : str, optional
-            Name of the sweep. The default is ``None``.
+        name : str, optional
+            Name of the sweep. The default is ``None``, in which
+            case a name is automatically assigned.
         save_fields : bool, optional
             Whether to save fields for a discrete sweep only. The
             default is ``True``.
         save_rad_fields_only : bool, optional
             Whether to save only radiated fields if
             ``save_fields=True``. The default is ``False``.
         sweep_type : str, optional
@@ -964,84 +961,89 @@
 
         >>> oModule.AddSweep
         """
         if sweep_type not in ["Discrete", "Interpolating", "Fast"]:
             raise AttributeError(
                 "Invalid value for `sweep_type`. The value must be 'Discrete', 'Interpolating', or 'Fast'."
             )
-        if sweepname is None:
-            sweepname = generate_unique_name("Sweep")
+        if name is None:
+            sweep_name = generate_unique_name("Sweep")
+        else:
+            sweep_name = name
 
         interpolation = False
         if sweep_type == "Interpolating":
             interpolation = True
             save_fields = False
 
         if not save_fields:
             save_rad_fields_only = False
 
         interpolation_tol = interpolation_tol_percent / 100.0
 
         for s in self.setups:
-            if s.name == setupname:
+            if s.name == setup:
                 setupdata = s
-                if sweepname in [sweep.name for sweep in setupdata.sweeps]:
-                    oldname = sweepname
-                    sweepname = generate_unique_name(oldname)
+                if sweep_name in [sweep.name for sweep in setupdata.sweeps]:
+                    oldname = sweep_name
+                    sweep_name = generate_unique_name(oldname)
                     self.logger.warning(
-                        "Sweep %s is already present. Sweep has been renamed in %s.", oldname, sweepname
+                        "Sweep %s is already present. Sweep has been renamed in %s.", oldname, sweep_name
                     )
-                sweep = setupdata.add_sweep(sweepname=sweepname)
-                if not sweep:
+                name = setupdata.add_sweep(name=sweep_name)
+                if not name:
                     return False
-                sweep.change_range("LinearCount", freqstart, freqstop, num_of_freq_points, unit)
-                sweep.props["GenerateSurfaceCurrent"] = save_fields
-                sweep.props["SaveRadFieldsOnly"] = save_rad_fields_only
-                sweep.props["FastSweep"] = interpolation
-                sweep.props["SAbsError"] = interpolation_tol
-                sweep.props["EnforcePassivity"] = interpolation
-                sweep.props["UseQ3DForDC"] = use_q3d_for_dc
-                sweep.props["MaxSolutions"] = interpolation_max_solutions
-                sweep.update()
-                self.logger.info("Linear count sweep %s has been correctly created.", sweepname)
-                return sweep
+                name.change_range("LinearCount", start_frequency, stop_frequency, num_of_freq_points, unit)
+                name.props["GenerateSurfaceCurrent"] = save_fields
+                name.props["SaveRadFieldsOnly"] = save_rad_fields_only
+                name.props["FastSweep"] = interpolation
+                name.props["SAbsError"] = interpolation_tol
+                name.props["EnforcePassivity"] = interpolation
+                name.props["UseQ3DForDC"] = use_q3d_for_dc
+                name.props["MaxSolutions"] = interpolation_max_solutions
+                name.update()
+                self.logger.info("Linear count sweep %s has been correctly created.", sweep_name)
+                return name
         return False
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(
+        setupname="setup", freqstart="start_frequency", freqstop="stop_frequency", sweepname="name"
+    )
     def create_linear_step_sweep(
         self,
-        setupname,
+        setup,
         unit,
-        freqstart,
-        freqstop,
+        start_frequency,
+        stop_frequency,
         step_size,
-        sweepname=None,
+        name=None,
         save_fields=True,
         save_rad_fields_only=False,
         sweep_type="Interpolating",
         interpolation_tol_percent=0.5,
         interpolation_max_solutions=250,
         use_q3d_for_dc=False,
     ):
         """Create a sweep with the specified frequency step.
 
         Parameters
         ----------
-        setupname : str
+        setup : str
             Name of the setup to attach to the sweep.
         unit : str
             Unit of the frequency. For example, ``"MHz"`` or ``"GHz"``.
-        freqstart : float
+        start_frequency : float
             Starting frequency of the sweep.
-        freqstop : float
+        stop_frequency : float
             Stopping frequency of the sweep.
         step_size : float
             Frequency size of the step.
-        sweepname : str, optional
-            Name of the sweep. The default is ``None``.
+        name : str, optional
+            Name of the sweep. The default is ``None``, in which
+            case a name is automatically assigned.
         save_fields : bool, optional
             Whether to save fields for a discrete sweep only. The
             default is ``True``.
         save_rad_fields_only : bool, optional
             Whether to save only radiated fields if
             ``save_fields=True``. The default is ``False``.
         sweep_type : str, optional
@@ -1067,74 +1069,77 @@
 
         >>> oModule.AddSweep
         """
         if sweep_type not in ["Discrete", "Interpolating", "Fast"]:
             raise AttributeError(
                 "Invalid value for `sweep_type`. The value must be 'Discrete', 'Interpolating', or 'Fast'."
             )
-        if sweepname is None:
-            sweepname = generate_unique_name("Sweep")
+        if name is None:
+            sweep_name = generate_unique_name("Sweep")
+        else:
+            sweep_name = name
 
         interpolation = False
         if sweep_type == "Interpolating":
             interpolation = True
             save_fields = False
 
         if not save_fields:
             save_rad_fields_only = False
 
         interpolation_tol = interpolation_tol_percent / 100.0
 
         for s in self.setups:
-            if s.name == setupname:
+            if s.name == setup:
                 setupdata = s
-                if sweepname in [sweep.name for sweep in setupdata.sweeps]:
-                    oldname = sweepname
-                    sweepname = generate_unique_name(oldname)
+                if sweep_name in [sweep.name for sweep in setupdata.sweeps]:
+                    oldname = sweep_name
+                    sweep_name = generate_unique_name(oldname)
                     self.logger.warning(
-                        "Sweep %s is already present. Sweep has been renamed in %s.", oldname, sweepname
+                        "Sweep %s is already present. Sweep has been renamed in %s.", oldname, sweep_name
                     )
-                sweep = setupdata.add_sweep(sweepname=sweepname, sweeptype=sweep_type)
+                sweep = setupdata.add_sweep(name=sweep_name, sweep_type=sweep_type)
                 if not sweep:
                     return False
-                sweep.change_range("LinearStep", freqstart, freqstop, step_size, unit)
+                sweep.change_range("LinearStep", start_frequency, stop_frequency, step_size, unit)
                 sweep.props["GenerateSurfaceCurrent"] = save_fields
                 sweep.props["SaveRadFieldsOnly"] = save_rad_fields_only
                 sweep.props["FastSweep"] = interpolation
                 sweep.props["SAbsError"] = interpolation_tol
                 sweep.props["EnforcePassivity"] = interpolation
                 sweep.props["UseQ3DForDC"] = use_q3d_for_dc
                 sweep.props["MaxSolutions"] = interpolation_max_solutions
                 sweep.update()
-                self.logger.info("Linear step sweep %s has been correctly created.", sweepname)
+                self.logger.info("Linear step sweep %s has been correctly created.", sweep_name)
                 return sweep
         return False
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(setupname="setup", sweepname="name")
     def create_single_point_sweep(
         self,
-        setupname,
+        setup,
         unit,
         freq,
-        sweepname=None,
+        name=None,
         save_fields=False,
         save_rad_fields_only=False,
     ):
         """Create a sweep with a single frequency point.
 
         Parameters
         ----------
-        setupname : str
+        setup : str
             Name of the setup.
         unit : str
             Unit of the frequency. For example, ``"MHz`` or ``"GHz"``.
         freq : float, list
             Frequency of the single point or list of frequencies to create distinct single points.
-        sweepname : str, optional
-            Name of the sweep. The default is ``None``.
+        name : str, optional
+            Name of the sweep. The default is ``None``, in which
+            case a name is automatically assigned.
         save_fields : bool, optional
             Whether to save fields for all points and subranges defined in the sweep. The default is ``False``.
         save_rad_fields_only : bool, optional
             Whether to save only radiating fields. The default is ``False``.
 
         Returns
         -------
@@ -1142,47 +1147,49 @@
             Sweep object if successful, ``False`` otherwise.
 
         References
         ----------
 
         >>> oModule.AddSweep
         """
-        if sweepname is None:
-            sweepname = generate_unique_name("SinglePoint")
+        if name is None:
+            sweep_name = generate_unique_name("SinglePoint")
+        else:
+            sweep_name = name
 
         add_subranges = False
         if isinstance(freq, list):
             if not freq:
                 raise AttributeError("Frequency list is empty. Specify at least one frequency point.")
             freq0 = freq.pop(0)
             if freq:
                 add_subranges = True
         else:
             freq0 = freq
 
-        if setupname not in self.setup_names:
+        if setup not in self.setup_names:
             return False
         for s in self.setups:
-            if s.name == setupname:
+            if s.name == setup:
                 setupdata = s
-                if sweepname in [sweep.name for sweep in setupdata.sweeps]:
-                    oldname = sweepname
-                    sweepname = generate_unique_name(oldname)
+                if sweep_name in [sweep.name for sweep in setupdata.sweeps]:
+                    oldname = sweep_name
+                    sweep_name = generate_unique_name(oldname)
                     self.logger.warning(
-                        "Sweep %s is already present. Sweep has been renamed in %s.", oldname, sweepname
+                        "Sweep %s is already present. Sweep has been renamed in %s.", oldname, sweep_name
                     )
-                sweepdata = setupdata.add_sweep(sweepname, "Discrete")
+                sweepdata = setupdata.add_sweep(sweep_name, "Discrete")
                 sweepdata.change_range("SinglePoint", freq0, unit=unit)
                 sweepdata.props["GenerateSurfaceCurrent"] = save_fields
                 sweepdata.props["SaveRadFieldsOnly"] = save_rad_fields_only
                 sweepdata.update()
                 if add_subranges:
                     for f in freq:
-                        sweepdata.add_subrange(rangetype="SinglePoint", start=f, unit=unit)
-                self.logger.info("Single point sweep %s has been correctly created.", sweepname)
+                        sweepdata.add_subrange(range_type="SinglePoint", start=f, unit=unit)
+                self.logger.info("Single point sweep %s has been correctly created.", sweep_name)
                 return sweepdata
         return False
 
     @pyaedt_function_handler()
     def _import_cad(
         self, cad_path, cad_format="gds", aedb_path=None, xml_path=None, set_as_active=True, close_active_project=False
     ):
@@ -2028,26 +2035,26 @@
                 )
 
                 self.logger.info("Source Excitation updated with Dataset.")
                 return True
         self.logger.error("Port not found.")
         return False
 
-    @pyaedt_function_handler()
-    def get_dcir_solution_data(self, setup_name, show="RL", category="Loop_Resistance"):
+    @pyaedt_function_handler(setup_name="setup")
+    def get_dcir_solution_data(self, setup, show="RL", category="Loop_Resistance"):
         """Retrieve dcir solution data. Available element_names are dependent on element_type as below.
         Sources ["Voltage", "Current", "Power"]
         "RL" ['Loop Resistance', 'Path Resistance', 'Resistance', 'Inductance']
         "Vias" ['X', 'Y', 'Current', 'Limit', 'Resistance', 'IR Drop', 'Power']
         "Bondwires" ['Current', 'Limit', 'Resistance', 'IR Drop']
         "Probes" ['Voltage'].
 
         Parameters
         ----------
-        setup_name : str
+        setup : str
             Name of the setup.
         show : str, optional
             Type of the element. Options are ``"Sources"`, ``"RL"`, ``"Vias"``, ``"Bondwires"``, and ``"Probes"``.
         category : str, optional
             Name of the element. Options are ``"Voltage"`, ``"Current"`, ``"Power"``, ``"Loop_Resistance"``,
             ``"Path_Resistance"``, ``"Resistance"``, ``"Inductance"``, ``"X"``, ``"Y"``, ``"Limit"`` and ``"IR Drop"``.
         Returns
@@ -2061,76 +2068,34 @@
         all_categories = self.post.available_quantities_categories(context=show, is_siwave_dc=True)
         if category not in all_categories:
             return False  # pragma: no cover
         all_quantities = self.post.available_report_quantities(
             context=show, is_siwave_dc=True, quantities_category=category
         )
 
-        return self.post.get_solution_data(all_quantities, setup_sweep_name=setup_name, domain="DCIR", context=show)
-
-    @pyaedt_function_handler()
-    def get_touchstone_data(self, setup_name=None, sweep_name=None, variations=None):
-        """
-        Return a Touchstone data plot.
-
-        Parameters
-        ----------
-        setup_name : list
-            Name of the setup.
-        sweep_name : str, optional
-            Name of the sweep. The default value is ``None``.
-        variations : dict, optional
-            Dictionary of variation names. The default value is ``None``.
-
-        Returns
-        -------
-        :class:`pyaedt.generic.touchstone_parser.TouchstoneData`
-           Class containing all requested data.
-
-        References
-        ----------
+        return self.post.get_solution_data(all_quantities, setup_sweep_name=setup, domain="DCIR", context=show)
 
-        >>> oModule.GetSolutionDataPerVariation
-        """
-        from pyaedt.generic.touchstone_parser import TouchstoneData
-
-        if not setup_name:
-            setup_name = self.setups[0].name
-
-        if not sweep_name:
-            for setup in self.setups:
-                if setup.name == setup_name:
-                    sweep_name = setup.sweeps[0].name
-        s_parameters = []
-        solution = "{} : {}".format(setup_name, sweep_name)
-        expression = self.get_traces_for_plot(category="S")
-        sol_data = self.post.get_solution_data(expression, solution, variations=variations)
-        for i in range(sol_data.number_of_variations):
-            sol_data.set_active_variation(i)
-            s_parameters.append(TouchstoneData(solution_data=sol_data))
-        return s_parameters
-
-    @pyaedt_function_handler()
-    def get_dcir_element_data_loop_resistance(self, setup_name):
+    @pyaedt_function_handler(setup_name="setup")
+    def get_dcir_element_data_loop_resistance(self, setup):
         """Get dcir element data loop resistance.
 
         Parameters
         ----------
-        setup_name : str
+        setup : str
             Name of the setup.
         Returns
         -------
         pandas.Dataframe
         """
         if is_ironpython:  # pragma: no cover
             self.logger.error("Method not supported in IronPython.")
             return False
         import pandas as pd
 
-        solution_data = self.get_dcir_solution_data(setup_name=setup_name, show="RL", category="Loop Resistance")
+        solution_data = self.get_dcir_solution_data(setup=setup, show="RL", category="Loop Resistance")
 
         terms = []
         pattern = r"LoopRes\((.*?)\)"
         for ex in solution_data.expressions:
             matches = re.findall(pattern, ex)
             if matches:
                 terms.extend(matches[0].split(","))
@@ -2147,32 +2112,32 @@
                     data2.append(False)
             data[i] = data2
 
         df = pd.DataFrame(data)
         df.index = terms
         return df
 
-    @pyaedt_function_handler()
-    def get_dcir_element_data_current_source(self, setup_name):
+    @pyaedt_function_handler(setup_name="setup")
+    def get_dcir_element_data_current_source(self, setup):
         """Get dcir element data current source.
 
         Parameters
         ----------
-        setup_name : str
+        setup : str
             Name of the setup.
         Returns
         -------
         pandas.Dataframe
         """
         if is_ironpython:  # pragma: no cover
             self.logger.error("Method not supported in IronPython.")
             return False
         import pandas as pd
 
-        solution_data = self.get_dcir_solution_data(setup_name=setup_name, show="Sources", category="Voltage")
+        solution_data = self.get_dcir_solution_data(setup=setup, show="Sources", category="Voltage")
         terms = []
         pattern = r"^V\((.*?)\)"
         for t_name in solution_data.expressions:
             matches = re.findall(pattern, t_name)
             if matches:
                 terms.append(matches[0])
         terms = list(set(terms))
@@ -2183,36 +2148,36 @@
             value = solution_data.data_magnitude(ex, convert_to_SI=True)
             if value is not False:
                 data["Voltage"].append(value[0])
         df = pd.DataFrame(data)
         df.index = terms
         return df
 
-    @pyaedt_function_handler()
-    def get_dcir_element_data_via(self, setup_name):
+    @pyaedt_function_handler(setup_name="setup")
+    def get_dcir_element_data_via(self, setup):
         """Get dcir element data via.
 
         Parameters
         ----------
-        setup_name : str
+        setup : str
             Name of the setup.
         Returns
         -------
         pandas.Dataframe
         """
         if is_ironpython:
             self.logger.error("Method not supported in IronPython.")
             return False
         import pandas as pd
 
         cates = ["X", "Y", "Current", "Resistance", "IR Drop", "Power"]
         df = None
         for cat in cates:
             data = {cat: []}
-            solution_data = self.get_dcir_solution_data(setup_name=setup_name, show="Vias", category=cat)
+            solution_data = self.get_dcir_solution_data(setup=setup, show="Vias", category=cat)
             tmp_via_names = []
             pattern = r"\((.*?)\)"
             for t_name in solution_data.expressions:
                 matches = re.findall(pattern, t_name)
                 if matches:
                     tmp_via_names.append(matches[0])
```

### Comparing `pyaedt-0.8.7/pyaedt/icepak.py` & `pyaedt-0.8.8/pyaedt/icepak.py`

 * *Files 1% similar despite different names*

```diff
@@ -219,15 +219,14 @@
 
     @pyaedt_function_handler()
     def assign_grille(
         self,
         air_faces,
         free_loss_coeff=True,
         free_area_ratio=0.8,
-        resistance_type=0,
         external_temp="AmbientTemp",
         expternal_pressure="AmbientPressure",
         x_curve=["0", "1", "2"],
         y_curve=["0", "1", "2"],
         boundary_name=None,
     ):
         """Assign grille to a face or list of faces.
@@ -237,22 +236,14 @@
         air_faces : str, list
             List of face names.
         free_loss_coeff : bool
             Whether to use the free loss coefficient. The default is ``True``. If ``False``,
             the free loss coefficient is not used.
         free_area_ratio : float, str
             Free loss coefficient value. The default is ``0.8``.
-        resistance_type : int, optional
-            Type of the resistance. Options are:
-
-            - ``0`` for ``"Perforated Thin Vent"``
-            - ``1`` for ``"Circular Metal Wire Screen"``
-            - ``2`` for ``"Two-Plane Screen Cyl. Bars"``
-
-            The default is ``0`` for ``"Perforated Thin Vent"``.
         external_temp : str, optional
             External temperature. The default is ``"AmbientTemp"``.
         expternal_pressure : str, optional
             External pressure. The default is ``"AmbientPressure"``.
         x_curve : list, optional
             List of X curves in m_per_sec. The default is ``["0", "1", "2"]``.
         y_curve : list
@@ -342,23 +333,23 @@
         bound = BoundaryObject(self, boundary_name, props, "Opening")
         if bound.create():
             self._boundaries[bound.name] = bound
             self.logger.info("Opening Assigned")
             return bound
         return None
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(setup_name="setup")
     def assign_2way_coupling(
-        self, setup_name=None, number_of_iterations=2, continue_ipk_iterations=True, ipk_iterations_per_coupling=20
+        self, setup=None, number_of_iterations=2, continue_ipk_iterations=True, ipk_iterations_per_coupling=20
     ):
         """Assign two-way coupling to a setup.
 
         Parameters
         ----------
-        setup_name : str, optional
+        setup : str, optional
             Name of the setup. The default is ``None``, in which case the active setup is used.
         number_of_iterations : int, optional
             Number of iterations. The default is ``2``.
         continue_ipk_iterations : bool, optional
            Whether to continue Icepak iterations. The default is ``True``.
         ipk_iterations_per_coupling : int, optional
             Additional iterations per coupling. The default is ``20``.
@@ -372,26 +363,26 @@
         ----------
 
         >>> oModule.AddTwoWayCoupling
 
         Examples
         --------
 
-        >>> icepak.assign_2way_coupling("Setup1", 1, True, 10)
+        >>> icepak.assign_2way_coupling("Setup1",1,True,10)
         True
 
         """
-        if not setup_name:
+        if not setup:
             if self.setups:
-                setup_name = self.setups[0].name
+                setup = self.setups[0].name
             else:
                 self.logger.error("No setup is defined.")
                 return False
         self.oanalysis.AddTwoWayCoupling(
-            setup_name,
+            setup,
             [
                 "NAME:Options",
                 "NumCouplingIters:=",
                 number_of_iterations,
                 "ContinueIcepakIterations:=",
                 continue_ipk_iterations,
                 "IcepakIterationsPerCoupling:=",
@@ -1422,16 +1413,15 @@
                 self[name_map[var_name + "_Factor"]] = var
                 self[name_map[var_name]] = (
                     name_map[var_name + "_Factor"] + "*" + [name_map["HSHeight"], name_map["HSWidth"]][width_or_height]
                 )
             else:
                 self[name_map[var_name]] = self.modeler._arg_with_dim(var)
 
-        if numcolumn_perside > 1:
-            self[name_map["NumColumnsPerSide"]] = numcolumn_perside
+        self[name_map["NumColumnsPerSide"]] = numcolumn_perside
         if symmetric:
             if relative:
                 self[name_map["SymSeparation_Factor"]] = symmetric_separation
                 self[name_map["SymSeparation"]] = name_map["SymSeparation_Factor"] + "*" + name_map["HSHeight"]
             else:
                 self[name_map["SymSeparation"]] = self.modeler._arg_with_dim(symmetric_separation)
 
@@ -1548,25 +1538,24 @@
         )
         self.modeler.duplicate_along_line(
             fin_base.name,
             self.Position(0, name_map["FinSeparation"] + "+" + name_map["FinThickness"], 0),
             name_map["_num"] + "*2",
             True,
         )
-        if numcolumn_perside > 0:
-            self.modeler.duplicate_along_line(
-                fin_base.name,
-                self.Position(
-                    name_map["FinLength"] + "+" + name_map["ColumnSeparation"],
-                    name_map["FinLength"] + "*sin(" + name_map["PatternAngle"] + "*3.14/180)",
-                    0,
-                ),
-                name_map["NumColumnsPerSide"],
-                True,
-            )
+        self.modeler.duplicate_along_line(
+            fin_base.name,
+            self.Position(
+                name_map["FinLength"] + "+" + name_map["ColumnSeparation"],
+                name_map["FinLength"] + "*sin(" + name_map["PatternAngle"] + "*3.14/180)",
+                0,
+            ),
+            name_map["NumColumnsPerSide"],
+            True,
+        )
         cs = self.modeler.oeditor.GetActiveCoordinateSystem()
         cs_ymax = self.modeler.create_coordinate_system(
             self.Position(0, name_map["HSHeight"] + "/2", 0),
             mode="view",
             view="XY",
             name=generate_unique_name("yMax"),
             reference_cs=cs,
@@ -1739,123 +1728,128 @@
                 ignore_unclassified_objects,
                 "SkipIntersectionChecks:=",
                 skip_intersection_checks,
             ],
         )
         return True
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(designname="design",
+                             setupname="setup",
+                             sweepname="sweep",
+                             paramlist="parameters",
+                             object_list="assignment")
     def assign_em_losses(
             self,
-            designname="HFSSDesign1",
-            setupname="Setup1",
-            sweepname="LastAdaptive",
+            design="HFSSDesign1",
+            setup="Setup1",
+            sweep="LastAdaptive",
             map_frequency=None,
             surface_objects=None,
             source_project_name=None,
-            paramlist=None,
-            object_list=None,
+            parameters=None,
+            assignment=None,
     ):
         """Map EM losses to an Icepak design.
 
         Parameters
         ----------
-        designname : string, optional
+        design : string, optional
             Name of the design with the source mapping. The default is ``"HFSSDesign1"``.
-        setupname : str, optional
+        setup : str, optional
             Name of the EM setup. The default is ``"Setup1"``.
-        sweepname : str, optional
+        sweep : str, optional
             Name of the EM sweep to use for the mapping. The default is ``"LastAdaptive"``.
         map_frequency : str, optional
             String containing the frequency to map. The default is ``None``.
             The value must be ``None`` for Eigenmode analysis.
         surface_objects : list, optional
             List of objects in the source that are metals. The default is ``None``.
         source_project_name : str, optional
             Name of the source project. The default is ``None``, in which case the
             source from the same project is used.
-        paramlist : list, dict, optional
-            List of all parameters to map from source and Icepak design. The default is ``None``.
+        parameters : list, dict, optional
+            List of all parameters to map from source and Icepak design.
+            The default is ``None``, in which case the variables are set to their values (no mapping).
             If ``None`` the variables are set to their values (no mapping).
-            If it is a list, the specified variables in the icepak design are mapped to variables
+            If a list is provided, the specified variables in the Icepak design are mapped to variables
             in the source design having the same name.
-            If it is a dictionary, it is possible to map variables to the source design having a different name.
+            If a dictionary is provided, it is possible to map variables to the source design having a different name.
             The dictionary structure is {"source_design_variable": "icepak_variable"}.
-        object_list : list, optional
+        assignment : list, optional
             List of objects. The default is ``None``.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         References
         ----------
 
         >>> oModule.AssignEMLoss
         """
         if surface_objects is None:
             surface_objects = []
-        if object_list is None:
-            object_list = []
+        if assignment is None:
+            assignment = []
 
         self.logger.info("Mapping EM losses.")
 
         if self.project_name == source_project_name or source_project_name is None:
             project_name = "This Project*"
         else:
             project_name = source_project_name + ".aedt"
         #
         # Generate a list of model objects from the lists made previously and use to map the HFSS losses into Icepak
         #
-        if not object_list:
-            all_objects = self.modeler.object_names
-            if "Region" in all_objects:
-                all_objects.remove("Region")
+        if not assignment:
+            assignment = self.modeler.object_names
+            if "Region" in assignment:
+                assignment.remove("Region")
         else:
-            all_objects = object_list[:]
+            assignment = assignment[:]
 
         surfaces = surface_objects
         if map_frequency:
             intr = [map_frequency]
         else:
             intr = []
 
         argparam = OrderedDict({})
         for el in self.available_variations.nominal_w_values_dict:
             argparam[el] = self.available_variations.nominal_w_values_dict[el]
 
-        if paramlist and isinstance(paramlist, list):
-            for el in paramlist:
+        if parameters and isinstance(parameters, list):
+            for el in parameters:
                 argparam[el] = el
-        elif paramlist and isinstance(paramlist, dict):
-            for el in paramlist:
-                argparam[el] = paramlist[el]
+        elif parameters and isinstance(parameters, dict):
+            for el in parameters:
+                argparam[el] = parameters[el]
 
         props = OrderedDict(
             {
-                "Objects": all_objects,
+                "Objects": assignment,
                 "Project": project_name,
                 "Product": "ElectronicsDesktop",
-                "Design": designname,
-                "Soln": setupname + " : " + sweepname,
+                "Design": design,
+                "Soln": setup + " : " + sweep,
                 "Params": argparam,
                 "ForceSourceToSolve": True,
                 "PreservePartnerSoln": True,
                 "PathRelativeTo": "TargetProject",
             }
         )
         props["Intrinsics"] = intr
         props["SurfaceOnly"] = surfaces
 
         name = generate_unique_name("EMLoss")
         bound = BoundaryObject(self, name, props, "EMLoss")
         if bound.create():
             self._boundaries[bound.name] = bound
-            self.logger.info("EM losses mapped from design: %s.", designname)
+            self.logger.info("EM losses mapped from design: %s.", design)
             return bound
         return False
 
     @pyaedt_function_handler()
     def eval_surface_quantity_from_field_summary(
             self,
             faces_list,
@@ -4053,32 +4047,32 @@
                 ext_surf_rad_ref_temp=ext_surf_rad_ref_temp,
                 ext_surf_rad_view_factor=ext_surf_rad_view_factor,
                 radiate=radiate,
                 radiate_surf_mat=radiate_surf_mat,
                 shell_conduction=shell_conduction,
             )
 
-    @pyaedt_function_handler()
-    def create_setup(self, setupname="MySetupAuto", setuptype=None, **kwargs):
+    @pyaedt_function_handler(setupname="name", setuptype="setup_type")
+    def create_setup(self, name="MySetupAuto", setup_type=None, **kwargs):
         """Create an analysis setup for Icepak.
-        Optional arguments are passed along with ``setuptype`` and ``setupname``.  Keyword
-        names correspond to the ``setuptype``
+        Optional arguments are passed along with ``setup_type`` and ``name``.  Keyword
+        names correspond to the ``setup_type``
         corresponding to the native AEDT API.  The list of
         keywords here is not exhaustive.
 
         .. note::
            This method overrides the ``Analysis.setup()`` method for the HFSS app.
 
         Parameters
         ----------
-        setuptype : int, str, optional
+        name : str, optional
+            Name of the setup. The default is ``"Setup1"``.
+        setup_type : int, str, optional
             Type of the setup. Options are ``"IcepakSteadyState"``
             and ``"IcepakTransient"``. The default is ``"IcepakSteadyState"``.
-        setupname : str, optional
-            Name of the setup. The default is ``"Setup1"``.
         **kwargs : dict, optional
             Available keys depend on setup chosen.
             For more information, see
             :doc:`../SetupTemplatesIcepak`.
 
         Returns
         -------
@@ -4091,25 +4085,25 @@
         >>> oModule.InsertSetup
 
         Examples
         --------
 
         >>> from pyaedt import Icepak
         >>> app = Icepak()
-        >>> app.create_setup(setupname="Setup1", setuptype="TransientTemperatureOnly", MaxIterations=20)
+        >>> app.create_setup(setup_type="TransientTemperatureOnly",name="Setup1",MaxIterations=20)
 
         """
-        if setuptype is None:
-            setuptype = self.design_solutions.default_setup
-        elif setuptype in SetupKeys.SetupNames:
-            setuptype = SetupKeys.SetupNames.index(setuptype)
+        if setup_type is None:
+            setup_type = self.design_solutions.default_setup
+        elif setup_type in SetupKeys.SetupNames:
+            setup_type = SetupKeys.SetupNames.index(setup_type)
         if "props" in kwargs:
-            return self._create_setup(setupname=setupname, setuptype=setuptype, props=kwargs["props"])
+            return self._create_setup(name=name, setup_type=setup_type, props=kwargs["props"])
         else:
-            setup = self._create_setup(setupname=setupname, setuptype=setuptype)
+            setup = self._create_setup(name=name, setup_type=setup_type)
         setup.auto_update = False
         for arg_name, arg_value in kwargs.items():
             if setup[arg_name] is not None:
                 setup[arg_name] = arg_value
         setup.auto_update = True
         setup.update()
         return setup
@@ -4599,28 +4593,28 @@
 
         if not boundary_name:
             boundary_name = generate_unique_name("Block")
 
         bound = BoundaryObject(self, boundary_name, props, "Block")
         return _create_boundary(bound)
 
-    @pyaedt_function_handler()
-    def get_fans_operating_point(self, export_file=None, setup_name=None, timestep=None, design_variation=None):
+    @pyaedt_function_handler(timestep="time_step")
+    def get_fans_operating_point(self, export_file=None, setup_name=None, time_step=None, design_variation=None):
         """
         Get operating point of the fans in the design.
 
         Parameters
         ----------
         export_file : str, optional
             Name of the file in which the fans' operating point is saved. The default is
             ``None``, in which case the filename is automatically generated.
         setup_name : str, optional
             Setup name from which to determine the fans' operating point. The default is
             ``None``, in which case the first available setup is used.
-        timestep : str, optional
+        time_step : str, optional
             Time, with units, at which to determine the fans' operating point. The default
             is ``None``, in which case the first available timestep is used. This argument is
             only relevant in transient simulations.
         design_variation : str, optional
             Design variation from which to determine the fans' operating point. The default is
             ``None``, in which case the nominal variation is used.
 
@@ -4642,15 +4636,15 @@
         --------
         >>> from pyaedt import Icepak
         >>> ipk = Icepak()
         >>> ipk.create_fan()
         >>> filename, vol_flow_name, p_rise_name, op_dict= ipk.post.get_fans_operating_point()
         """
 
-        return self.post.get_fans_operating_point(export_file, setup_name, timestep, design_variation)
+        return self.post.get_fans_operating_point(export_file, setup_name, time_step, design_variation)
 
     @pyaedt_function_handler()
     def assign_free_opening(
             self,
             assignment,
             boundary_name=None,
             temperature="AmbientTemp",
```

### Comparing `pyaedt-0.8.7/pyaedt/maxwell.py` & `pyaedt-0.8.8/pyaedt/maxwell.py`

 * *Files 6% similar despite different names*

```diff
@@ -7,14 +7,15 @@
 import os
 import re
 
 from pyaedt.application.Analysis3D import FieldAnalysis3D
 from pyaedt.application.Variables import decompose_variable_value
 from pyaedt.generic.constants import SOLUTIONS
 from pyaedt.generic.general_methods import generate_unique_name
+from pyaedt.generic.general_methods import open_file
 from pyaedt.generic.general_methods import pyaedt_function_handler
 from pyaedt.generic.general_methods import read_configuration_file
 from pyaedt.generic.general_methods import write_configuration_file
 from pyaedt.modeler.geometry_operators import GeometryOperators
 from pyaedt.modules.Boundary import BoundaryObject
 from pyaedt.modules.Boundary import MaxwellParameters
 from pyaedt.modules.SetupTemplates import SetupKeys
@@ -181,27 +182,27 @@
                 "SkewPart": skew_part,
                 "SkewAngleUnit": skew_angle_unit,
                 "NumberOfSlices": number_of_slices,
             }
             props.update(arg_slice_table)
             return self.change_design_settings(props)
 
-    @pyaedt_function_handler()
-    def set_core_losses(self, objects, value=False):
+    @pyaedt_function_handler(objects="assignment", value="core_loss_on_field")
+    def set_core_losses(self, assignment, core_loss_on_field=False):
         """Whether to enable core losses for a set of objects.
 
-        For ``EddyCurrent`` and ``Transient`` solver designs, core losses calulcations
+        For ``EddyCurrent`` and ``Transient`` solver designs, core losses calculations
         may be included in the simulation on any object that has a corresponding
         core loss definition (with core loss coefficient settings) in the material library.
 
         Parameters
         ----------
-        objects : list, str
+        assignment : list, str
             List of object to apply core losses to.
-        value : bool, optional
+        core_loss_on_field : bool, optional
             Whether to enable ``Consider core loss effect on field`` for the given list. The default is
             ``False``.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
@@ -212,30 +213,30 @@
         >>> oModule.SetCoreLoss
 
         Examples
         --------
         Set core losses in Maxwell 3D.
 
         >>> from pyaedt import Maxwell3d
-        >>> maxwell_3d = Maxwell3d()
-        >>> maxwell_3d.set_core_losses(["PQ_Core_Bottom", "PQ_Core_Top"], True)
-
+        >>> m3d = Maxwell3d()
+        >>> m3d.set_core_losses(assignment=["PQ_Core_Bottom", "PQ_Core_Top"],core_loss_on_field=True)
+        >>> m3d.release_desktop(True, True)
         """
         if self.solution_type in ["EddyCurrent", "Transient"]:
-            objects = self.modeler.convert_to_selections(objects, True)
-            self.oboundary.SetCoreLoss(objects, value)
+            assignment = self.modeler.convert_to_selections(assignment, True)
+            self.oboundary.SetCoreLoss(assignment, core_loss_on_field)
             return True
         else:
             raise Exception("Core losses is only available with `EddyCurrent` and `Transient` solutions.")
         return False
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(sources="assignment")
     def assign_matrix(
         self,
-        sources,
+        assignment,
         matrix_name=None,
         turns=None,
         return_path=None,
         group_sources=None,
         branches=None,
     ):
         """Assign a matrix to the selection.
@@ -243,15 +244,15 @@
         Matrix assignment can be calculated based upon the solver type.
         For 2D/3D solvers the available solution types are: ``Magnetostatic``,
         ``Electrostatic``, ``Eddy Current``, ``DC Conduction`` and ``AC Conduction``.
 
 
         Parameters
         ----------
-        sources : list, str
+        assignment : list, str
             List of sources to assign a matrix to.
         matrix_name : str, optional
             Name of the matrix. The default is ``None``.
         turns : list, int, optional
             Number of turns. The default is 1.
         return_path : list, str, optional
             Return path. The default is ``infinite``
@@ -272,59 +273,60 @@
 
         >>> oModule.AssignMatrix
 
         Examples
         --------
         Set matrix in a Maxwell magnetostatic analysis.
 
-        >>> m2d = Maxwell2d(solution_type="MagnetostaticXY", close_on_exit=True, specified_version="2022.1")
+        >>> from pyaedt import Maxwell2d
+        >>> m2d = Maxwell2d(solution_type="MagnetostaticXY",specified_version="2022.1",close_on_exit=True)
         >>> coil1 = m2d.modeler.create_rectangle([0, 1.5, 0], [8, 3], is_covered=True, name="Coil_1")
         >>> coil2 = m2d.modeler.create_rectangle([8.5, 1.5, 0], [8, 3], is_covered=True, name="Coil_2")
         >>> coil3 = m2d.modeler.create_rectangle([16, 1.5, 0], [8, 3], is_covered=True, name="Coil_3")
         >>> coil4 = m2d.modeler.create_rectangle([32, 1.5, 0], [8, 3], is_covered=True, name="Coil_4")
-        >>> current1 = m2d.assign_current("Coil_1", amplitude=1, swap_direction=False, name="Current1")
-        >>> current2 = m2d.assign_current("Coil_2", amplitude=1, swap_direction=True, name="Current2")
-        >>> current3 = m2d.assign_current("Coil_3", amplitude=1, swap_direction=True, name="Current3")
-        >>> current4 = m2d.assign_current("Coil_4", amplitude=1, swap_direction=True, name="Current4")
+        >>> current1 = m2d.assign_current(assignment="Coil_1",amplitude=1,swap_direction=False,name="Current1")
+        >>> current2 = m2d.assign_current(assignment="Coil_2",amplitude=1,swap_direction=True,name="Current2")
+        >>> current3 = m2d.assign_current(assignment="Coil_3",amplitude=1,swap_direction=True,name="Current3")
+        >>> current4 = m2d.assign_current(assignment="Coil_4",amplitude=1,swap_direction=True,name="Current4")
         >>> group_sources = {"Group1_Test": ["Current1", "Current3"], "Group2_Test": ["Current2", "Current4"]}
         >>> selection = ['Current1', 'Current2', 'Current3', 'Current4']
         >>> turns = [5, 1, 2, 3]
-        >>> L = m2d.assign_matrix(sources=selection, matrix_name="Test2", turns=turns, group_sources=group_sources)
+        >>> L = m2d.assign_matrix(assignment=selection,matrix_name="Test2",turns=turns,group_sources=group_sources)
 
         Set matrix in a Maxwell DC Conduction analysis.
-        >>> m2d.assign_voltage(["Port1"], amplitude=1, name="1V")
-        >>> m2d.assign_voltage(["Port2"], amplitude=0, name="0V")
-        >>> m2d.assign_matrix(sources=['1V'], group_sources=['0V'], matrix_name="Matrix1")
-
+        >>> m2d.assign_voltage(["Port1"],amplitude=1,name="1V")
+        >>> m2d.assign_voltage(["Port2"],amplitude=0,name="0V")
+        >>> m2d.assign_matrix(assignment=['1V'],matrix_name="Matrix1",group_sources=['0V'])
+        >>> m2d.release_desktop(True, True)
         """
 
-        sources = self.modeler.convert_to_selections(sources, True)
+        assignment = self.modeler.convert_to_selections(assignment, True)
         if self.solution_type in ["Electrostatic", "ACConduction", "DCConduction"]:
-            turns = ["1"] * len(sources)
+            turns = ["1"] * len(assignment)
             branches = None
             if self.design_type == "Maxwell 2D":
                 if group_sources:
                     if isinstance(group_sources, dict):
                         first_key = next(iter(group_sources))
                         group_sources = group_sources[first_key]
                         self.logger.warning("First Ground is selected")
                     group_sources = self.modeler.convert_to_selections(group_sources, True)
-                    if any(item in group_sources for item in sources):
+                    if any(item in group_sources for item in assignment):
                         self.logger.error("Ground must be different than selected sources")
                         return False
             else:
                 group_sources = None
 
         elif self.solution_type in ["EddyCurrent", "Magnetostatic"]:
             if self.solution_type == "Magnetostatic":
                 if group_sources:
                     if isinstance(group_sources, (dict, OrderedDict)):
                         new_group = group_sources.copy()
                         for element in new_group:
-                            if not all(item in sources for item in group_sources[element]):
+                            if not all(item in assignment for item in group_sources[element]):
                                 self.logger.warning("Sources in group " + element + " are not selected")
                                 group_sources.pop(element)
                         if not branches or len(group_sources) != len(
                             self.modeler.convert_to_selections(branches, True)
                         ):
                             if branches:
                                 branches = self.modeler.convert_to_selections(branches, True)
@@ -341,62 +343,62 @@
                         group_sources = {group_name: group_sources}
                     else:
                         self.logger.warning("Group of sources is not a dictionary")
                         group_sources = None
             else:
                 group_sources = None
                 branches = None
-                turns = ["1"] * len(sources)
+                turns = ["1"] * len(assignment)
                 self.logger.info("Infinite is the only return path option in EddyCurrent.")
-                return_path = ["infinite"] * len(sources)
+                return_path = ["infinite"] * len(assignment)
 
         if self.solution_type not in ["Transient", "ElectricTransient"]:
             if not matrix_name:
                 matrix_name = generate_unique_name("Matrix")
-            if not turns or len(sources) != len(self.modeler.convert_to_selections(turns, True)):
+            if not turns or len(assignment) != len(self.modeler.convert_to_selections(turns, True)):
                 if turns:
                     turns = self.modeler.convert_to_selections(turns, True)
-                    num = abs(len(sources) - len(self.modeler.convert_to_selections(turns, True)))
-                    if len(sources) < len(self.modeler.convert_to_selections(turns, True)):
+                    num = abs(len(assignment) - len(self.modeler.convert_to_selections(turns, True)))
+                    if len(assignment) < len(self.modeler.convert_to_selections(turns, True)):
                         turns = turns[:-num]
                     else:
                         new_element = [turns[0]] * num
                         turns.extend(new_element)
                 else:
-                    turns = ["1"] * len(sources)
+                    turns = ["1"] * len(assignment)
             else:
                 turns = self.modeler.convert_to_selections(turns, True)
-            if not return_path or len(sources) != len(self.modeler.convert_to_selections(return_path, True)):
-                return_path = ["infinite"] * len(sources)
+            if not return_path or len(assignment) != len(self.modeler.convert_to_selections(return_path, True)):
+                return_path = ["infinite"] * len(assignment)
             else:
                 return_path = self.modeler.convert_to_selections(return_path, True)
-            if any(item in return_path for item in sources):
+            if any(item in return_path for item in assignment):
                 self.logger.error("Return path specified must not be included in sources")
                 return False
 
             if group_sources and self.solution_type in ["EddyCurrent", "Magnetostatic"]:
                 props = OrderedDict(
                     {"MatrixEntry": OrderedDict({"MatrixEntry": []}), "MatrixGroup": OrderedDict({"MatrixGroup": []})}
                 )
             else:
                 props = OrderedDict({"MatrixEntry": OrderedDict({"MatrixEntry": []}), "MatrixGroup": []})
 
-            for element in range(len(sources)):
+            for element in range(len(assignment)):
                 if self.solution_type == "Magnetostatic" and self.design_type == "Maxwell 2D":
                     prop = OrderedDict(
                         {
-                            "Source": sources[element],
+                            "Source": assignment[element],
                             "NumberOfTurns": turns[element],
                             "ReturnPath": return_path[element],
                         }
                     )
                 elif self.solution_type == "EddyCurrent":
-                    prop = OrderedDict({"Source": sources[element], "ReturnPath": return_path[element]})
+                    prop = OrderedDict({"Source": assignment[element], "ReturnPath": return_path[element]})
                 else:
-                    prop = OrderedDict({"Source": sources[element], "NumberOfTurns": turns[element]})
+                    prop = OrderedDict({"Source": assignment[element], "NumberOfTurns": turns[element]})
                 props["MatrixEntry"]["MatrixEntry"].append(prop)
 
             if group_sources:
                 if self.solution_type in ["Electrostatic", "ACConduction", "DCConduction"]:
                     source_list = ",".join(group_sources)
                     props["GroundSources"] = source_list
                 else:
@@ -456,17 +458,17 @@
 
         if aedt_lib_dir:
             source_dir = aedt_lib_dir
         else:
             source_dir = self.pyaedt_dir
 
         if os.path.exists(ctl_file_path) and keep_modifications:
-            with open(ctl_file_path, "r") as fi:
+            with open_file(ctl_file_path, "r") as fi:
                 existing_data = fi.readlines()
-            with open(ctl_file_path, "w") as fo:
+            with open_file(ctl_file_path, "w") as fo:
                 first_line = True
                 for line in existing_data:
                     if first_line:
                         first_line = False
                         if python_interpreter:
                             fo.write("#!{0}\n".format(python_interpreter))
                     if line.startswith("work_dir"):
@@ -495,27 +497,31 @@
                 "",
                 "CallCtrlProgAfterLastStep:=",
                 True,
             ],
         )
         return True
 
-    @pyaedt_function_handler()
-    def eddy_effects_on(self, object_list, activate_eddy_effects=True, activate_displacement_current=True):
+    @pyaedt_function_handler(
+        object_list="assignment",
+        activate_eddy_effects="enable_eddy_effects",
+        activate_displacement_current="enable_displacement_current",
+    )
+    def eddy_effects_on(self, assignment, enable_eddy_effects=True, enable_displacement_current=True):
         """Assign eddy effects on a list of objects.
 
         For Eddy Current solvers only, you must specify the displacement current on the model objects.
 
         Parameters
         ----------
-        object_list : list, str
+        assignment : list, str
             List of objects to assign eddy effects to.
-        activate_eddy_effects : bool, optional
+        enable_eddy_effects : bool, optional
             Whether to activate eddy effects. The default is ``True``.
-        activate_displacement_current : bool, optional
+        enable_displacement_current : bool, optional
             Whether to activate the displacement current. The default is ``True``.
             Valid only for Eddy Current solvers.
 
         Returns
         -------
         bool
             ``True`` when successful and ``False`` when failed.
@@ -525,28 +531,28 @@
 
         >>> oModule.SetEddyEffect
         """
         solid_objects_names = self.get_all_conductors_names()
 
         EddyVector = ["NAME:EddyEffectVector"]
         if self.modeler._is3d:
-            if not activate_eddy_effects:
-                activate_displacement_current = False
+            if not enable_eddy_effects:
+                enable_displacement_current = False
             for obj in solid_objects_names:
                 if self.solution_type == "EddyCurrent":
-                    if obj in object_list:
+                    if obj in assignment:
                         EddyVector.append(
                             [
                                 "NAME:Data",
                                 "Object Name:=",
                                 obj,
                                 "Eddy Effect:=",
-                                activate_eddy_effects,
+                                enable_eddy_effects,
                                 "Displacement Current:=",
-                                activate_displacement_current,
+                                enable_displacement_current,
                             ]
                         )
                     else:
                         EddyVector.append(
                             [
                                 "NAME:Data",
                                 "Object Name:=",
@@ -554,44 +560,44 @@
                                 "Eddy Effect:=",
                                 bool(self.oboundary.GetEddyEffect(obj)),
                                 "Displacement Current:=",
                                 bool(self.oboundary.GetDisplacementCurrent(obj)),
                             ]
                         )
                 if self.solution_type == "Transient":
-                    if obj in object_list:
+                    if obj in assignment:
                         EddyVector.append(
                             [
                                 "NAME:Data",
                                 "Object Name:=",
                                 obj,
                                 "Eddy Effect:=",
-                                activate_eddy_effects,
+                                enable_eddy_effects,
                             ]
                         )
                     else:
                         EddyVector.append(
                             [
                                 "NAME:Data",
                                 "Object Name:=",
                                 obj,
                                 "Eddy Effect:=",
                                 bool(self.oboundary.GetEddyEffect(obj)),
                             ]
                         )
         else:
             for obj in solid_objects_names:
-                if obj in object_list:
+                if obj in assignment:
                     EddyVector.append(
                         [
                             "NAME:Data",
                             "Object Name:=",
                             obj,
                             "Eddy Effect:=",
-                            activate_eddy_effects,
+                            enable_eddy_effects,
                         ]
                     )
                 else:
                     EddyVector.append(
                         [
                             "NAME:Data",
                             "Object Name:=",
@@ -599,23 +605,23 @@
                             "Eddy Effect:=",
                             bool(self.oboundary.GetEddyEffect(obj)),
                         ]
                     )
         self.oboundary.SetEddyEffect(["NAME:Eddy Effect Setting", EddyVector])
         return True
 
-    @pyaedt_function_handler()
-    def setup_y_connection(self, windings_name=None):
-        """Setup the Y connection.
+    @pyaedt_function_handler(windings_name="assignment")
+    def setup_y_connection(self, assignment=None):
+        """Set up the Y connection.
 
         Parameters
         ----------
-        windings_name : list, optional
+        assignment : list, optional
             List of windings. For example, ``["PhaseA", "PhaseB", "PhaseC"]``.
-            The default value is ``None``, in which case the design has no Y connection.
+            The default is ``None``, in which case the design has no Y connection.
 
         Returns
         -------
         bool
             ``True`` when successful and ``False`` when failed.
 
         References
@@ -625,38 +631,39 @@
 
         Examples
         --------
         Set up the Y connection for three existing windings named ``PhaseA``, ``PhaseB``, and ``PhaseC``.
         This creates one ``YConnection`` group containing these three phases.
 
         >>> from pyaedt import Maxwell2d
-        >>> aedtapp = Maxwell2d("Motor_EM_R2019R3.aedt")
-        >>> aedtapp.set_active_design("Basis_Model_For_Test")
-        >>> aedtapp.setup_y_connection(["PhaseA", "PhaseB", "PhaseC"])
+        >>> m2d = Maxwell2d("Motor_EM_R2019R3.aedt")
+        >>> m2d.set_active_design("Basis_Model_For_Test")
+        >>> m2d.setup_y_connection(["PhaseA", "PhaseB", "PhaseC"])
+        >>> m2d.release_desktop(True, True)
         """
 
         if self.solution_type not in ["Transient"]:
             self.logger.error("Y connections only available for Transient solutions.")
             return False
 
-        if windings_name:
-            connection = ["NAME:YConnection", "Windings:=", ",".join(windings_name)]
-            windings = ["NAME:YConnection", connection]
-            self.oboundary.SetupYConnection(windings)
+        if assignment:
+            connection = ["NAME:YConnection", "Windings:=", ",".join(assignment)]
+            assignment = ["NAME:YConnection", connection]
+            self.oboundary.SetupYConnection(assignment)
         else:
             self.oboundary.SetupYConnection()
         return True
 
-    @pyaedt_function_handler()
-    def assign_current(self, object_list, amplitude=1, phase="0deg", solid=True, swap_direction=False, name=None):
+    @pyaedt_function_handler(object_list="assignment")
+    def assign_current(self, assignment, amplitude=1, phase="0deg", solid=True, swap_direction=False, name=None):
         """Assign the source of the current.
 
         Parameters
         ----------
-        object_list : list, str
+        assignment : list, str
             List of objects to assign the current source to.
         amplitude : float or str, optional
             Current amplitude. The default is ``1A``.
         phase : str, optional
             Current phase.
             The default is ``"0deg"``.
         solid : bool, optional
@@ -680,38 +687,39 @@
 
         >>> oModule.AssignCurrent
 
         Examples
         --------
 
         >>> from pyaedt import Maxwell3d
-        >>> app = pyaedt.Maxwell3d(solution_type="ElectroDCConduction")
-        >>> cylinder= app.modeler.create_cylinder("X", [0,0,0],10, 100, 250)
-        >>> current = app.assign_current(cylinder.top_face_x.id, amplitude= "2mA")
+        >>> m3d = Maxwell3d(solution_type="ElectroDCConduction")
+        >>> cylinder= m3d.modeler.create_cylinder("X", [0,0,0],10, 100, 250)
+        >>> current = m3d.assign_current(cylinder.top_face_x.id,amplitude="2mA")
+        >>> m3d.release_desktop(True, True)
         """
 
         if isinstance(amplitude, (int, float)):
             amplitude = str(amplitude) + "A"
 
         if not name:
             name = generate_unique_name("Current")
 
-        object_list = self.modeler.convert_to_selections(object_list, True)
+        assignment = self.modeler.convert_to_selections(assignment, True)
         if self.is3d:
-            if type(object_list[0]) is int:
+            if type(assignment[0]) is int:
                 props = OrderedDict(
                     {
-                        "Faces": object_list,
+                        "Faces": assignment,
                         "Current": amplitude,
                     }
                 )
             else:
                 props = OrderedDict(
                     {
-                        "Objects": object_list,
+                        "Objects": assignment,
                         "Current": amplitude,
                     }
                 )
             if self.solution_type not in [
                 "Magnetostatic",
                 "DCConduction",
                 "ElectricTransient",
@@ -719,29 +727,29 @@
                 "ElectroDCConduction",
             ]:
                 props["Phase"] = phase
             if self.solution_type not in ["DCConduction", "ElectricTransient", "ElectroDCConduction"]:
                 props["IsSolid"] = solid
             props["Point out of terminal"] = swap_direction
         else:
-            if type(object_list[0]) is str:
-                props = OrderedDict({"Objects": object_list, "Current": amplitude, "IsPositive": swap_direction})
+            if type(assignment[0]) is str:
+                props = OrderedDict({"Objects": assignment, "Current": amplitude, "IsPositive": swap_direction})
             else:
                 self.logger.warning("Input must be a 2D object.")
                 return False
         bound = BoundaryObject(self, name, props, "Current")
         if bound.create():
             self._boundaries[bound.name] = bound
             return bound
         return False
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(band_object="assignment")
     def assign_translate_motion(
         self,
-        band_object,
+        assignment,
         coordinate_system="Global",
         axis="Z",
         positive_movement=True,
         start_position=0,
         periodic_translate=True,
         negative_limit=0,
         positive_limit=0,
@@ -754,15 +762,15 @@
     ):
         """Assign a translation motion to an object container.
 
         For both rotational and translational problems, the band objects must always enclose all the moving objects.
 
         Parameters
         ----------
-        band_object : str
+        assignment : str
             Object container.
         coordinate_system : str, optional
             Coordinate system name. The default is ``"Global"``.
         axis : str or int, optional
             Coordinate system axis. The default is ``"Z"``.
             It can be a ``pyaedt.generic.constants.AXIS`` enumerator value.
         positive_movement : bool, optional
@@ -804,15 +812,15 @@
         ----------
 
         >>> oModule.AssignBand
         """
         assert self.solution_type == SOLUTIONS.Maxwell3d.Transient, "Motion applies only to the Transient setup."
         if not motion_name:
             motion_name = generate_unique_name("Motion")
-        object_list = self.modeler.convert_to_selections(band_object, True)
+        object_list = self.modeler.convert_to_selections(assignment, True)
         props = OrderedDict(
             {
                 "Move Type": "Translate",
                 "Coordinate System": coordinate_system,
                 "PostProcessing Coordinate System": coordinate_system,
                 "Axis": GeometryOperators.cs_axis_str(axis),
                 "Is Positive": positive_movement,
@@ -830,18 +838,18 @@
         )
         bound = BoundaryObject(self, motion_name, props, "Band")
         if bound.create():
             self._boundaries[bound.name] = bound
             return bound
         return False
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(band_object="assignment")
     def assign_rotate_motion(
         self,
-        band_object,
+        assignment,
         coordinate_system="Global",
         axis="Z",
         positive_movement=True,
         start_position=0,
         has_rotation_limits=True,
         negative_limit=0,
         positive_limit=360,
@@ -854,15 +862,15 @@
     ):
         """Assign a rotation motion to an object container.
 
         For both rotational and translational problems, the band objects must always enclose all the moving objects.
 
         Parameters
         ----------
-        band_object : str,
+        assignment : str,
             Object container.
         coordinate_system : str, optional
             Coordinate system name. The default is ``"Global"``.
         axis : str or int, optional
             Coordinate system axis. The default is ``"Z"``.
             It can be a ``pyaedt.generic.constants.AXIS`` enumerator value.
         positive_movement : bool, optional
@@ -902,15 +910,15 @@
         ----------
 
         >>> oModule.AssignBand
         """
         assert self.solution_type == SOLUTIONS.Maxwell3d.Transient, "Motion applies only to the Transient setup."
         names = list(self.omodelsetup.GetMotionSetupNames())
         motion_name = "MotionSetup" + str(len(names) + 1)
-        object_list = self.modeler.convert_to_selections(band_object, True)
+        object_list = self.modeler.convert_to_selections(assignment, True)
         props = OrderedDict(
             {
                 "Move Type": "Rotate",
                 "Coordinate System": coordinate_system,
                 "Axis": GeometryOperators.cs_axis_str(axis),
                 "Is Positive": positive_movement,
                 "InitPos": self._arg_with_units(start_position, "deg"),
@@ -928,21 +936,21 @@
         )
         bound = BoundaryObject(self, motion_name, props, "Band")
         if bound.create():
             self._boundaries[bound.name] = bound
             return bound
         return False
 
-    @pyaedt_function_handler()
-    def assign_voltage(self, face_list, amplitude=1, name=None):
-        """Assign a voltage source to a list of faces in Maxwell 3D or a list of Objects in Maxwell 2D.
+    @pyaedt_function_handler(face_list="assignment")
+    def assign_voltage(self, assignment, amplitude=1, name=None):
+        """Assign a voltage source to a list of faces in Maxwell 3D or a list of objects in Maxwell 2D.
 
         Parameters
         ----------
-        face_list : list
+        assignment : list
             List of faces or objects to assign a voltage source to.
         amplitude : float, optional
             Voltage amplitude in mV. The default is ``1``.
         name : str, optional
             Name of the boundary. The default is ``None``.
 
         Returns
@@ -957,41 +965,41 @@
         >>> oModule.AssignVoltage
         """
         if isinstance(amplitude, (int, float)):
             amplitude = str(amplitude) + "mV"
 
         if not name:
             name = generate_unique_name("Voltage")
-        face_list = self.modeler.convert_to_selections(face_list, True)
+        assignment = self.modeler.convert_to_selections(assignment, True)
 
         if self.design_type == "Maxwell 2D":
-            props = OrderedDict({"Objects": face_list, "Value": amplitude})
+            props = OrderedDict({"Objects": assignment, "Value": amplitude})
         else:
-            if len(face_list) == 1:
-                if isinstance(face_list[0], str) and face_list[0] in self.modeler.object_names:
-                    props = OrderedDict({"Objects": face_list, "Voltage": amplitude})
+            if len(assignment) == 1:
+                if isinstance(assignment[0], str) and assignment[0] in self.modeler.object_names:
+                    props = OrderedDict({"Objects": assignment, "Voltage": amplitude})
                 else:
-                    props = OrderedDict({"Faces": face_list, "Value": amplitude})
+                    props = OrderedDict({"Faces": assignment, "Value": amplitude})
             else:
-                props = OrderedDict({"Faces": face_list, "Voltage": amplitude})
+                props = OrderedDict({"Faces": assignment, "Voltage": amplitude})
         bound = BoundaryObject(self, name, props, "Voltage")
         if bound.create():
             self._boundaries[bound.name] = bound
             return bound
         return False
 
-    @pyaedt_function_handler()
-    def assign_voltage_drop(self, face_list, amplitude=1, swap_direction=False, name=None):
+    @pyaedt_function_handler(face_list="assignment")
+    def assign_voltage_drop(self, assignment, amplitude=1, swap_direction=False, name=None):
         """Assign a voltage drop across a list of faces to a specific value.
 
         The voltage drop applies only to sheet objects.
 
         Parameters
         ----------
-        face_list : list
+        assignment : list
             List of faces to assign a voltage drop to.
         amplitude : float, optional
             Voltage amplitude in mV. The default is ``1``.
         swap_direction : bool, optional
             Whether to swap the direction. The default value is ``False``.
         name : str, optional
             Name of the boundary. The default is ``None``.
@@ -1008,56 +1016,56 @@
         >>> oModule.AssignVoltageDrop
         """
         if isinstance(amplitude, (int, float)):
             amplitude = str(amplitude) + "mV"
 
         if not name:
             name = generate_unique_name("VoltageDrop")
-        face_list = self.modeler.convert_to_selections(face_list, True)
+        assignment = self.modeler.convert_to_selections(assignment, True)
 
-        props = OrderedDict({"Faces": face_list, "Voltage Drop": amplitude, "Point out of terminal": swap_direction})
+        props = OrderedDict({"Faces": assignment, "Voltage Drop": amplitude, "Point out of terminal": swap_direction})
         bound = BoundaryObject(self, name, props, "VoltageDrop")
         if bound.create():
             self._boundaries[bound.name] = bound
             return bound
         return False
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(coil_terminals="assignment", current_value="current", res="resistance", ind="inductance")
     def assign_winding(
         self,
-        coil_terminals=None,
+        assignment=None,
         winding_type="Current",
         is_solid=True,
-        current_value=1,
-        res=0,
-        ind=0,
+        current=1,
+        resistance=0,
+        inductance=0,
         voltage=0,
         parallel_branches=1,
         phase=0,
         name=None,
     ):
         """Assign a winding to a Maxwell design.
 
         Parameters
         ----------
-        coil_terminals : list, optional
+        assignment : list, optional
             List of faces to create the coil terminal on.
             The default is ``None``.
         winding_type : str, optional
             Type of the winding. Options are ``"Current"``, ``"Voltage"``,
             and ``"External"``. The default is ``"Current"``.
         is_solid : bool, optional
             Whether the winding is the solid type. The default is ``True``. If ``False``,
             the winding is the stranded type.
-        current_value : float, optional
+        current : float, optional
             Value of the current in amperes. The default is ``1``.
-        res : float, optional
+        resistance : float, optional
             Resistance in ohms. The default is ``0``.
-        ind : float, optional
-            Henry (H). The default is ``0``.
+        inductance : float, optional
+            Inductance in Henry (H). The default is ``0``.
         voltage : float, optional
             Voltage value. The default is ``0``.
         parallel_branches : int, optional
             Number of parallel branches. The default is ``1``.
         phase : float, optional
             Value of the phase delay in degrees. The default is ``0``.
         name : str, optional
@@ -1078,77 +1086,77 @@
         if not name:
             name = generate_unique_name("Winding")
 
         props = OrderedDict(
             {
                 "Type": winding_type,
                 "IsSolid": is_solid,
-                "Current": self.modeler._arg_with_dim(current_value, "A"),
-                "Resistance": self.modeler._arg_with_dim(res, "ohm"),
-                "Inductance": self.modeler._arg_with_dim(ind, "H"),
+                "Current": self.modeler._arg_with_dim(current, "A"),
+                "Resistance": self.modeler._arg_with_dim(resistance, "ohm"),
+                "Inductance": self.modeler._arg_with_dim(inductance, "H"),
                 "Voltage": self.modeler._arg_with_dim(voltage, "V"),
                 "ParallelBranchesNum": str(parallel_branches),
                 "Phase": self.modeler._arg_with_dim(phase, "deg"),
             }
         )
         bound = BoundaryObject(self, name, props, "Winding")
         if bound.create():
             self._boundaries[bound.name] = bound
-            if coil_terminals is None:
-                coil_terminals = []
-            if type(coil_terminals) is not list:
-                coil_terminals = [coil_terminals]
+            if assignment is None:
+                assignment = []
+            if type(assignment) is not list:
+                assignment = [assignment]
             coil_names = []
-            for coil in coil_terminals:
+            for coil in assignment:
                 c = self.assign_coil(coil)
                 if c:
                     coil_names.append(c.name)
 
             if coil_names:
                 self.add_winding_coils(bound.name, coil_names)
             return bound
         return False
 
-    @pyaedt_function_handler()
-    def add_winding_coils(self, windingname, coil_names):
+    @pyaedt_function_handler(windingname="assignment", coil_names="coils")
+    def add_winding_coils(self, assignment, coils):
         """Add coils to the winding.
 
         Parameters
         ----------
-        windingname : str
+        assignment : str
             Name of the winding.
-        coil_names : list
+        coils : list
             List of the coil names.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         References
         ----------
 
         >>> oModule.AddWindingTerminals
         >>> oModule.AddWindingCoils
         """
         if self.modeler._is3d:
-            self.oboundary.AddWindingTerminals(windingname, coil_names)
+            self.oboundary.AddWindingTerminals(assignment, coils)
         else:
-            self.oboundary.AddWindingCoils(windingname, coil_names)
+            self.oboundary.AddWindingCoils(assignment, coils)
         return True
 
-    @pyaedt_function_handler()
-    def assign_coil(self, input_object, conductor_number=1, polarity="Positive", name=None):
+    @pyaedt_function_handler(input_object="assignment", conductor_number="conductors_number")
+    def assign_coil(self, assignment, conductors_number=1, polarity="Positive", name=None):
         """Assign coils to a list of objects or face IDs.
 
         Parameters
         ----------
-        input_object : list
+        assignment : list
             List of objects or face IDs.
-        conductor_number : int, optional
+        conductors_number : int, optional
             Number of conductors. The default is ``1``.
         polarity : str, optional
             Type of the polarity. The default is ``"Positive"``.
         name : str, optional
             The default is ``None``.
 
         Returns
@@ -1163,64 +1171,64 @@
         >>> oModule.AssignCoil
         """
         if polarity.lower() == "positive":
             point = False
         else:
             point = True
 
-        input_object = self.modeler.convert_to_selections(input_object, True)
+        assignment = self.modeler.convert_to_selections(assignment, True)
 
         if not name:
             name = generate_unique_name("Coil")
 
-        if type(input_object[0]) is str:
+        if type(assignment[0]) is str:
             if self.modeler._is3d:
                 props2 = OrderedDict(
-                    {"Objects": input_object, "Conductor number": str(conductor_number), "Point out of terminal": point}
+                    {"Objects": assignment, "Conductor number": str(conductors_number), "Point out of terminal": point}
                 )
                 bound = BoundaryObject(self, name, props2, "CoilTerminal")
             else:
                 props2 = OrderedDict(
                     {
-                        "Objects": input_object,
-                        "Conductor number": str(conductor_number),
+                        "Objects": assignment,
+                        "Conductor number": str(conductors_number),
                         "PolarityType": polarity.lower(),
                     }
                 )
                 bound = BoundaryObject(self, name, props2, "Coil")
         else:
             if self.modeler._is3d:
                 props2 = OrderedDict(
-                    {"Faces": input_object, "Conductor number": str(conductor_number), "Point out of terminal": point}
+                    {"Faces": assignment, "Conductor number": str(conductors_number), "Point out of terminal": point}
                 )
                 bound = BoundaryObject(self, name, props2, "CoilTerminal")
 
             else:
                 self.logger.warning("Face Selection is not allowed in Maxwell 2D. Provide a 2D object.")
                 return False
         if bound.create():
             self._boundaries[bound.name] = bound
             return bound
         return False
 
-    @pyaedt_function_handler()
-    def assign_force(self, input_object, reference_cs="Global", is_virtual=True, force_name=None):
+    @pyaedt_function_handler(input_object="assignment", reference_cs="coordinate_system")
+    def assign_force(self, assignment, coordinate_system="Global", is_virtual=True, force_name=None):
         """Assign a force to one or more objects.
 
         Force assignment can be calculated based upon the solver type.
         For 3D solvers the available solution types are: ``Magnetostatic``,
         ``Electrostatic``, ``Eddy Current``, ``Transient`` and ``Electric Transient``.
         For 2D solvers the available solution types are: ``Magnetostatic``,
         ``Electrostatic``, ``Eddy Current`` and ``Transient``.
 
         Parameters
         ----------
-        input_object : str, list
+        assignment : str, list
             One or more objects to assign the force to.
-        reference_cs : str, optional
+        coordinate_system : str, optional
             Name of the reference coordinate system. The default is ``"Global"``.
         is_virtual : bool, optional
             Whether the force is virtual. The default is ``True.``
         force_name : str, optional
             Name of the force. The default is ``None``, in which case the default
             name is used.
 
@@ -1235,75 +1243,78 @@
         >>> oModule.AssignForce
 
         Examples
         --------
 
         Assign virtual force to a magnetic object:
 
+        >>> from pyaedt import Maxwell3d
+        >>> m3d = Maxwell3d()
         >>> iron_object = m3d.modeler.create_box([0, 0, 0], [2, 10, 10], name="iron")
         >>> magnet_object = m3d.modeler.create_box([10, 0, 0], [2, 10, 10], name="magnet")
         >>> m3d.assign_material(iron_object, "iron")
         >>> m3d.assign_material(magnet_object, "NdFe30")
-        >>> m3d.assign_force("iron", force_name="force_iron", is_virtual=True)
+        >>> m3d.assign_force("iron",is_virtual=True,force_name="force_iron")
 
         Assign Lorentz force to a conductor:
 
         >>> conductor1 = m3d.modeler.create_box([0, 0, 0], [1, 1, 10], name="conductor1")
         >>> conductor2 = m3d.modeler.create_box([10, 0, 0], [1, 1, 10], name="conductor2")
         >>> m3d.assign_material(conductor1, "copper")
         >>> m3d.assign_material(conductor2, "copper")
-        >>> m3d.assign_force("conductor1", force_name="force_copper", is_virtual=False) # conductor, use Lorentz force
+        >>> m3d.assign_force("conductor1",is_virtual=False,force_name="force_copper") # conductor, use Lorentz force
+        >>> m3d.release_desktop(True, True)
         """
         if self.solution_type not in ["ACConduction", "DCConduction"]:
-            input_object = self.modeler.convert_to_selections(input_object, True)
+            assignment = self.modeler.convert_to_selections(assignment, True)
             if not force_name:
                 force_name = generate_unique_name("Force")
             if self.design_type == "Maxwell 3D":
                 prop = OrderedDict(
                     {
                         "Name": force_name,
-                        "Reference CS": reference_cs,
+                        "Reference CS": coordinate_system,
                         "Is Virtual": is_virtual,
-                        "Objects": input_object,
+                        "Objects": assignment,
                     }
                 )
             else:
                 prop = OrderedDict(
                     {
                         "Name": force_name,
-                        "Reference CS": reference_cs,
-                        "Objects": input_object,
+                        "Reference CS": coordinate_system,
+                        "Objects": assignment,
                     }
                 )
 
             bound = MaxwellParameters(self, force_name, prop, "Force")
             if bound.create():
                 self._boundaries[bound.name] = bound
                 return bound
         else:
-            self.logger.error("Solution Type has not Matrix Parameter")
+            self.logger.error("Solution type has no 'Matrix' parameter.")
             return False
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(input_object="assignment", reference_cs="coordinate_system")
     def assign_torque(
-        self, input_object, reference_cs="Global", is_positive=True, is_virtual=True, axis="Z", torque_name=None
+        self, assignment, coordinate_system="Global", is_positive=True, is_virtual=True, axis="Z", torque_name=None
     ):
         """Assign a torque to one or more objects.
 
         Torque assignment can be calculated based upon the solver type.
         For 3D solvers the available solution types are: ``Magnetostatic``,
         ``Electrostatic``, ``Eddy Current``, ``Transient`` and ``Electric Transient``.
         For 2D solvers the available solution types are: ``Magnetostatic``,
         ``Electrostatic``, ``Eddy Current`` and ``Transient``.
 
         Parameters
         ----------
-        input_object : str or list
+        assignment : str or list
            One or more objects to assign the torque to.
-        reference_cs : str, optional
+        coordinate_system : str, optional
             Name of the reference coordinate system. The default is ``"Global"``.
         is_positive : bool, optional
             Whether the torque is positive. The default is ``True``.
         is_virtual : bool, optional
             Whether the torque is virtual. The default is ``True``.
         axis : str, optional
             Axis to apply the torque to. The default is ``"Z"``.
@@ -1320,35 +1331,35 @@
         ----------
 
         >>> oModule.AssignTorque
         """
         if self.solution_type not in ["ACConduction", "DCConduction"]:
             if self.solution_type == "Transient":
                 is_virtual = True
-            input_object = self.modeler.convert_to_selections(input_object, True)
+            assignment = self.modeler.convert_to_selections(assignment, True)
             if not torque_name:
                 torque_name = generate_unique_name("Torque")
             if self.design_type == "Maxwell 3D":
                 prop = OrderedDict(
                     {
                         "Name": torque_name,
                         "Is Virtual": is_virtual,
-                        "Coordinate System": reference_cs,
+                        "Coordinate System": coordinate_system,
                         "Axis": axis,
                         "Is Positive": is_positive,
-                        "Objects": input_object,
+                        "Objects": assignment,
                     }
                 )
             else:
                 prop = OrderedDict(
                     {
                         "Name": torque_name,
-                        "Coordinate System": reference_cs,
+                        "Coordinate System": coordinate_system,
                         "Is Positive": is_positive,
-                        "Objects": input_object,
+                        "Objects": assignment,
                     }
                 )
 
             bound = MaxwellParameters(self, torque_name, prop, "Torque")
             if bound.create():
                 self._boundaries[bound.name] = bound
                 return bound
@@ -1402,23 +1413,23 @@
         if self.solution_type != "Transient":
             self.logger.error("This methods work only with Maxwell Transient Analysis.")
             return False
         self.oanalysis.ResetSetupToTimeZero(self._setup)
         self.analyze()
         return True
 
-    @pyaedt_function_handler()
-    def set_initial_angle(self, motion_setup, val):
+    @pyaedt_function_handler(val="angle")
+    def set_initial_angle(self, motion_setup, angle):
         """Set the initial angle.
 
         Parameters
         ----------
         motion_setup : str
             Name of the motion setup.
-        val : float
+        angle : float
             Value of the angle in degrees.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
@@ -1429,30 +1440,30 @@
         """
         self.odesign.ChangeProperty(
             [
                 "NAME:AllTabs",
                 [
                     "NAME:Maxwell2D",
                     ["NAME:PropServers", "ModelSetup:" + motion_setup],
-                    ["NAME:ChangedProps", ["NAME:Initial Position", "Value:=", val]],
+                    ["NAME:ChangedProps", ["NAME:Initial Position", "Value:=", angle]],
                 ],
             ]
         )
         return True
 
-    @pyaedt_function_handler()
-    def assign_symmetry(self, entity_list, symmetry_name=None, is_odd=True):
+    @pyaedt_function_handler(entity_list="assignment")
+    def assign_symmetry(self, assignment, symmetry_name=None, is_odd=True):
         """Assign symmetry boundary.
 
         This boundary condition defines a plane of geometric or magnetic symmetry in a structure.
         Assign it only to the outer surfaces of the problem region.
 
         Parameters
         ----------
-        entity_list : list
+        assignment : list
             List IDs or :class:`pyaedt.modeler.Object3d.EdgePrimitive` or
             :class:`pyaedt.modeler.Object3d.FacePrimitive`.
         symmetry_name : str, optional
             Name of the symmetry.
         is_odd : bool, optional
             Type of the symmetry. The default is ``True`,` in which case the H field
             is tangential to the boundary. If ``False``, the H field is normal to
@@ -1468,53 +1479,57 @@
 
         >>> oModule.AssignSymmetry
         """
         try:
             if symmetry_name is None:
                 symmetry_name = generate_unique_name("Symmetry")
 
-            if entity_list:
+            if assignment:
                 if self.design_type == "Maxwell 2D":
-                    entity_list = self.modeler.convert_to_selections(entity_list, True)
-                    prop = OrderedDict({"Name": symmetry_name, "Edges": entity_list, "IsOdd": is_odd})
+                    assignment = self.modeler.convert_to_selections(assignment, True)
+                    prop = OrderedDict({"Name": symmetry_name, "Edges": assignment, "IsOdd": is_odd})
                 else:
-                    entity_list = self.modeler.convert_to_selections(entity_list, True)
-                    prop = OrderedDict({"Name": symmetry_name, "Faces": entity_list, "IsOdd": is_odd})
+                    assignment = self.modeler.convert_to_selections(assignment, True)
+                    prop = OrderedDict({"Name": symmetry_name, "Faces": assignment, "IsOdd": is_odd})
             else:
                 msg = "At least one edge must be provided."
                 ValueError(msg)
 
             bound = BoundaryObject(self, symmetry_name, prop, "Symmetry")
             if bound.create():
                 self._boundaries[bound.name] = bound
                 return bound
             return True
         except Exception:
             return False
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(
+        entities="assignment",
+        coordinate_system_name="coordinate_system",
+        coordinate_system_cartesian="coordinate_system_type",
+    )
     def assign_current_density(
         self,
-        entities,
+        assignment,
         current_density_name=None,
         phase="0deg",
         current_density_x="0",
         current_density_y="0",
         current_density_z="0",
         current_density_2d="0",
-        coordinate_system_name="Global",
-        coordinate_system_cartesian="Cartesian",
+        coordinate_system="Global",
+        coordinate_system_type="Cartesian",
     ):
         """Assign current density to a single or list of entities.
 
         This method specifies the x-, y-, and z-components of the current density in a conduction path.
 
         Parameters
         ----------
-        entities : list
+        assignment : list
             Objects to assign the current to.
         current_density_name : str, optional
             Current density name.
             If no name is provided a random name is generated.
         phase : str, optional
             Current density phase.
             Available units are 'deg', 'degmin', 'degsec' and 'rad'.
@@ -1527,18 +1542,18 @@
             Default value is 0 A/m2.
         current_density_z : str, optional
             Current density Z coordinate value.
             Default value is 0 A/m2.
         current_density_2d : str, optional
             Current density 2D value.
             Default value is 0 A/m2.
-        coordinate_system_name : str, optional
+        coordinate_system : str, optional
             Coordinate system name.
             Default value is 'Global'.
-        coordinate_system_cartesian : str, optional
+        coordinate_system_type : str, optional
             Coordinate system cartesian.
             Possible values can be ``"Cartesian"``, ``"Cylindrical"``, and ``"Spherical"``.
             Default value is ``"Cartesian"``.
 
         Returns
         -------
         bool
@@ -1546,19 +1561,19 @@
         """
         if self.solution_type in ["EddyCurrent", "Magnetostatic"]:
             if current_density_name is None:
                 current_density_name = generate_unique_name("CurrentDensity")
             if re.compile(r"(\d+)\s*(\w+)").match(phase).groups()[1] not in ["deg", "degmin", "degsec", "rad"]:
                 self.logger.error("Invalid phase unit.")
                 return False
-            if coordinate_system_cartesian not in ["Cartesian", "Cylindrical", "Spherical"]:
+            if coordinate_system_type not in ["Cartesian", "Cylindrical", "Spherical"]:
                 self.logger.error("Invalid coordinate system.")
                 return False
 
-            objects_list = self.modeler.convert_to_selections(entities, True)
+            objects_list = self.modeler.convert_to_selections(assignment, True)
 
             try:
                 if self.modeler._is3d:
                     if len(objects_list) > 1:
                         current_density_group_names = []
                         for x in range(0, len(objects_list)):
                             current_density_group_names.append(current_density_name + "_{}".format(str(x + 1)))
@@ -1567,29 +1582,29 @@
                         props[current_density_group_names[0]] = OrderedDict(
                             {
                                 "Objects": objects_list,
                                 "Phase": phase,
                                 "CurrentDensityX": current_density_x,
                                 "CurrentDensityY": current_density_y,
                                 "CurrentDensityZ": current_density_z,
-                                "CoordinateSystem Name": coordinate_system_name,
-                                "CoordinateSystem Type": coordinate_system_cartesian,
+                                "CoordinateSystem Name": coordinate_system,
+                                "CoordinateSystem Type": coordinate_system_type,
                             }
                         )
                         bound = BoundaryObject(self, current_density_group_names[0], props, "CurrentDensityGroup")
                     else:
                         props = OrderedDict(
                             {
                                 "Objects": objects_list,
                                 "Phase": phase,
                                 "CurrentDensityX": current_density_x,
                                 "CurrentDensityY": current_density_y,
                                 "CurrentDensityZ": current_density_z,
-                                "CoordinateSystem Name": coordinate_system_name,
-                                "CoordinateSystem Type": coordinate_system_cartesian,
+                                "CoordinateSystem Name": coordinate_system,
+                                "CoordinateSystem Type": coordinate_system_type,
                             }
                         )
                         bound = BoundaryObject(self, current_density_name, props, "CurrentDensity")
                 else:
                     if len(objects_list) > 1:
                         current_density_group_names = []
                         for x in range(0, len(objects_list)):
@@ -1623,26 +1638,26 @@
             except Exception:
                 self.logger.error("Couldn't assign current density to desired list of objects.")
                 return False
         else:
             self.logger.error("Current density can only be applied to Eddy current or magnetostatic solution types.")
             return False
 
-    @pyaedt_function_handler()
-    def assign_radiation(self, input_object, radiation_name=None):
+    @pyaedt_function_handler(input_object="assignment", radiation_name="radiation")
+    def assign_radiation(self, assignment, radiation=None):
         """Assign radiation boundary to one or more objects.
 
         Radiation assignment can be calculated based upon the solver type.
         Available solution type is: ``Eddy Current``.
 
         Parameters
         ----------
-        input_object : str, list
+        assignment : str, list
             One or more objects to assign the radiation to.
-        radiation_name : str, optional
+        radiation : str, optional
             Name of the force. The default is ``None``, in which case the default
             name is used.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject`
             Radiation objects. If the method fails to execute it returns ``False``.
@@ -1653,63 +1668,66 @@
         >>> oModule.Radiation
 
         Examples
         --------
 
         Assign radiation boundary to one box and one face:
 
+        >>> from pyaedt import Maxwell3d
+        >>> m3d = Maxwell3d()
         >>> box1 = m3d.modeler.create_box([0, 0, 0], [2, 10, 10])
         >>> box2 = m3d.modeler.create_box([10, 0, 0], [2, 10, 10])
-        >>> m3d.assign_radiation([box1, box2.faces[0]], force_name="radiation_boundary")
+        >>> m3d.assign_radiation([box1, box2.faces[0]])
+        >>> m3d.release_desktop(True, True)
         """
 
         if self.solution_type in ["EddyCurrent"]:
-            if not radiation_name:
-                radiation_name = generate_unique_name("Radiation")
-            elif radiation_name in self.modeler.get_boundaries_name():
-                radiation_name = generate_unique_name(radiation_name)
+            if not radiation:
+                radiation = generate_unique_name("Radiation")
+            elif radiation in self.modeler.get_boundaries_name():
+                radiation = generate_unique_name(radiation)
 
-            listobj = self.modeler.convert_to_selections(input_object, True)
+            listobj = self.modeler.convert_to_selections(assignment, True)
             props = {"Objects": [], "Faces": []}
             for sel in listobj:
                 if isinstance(sel, str):
                     props["Objects"].append(sel)
                 elif isinstance(sel, int):
                     props["Faces"].append(sel)
-            bound = BoundaryObject(self, radiation_name, props, "Radiation")
+            bound = BoundaryObject(self, radiation, props, "Radiation")
             if bound.create():
                 self._boundaries[bound.name] = bound
                 return bound
         self.logger.error("Excitation applicable only to Eddy current.")
         return False
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(objects="assignment")
     def enable_harmonic_force(
         self,
-        objects,
+        assignment,
         force_type=0,
         window_function="Rectangular",
         use_number_of_last_cycles=True,
         last_cycles_number=1,
         calculate_force="Harmonic",
     ):
         """Enable the harmonic force calculation for the transient analysis.
 
         Parameters
         ----------
-        objects : list
+        assignment : list
             List of object names for force calculations.
         force_type : int, optional
-            Force Type. ``0`` for Objects, ``1`` for Surface, ``2`` for volumetric.
+            Force type. Options are ``0`` for objects, ``1`` for surface, and ``2`` for volumetric.
         window_function : str, optional
             Windowing function. Default is ``"Rectangular"``.
             Available options are: ``"Rectangular"``, ``"Tri"``, ``"Van Hann"``, ``"Hamming"``,
             ``"Blackman"``, ``"Lanczos"``, ``"Welch"``.
         use_number_of_last_cycles : bool, optional
-            Use number Of last cycles for force calculations. Default is ``True``.
+            Use number of last cycles for force calculations. Default is ``True``.
         last_cycles_number : int, optional
             Defines the number of cycles to compute if `use_number_of_last_cycle` is ``True``.
         calculate_force : sr, optional
             How to calculate force. The default is ``"Harmonic"``.
             Options are ``"Harmonic"`` and ``"Transient"``.
 
 
@@ -1718,19 +1736,19 @@
         bool
             ``True`` when successful, ``False`` when failed.
 
         """
         if self.solution_type != "Transient":
             self.logger.error("This methods work only with Maxwell Transient Analysis.")
             return False
-        objects = self.modeler.convert_to_selections(objects, True)
+        assignment = self.modeler.convert_to_selections(assignment, True)
         self.odesign.EnableHarmonicForceCalculation(
             [
                 "EnabledObjects:=",
-                objects,
+                assignment,
                 "ForceType:=",
                 force_type,
                 "WindowFunctionType:=",
                 window_function,
                 "UseNumberOfLastCycles:=",
                 use_number_of_last_cycles,
                 "NumberOfLastCycles:=",
@@ -1747,18 +1765,18 @@
                 "Use All",
                 "CaculateForceType:=",
                 calculate_force + " Force",
             ]
         )
         return True
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(layout_component_name="assignment")
     def enable_harmonic_force_on_layout_component(
         self,
-        layout_component_name,
+        assignment,
         nets,
         force_type=0,
         window_function="Rectangular",
         use_number_of_last_cycles=True,
         last_cycles_number=1,
         calculate_force="Harmonic",
         start_time="0s",
@@ -1768,18 +1786,18 @@
         include_no_layer=True,
     ):
         # type: (str, dict, int, str,bool, int, str, str, str, bool, int, bool) -> bool
         """Enable the harmonic force calculation for the transient analysis.
 
         Parameters
         ----------
-        layout_component_name : str
-            Name of layout component to apply harmonic forces.
+        assignment : str
+            Name of layout component to apply harmonic forces to.
         nets : dict
-            Dictionary containing nets and layers on which enable harmonic forces.
+            Dictionary containing nets and layers to enable harmonic forces on.
         force_type : int, optional
             Force Type. ``0`` for Objects, ``1`` for Surface, ``2`` for volumetric.
         window_function : str, optional
             Windowing function. Default is ``"Rectangular"``.
             Available options are: ``"Rectangular"``, ``"Tri"``, ``"Van Hann"``, ``"Hamming"``,
             ``"Blackman"``, ``"Lanczos"``, ``"Welch"``.
         use_number_of_last_cycles : bool, optional
@@ -1831,45 +1849,45 @@
             "Use All",
             "CaculateForceType:=",
             calculate_force + " Force",
         ]
         args2 = [
             "NAME:NetsAndLayersChoices",
             [
-                "NAME:" + layout_component_name,
+                "NAME:" + assignment,
                 [
                     "NAME:NetLayerSetMap",
                 ],
             ],
         ]
         for net, layers in nets.items():
             if include_no_layer:
                 args2[1][1].append(["Name:" + net, "LayerSet:=", ["<no-layer>"] + layers])
             else:
                 args2[1][1].append(["Name:" + net, "LayerSet:=", layers])
         args.append(args2)
         self.odesign.EnableHarmonicForceCalculation(args)
         return True
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(setup_name="setup")
     def export_element_based_harmonic_force(
         self,
         output_directory=None,
-        setup_name=None,
+        setup=None,
         start_frequency=None,
         stop_frequency=None,
         number_of_frequency=None,
     ):
         """Export an element-based harmonic force data to a .csv file.
 
         Parameters
         ----------
         output_directory : str, optional
-            The path for the output directory. If ``None`` pyaedt working dir will be used.
-        setup_name : str, optional
+            Path for the output directory. If ``None`` pyaedt working dir will be used.
+        setup : str, optional
             Name of the solution setup. If ``None``, the nominal setup is used.
         start_frequency : float, optional
             When a float is entered the Start-Stop Frequency approach is used.
         stop_frequency : float, optional
             When a float is entered, the Start-Stop Frequency approach is used.
         number_of_frequency : int, optional
             When a number is entered, the number of frequencies approach is used.
@@ -1880,27 +1898,27 @@
             Path to the export directory.
         """
         if self.solution_type != "Transient" and self.solution_type != "TransientAPhiFormulation":
             self.logger.error("This methods work only with Maxwell Transient Analysis.")
             return False
         if not output_directory:
             output_directory = self.working_directory
-        if not setup_name:
-            setup_name = self.setups[0].name
+        if not setup:
+            setup = self.setups[0].name
         freq_option = 1
         f1 = -1
         f2 = -1
         if start_frequency and stop_frequency:
             freq_option = 2
             f1 = start_frequency
             f2 = stop_frequency
         elif number_of_frequency:
             freq_option = 3
             f1 = number_of_frequency
-        self.odesign.ExportElementBasedHarmonicForce(output_directory, setup_name, freq_option, f1, f2)
+        self.odesign.ExportElementBasedHarmonicForce(output_directory, setup, freq_option, f1, f2)
         return output_directory
 
     @pyaedt_function_handler
     def edit_external_circuit(self, netlist_file_path, schematic_design_name):
         """
         Edit the external circuit for the winding.
 
@@ -1942,30 +1960,31 @@
                 elif source_type == "POS":
                     sources_type_array.append(2)
                 elif source_type == "SPEED":
                     sources_type_array.append(3)
         self.oboundary.EditExternalCircuit(netlist_file_path, sources_array, sources_type_array, [], [])
         return True
 
-    @pyaedt_function_handler()
-    def create_setup(self, setupname="MySetupAuto", setuptype=None, **kwargs):
+    @pyaedt_function_handler(setupname="name", setuptype="setup_type")
+    def create_setup(self, name="MySetupAuto", setup_type=None, **kwargs):
         """Create an analysis setup for Maxwell 3D or 2D.
 
-        Optional arguments are passed along with ``setuptype`` and ``setupname``.
+        Optional arguments are passed using the ``setup_type`` and ``name``
+        parameters.
         Keyword names correspond to the ``setuptype`` corresponding to the native AEDT API.
         The list of keywords here is not exhaustive.
 
         Parameters
         ----------
-        setuptype : int, str, optional
+        setup_type : int, str, optional
             Type of the setup. Depending on the solution type, options are
             ``"AC Conduction"``, ``"DC Conduction"``, ``"EddyCurrent"``,
             ``"Electric Transient"``, ``"Electrostatic"``, ``"Magnetostatic"``,
             and ``Transient"``.
-        setupname : str, optional
+        name : str, optional
             Name of the setup. The default is ``"Setup1"``.
         **kwargs : dict, optional
             Available keys depend on the setup chosen.
             For more information, see :doc:`../SetupTemplatesMaxwell`.
 
         Returns
         -------
@@ -1975,26 +1994,26 @@
         References
         ----------
         >>> oModule.InsertSetup
 
         Examples
         --------
         >>> from pyaedt import Maxwell3d
-        >>> app = Maxwell3d()
-        >>> app.create_setup(setupname="My_Setup", setuptype="EddyCurrent", MaximumPasses=10, PercentError=2 )
-
+        >>> m3d = Maxwell3d()
+        >>> m3d.create_setup(name="My_Setup",setup_type="EddyCurrent",MaximumPasses=10,PercentError=2)
+        >>> m3d.release_desktop(True, True)
         """
-        if setuptype is None:
-            setuptype = self.design_solutions.default_setup
-        elif setuptype in SetupKeys.SetupNames:
-            setuptype = SetupKeys.SetupNames.index(setuptype)
+        if setup_type is None:
+            setup_type = self.design_solutions.default_setup
+        elif setup_type in SetupKeys.SetupNames:
+            setup_type = SetupKeys.SetupNames.index(setup_type)
         if "props" in kwargs:
-            return self._create_setup(setupname=setupname, setuptype=setuptype, props=kwargs["props"])
+            return self._create_setup(name=name, setup_type=setup_type, props=kwargs["props"])
         else:
-            setup = self._create_setup(setupname=setupname, setuptype=setuptype)
+            setup = self._create_setup(name=name, setup_type=setup_type)
         setup.auto_update = False
         for arg_name, arg_value in kwargs.items():
             if setup[arg_name] is not None:
                 setup[arg_name] = arg_value
         setup.auto_update = True
         setup.update()
         return setup
@@ -2060,21 +2079,21 @@
 
     Examples
     --------
     Create an instance of Maxwell 3D and open the specified
     project, which is named ``mymaxwell.aedt``.
 
     >>> from pyaedt import Maxwell3d
-    >>> aedtapp = Maxwell3d("mymaxwell.aedt")
+    >>> m3d = Maxwell3d("mymaxwell.aedt")
     PyAEDT INFO: Added design ...
 
-    Create an instance of Maxwell 3D using the 2023 R2 release and open
+    Create an instance of Maxwell 3D using the 2024 R1 release and open
     the specified project, which is named ``mymaxwell2.aedt``.
 
-    >>> aedtapp = Maxwell3d(specified_version="2023.2", projectname="mymaxwell2.aedt")
+    >>> m3d = Maxwell3d(specified_version="2024.1", projectname="mymaxwell2.aedt")
     PyAEDT INFO: Added design ...
 
     """
 
     @property  # for legacy purposes
     def dim(self):
         """Dimensions."""
@@ -2114,29 +2133,29 @@
             machine,
             port,
             aedt_process_id,
         )
         Maxwell.__init__(self)
 
     def _init_from_design(self, *args, **kwargs):
-        self.__init__(*args, **kwargs)
+        self.__init__(**kwargs)
 
-    @pyaedt_function_handler()
-    def assign_insulating(self, geometry_selection, insulation_name=None):
+    @pyaedt_function_handler(geometry_selection="assignment", insulation_name="insulation")
+    def assign_insulating(self, assignment, insulation=None):
         """Create an insulating boundary condition.
 
         This boundary condition is used to model very thin sheets of perfectly insulating material between
         touching conductors. Current cannot cross an insulating boundary.
 
         Parameters
         ----------
-        geometry_selection : str or int
+        assignment : str or int
             Objects or faces to apply the insulating boundary to.
-        insulation_name : str, optional
-            Name of the insulation. The default is ``None`` in which case a unique name is chosen.
+        insulation : str, optional
+            Name of the insulation. The default is ``None``, in which case a unique name is assigned.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject`
             Boundary object if successful, ``False`` otherwise.
 
         References
@@ -2145,73 +2164,75 @@
         >>> oModule.AssignInsulating
 
         Examples
         --------
 
         Create a box and assign insulating boundary to it.
 
-        >>> insulated_box = maxwell3d_app.modeler.create_box([50, 0, 50], [294, 294, 19], name="InsulatedBox")
-        >>> insulating_assignment = maxwell3d_app.assign_insulating(insulated_box, "InsulatingExample")
-        >>> type(insulating_assignment)
+        >>> from pyaedt import Maxwell3d
+        >>> m3d = Maxwell3d()
+        >>> insulated_box = m3d.modeler.create_box([50, 0, 50], [294, 294, 19], name="InsulatedBox")
+        >>> insulating_assignment = m3d.assign_insulating(assignment=insulated_box,insulation="InsulatingExample")
+        >>> m3d.release_desktop(True, True)
         """
 
         if self.solution_type in [
             "EddyCurrent",
             "Transient",
             "TransientAPhiFormulation",
             "DCConduction",
             "ElectroDCConduction",
         ]:
-            if not insulation_name:
-                insulation_name = generate_unique_name("Insulation")
-            elif insulation_name in self.modeler.get_boundaries_name():
-                insulation_name = generate_unique_name(insulation_name)
+            if not insulation:
+                insulation = generate_unique_name("Insulation")
+            elif insulation in self.modeler.get_boundaries_name():
+                insulation = generate_unique_name(insulation)
 
-            listobj = self.modeler.convert_to_selections(geometry_selection, True)
+            listobj = self.modeler.convert_to_selections(assignment, True)
             props = {"Objects": [], "Faces": []}
             for sel in listobj:
                 if isinstance(sel, str):
                     props["Objects"].append(sel)
                 elif isinstance(sel, int):
                     props["Faces"].append(sel)
 
-            return self._create_boundary(insulation_name, props, "Insulating")
+            return self._create_boundary(insulation, props, "Insulating")
         return False
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(geometry_selection="assignment", impedance_name="impedance")
     def assign_impedance(
         self,
-        geometry_selection,
+        assignment,
         material_name=None,
         permeability=0.0,
         conductivity=None,
         non_linear_permeability=False,
-        impedance_name=None,
+        impedance=None,
     ):
         """Create an impedance boundary condition for Transient or Eddy Current solvers.
 
         This boundary condition is used to simulate the effect of induced currents in a conductor without
         explicitly computing them.
 
         Parameters
         ----------
-        geometry_selection : str
+        assignment : str
             Faces or objects to apply the impedance boundary to.
         material_name : str, optional
-            If it is different from ``None``, then material properties values will be extracted from
-            the named material in the list of materials available. The default value is ``None``.
+            Material name. The default is ``None``. If other than ``None``, material properties values are extracted
+            from the named material in the list of materials available. The default value is ``None``.
         permeability : float, optional
             Permeability of the material.The default value is ``0.0``.
         conductivity : float, optional
             Conductivity of the material. The default value is ``None``.
         non_linear_permeability : bool, optional
             If the option ``material_name`` is activated, the permeability can either be linear or not.
             The default value is ``False``.
-        impedance_name : str, optional
-            Name of the impedance. The default is ``None`` in which case a unique name is chosen.
+        impedance : str, optional
+            Name of the impedance. The default is ``None``, in which case a unique name is assigned.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject`
             Boundary object if successful, ``False`` otherwise.
 
         References
@@ -2220,32 +2241,32 @@
         >>> oModule.AssignImpedance
 
         Examples
         --------
 
         Create a box and assign impedance boundary to the faces.
 
+        >>> from pyaedt import Maxwell3d
+        >>> m3d = Maxwell3d()
         >>> shield = m3d.modeler.create_box([-50, -50, -50], [294, 294, 19], name="shield")
         >>> shield_faces = m3d.modeler.select_allfaces_fromobjects(["shield"])
-        >>> impedance_assignment = m3d.assign_impedance(shield_faces, "ShieldImpedance")
-
-        <class 'pyaedt.modules.Boundary.BoundaryObject'>
-
+        >>> impedance_assignment = m3d.assign_impedance(assignment=shield_faces,impedance="ShieldImpedance")
+        >>> m3d.release_desktop(True, True)
         """
 
         if self.solution_type in [
             "EddyCurrent",
             "Transient",
         ]:
-            if not impedance_name:
-                impedance_name = generate_unique_name("Impedance")
-            elif impedance_name in self.modeler.get_boundaries_name():
-                impedance_name = generate_unique_name(impedance_name)
+            if not impedance:
+                impedance = generate_unique_name("Impedance")
+            elif impedance in self.modeler.get_boundaries_name():
+                impedance = generate_unique_name(impedance)
 
-            listobj = self.modeler.convert_to_selections(geometry_selection, True)
+            listobj = self.modeler.convert_to_selections(assignment, True)
             props = {"Objects": [], "Faces": []}
             for sel in listobj:
                 if isinstance(sel, str):
                     props["Objects"].append(sel)
                 elif isinstance(sel, int):
                     props["Faces"].append(sel)
 
@@ -2256,39 +2277,39 @@
                 if conductivity is not None:
                     props["Conductivity"] = conductivity
             else:
                 props["UseMaterial"] = False
                 props["Permeability"] = permeability
                 props["Conductivity"] = conductivity
 
-            return self._create_boundary(impedance_name, props, "Impedance")
+            return self._create_boundary(impedance, props, "Impedance")
         return False
 
-    @pyaedt_function_handler()
-    def assign_current_density_terminal(self, entities, current_density_name=None):
+    @pyaedt_function_handler(entities="assignment")
+    def assign_current_density_terminal(self, assignment, current_density_name=None):
         """Assign current density terminal to a single or list of entities for an Eddy Current or Magnetostatic solver.
 
         Parameters
         ----------
-        entities : list
+        assignment : list
             Objects to assign the current to.
         current_density_name : str, optional
             Current density name.
             If no name is provided a random name is generated.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
         """
         if self.solution_type in ["EddyCurrent", "Magnetostatic"]:
             if current_density_name is None:
                 current_density_name = generate_unique_name("CurrentDensity")
 
-            objects_list = self.modeler.convert_to_selections(entities, True)
+            objects_list = self.modeler.convert_to_selections(assignment, True)
 
             existing_2d_objects_list = [x.name for x in self.modeler.object_list if not x.is3d]
             if [x for x in objects_list if x not in existing_2d_objects_list]:
                 self.logger.error("Entity provided not a planar entity.")
                 return False
 
             try:
@@ -2360,35 +2381,35 @@
             paths = list(self.oboundary.GetConductionPaths())
             for path in paths:
                 conduction_paths[path] = list(self.oboundary.GetConductionPathObjects(path))
             return conduction_paths
         except Exception:
             return conduction_paths
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(master_entity="independent", slave_entity="dependent")
     def assign_master_slave(
         self,
-        master_entity,
-        slave_entity,
+        independent,
+        dependent,
         u_vector_origin_coordinates_master,
         u_vector_pos_coordinates_master,
         u_vector_origin_coordinates_slave,
         u_vector_pos_coordinates_slave,
         reverse_master=False,
         reverse_slave=False,
         same_as_master=True,
         bound_name=None,
     ):
         """Assign dependent and independent boundary conditions to two faces of the same object.
 
         Parameters
         ----------
-        master_entity : int
+        independent : int
             ID of the master entity.
-        slave_entity : int
+        dependent : int
             ID of the slave entity.
         u_vector_origin_coordinates_master : list
             Master's list of U vector origin coordinates.
         u_vector_pos_coordinates_master : list
             Master's list of U vector position coordinates.
         u_vector_origin_coordinates_slave : list
             Slave's list of U vector origin coordinates.
@@ -2412,16 +2433,16 @@
         References
         ----------
 
         >>> oModule.AssignIndependent
         >>> oModule.AssignDependent
         """
         try:
-            master_entity = self.modeler.convert_to_selections(master_entity, True)
-            slave_entity = self.modeler.convert_to_selections(slave_entity, True)
+            independent = self.modeler.convert_to_selections(independent, True)
+            dependent = self.modeler.convert_to_selections(dependent, True)
             if not bound_name:
                 bound_name_m = generate_unique_name("Independent")
                 bound_name_s = generate_unique_name("Dependent")
             else:
                 bound_name_m = bound_name
                 bound_name_s = bound_name + "_dep"
             if (
@@ -2451,15 +2472,15 @@
                 {
                     "Coordinate System": "Global",
                     "Origin": u_vector_origin_coordinates_master,
                     "UPos": u_vector_pos_coordinates_master,
                 }
             )
             props2 = OrderedDict(
-                {"Faces": master_entity, "CoordSysVector": u_master_vector_coordinates, "ReverseV": reverse_master}
+                {"Faces": independent, "CoordSysVector": u_master_vector_coordinates, "ReverseV": reverse_master}
             )
             bound = BoundaryObject(self, bound_name_m, props2, "Independent")
             if bound.create():
                 self._boundaries[bound.name] = bound
 
                 u_slave_vector_coordinates = OrderedDict(
                     {
@@ -2467,15 +2488,15 @@
                         "Origin": u_vector_origin_coordinates_slave,
                         "UPos": u_vector_pos_coordinates_slave,
                     }
                 )
 
                 props2 = OrderedDict(
                     {
-                        "Faces": slave_entity,
+                        "Faces": dependent,
                         "CoordSysVector": u_slave_vector_coordinates,
                         "ReverseU": reverse_slave,
                         "Independent": bound_name_m,
                         "RelationIsSame": same_as_master,
                     }
                 )
                 bound2 = BoundaryObject(self, bound_name_s, props2, "Dependent")
@@ -2483,22 +2504,22 @@
                     self._boundaries[bound2.name] = bound2
                     return bound, bound2
                 else:
                     return bound, False
         except Exception:
             return False, False
 
-    @pyaedt_function_handler
-    def assign_flux_tangential(self, objects_list, flux_name=None):
+    @pyaedt_function_handler(objects_list="assignment")
+    def assign_flux_tangential(self, assignment, flux_name=None):
         # type : (list, str = None) -> pyaedt.modules.Boundary.BoundaryObject
         """Assign a flux tangential boundary for a transient A-Phi solver.
 
         Parameters
         ----------
-        objects_list : list
+        assignment : list
             List of objects to assign the flux tangential boundary condition to.
         flux_name : str, optional
             Name of the flux tangential boundary. The default is ``None``,
             in which case a random name is automatically generated.
 
         Returns
         -------
@@ -2511,52 +2532,55 @@
         >>> oModule.AssignFluxTangential
 
         Examples
         --------
 
         Create a box and assign a flux tangential boundary to one of its faces.
 
-        >>> box = maxwell3d_app.modeler.create_box([50, 0, 50], [294, 294, 19], name="Box")
-        >>> flux_tangential = maxwell3d_app.assign_flux_tangential(box.faces[0], "FluxExample")
+        >>> from pyaedt import Maxwell3d
+        >>> m3d = Maxwell3d()
+        >>> box = m3d.modeler.create_box([50, 0, 50], [294, 294, 19], name="Box")
+        >>> flux_tangential = m3d.assign_flux_tangential(box.faces[0],"FluxExample")
+        >>> m3d.release_desktop(True, True)
         """
         if self.solution_type != "TransientAPhiFormulation":
             self.logger.error("Flux tangential boundary can only be assigned to a transient APhi solution type.")
             return False
 
-        objects_list = self.modeler.convert_to_selections(objects_list, True)
+        assignment = self.modeler.convert_to_selections(assignment, True)
 
         if not flux_name:
             flux_name = generate_unique_name("FluxTangential")
         elif flux_name in self.modeler.get_boundaries_name():
             flux_name = generate_unique_name(flux_name)
 
         props = {"NAME": flux_name, "Faces": []}
-        for sel in objects_list:
+        for sel in assignment:
             props["Faces"].append(sel)
 
         return self._create_boundary(flux_name, props, "FluxTangential")
 
-    @pyaedt_function_handler
+    @pyaedt_function_handler(nets_layers_mapping="net_layers", reference_cs="coordinate_system")
     def assign_layout_force(
-        self, nets_layers_mapping, component_name, reference_cs="Global", force_name=None, include_no_layer=True
+        self, net_layers, component_name, coordinate_system="Global", force_name=None, include_no_layer=True
     ):
         # type: (dict, str, str, str, bool) -> bool
         """Assign the layout force to a component in a Transient A-Phi solver.
         To access layout component features the Beta option has to be enabled first.
 
         Parameters
         ----------
-        nets_layers_mapping : dict
-            Each <layer, net> pair represents the object(s) in the intersection of corresponding layer and net.
-            Net name is dictionary's key, layers name is the list of layer names.
+        net_layers : dict
+            Each <net, layer> pair represents the objects in the intersection of the corresponding net and layer.
+            The layer name is from the list of layer names. The net name is the dictionary's key.
         component_name : str
-            Name of the 3d component to assign the layout force to.
-        reference_cs : str, optional
+            Name of the 3D component to assign the layout force to.
+        coordinate_system : str, optional
             Reference coordinate system.
-            If not provided the global one will be set.
+            If not provided, the global one is used.
         force_name : str, optional
             Name of the layout force.
             If not provided a random name will be generated.
         include_no_layer : bool, optional
             Whether to include ``"<no-layer>"`` layer or not (used for vias). Default is ``True``.
 
         Returns
@@ -2569,76 +2593,78 @@
 
         >>> oModule.AssignLayoutForce
 
         Examples
         --------
 
         Create a dictionary to give as an input to assign_layout_force method.
-        >>> nets_layers = {}
-        >>> nets_layers["<no-net>"] = ["PWR","TOP","UNNAMED_000","UNNAMED_002"]
-        >>> nets_layers["GND"] = ["LYR_1","LYR_2","UNNAMED_006"]
+        >>> nets_layers = {"<no-net>": ["PWR","TOP","UNNAMED_000","UNNAMED_002"],
+        >>>                "GND": ["LYR_1","LYR_2","UNNAMED_006"]}
+        >>>
 
         Assign layout force to a component.
+        >>> from pyaedt import Maxwell3d
         >>> m3d = Maxwell3d()
-        >>> m3d.assign_layout_force(nets_layers_mapping=nets_layers, component_name="LC1_1")
+        >>> m3d.assign_layout_force(net_layers=nets_layers,component_name="LC1_1")
+        >>> m3d.release_desktop(True, True)
         """
 
-        for key in nets_layers_mapping.keys():
-            if not isinstance(nets_layers_mapping[key], list):
-                nets_layers_mapping[key] = list(nets_layers_mapping[key])
+        for key in net_layers.keys():
+            if not isinstance(net_layers[key], list):
+                net_layers[key] = list(net_layers[key])
 
         if component_name not in self.modeler.user_defined_component_names:
             self.logger.error("Provided component name doesn't exist in current design.")
             return False
 
         if not force_name:
             force_name = generate_unique_name("Layout_Force")
 
         nets_layers_props = None
-        for key, valy in nets_layers_mapping.items():
+        for key, valy in net_layers.items():
             layers = valy[:]
             if include_no_layer:
                 layers = layers[:] + ["<no-layer>"]
             if nets_layers_props:
                 nets_layers_props.append(OrderedDict({key: OrderedDict({"LayerSet": layers})}))
             else:
                 nets_layers_props = [OrderedDict({key: OrderedDict({"LayerSet": layers})})]
 
         props = OrderedDict(
             {
-                "Reference CS": reference_cs,
+                "Reference CS": coordinate_system,
                 "NetsAndLayersChoices": OrderedDict(
                     {component_name: OrderedDict({"NetLayerSetMap": nets_layers_props})}
                 ),
             }
         )
         bound = MaxwellParameters(self, force_name, props, "LayoutForce")
         if bound.create():
             self._boundaries[bound.name] = bound
             return bound
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(faces="assignment")
     def assign_tangential_h_field(
         self,
-        faces,
+        assignment,
         x_component_real=0,
         x_component_imag=0,
         y_component_real=0,
         y_component_imag=0,
         coordinate_system="Global",
         origin=None,
         u_pos=None,
         reverse=False,
         bound_name=None,
     ):
         """Assign a tangential H field boundary to a list of faces.
 
         Parameters
         ----------
-        faces : list of int  or :class:`pyaedt.modeler.cad.object3d.Object3d`
+        assignment : list of int  or :class:`pyaedt.modeler.cad.object3d.Object3d`
             List of objects to assign an end connection to.
         x_component_real : float, str, optional
             X component value real part. The default is ``0``.
         x_component_imag : float, str, optional
             X component value imaginary part. The default is ``0``.
         y_component_real : float, str, optional
             Y component value real part. The default is ``0``.
@@ -2667,57 +2693,57 @@
         ----------
 
         >>> oModule.AssignTangentialHField
         """
         if self.solution_type not in ["EddyCurrent", "Magnetostatic"]:
             self.logger.error("Tangential H Field is applicable only to Eddy current.")
             return False
-        objects = self.modeler.convert_to_selections(faces, True)
+        assignment = self.modeler.convert_to_selections(assignment, True)
         if not bound_name:
             bound_name = generate_unique_name("TangentialHField")
         props = OrderedDict(
             {
-                "Faces": objects,
+                "Faces": assignment,
             }
         )
-        if isinstance(objects[0], str):
+        if isinstance(assignment[0], str):
             props = OrderedDict(
                 {
-                    "Objects": objects,
+                    "Objects": assignment,
                 }
             )
         props["ComponentXReal"] = x_component_real
         if self.solution_type == "EddyCurrent":
             props["ComponentXImag"] = x_component_imag
         props["ComponentYReal"] = y_component_real
         if self.solution_type == "EddyCurrent":
             props["ComponentYImag"] = y_component_imag
-        if not origin and isinstance(objects[0], int):
-            edges = self.modeler.get_face_edges(objects[0])
+        if not origin and isinstance(assignment[0], int):
+            edges = self.modeler.get_face_edges(assignment[0])
             origin = self.oeditor.GetEdgePositionAtNormalizedParameter(edges[0], 0)
             if not u_pos:
                 u_pos = self.oeditor.GetEdgePositionAtNormalizedParameter(edges[0], 1)
 
         props["CoordSysVector"] = OrderedDict({"Coordinate System": coordinate_system, "Origin": origin, "UPos": u_pos})
         props["ReverseV"] = reverse
         bound = BoundaryObject(self, bound_name, props, "Tangential H Field")
         if bound.create():
             self._boundaries[bound.name] = bound
             return bound
         return False
 
-    @pyaedt_function_handler()
-    def assign_zero_tangential_h_field(self, faces, bound_name=None):
+    @pyaedt_function_handler(faces="assignment", bound_name="boundary")
+    def assign_zero_tangential_h_field(self, assignment, boundary=None):
         """Assign a zero tangential H field boundary to a list of faces.
 
         Parameters
         ----------
-        faces : list of int or :class:`pyaedt.modeler.cad.object3d.Object3d`
+        assignment : list of int or :class:`pyaedt.modeler.cad.object3d.Object3d`
             List of objects to assign an end connection to.
-        bound_name : str, optional
+        boundary : str, optional
             Name of the end connection boundary. The default is ``None``, in which case the
             default name is used.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject`
             Newly created object. ``False`` if it fails.
@@ -2726,23 +2752,23 @@
         ----------
 
         >>> oModule.AssignZeroTangentialHField
         """
         if self.solution_type not in ["EddyCurrent"]:
             self.logger.error("Tangential H Field is applicable only to Eddy current.")
             return False
-        objects = self.modeler.convert_to_selections(faces, True)
-        if not bound_name:
-            bound_name = generate_unique_name("ZeroTangentialHField")
+        assignment = self.modeler.convert_to_selections(assignment, True)
+        if not boundary:
+            boundary = generate_unique_name("ZeroTangentialHField")
         props = OrderedDict(
             {
-                "Faces": objects,
+                "Faces": assignment,
             }
         )
-        bound = BoundaryObject(self, bound_name, props, "Zero Tangential H Field")
+        bound = BoundaryObject(self, boundary, props, "Zero Tangential H Field")
         if bound.create():
             self._boundaries[bound.name] = bound
             return bound
         return False
 
 
 class Maxwell2d(Maxwell, FieldAnalysis3D, object):
@@ -2804,26 +2830,26 @@
     Examples
     --------
     Create an instance of Maxwell 2D and connect to an existing
     Maxwell 2D design or create a new Maxwell 2D design if one does
     not exist.
 
     >>> from pyaedt import Maxwell2d
-    >>> aedtapp = Maxwell2d()
+    >>> m2d = Maxwell2d()
 
     Create an instance of Maxwell 2D and link to a project named
     ``projectname``. If this project does not exist, create one with
     this name.
 
-    >>> aedtapp = Maxwell2d(projectname)
+    >>> m2d = Maxwell2d(projectname)
 
     Create an instance of Maxwell 2D and link to a design named
     ``designname`` in a project named ``projectname``.
 
-    >>> aedtapp = Maxwell2d(projectname,designame)
+    >>> m2d = Maxwell2d(projectname,designname)
 
     """
 
     @property  # for legacy purposes
     def dim(self):
         """Dimensions."""
         return self.modeler.dimension
@@ -2869,15 +2895,15 @@
             machine,
             port,
             aedt_process_id,
         )
         Maxwell.__init__(self)
 
     def _init_from_design(self, *args, **kwargs):
-        self.__init__(*args, **kwargs)
+        self.__init__(**kwargs)
 
     @property
     def xy_plane(self):
         """Maxwell 2D plane between ``True`` and ``False``."""
         return self.design_solutions.xy_plane
 
     @xy_plane.setter
@@ -2897,23 +2923,23 @@
     @model_depth.setter
     def model_depth(self, value):
         """Set model depth."""
         if isinstance(value, float) or isinstance(value, int):
             value = self.modeler._arg_with_dim(value, self.modeler.model_units)
         self.change_design_settings({"ModelDepth": value})
 
-    @pyaedt_function_handler()
-    def generate_design_data(self, linefilter=None, objectfilter=None):
-        """Generate a generic set of design data and store it in the extension directory as ``design_data.json``.
+    @pyaedt_function_handler(linefilter="line_filter", objectfilter="object_filter")
+    def generate_design_data(self, line_filter=None, object_filter=None):
+        """Generate a generic set of design data and store it in the extension directory in a ``design_data.json`` file.
 
         Parameters
         ----------
-        linefilter : optional
+        line_filter : optional
             The default is ``None``.
-        objectfilter : optional
+        object_filter : optional
             The default is ``None``.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
@@ -2925,29 +2951,29 @@
             if isinstance(obj, (list, tuple)):
                 return [convert(item) for item in obj]
             if isinstance(obj, dict):
                 return {convert(key): convert(value) for key, value in obj.items()}
             return obj
 
         solid_bodies = self.modeler.solid_bodies
-        if objectfilter:
-            solid_ids = [i for i, j in self.modeler._object_names_to_ids.items() if j.name in objectfilter]
+        if object_filter:
+            solid_ids = [i for i, j in self.modeler._object_names_to_ids.items() if j.name in object_filter]
         else:
             solid_ids = [i for i in list(self.modeler._object_names_to_ids.keys())]
         self.design_data = {
             "Project Directory": self.project_path,
             "Working Directory": self.working_directory,
             "Library Directories": self.library_list,
             "Dimension": self.modeler.dimension,
             "GeoMode": self.geometry_mode,
             "ModelUnits": self.modeler.model_units,
             "Symmetry": self.symmetry_multiplier,
             "ModelDepth": self.model_depth,
             "ObjectList": solid_ids,
-            "LineList": self.modeler.vertex_data_of_lines(linefilter),
+            "LineList": self.modeler.vertex_data_of_lines(line_filter),
             "VarList": self.variable_manager.variable_names,
             "Setups": self.existing_analysis_setups,
             "MaterialProperties": self.get_object_material_properties(solid_bodies),
         }
 
         design_file = os.path.join(self.working_directory, "design_data.json")
         write_configuration_file(self.design_data, design_file)
@@ -2962,166 +2988,166 @@
         dict
             Dictionary of design data.
 
         """
         design_file = os.path.join(self.working_directory, "design_data.json")
         return read_configuration_file(design_file)
 
-    @pyaedt_function_handler()
-    def assign_balloon(self, edge_list, bound_name=None):
+    @pyaedt_function_handler(edge_list="assignment", bound_name="boundary")
+    def assign_balloon(self, assignment, boundary=None):
         """Assign a balloon boundary to a list of edges.
 
         Parameters
         ----------
-        edge_list : list
+        assignment : list
             List of edges.
-        bound_name : str, optional
+        boundary : str, optional
             Name of the boundary. The default is ``None``, in which
             case the default name is used.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject`
             Boundary object. If the method fails to execute it returns ``False``.
 
         References
         ----------
 
         >>> oModule.AssignBalloon
         """
-        edge_list = self.modeler.convert_to_selections(edge_list, True)
+        assignment = self.modeler.convert_to_selections(assignment, True)
 
-        if not bound_name:
-            bound_name = generate_unique_name("Balloon")
+        if not boundary:
+            boundary = generate_unique_name("Balloon")
 
-        props2 = OrderedDict({"Edges": edge_list})
-        bound = BoundaryObject(self, bound_name, props2, "Balloon")
+        props2 = OrderedDict({"Edges": assignment})
+        bound = BoundaryObject(self, boundary, props2, "Balloon")
 
         if bound.create():
             self._boundaries[bound.name] = bound
             return bound
         return False
 
-    @pyaedt_function_handler()
-    def assign_vector_potential(self, input_edge, vectorvalue=0, bound_name=None):
+    @pyaedt_function_handler(input_edge="assignment", vectorvalue="vector_value", bound_name="boundary")
+    def assign_vector_potential(self, assignment, vector_value=0, boundary=None):
         """Assign a vector potential boundary condition to specified edges.
 
         This method is valid for Maxwell 2D Eddy Current, Magnetostatic, and Transient solvers.
 
         Parameters
         ----------
-        input_edge : list
+        assignment : list
             List of edge names or edge IDs to assign a vector to.
-        vectorvalue : float, optional
+        vector_value : float, optional
             Value of the vector. The default is ``0``.
-        bound_name : str, optional
+        boundary : str, optional
             Name of the boundary. The default is ``None``, in which
             case the default name is used.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject`
             Vector Potential Object. ``False`` if it fails.
 
         References
         ----------
 
         >>> oModule.AssignVectorPotential
         """
-        input_edge = self.modeler.convert_to_selections(input_edge, True)
+        assignment = self.modeler.convert_to_selections(assignment, True)
 
-        if not bound_name:
-            bound_name = generate_unique_name("Vector")
-        if type(input_edge[0]) is str:
-            props2 = OrderedDict({"Objects": input_edge, "Value": str(vectorvalue), "CoordinateSystem": ""})
+        if not boundary:
+            boundary = generate_unique_name("Vector")
+        if type(assignment[0]) is str:
+            props2 = OrderedDict({"Objects": assignment, "Value": str(vector_value), "CoordinateSystem": ""})
         else:
-            props2 = OrderedDict({"Edges": input_edge, "Value": str(vectorvalue), "CoordinateSystem": ""})
-        bound = BoundaryObject(self, bound_name, props2, "Vector Potential")
+            props2 = OrderedDict({"Edges": assignment, "Value": str(vector_value), "CoordinateSystem": ""})
+        bound = BoundaryObject(self, boundary, props2, "Vector Potential")
 
         if bound.create():
             self._boundaries[bound.name] = bound
             return bound
         return False
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(master_edge="independent", slave_edge="dependent", bound_name="boundary")
     def assign_master_slave(
-        self, master_edge, slave_edge, reverse_master=False, reverse_slave=False, same_as_master=True, bound_name=None
+        self, independent, dependent, reverse_master=False, reverse_slave=False, same_as_master=True, boundary=None
     ):
         """Assign dependent and independent boundary conditions to two edges of the same object.
 
         Parameters
         ----------
-        master_edge : int
+        independent : int
             ID of the master edge.
-        slave_edge : int
+        dependent : int
             ID of the slave edge.
         reverse_master : bool, optional
             Whether to reverse the master edge to the V direction. The default is ``False``.
         reverse_slave : bool, optional
             Whether to reverse the master edge to the U direction. The default is ``False``.
         same_as_master : bool, optional
             Whether the B-Field of the slave edge and master edge are the same. The default is ``True``.
-        bound_name : str, optional
+        boundary : str, optional
             Name of the master boundary. The default is ``None``, in which case the default name
             is used. The name of the slave boundary has a ``_dep`` suffix.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject`, :class:`pyaedt.modules.Boundary.BoundaryObject`
             Master and slave objects. If the method fails to execute it returns ``False``.
 
         References
         ----------
         >>> oModule.AssignIndependent
         >>> oModule.AssignDependent
         """
-        master_edge = self.modeler.convert_to_selections(master_edge, True)
-        slave_edge = self.modeler.convert_to_selections(slave_edge, True)
-        if not bound_name:
+        independent = self.modeler.convert_to_selections(independent, True)
+        dependent = self.modeler.convert_to_selections(dependent, True)
+        if not boundary:
             bound_name_m = generate_unique_name("Independent")
             bound_name_s = generate_unique_name("Dependent")
         else:
-            bound_name_m = bound_name
-            bound_name_s = bound_name + "_dep"
-        props2 = OrderedDict({"Edges": master_edge, "ReverseV": reverse_master})
+            bound_name_m = boundary
+            bound_name_s = boundary + "_dep"
+        props2 = OrderedDict({"Edges": independent, "ReverseV": reverse_master})
         bound = BoundaryObject(self, bound_name_m, props2, "Independent")
         if bound.create():
             self._boundaries[bound.name] = bound
 
             props2 = OrderedDict(
                 {
-                    "Edges": slave_edge,
+                    "Edges": dependent,
                     "ReverseU": reverse_slave,
                     "Independent": bound_name_m,
                     "SameAsMaster": same_as_master,
                 }
             )
             bound2 = BoundaryObject(self, bound_name_s, props2, "Dependent")
             if bound2.create():
                 self._boundaries[bound2.name] = bound2
                 return bound, bound2
             else:
                 return bound, False
         return False, False
 
-    @pyaedt_function_handler()
-    def assign_end_connection(self, objects, resistance=0, inductance=0, bound_name=None):
+    @pyaedt_function_handler(objects="assignment", bound_name="boundary")
+    def assign_end_connection(self, assignment, resistance=0, inductance=0, boundary=None):
         """Assign an end connection to a list of objects.
 
         Parameters
         ----------
-        objects : list of int or str or :class:`pyaedt.modeler.cad.object3d.Object3d`
+        assignment : list of int or str or :class:`pyaedt.modeler.cad.object3d.Object3d`
             List of objects to assign an end connection to.
         resistance : float or str, optional
             Resistance value. If float is provided, the units are assumed to be ohms.
             The default value is ``0``,
         inductance : float or str, optional
             Inductance value. If a float is provided, the units are assumed to Henry (H).
             The default value is ``0``.
-        bound_name : str, optional
+        boundary : str, optional
             Name of the end connection boundary. The default is ``None``, in which case the
             default name is used.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject`
             Newly created object. ``False`` if it fails.
@@ -3130,26 +3156,26 @@
         ----------
 
         >>> oModule.AssignEndConnection
         """
         if self.solution_type not in ["EddyCurrent", "Transient"]:
             self.logger.error("Excitation applicable only to Eddy current or Transient Solver.")
             return False
-        if len(objects) < 2:
+        if len(assignment) < 2:
             self.logger.error("At least 2 objects are needed.")
             return False
-        objects = self.modeler.convert_to_selections(objects, True)
-        if not bound_name:
-            bound_name = generate_unique_name("EndConnection")
+        assignment = self.modeler.convert_to_selections(assignment, True)
+        if not boundary:
+            boundary = generate_unique_name("EndConnection")
 
         props = OrderedDict(
             {
-                "Objects": objects,
+                "Objects": assignment,
                 "ResistanceValue": self.modeler._arg_with_dim(resistance, "ohm"),
                 "InductanceValue": self.modeler._arg_with_dim(inductance, "H"),
             }
         )
-        bound = BoundaryObject(self, bound_name, props, "EndConnection")
+        bound = BoundaryObject(self, boundary, props, "EndConnection")
         if bound.create():
             self._boundaries[bound.name] = bound
             return bound
         return False
```

### Comparing `pyaedt-0.8.7/pyaedt/maxwellcircuit.py` & `pyaedt-0.8.8/pyaedt/maxwellcircuit.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/mechanical.py` & `pyaedt-0.8.8/pyaedt/mechanical.py`

 * *Files 4% similar despite different names*

```diff
@@ -127,166 +127,178 @@
             port,
             aedt_process_id,
         )
 
     def _init_from_design(self, *args, **kwargs):
         self.__init__(*args, **kwargs)
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(
+        designname="design",
+        setupname="setup",
+        sweepname="sweep",
+        paramlist="parameters",
+        object_list="assignment",
+    )
     def assign_em_losses(
         self,
-        designname="HFSSDesign1",
-        setupname="Setup1",
-        sweepname="LastAdaptive",
+        design="HFSSDesign1",
+        setup="Setup1",
+        sweep="LastAdaptive",
         map_frequency=None,
         surface_objects=None,
         source_project_name=None,
-        paramlist=None,
-        object_list=None,
+        parameters=None,
+        assignment=None,
     ):
         """Map EM losses to a Mechanical design.
 
         Parameters
         ----------
-        designname : str, optional
+        design : str, optional
             Name of the design of the source mapping. The default is ``"HFSSDesign1"``.
-        setupname : str, optional
+        setup : str, optional
             Name of the EM setup. The default is ``"Setup1"``.
-        sweepname : str, optional
+        sweep : str, optional
             Name of the EM sweep to use for the mapping. The default is ``"LastAdaptive"``.
         map_frequency : str, optional
             Frequency to map. The default is ``None``. The value must be ``None`` for
             Eigenmode analysis.
         surface_objects : list, optional
             List objects in the source that are metals. The default is ``None``.
         source_project_name : str, optional
             Name of the source project. The default is ``None``, in which case
             the source from the same project is used.
-        paramlist : list, optional
+        parameters : list, optional
             List of all parameters in the EM to map. The default is ``None``.
-        object_list : list, optional
+        assignment : list, optional
              The default is ``None``.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject`
 
         References
         ----------
 
         >>> oModule.AssignEMLoss
         """
         if surface_objects is None:
             surface_objects = []
-        if paramlist is None:
-            paramlist = []
-        if object_list is None:
-            object_list = []
+        if parameters is None:
+            parameters = []
+        if assignment is None:
+            assignment = []
 
         assert "Thermal" in self.solution_type, "This method works only in a Mechanical Thermal analysis."
 
-        self.logger.info("Mapping HFSS EM Lossess")
+        self.logger.info("Mapping HFSS EM Loss")
         oName = self.project_name
         if oName == source_project_name or source_project_name is None:
             projname = "This Project*"
         else:
             projname = source_project_name + ".aedt"
         #
         # Generate a list of model objects from the lists made previously and use to map the HFSS losses into Icepak.
         #
-        if not object_list:
+        if not assignment:
             allObjects = self.modeler.object_names
         else:
-            allObjects = object_list[:]
+            allObjects = assignment[:]
         surfaces = surface_objects
         if map_frequency:
             intr = [map_frequency]
         else:
             intr = []
 
         argparam = OrderedDict({})
         for el in self.available_variations.nominal_w_values_dict:
             argparam[el] = self.available_variations.nominal_w_values_dict[el]
 
-        for el in paramlist:
+        for el in parameters:
             argparam[el] = el
 
         props = OrderedDict(
             {
                 "Objects": allObjects,
                 "allObjects": False,
                 "Project": projname,
                 "projname": "ElectronicsDesktop",
-                "Design": designname,
-                "Soln": setupname + " : " + sweepname,
+                "Design": design,
+                "Soln": setup + " : " + sweep,
                 "Params": argparam,
                 "ForceSourceToSolve": True,
                 "PreservePartnerSoln": True,
                 "PathRelativeTo": "TargetProject",
             }
         )
         if intr:
             props["Intrinsics"] = intr
             props["SurfaceOnly"] = surfaces
 
         name = generate_unique_name("EMLoss")
         bound = BoundaryObject(self, name, props, "EMLoss")
         if bound.create():
             self._boundaries[bound.name] = bound
-            self.logger.info("EM losses mapped from design %s.", designname)
+            self.logger.info("EM losses mapped from design %s.", design)
             return bound
         return False
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(
+        designname="design",
+        setupname="setup",
+        sweepname="sweep",
+        paramlist="parameters",
+        object_list="assignment",
+    )
     def assign_thermal_map(
         self,
         object_list,
-        designname="IcepakDesign1",
-        setupname="Setup1",
-        sweepname="SteadyState",
+        design="IcepakDesign1",
+        setup="Setup1",
+        sweep="SteadyState",
         source_project_name=None,
-        paramlist=None,
+        parameters=None,
     ):
         """Map thermal losses to a Mechanical design.
 
         .. note::
            This method works in 2021 R2 only when coupled with Icepak.
 
         Parameters
         ----------
         object_list : list
 
-        designname : str, optional
+        design : str, optional
             Name of the design with the source mapping. The default is ``"IcepakDesign1"``.
-        setupname : str, optional
+        setup : str, optional
             Name of the EM setup. The default is ``"Setup1"``.
-        sweepname : str, optional
+        sweep : str, optional
             Name of the EM sweep to use for the mapping. The default is ``"SteadyState"``.
         source_project_name : str, optional
             Name of the source project. The default is ``None``, in which case the
             source from the same project is used.
-        paramlist : list, optional
+        parameters : list, optional
             List of all parameters in the EM to map. The default is ``None``.
 
         Returns
         -------
         :class:`aedt.modules.Boundary.Boundary object`
             Boundary object.
 
         References
         ----------
 
         >>> oModule.AssignThermalCondition
         """
-        if paramlist is None:
-            paramlist = []
+        if parameters is None:
+            parameters = []
 
         assert self.solution_type == "Structural", "This method works only in a Mechanical Structural analysis."
 
-        self.logger.info("Mapping HFSS EM Lossess")
+        self.logger.info("Mapping HFSS EM Loss")
         oName = self.project_name
         if oName == source_project_name or source_project_name is None:
             projname = "This Project*"
         else:
             projname = source_project_name + ".aedt"
         #
         # Generate a list of model objects from the lists made previously and use to map the HFSS losses into Icepak.
@@ -296,37 +308,37 @@
             allObjects = self.modeler.object_names
         else:
             allObjects = object_list[:]
         argparam = OrderedDict({})
         for el in self.available_variations.nominal_w_values_dict:
             argparam[el] = self.available_variations.nominal_w_values_dict[el]
 
-        for el in paramlist:
+        for el in parameters:
             argparam[el] = el
 
         props = OrderedDict(
             {
                 "Objects": allObjects,
                 "Uniform": False,
                 "Project": projname,
                 "Product": "ElectronicsDesktop",
-                "Design": designname,
-                "Soln": setupname + " : " + sweepname,
+                "Design": design,
+                "Soln": setup + " : " + sweep,
                 "Params": argparam,
                 "ForceSourceToSolve": True,
                 "PreservePartnerSoln": True,
                 "PathRelativeTo": "TargetProject",
             }
         )
 
         name = generate_unique_name("ThermalLink")
         bound = BoundaryObject(self, name, props, "ThermalCondition")
         if bound.create():
             self._boundaries[bound.name] = bound
-            self.logger.info("Thermal conditions are mapped from design %s.", designname)
+            self.logger.info("Thermal conditions are mapped from design %s.", design)
             return bound
 
         return True
 
     @pyaedt_function_handler()
     def assign_uniform_convection(
         self,
@@ -363,16 +375,16 @@
         >>> oModule.AssignConvection
         """
         assert "Thermal" in self.solution_type, "This method works only in a Mechanical Thermal analysis."
 
         props = {}
         objects_list = self.modeler.convert_to_selections(objects_list, True)
 
-        if type(objects_list) is list:
-            if type(objects_list[0]) is str:
+        if isinstance(objects_list, list):
+            if isinstance(objects_list[0], str):
                 props["Objects"] = objects_list
             else:
                 props["Faces"] = objects_list
 
         props["Temperature"] = temperature
         props["Uniform"] = True
         props["FilmCoeff"] = str(convection_value) + convection_unit
@@ -412,16 +424,16 @@
         >>> oModule.AssignTemperature
         """
         assert "Thermal" in self.solution_type, "This method works only in a Mechanical Thermal analysis."
 
         props = {}
         objects_list = self.modeler.convert_to_selections(objects_list, True)
 
-        if type(objects_list) is list:
-            if type(objects_list[0]) is str:
+        if isinstance(objects_list, list):
+            if isinstance(objects_list[0], str):
                 props["Objects"] = objects_list
             else:
                 props["Faces"] = objects_list
 
         props["Temperature"] = temperature
 
         if not boundary_name:
@@ -628,31 +640,29 @@
 
         bound = BoundaryObject(self, boundary_name, props, "HeatGeneration")
         if bound.create():
             self._boundaries[bound.name] = bound
             return bound
         return False
 
-    @pyaedt_function_handler()
-    def create_setup(self, setupname="MySetupAuto", setuptype=None, **kwargs):
+    @pyaedt_function_handler(setupname="name", setuptype="setup_type")
+    def create_setup(self, name="MySetupAuto", setup_type=None, **kwargs):
         """Create an analysis setup for Mechanical.
 
-        Optional arguments are passed along with ``setuptype`` and ``setupname``.  Keyword
-        names correspond to the ``setuptype``
-        corresponding to the native AEDT API.  The list of
+        Optional arguments are passed along with ``setup_type`` and ``name``. Keyword
+        names correspond to the ``setup_type`` corresponding to the native AEDT API.  The list of
         keywords here is not exhaustive.
 
-
         Parameters
         ----------
-        setuptype : int, str, optional
+        name : str, optional
+            Name of the setup. The default is ``"Setup1"``.
+        setup_type : int, str, optional
             Type of the setup. Options are  ``"IcepakSteadyState"`` and
             ``"IcepakTransient"``. The default is ``"IcepakSteadyState"``.
-        setupname : str, optional
-            Name of the setup. The default is ``"Setup1"``.
         **kwargs : dict, optional
             Available keys depend on the setup chosen.
             For more information, see :doc:`../SetupTemplatesMechanical`.
 
         Returns
         -------
         :class:`pyaedt.modules.SolveSetup.SetupHFSS`
@@ -664,25 +674,25 @@
         >>> oModule.InsertSetup
 
         Examples
         --------
 
         >>> from pyaedt import Mechanical
         >>> app = Mechanical()
-        >>> app.create_setup(setupname="Setup1", MaxModes=6))
+        >>> app.create_setup(name="Setup1",MaxModes=6)
 
         """
-        if setuptype is None:
-            setuptype = self.design_solutions.default_setup
-        elif setuptype in SetupKeys.SetupNames:
-            setuptype = SetupKeys.SetupNames.index(setuptype)
+        if setup_type is None:
+            setup_type = self.design_solutions.default_setup
+        elif setup_type in SetupKeys.SetupNames:
+            setup_type = SetupKeys.SetupNames.index(setup_type)
         if "props" in kwargs:
-            return self._create_setup(setupname=setupname, setuptype=setuptype, props=kwargs["props"])
+            return self._create_setup(name=name, setup_type=setup_type, props=kwargs["props"])
         else:
-            setup = self._create_setup(setupname=setupname, setuptype=setuptype)
+            setup = self._create_setup(name=name, setup_type=setup_type)
         setup.auto_update = False
         for arg_name, arg_value in kwargs.items():
             if setup[arg_name] is not None:
                 setup[arg_name] = arg_value
         setup.auto_update = True
         setup.update()
         return setup
```

### Comparing `pyaedt-0.8.7/pyaedt/misc/Console.py_build` & `pyaedt-0.8.8/pyaedt/misc/Console.py_build`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/misc/Job_Settings.areg` & `pyaedt-0.8.8/pyaedt/misc/Job_Settings.areg`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/misc/Jupyter.py_build` & `pyaedt-0.8.8/pyaedt/misc/Jupyter.py_build`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/misc/Run_PyAEDT_Script.py_build` & `pyaedt-0.8.8/pyaedt/misc/Run_PyAEDT_Script.py_build`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/misc/Run_PyAEDT_Toolkit_Script.py_build` & `pyaedt-0.8.8/pyaedt/misc/Run_PyAEDT_Toolkit_Script.py_build`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/misc/aedtlib_personalib_install.py` & `pyaedt-0.8.8/pyaedt/misc/aedtlib_personalib_install.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/misc/amat.xml` & `pyaedt-0.8.8/pyaedt/misc/amat.xml`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/misc/ansys_cloud.areg` & `pyaedt-0.8.8/pyaedt/misc/ansys_cloud.areg`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/misc/config.schema.json` & `pyaedt-0.8.8/pyaedt/misc/config.schema.json`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/misc/console_setup.py` & `pyaedt-0.8.8/pyaedt/misc/console_setup.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/misc/images/gallery/PyAEDT.png` & `pyaedt-0.8.8/pyaedt/misc/images/gallery/PyAEDT.png`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/misc/images/large/pyansys.png` & `pyaedt-0.8.8/pyaedt/misc/images/large/pyansys.png`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/misc/install_extra_toolkits.py` & `pyaedt-0.8.8/pyaedt/misc/install_extra_toolkits.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/misc/jupyter_template.ipynb` & `pyaedt-0.8.8/pyaedt/misc/jupyter_template.ipynb`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/misc/misc.py` & `pyaedt-0.8.8/pyaedt/misc/misc.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/misc/ml_data_file_train_100MHz_1GHz.json` & `pyaedt-0.8.8/pyaedt/misc/ml_data_file_train_100MHz_1GHz.json`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/misc/ml_data_file_train_1GHz_10GHz.json` & `pyaedt-0.8.8/pyaedt/misc/ml_data_file_train_1GHz_10GHz.json`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/misc/patch_svr_model_100MHz_1GHz.joblib` & `pyaedt-0.8.8/pyaedt/misc/patch_svr_model_100MHz_1GHz.joblib`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/misc/patch_svr_model_1GHz_10GHz.joblib` & `pyaedt-0.8.8/pyaedt/misc/patch_svr_model_1GHz_10GHz.joblib`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/misc/pyaedt_local_config.acf` & `pyaedt-0.8.8/pyaedt/misc/pyaedt_local_config.acf`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/misc/pyansys-logo-black-cropped.png` & `pyaedt-0.8.8/pyaedt/misc/pyansys-logo-black-cropped.png`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/misc/spisim_com_configuration_files/com_120d_8.json` & `pyaedt-0.8.8/pyaedt/misc/spisim_com_configuration_files/com_120d_8.json`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/misc/spisim_com_configuration_files/com_93_8.json` & `pyaedt-0.8.8/pyaedt/misc/spisim_com_configuration_files/com_93_8.json`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/misc/spisim_com_configuration_files/com_94_17.json` & `pyaedt-0.8.8/pyaedt/misc/spisim_com_configuration_files/com_94_17.json`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/misc/spisim_com_configuration_files/com_parameters.py` & `pyaedt-0.8.8/pyaedt/misc/spisim_com_configuration_files/com_parameters.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/misc/spisim_com_configuration_files/com_settings_mapping.py` & `pyaedt-0.8.8/pyaedt/misc/spisim_com_configuration_files/com_settings_mapping.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/misc/template.acf` & `pyaedt-0.8.8/pyaedt/misc/template.acf`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/modeler/advanced_cad/actors.py` & `pyaedt-0.8.8/pyaedt/modeler/advanced_cad/actors.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/modeler/advanced_cad/multiparts.py` & `pyaedt-0.8.8/pyaedt/modeler/advanced_cad/multiparts.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/modeler/advanced_cad/oms.py` & `pyaedt-0.8.8/pyaedt/modeler/advanced_cad/oms.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/modeler/advanced_cad/parts.py` & `pyaedt-0.8.8/pyaedt/modeler/advanced_cad/parts.py`

 * *Files 0% similar despite different names*

```diff
@@ -483,24 +483,18 @@
         if not units:
             if self._multiparts._local_units:
                 units = self._multiparts._local_units
             else:
                 units = self._multiparts.units
         if self._compdef["ffd_name"]:
             ffd = os.path.join(self._compdef["part_folder"], self._compdef["ffd_name"] + ".ffd")
-            a = app.create_sbr_file_based_antenna(
-                ffd_full_path=ffd, model_units=units, target_cs=target_cs, antenna_name=self.name
-            )
+            a = app.create_sbr_file_based_antenna(far_field_data=ffd, target_cs=target_cs, units=units, name=self.name)
         else:
             a = app.create_sbr_antenna(
-                self._antenna_type(app),
-                model_units=units,
-                parameters_dict=self.params,
-                target_cs=target_cs,
-                antenna_name=self.name,
+                self._antenna_type(app), target_cs=target_cs, units=units, parameters=self.params, name=self.name
             )
         return a
 
     @pyaedt_function_handler()
     def insert(self, app, units=None):
         """Insert antenna in HFSS SBR+.
```

### Comparing `pyaedt-0.8.7/pyaedt/modeler/advanced_cad/stackup_3d.py` & `pyaedt-0.8.8/pyaedt/modeler/advanced_cad/stackup_3d.py`

 * *Files 1% similar despite different names*

```diff
@@ -2447,18 +2447,15 @@
         areas = [f.area for f in probe_feed_outer.faces]
         i_pec = areas.index(max(areas))
         outer_sheet_id = probe_feed_outer.faces[i_pec].id
         self.application.assign_perfecte_to_sheets(outer_sheet_id, "Probe_PEC")
 
         # Assign port. Find the face with the minimum z-position.
         self.application.wave_port(
-            probe_feed_outer.bottom_face_z,
-            reference=probe_feed_outer.name,
-            create_pec_cap=True,
-            name="Probe_Port",
+            probe_feed_outer.bottom_face_z, reference=probe_feed_outer.name, create_pec_cap=True, name="Probe_Port"
         )
 
     def create_lumped_port(self, reference_layer, opposite_side=False, port_name=None, axisdir=None):
         """Create a parametrized lumped port.
 
         Parameters
         ----------
@@ -2510,17 +2507,17 @@
             dimension_list=[string_width, string_length],
             name=self.name + "_port",
             matname=None,
         )
         if self.application.solution_type == "Modal":
             if axisdir is None:
                 axisdir = self.application.AxisDir.ZPos
-            port = self.application.lumped_port(rect.name, name=port_name, integration_line=axisdir)
+            port = self.application.lumped_port(rect.name, integration_line=axisdir, name=port_name)
         elif self.application.solution_type == "Terminal":
-            port = self.application.lumped_port(rect.name, name=port_name, reference=[reference_layer.name])
+            port = self.application.lumped_port(rect.name, reference=[reference_layer.name], name=port_name)
         return port
 
     def quarter_wave_feeding_line(self, impedance_to_adapt=50):
         """Create a Trace to feed the patch. The trace length is the quarter wavelength, and this width is calculated
         to return the desired impedance.
 
         Parameters
@@ -3250,18 +3247,24 @@
             dimension_list=[string_width, string_length],
             name=self.name + "_port",
             matname=None,
         )
         if self.application.solution_type == "Modal":
             if axisdir is None:
                 axisdir = self.application.AxisDir.ZPos
-            port = self.application.create_lumped_port_to_sheet(port.name, portname=port_name, axisdir=axisdir)
+            port = self.application.lumped_port(
+                signal=port.name, name=port_name, integration_line=axisdir, create_port_sheet=False
+            )
         elif self.application.solution_type == "Terminal":
-            port = self.application.create_lumped_port_to_sheet(
-                port.name, portname=port_name, reference_object_list=[reference_layer.name]
+            port = self.application.lumped_port(
+                signal=port.name,
+                name=port_name,
+                integration_line=axisdir,
+                create_port_sheet=False,
+                reference=[reference_layer.name],
             )
         return port
 
 
 class Polygon(CommonObject, object):
     """Polygon Class in Stackup3D. It is preferable to use the add_polygon method in the class Layer3D than directly
     the class constructor.
```

### Comparing `pyaedt-0.8.7/pyaedt/modeler/cad/Modeler.py` & `pyaedt-0.8.8/pyaedt/modeler/cad/Modeler.py`

 * *Files 1% similar despite different names*

```diff
@@ -610,21 +610,21 @@
                         if vertex.id == obj_id:
                             return "Vertex"
         raise ValueError("Cannot find entity id {}".format(obj_id))  # pragma: no cover
 
     @pyaedt_function_handler()
     def _get_type_from_object(self, obj):
         """Get the entity type from the object."""
-        if type(obj) is FacePrimitive:
+        if isinstance(obj, FacePrimitive):
             return "Face"
-        elif type(obj) is EdgePrimitive:
+        elif isinstance(obj, EdgePrimitive):
             return "Edge"
-        elif type(obj) is VertexPrimitive:
+        elif isinstance(obj, VertexPrimitive):
             return "Vertex"
-        elif type(obj) is Object3d:
+        elif isinstance(obj, Object3d):
             return "3dObject"
         else:  # pragma: no cover
             raise ValueError("Cannot detect the entity type.")
 
     @pyaedt_function_handler()
     def update(self):
         """Update the coordinate system.
```

### Comparing `pyaedt-0.8.7/pyaedt/modeler/cad/Primitives.py` & `pyaedt-0.8.8/pyaedt/modeler/cad/Primitives.py`

 * *Files 0% similar despite different names*

```diff
@@ -2419,15 +2419,15 @@
             List of objects belonging to the group.
 
         References
         ----------
 
         >>> oEditor.GetObjectsInGroup
         """
-        if type(group) is not str:
+        if not isinstance(group, str):
             raise ValueError("Group name must be a string")
         group_objs = list(self.oeditor.GetObjectsInGroup(group))
         if not group_objs:
             return None
         return group_objs
 
     @pyaedt_function_handler()
@@ -2447,15 +2447,15 @@
 
         References
         ----------
 
         >>> oEditor.GetObjectsInGroup
         >>> oEditor.GetModelBoundingBox
         """
-        if type(group) is not str:
+        if not isinstance(group, str):
             raise ValueError("Group name must be a string")
         group_objs = list(self.oeditor.GetObjectsInGroup(group))
         if not group_objs:
             return None
         all_objs = self.object_names
         objs_to_unmodel = [i for i in all_objs if i not in group_objs]
         if objs_to_unmodel:
@@ -4601,15 +4601,14 @@
             ``True`` when successful, ``False`` when failed.
 
         References
         ----------
 
         >>> oEditor.Import
         """
-
         if str(healing) in ["0", "1"]:
             warnings.warn(
                 "Assigning `0` or `1` to `healing` option is deprecated. Assign `True` or `False` instead.",
                 DeprecationWarning,
             )
         vArg1 = ["NAME:NativeBodyParameters"]
         vArg1.append("HealOption:="), vArg1.append(int(healing))
@@ -4962,15 +4961,15 @@
         >>> oEditor.GetObjectsByMaterial
         >>> oEditor.GetFaceIDs
         """
         self.logger.info("Selecting outer faces.")
 
         sel = []
         objs = []
-        if type(mats) is str:
+        if isinstance(mats, str):
             mats = [mats]
         for mat in mats:
             objs.extend(list(self.oeditor.GetObjectsByMaterial(mat.lower())))
 
             for i in objs:
                 oFaceIDs = self.oeditor.GetFaceIDs(i)
 
@@ -6229,18 +6228,16 @@
         if kwarg:
             if "is_percentage" in kwarg.keys():
                 is_percentage = kwarg["is_percentage"]
             else:
                 is_percentage = True
             if kwarg.get("pad_percent", False):
                 pad_percent = kwarg["pad_percent"]
-            else:
-                pad_percent = 300
-            pad_value = pad_percent
-            if isinstance(pad_value, list):
+                pad_value = pad_percent
+            if isinstance(pad_value, list) and len(pad_value) < 6:
                 pad_value = [pad_value[i // 2 + 3 * (i % 2)] for i in range(6)]
             pad_type = ["Absolute Offset", "Percentage Offset"][int(is_percentage)]
 
         if isinstance(pad_type, bool):
             pad_type = ["Absolute Offset", "Percentage Offset"][int(pad_type)]
             if isinstance(pad_value, list):
                 pad_value = [pad_value[i // 2 + 3 * (i % 2)] for i in range(6)]
@@ -8379,15 +8376,15 @@
 
         return arg_str
 
     @pyaedt_function_handler()
     def _arg_with_dim(self, value, units=None):
         if units is None:
             units = self.model_units
-        if type(value) is str:
+        if isinstance(value, str):
             try:
                 float(value)
                 val = "{0}{1}".format(value, units)
             except Exception:
                 val = value
         else:
             val = "{0}{1}".format(value, units)
```

### Comparing `pyaedt-0.8.7/pyaedt/modeler/cad/Primitives2D.py` & `pyaedt-0.8.8/pyaedt/modeler/cad/Primitives2D.py`

 * *Files 8% similar despite different names*

```diff
@@ -277,45 +277,70 @@
         vArg1.append("WhichAxis:="), vArg1.append(self.plane2d)
 
         vArg2 = self._default_object_attributes(name=name, matname=matname, flags="NonModel#" if non_model else "")
         new_object_name = self.oeditor.CreateRegularPolygon(vArg1, vArg2)
         return self._create_object(new_object_name, **kwargs)
 
     @pyaedt_function_handler()
-    def create_region(self, pad_percent=300, is_percentage=True):
+    def create_region(self, pad_value=300, pad_type="Percentage Offset", region_name="Region", **kwarg):
         """Create an air region.
 
         Parameters
         ----------
-        pad_percent : float, str, list of floats or list of str, optional
-            Same padding is applied if not a list. The default is ``300``.
-            If a list of floats or strings, interpret as adding ``["+X", "+Y", "-X", "-Y"]`` for XY geometry mode,
-            and ``["+R", "+Z", "-Z"]`` for RZ geometry mode.
-        is_percentage : bool, optional
-            Whether the region definition is a percentage or absolute value. The default is `True``.
+        pad_value : float, str, list of floats or list of str, optional
+            Padding values to apply. If a list is not provided, the same
+            value is applied to all padding directions. If a list of floats
+            or strings is provided, the values are
+            interpreted as padding for ``["+X", "-X", "+Y", "-Y", "+Z", "-Z"]``.
+        pad_type : str, optional
+            Padding definition. The default is ``"Percentage Offset"``.
+            Options are ``"Absolute Offset"``,
+            ``"Absolute Position"``, ``"Percentage Offset"``, and
+            ``"Transverse Percentage Offset"``. When using a list,
+            different padding types can be provided for different
+           directions.
+        region_name : str, optional
+            Region name. The default is ``None``, in which case the name
+            is generated automatically.
 
         Returns
         -------
         :class:`pyaedt.modeler.cad.object3d.Object3d`
             Region object.
 
         References
         ----------
 
         >>> oEditor.CreateRegion
         """
-        if not isinstance(pad_percent, list):
-            pad_percent = [pad_percent] * 4
+        # backward compatibility
+        if kwarg:
+            if "is_percentage" in kwarg.keys():
+                is_percentage = kwarg["is_percentage"]
+            else:
+                is_percentage = True
+            if kwarg.get("pad_percent", False):
+                pad_percent = kwarg["pad_percent"]
+                pad_value = pad_percent
+            if isinstance(pad_value, list) and len(pad_value) < 6:
+                pad_value = [pad_value[i // 2 + 3 * (i % 2)] for i in range(6)]
+            pad_type = ["Absolute Offset", "Percentage Offset"][int(is_percentage)]
+
+        if isinstance(pad_type, bool):
+            pad_type = ["Absolute Offset", "Percentage Offset"][int(pad_type)]
+
+        if not isinstance(pad_value, list):
+            pad_value = [pad_value] * 4
         if self._app.design_type == "2D Extractor" or (
             self._app.design_type == "Maxwell 2D" and self._app.odesign.GetGeometryMode() == "XY"
         ):
-            if len(pad_percent) != 4:
+            if len(pad_value) != 4:
                 self.logger.error("Wrong padding list provided. Four values have to be provided.")
                 return False
-            pad_percent = [pad_percent[0], pad_percent[2], pad_percent[1], pad_percent[3], 0, 0]
+            pad_value = [pad_value[0], pad_value[2], pad_value[1], pad_value[3], 0, 0]
         else:
-            if len(pad_percent) < 3:
+            if len(pad_value) < 3:
                 self.logger.error("Wrong padding list provided. Three values have to be provided for RZ geometry.")
                 return False
-            pad_percent = [pad_percent[0], 0, 0, 0, pad_percent[1], pad_percent[2]]
+            pad_value = [pad_value[0], 0, 0, 0, pad_value[1], pad_value[2]]
 
-        return self._create_region(pad_percent, ["Absolute Offset", "Percentage Offset"][int(is_percentage)])
+        return self._create_region(pad_value, pad_type, region_name, region_type="Region")
```

### Comparing `pyaedt-0.8.7/pyaedt/modeler/cad/Primitives3D.py` & `pyaedt-0.8.8/pyaedt/modeler/cad/Primitives3D.py`

 * *Files 1% similar despite different names*

```diff
@@ -10,15 +10,17 @@
 from math import sqrt
 from math import tan
 import os
 
 from pyaedt import Edb
 from pyaedt import Icepak
 from pyaedt.generic import LoadAEDTFile
+from pyaedt.generic.desktop_sessions import _edb_sessions
 from pyaedt.generic.general_methods import generate_unique_name
+from pyaedt.generic.general_methods import generate_unique_project_name
 from pyaedt.generic.general_methods import normalize_path
 from pyaedt.generic.general_methods import open_file
 from pyaedt.generic.general_methods import pyaedt_function_handler
 from pyaedt.modeler.advanced_cad.actors import Bird
 from pyaedt.modeler.advanced_cad.actors import Person
 from pyaedt.modeler.advanced_cad.actors import Vehicle
 from pyaedt.modeler.advanced_cad.multiparts import Environment
@@ -283,15 +285,14 @@
 
         >>> from pyaedt import Hfss
         >>> aedtapp = Hfss()
         >>> ret_obj = aedtapp.modeler.create_polyhedron(cs_axis='X', center_position=[0, 0, 0],
         ...                                             start_position=[0,5,0], height=0.5,
         ...                                              num_sides=8, name="mybox", matname="copper")
         """
-        test = cs_axis
         cs_axis = GeometryOperators.cs_axis_str(cs_axis)
         if len(center_position) != 3:
             self.logger.error("The ``center_position`` argument must be a valid three-element list.")
             return False
         if len(start_position) != 3:
             self.logger.error("The ``start_position`` argument must be a valid three-element list.")
             return False
@@ -668,27 +669,27 @@
         first_argument.append("XPadPos:="), first_argument.append(x_position)
         first_argument.append("YPadPos:="), first_argument.append(y_position)
         first_argument.append("ZPadPos:="), first_argument.append(z_position)
         first_argument.append("XDir:="), first_argument.append(x_length)
         first_argument.append("YDir:="), first_argument.append(y_length)
         first_argument.append("ZDir:="), first_argument.append(z_length)
         distance = (
-            "sqrt(("
-            + str(x_position_end)
-            + "-("
-            + str(x_position)
-            + ")) ** 2 + ("
-            + str(y_position_end)
-            + "-("
-            + str(y_position)
-            + ")) ** 2 + ( "
-            + str(z_position_end)
-            + "-("
-            + str(z_position)
-            + ")) ** 2) meter"
+                "sqrt(("
+                + str(x_position_end)
+                + "-("
+                + str(x_position)
+                + ")) ** 2 + ("
+                + str(y_position_end)
+                + "-("
+                + str(y_position)
+                + ")) ** 2 + ( "
+                + str(z_position_end)
+                + "-("
+                + str(z_position)
+                + ")) ** 2) meter"
         )
 
         first_argument.append("Distance:="), first_argument.append(distance)
 
         first_argument.append("h1:="), first_argument.append(self._arg_with_dim(h1))
         first_argument.append("h2:="), first_argument.append(self._arg_with_dim(h2))
         first_argument.append("alpha:="), first_argument.append(self._arg_with_dim(alpha, "deg"))
@@ -833,15 +834,15 @@
         vArg1.append("NumSegments:="), vArg1.append("{}".format(numSides))
         vArg2 = self._default_object_attributes(name=name, matname=matname, flags=non_model_flag)
         new_object_name = self.oeditor.CreateCircle(vArg1, vArg2)
         return self._create_object(new_object_name, **kwargs)
 
     @pyaedt_function_handler()
     def create_ellipse(
-        self, cs_plane, position, major_radius, ratio, is_covered=True, name=None, matname=None, **kwargs
+            self, cs_plane, position, major_radius, ratio, is_covered=True, name=None, matname=None, **kwargs
     ):
         """Create an ellipse.
 
         Parameters
         ----------
         cs_plane : str or int
             Coordinate system plane for orienting the ellipse.
@@ -1150,19 +1151,19 @@
         self.oeditor.CreateHelix(vArg1, vArg2)
         if polyline_name in self.objects_by_name:
             del self.objects[self.objects_by_name[polyline_name].id]
         return self._create_object(polyline_name, **kwargs)
 
     @pyaedt_function_handler()
     def create_udm(
-        self,
-        udmfullname,
-        udm_params_list,
-        udm_library="syslib",
-        name=None,
+            self,
+            udmfullname,
+            udm_params_list,
+            udm_library="syslib",
+            name=None,
     ):
         """Create a user-defined model.
 
         Parameters
         ----------
         udmfullname : str
             Full name for the user-defined model, including the folder name.
@@ -1357,23 +1358,23 @@
             return cs_name
         else:
             app.oproject.Close()
             return udm_obj.target_coordinate_system
 
     @pyaedt_function_handler()
     def insert_3d_component(
-        self,
-        comp_file,
-        geo_params=None,
-        sz_mat_params="",
-        sz_design_params="",
-        targetCS="Global",
-        name=None,
-        password="",
-        auxiliary_dict=False,
+            self,
+            comp_file,
+            geo_params=None,
+            sz_mat_params="",
+            sz_design_params="",
+            targetCS="Global",
+            name=None,
+            password="",
+            auxiliary_dict=False,
     ):
         """Insert a new 3D component.
 
         Parameters
         ----------
         comp_file : str
             Name of the component file.
@@ -1412,16 +1413,15 @@
                     _all_lines.append(line.decode("utf-8").lstrip("\t"))
                 except UnicodeDecodeError:
                     break
             for line in _all_lines:
                 if "IsEncrypted" in line:
                     line_list = line.split("=")
                     if line_list[1] in ["true", "True", True] and password == "":
-                        self.logger.error("Password can't be an empty string.")
-                        return False
+                        self.logger.warning("Encrypted model.")
             aedt_fh.close()
         vArg1 = ["NAME:InsertComponentData"]
         sz_geo_params = ""
         if not geo_params:
             geometryparams = self._app.get_components3d_vars(comp_file)
             if geometryparams:
                 geo_params = geometryparams
@@ -1489,17 +1489,17 @@
             if aux_dict.get("native components", None):
                 if aux_dict.get("coordinatesystems", None):
                     for cs in list(aux_dict["coordinatesystems"].keys()):
                         aux_dict["coordinatesystems"][udm_obj.name + "_" + cs] = aux_dict["coordinatesystems"][cs]
                         aux_dict["coordinatesystems"].pop(cs)
                         if aux_dict["coordinatesystems"][udm_obj.name + "_" + cs]["Reference CS"] != "Global":
                             aux_dict["coordinatesystems"][udm_obj.name + "_" + cs]["Reference CS"] = (
-                                udm_obj.name
-                                + "_"
-                                + aux_dict["coordinatesystems"][udm_obj.name + "_" + cs]["Reference CS"]
+                                    udm_obj.name
+                                    + "_"
+                                    + aux_dict["coordinatesystems"][udm_obj.name + "_" + cs]["Reference CS"]
                             )
                 for _, ncdict in aux_dict["native components"].items():
                     for _, inst_dict in ncdict["Instances"].items():
                         if inst_dict["CS"]:
                             if inst_dict["CS"] != "Global":
                                 inst_dict["CS"] = udm_obj.name + "_" + inst_dict["CS"]
                 temp_dict = {}
@@ -1513,15 +1513,15 @@
                         to_remove.append(mon)
                 for mon in to_remove:
                     aux_dict["monitors"].remove(mon)
                 self._app.configurations.options.unset_all_import()
                 self._app.configurations.options.import_native_components = True
                 self._app.configurations.options.import_monitor = True
                 temp_dict_file = os.path.join(self._app.toolkit_directory, generate_unique_name("tempdict_"))
-                with open(temp_dict_file, "w") as f:
+                with open_file(temp_dict_file, "w") as f:
                     json.dump(temp_dict, f)
                 exclude_set = set([obj.name for _, obj in self._app.modeler.objects.items()])
                 old_udm = set(list(self._app.modeler.user_defined_components))
                 old_cs = set(self._app.modeler.coordinate_systems)
                 self._app.configurations.import_config(temp_dict_file, exclude_set)
                 targetCS = self._create_reference_cs_from_3dcomp(udm_obj, password)
                 if targetCS != "Global":
@@ -1529,15 +1529,15 @@
                     for udm in set(list(self._app.modeler.user_defined_components)) - old_udm:
                         if self._app.modeler.user_defined_components[udm].target_coordinate_system == "Global":
                             self._app.modeler.user_defined_components[udm].target_coordinate_system = targetCS
                 for cs in set(self._app.modeler.coordinate_systems) - old_cs:
                     if cs.ref_cs == "Global":
                         cs.ref_cs = targetCS
             if aux_dict.get("monitors", None):
-                temp_proj_name = self._app._generate_unique_project_name()
+                temp_proj_name = generate_unique_project_name()
                 ipkapp_temp = Icepak(projectname=os.path.join(self._app.toolkit_directory, temp_proj_name))
                 ipkapp_temp.delete_design(ipkapp_temp.design_name)
                 self._app.oproject.CopyDesign(self._app.design_name)
                 ipkapp_temp.oproject.Paste()
                 temp_proj = ipkapp_temp.project_file
                 ipkapp_temp.close_project()
                 read_dict = LoadAEDTFile.load_keyword_in_aedt_file(temp_proj, "ToplevelParts")
@@ -1557,28 +1557,28 @@
                     if part["Attributes"]["Name"] in parts_name:
                         mapping_dict["ReferenceCoordSystemID"] = part["Operations"]["Operation"][
                             "ReferenceCoordSystemID"
                         ]
                         for i in ["FaceKeyIDMap", "EdgeKeyIDMap", "VertexKeyIDMap", "BodyKeyIDMap"]:
                             try:
                                 dict_str = (
-                                    "{"
-                                    + ",".join(part["Operations"]["Operation"]["OperationIdentity"][i])
-                                    .replace("'", '"')
-                                    .replace("=", ":")
-                                    + "}"
+                                        "{"
+                                        + ",".join(part["Operations"]["Operation"]["OperationIdentity"][i])
+                                        .replace("'", '"')
+                                        .replace("=", ":")
+                                        + "}"
                                 )
                             except KeyError:  # TODO: fix reading AEDT
                                 for key, mon in part["Operations"]["Operation"]["OperationIdentity"].items():
                                     if i in key:
                                         keyarr = key.split("(")
                                         dict_str = (
-                                            "{"
-                                            + "{}: {}".format(keyarr[1], mon.replace(")", "")).replace("'", '"')
-                                            + "}"
+                                                "{"
+                                                + "{}: {}".format(keyarr[1], mon.replace(")", "")).replace("'", '"')
+                                                + "}"
                                         )
                                         break
                             mapping_dict[i].update(json.loads(dict_str))
                 if mapping_dict["ReferenceCoordSystemID"] != 1:
                     read_cs = True
                 if read_cs:
                     read_dict = LoadAEDTFile.load_keyword_in_aedt_file(temp_proj, "CoordinateSystems")
@@ -1634,21 +1634,21 @@
             os.remove(temp_proj)
             return udm_obj, mapping_dict, aux_dict
         else:
             return udm_obj
 
     @pyaedt_function_handler()
     def insert_layout_component(
-        self,
-        comp_file,
-        coordinate_system="Global",
-        name=None,
-        parameter_mapping=False,
-        layout_coordinate_systems=[],
-        reference_coordinate_system="Global"
+            self,
+            comp_file,
+            coordinate_system="Global",
+            name=None,
+            parameter_mapping=False,
+            layout_coordinate_systems=None,
+            reference_coordinate_system="Global"
     ):
         """Insert a new layout component.
 
         Parameters
         ----------
         comp_file : str
             Path of the component file. Either ``".aedb"`` and ``".aedbcomp"`` are allowed.
@@ -1677,14 +1677,16 @@
         --------
         >>> from pyaedt import Hfss
         >>> app = Hfss()
         >>> layout_component = "path/to/layout_component/component.aedbcomp"
         >>> comp = app.modeler.insert_layout_component(layout_component)
 
         """
+        if layout_coordinate_systems is None:
+            layout_coordinate_systems = []
         if self._app.solution_type != "Terminal" and self._app.solution_type != "TransientAPhiFormulation":
             self.logger.warning("Solution type must be terminal in HFSS or APhi in Maxwell")
             return False
 
         component_name = os.path.splitext(os.path.basename(comp_file))[0]
         aedt_component_name = component_name
         if component_name not in self._app.o_component_manager.GetNames():
@@ -1721,32 +1723,48 @@
         if os.path.splitext(os.path.basename(comp_file))[1] == ".aedbcomp":
             aedb_project_path = os.path.join(self._app.project_path, self._app.project_name + ".aedb")
             aedb_component_path = os.path.join(
                 aedb_project_path, "LayoutComponents", aedt_component_name, aedt_component_name + ".aedb"
             )
             aedb_component_path = normalize_path(aedb_component_path)
 
-        component_obj = Edb(
-            edbpath=aedb_component_path,
-            isreadonly=True,
-            edbversion=self._app._aedt_version,
-            student_version=self._app.student_version,
-        )
-
-        # Extract and map parameters
+        is_edb_open = False
         parameters = {}
-        for param in component_obj.design_variables:
-            parameters[param] = [param + "_" + name, component_obj.design_variables[param].value_string]
-            if parameter_mapping:
-                self._app[param + "_" + name] = component_obj.design_variables[param].value_string
+        component_cs = []
+        for edb_object in _edb_sessions:
+            if edb_object.edbpath == aedb_component_path:
+                is_edb_open = True
+                # Extract and map parameters
+                for param in edb_object.design_variables:
+                    parameters[param] = [param + "_" + name, edb_object.design_variables[param].value_string]
+                    if parameter_mapping:
+                        self._app[param + "_" + name] = edb_object.design_variables[param].value_string
+                # Get coordinate systems
+                component_cs = list(edb_object.components.instances.keys())
+                break
+
+        if not is_edb_open:
+            component_obj = Edb(
+                edbpath=aedb_component_path,
+                isreadonly=True,
+                edbversion=self._app._aedt_version,
+                student_version=self._app.student_version,
+            )
+
+            # Extract and map parameters
+            parameters = {}
+            for param in component_obj.design_variables:
+                parameters[param] = [param + "_" + name, component_obj.design_variables[param].value_string]
+                if parameter_mapping:
+                    self._app[param + "_" + name] = component_obj.design_variables[param].value_string
 
-        # Get coordinate systems
-        component_cs = list(component_obj.components.instances.keys())
+            # Get coordinate systems
+            component_cs = list(component_obj.components.instances.keys())
 
-        component_obj.close_edb()
+            component_obj.close()
 
         vArg1 = ["NAME:InsertNativeComponentData"]
         vArg1.append("TargetCS:=")
         vArg1.append(coordinate_system)
         vArg1.append("SubmodelDefinitionName:=")
         vArg1.append("LC")
         varg2 = ["NAME:ComponentPriorityLists"]
@@ -1874,17 +1892,18 @@
             udm_obj = False
             if new_object_name:
                 obj_list = list(self.oeditor.Get3DComponentPartNames(new_object_name))
                 for new_name in obj_list:
                     self._create_object(new_name)
 
                 udm_obj = self._create_user_defined_component(new_object_name)
-
+                _ = udm_obj.layout_component.edb_object
                 if name:
                     udm_obj.name = name
+                    udm_obj.layout_component._name = name
 
         except Exception:  # pragma: no cover
             udm_obj = False
         return udm_obj
 
     @pyaedt_function_handler()
     def get_3d_component_object_list(self, componentname):
@@ -1915,38 +1934,38 @@
 
     @pyaedt_function_handler()
     def _check_actor_folder(self, actor_folder):
         if not os.path.exists(actor_folder):
             self.logger.error("Folder {} does not exist.".format(actor_folder))
             return False
         if not any(fname.endswith(".json") for fname in os.listdir(actor_folder)) or not any(
-            fname.endswith(".a3dcomp") for fname in os.listdir(actor_folder)
+                fname.endswith(".a3dcomp") for fname in os.listdir(actor_folder)
         ):
             self.logger.error("At least one json and one a3dcomp file is needed.")
             return False
         return True
 
     @pyaedt_function_handler()
     def _initialize_multipart(self):
         if MultiPartComponent._t in self._app._variable_manager.independent_variable_names:
             return True
         else:
             return MultiPartComponent.start(self._app)
 
     @pyaedt_function_handler()
     def add_person(
-        self,
-        actor_folder,
-        speed=0.0,
-        global_offset=[0, 0, 0],
-        yaw=0,
-        pitch=0,
-        roll=0,
-        relative_cs_name=None,
-        actor_name=None,
+            self,
+            actor_folder,
+            speed=0.0,
+            global_offset=[0, 0, 0],
+            yaw=0,
+            pitch=0,
+            roll=0,
+            relative_cs_name=None,
+            actor_name=None,
     ):
         """Add a Walking Person Multipart from 3D Components.
 
         It requires a json file in the folder containing person
         infos. An example json file follows:
 
          .. code-block:: json
@@ -2038,23 +2057,23 @@
         person1.roll = self._arg_with_dim(roll, "deg")
         person1.insert(self._app)
         self.multiparts.append(person1)
         return person1
 
     @pyaedt_function_handler()
     def add_vehicle(
-        self,
-        actor_folder,
-        speed=0,
-        global_offset=[0, 0, 0],
-        yaw=0,
-        pitch=0,
-        roll=0,
-        relative_cs_name=None,
-        actor_name=None,
+            self,
+            actor_folder,
+            speed=0,
+            global_offset=[0, 0, 0],
+            yaw=0,
+            pitch=0,
+            roll=0,
+            relative_cs_name=None,
+            actor_name=None,
     ):
         """Add a Moving Vehicle Multipart from 3D Components.
 
         It requires a json file in the folder containing vehicle
         infos. An example json file follows:
 
          .. code-block:: json
@@ -2128,24 +2147,24 @@
         vehicle.roll = self._arg_with_dim(roll, "deg")
         vehicle.insert(self._app)
         self.multiparts.append(vehicle)
         return vehicle
 
     @pyaedt_function_handler()
     def add_bird(
-        self,
-        actor_folder,
-        speed=0,
-        global_offset=[0, 0, 0],
-        yaw=0,
-        pitch=0,
-        roll=0,
-        flapping_rate=50,
-        relative_cs_name=None,
-        actor_name=None,
+            self,
+            actor_folder,
+            speed=0,
+            global_offset=[0, 0, 0],
+            yaw=0,
+            pitch=0,
+            roll=0,
+            flapping_rate=50,
+            relative_cs_name=None,
+            actor_name=None,
     ):
         """Add a Bird Multipart from 3D Components.
 
         It requires a json file in the folder containing bird infos. An example json file is showed here.
 
          .. code-block:: json
 
@@ -2244,17 +2263,18 @@
         bird.roll = self._arg_with_dim(roll, "deg")
         bird.insert(self._app)
         self.multiparts.append(bird)
         return bird
 
     @pyaedt_function_handler()
     def add_environment(
-        self, env_folder, global_offset=[0, 0, 0], yaw=0, pitch=0, roll=0, relative_cs_name=None, environment_name=None
+            self, env_folder, global_offset=[0, 0, 0], yaw=0, pitch=0, roll=0, relative_cs_name=None,
+            environment_name=None
     ):
-        """Add an Environment Multipart Component from Json file.
+        """Add an Environment Multipart Component from JSON file.
 
          .. code-block:: json
 
             {
                 "name": "open1",
                 "version": 1,
                 "class":"environment",
@@ -2470,30 +2490,30 @@
                 self.logger.info("Creating triple winding")
         else:
             list_object = self._make_winding(
                 name_wind, material_wind, in_rad_wind, out_rad_wind, height_wind, teta, turns, chamf, sep_layer
             )
             self.logger.info("Creating single winding")
         list_duplicated_object = []
-        if type(list_object[0]) == list:
+        if isinstance(list_object[0], list):
             for i in range(len(list_object)):
                 success = list_object[i][0].set_crosssection_properties(
                     type=section, width=w_dia, num_seg=segment_number
                 )
             returned_list = returned_list + list_object
         else:
             success = list_object[0].set_crosssection_properties(type=section, width=w_dia, num_seg=segment_number)
             returned_list.append(list_object)
 
         for key in values["Number of Windings"].keys():
             if values["Number of Windings"][key]:
                 number_duplication = int(key)
         if number_duplication >= 2:
             if values["Mode"]["Common"] and number_duplication == 2:
-                if type(list_object[0]) == list:
+                if isinstance(list_object[0], list):
                     for i in range(len(list_object)):
                         duplication = self.create_polyline(
                             position_list=list_object[i][1], name=name_wind, matname=material_wind
                         )
                         duplication.mirror([0, 0, 0], [-1, 0, 0])
                         duplication_points = self.get_vertices_of_line(duplication.name)
                         success = duplication.set_crosssection_properties(
@@ -2506,15 +2526,15 @@
                         position_list=list_object[1], name=name_wind, matname=material_wind
                     )
                     duplication.mirror([0, 0, 0], [-1, 0, 0])
                     duplication_points = self.get_vertices_of_line(duplication.name)
                     success = duplication.set_crosssection_properties(type=section, width=w_dia, num_seg=segment_number)
                     list_duplicated_object.append([duplication, duplication_points])
             else:
-                if type(list_object[0]) == list:
+                if isinstance(list_object[0], list):
                     for j in range(number_duplication - 1):
                         for i in range(len(list_object)):
                             duplication = self.create_polyline(
                                 position_list=list_object[i][1], name=name_wind, matname=material_wind
                             )
                             duplication.rotate("Z", (j + 1) * 360 / number_duplication)
                             duplication_points = self.get_vertices_of_line(duplication.name)
@@ -2599,28 +2619,28 @@
             positions = self.get_vertices_of_line(true_polyline.name)
             return [true_polyline, positions]
 
         return positions
 
     @pyaedt_function_handler()
     def _make_double_linked_winding(
-        self,
-        name,
-        material,
-        in_rad,
-        out_rad,
-        height,
-        w_dia,
-        teta,
-        teta_in_wind,
-        turns,
-        turns_in_wind,
-        chamfer,
-        chamf_in_wind,
-        sr,
+            self,
+            name,
+            material,
+            in_rad,
+            out_rad,
+            height,
+            w_dia,
+            teta,
+            teta_in_wind,
+            turns,
+            turns_in_wind,
+            chamfer,
+            chamf_in_wind,
+            sr,
     ):
         list_object = self._make_double_winding(
             name,
             material,
             in_rad,
             out_rad,
             height,
@@ -2658,30 +2678,30 @@
             list_positions = list_positions + self.get_vertices_of_line(list_polyline[i])
         self.delete(list_polyline)
         true_polyline = self.create_polyline(position_list=list_positions, name=name, matname=material)
         return [true_polyline, list_positions]
 
     @pyaedt_function_handler()
     def _make_triple_linked_winding(
-        self,
-        name,
-        material,
-        in_rad,
-        out_rad,
-        height,
-        w_dia,
-        teta,
-        teta_mid_wind,
-        teta_in_wind,
-        turns,
-        turns_mid_wind,
-        turns_in_wind,
-        chamfer,
-        chamf_in_wind,
-        sr,
+            self,
+            name,
+            material,
+            in_rad,
+            out_rad,
+            height,
+            w_dia,
+            teta,
+            teta_mid_wind,
+            teta_in_wind,
+            turns,
+            turns_mid_wind,
+            turns_in_wind,
+            chamfer,
+            chamf_in_wind,
+            sr,
     ):
         list_object = self._make_triple_winding(
             name,
             material,
             in_rad,
             out_rad,
             height,
@@ -2733,29 +2753,29 @@
             list_positions = list_positions + self.get_vertices_of_line(list_polyline[i])
         self.delete(list_polyline)
         true_polyline = self.create_polyline(position_list=list_positions, name=name, matname=material)
         return [true_polyline, list_positions]
 
     @pyaedt_function_handler()
     def _make_double_winding(
-        self,
-        name,
-        material,
-        in_rad,
-        out_rad,
-        height,
-        w_dia,
-        teta,
-        teta_in_wind,
-        turns,
-        turns_in_wind,
-        chamfer,
-        chamf_in_wind,
-        sr,
-        sep_layer,
+            self,
+            name,
+            material,
+            in_rad,
+            out_rad,
+            height,
+            w_dia,
+            teta,
+            teta_in_wind,
+            turns,
+            turns_in_wind,
+            chamfer,
+            chamf_in_wind,
+            sr,
+            sep_layer,
     ):
         chamf = self._make_winding_follow_chamfer(chamfer, sr, w_dia, 3)
         in_rad_in_wind = in_rad + sr * w_dia
         out_rad_in_wind = out_rad - sr * w_dia
         height_in_wind = height - 2 * sr * w_dia
         list_object = [
             self._make_winding(name, material, in_rad, out_rad, height, teta, turns, chamf, sep_layer),
@@ -2771,31 +2791,31 @@
                 sep_layer,
             ),
         ]
         return list_object
 
     @pyaedt_function_handler()
     def _make_triple_winding(
-        self,
-        name,
-        material,
-        in_rad,
-        out_rad,
-        height,
-        w_dia,
-        teta,
-        teta_mid_wind,
-        teta_in_wind,
-        turns,
-        turns_mid_wind,
-        turns_in_wind,
-        chamfer,
-        chamf_in_wind,
-        sr,
-        sep_layer,
+            self,
+            name,
+            material,
+            in_rad,
+            out_rad,
+            height,
+            w_dia,
+            teta,
+            teta_mid_wind,
+            teta_in_wind,
+            turns,
+            turns_mid_wind,
+            turns_in_wind,
+            chamfer,
+            chamf_in_wind,
+            sr,
+            sep_layer,
     ):
         chamf = self._make_winding_follow_chamfer(chamfer, sr, w_dia, 5)
         chamf_mid_wind = self._make_winding_follow_chamfer(chamfer, sr, w_dia, 3)
         in_rad_in_wind = in_rad + 2 * sr * w_dia
         in_rad_mid_wind = in_rad + sr * w_dia
         out_rad_in_wind = out_rad - 2 * sr * w_dia
         out_rad_mid_wind = out_rad - sr * w_dia
@@ -2925,23 +2945,23 @@
                     if k not in values[key]:
                         self.logger.error("Missing or incorrect key {}.".format(k))
                         return [False, values]
 
         for f_key in values.keys():
             count_true = False
             if (
-                f_key == "Number of Windings"
-                or f_key == "Layer"
-                or f_key == "Layer Type"
-                or f_key == "Similar Layer"
-                or f_key == "Mode"
-                or f_key == "Wire Section"
+                    f_key == "Number of Windings"
+                    or f_key == "Layer"
+                    or f_key == "Layer Type"
+                    or f_key == "Similar Layer"
+                    or f_key == "Mode"
+                    or f_key == "Wire Section"
             ):
                 for s_key in values[f_key].keys():
-                    if type(values[f_key][s_key]) == bool:
+                    if isinstance(values[f_key][s_key], bool):
                         if count_true:
                             values[f_key][s_key] = False
                         if values[f_key][s_key]:
                             count_true = True
                     else:
                         self.logger.error(
                             "A character entered is invalid. The values of the dictionary %s must be boolean" % f_key
@@ -3286,15 +3306,15 @@
                     json.dump(values, outfile)
 
         return [are_inequations_checkable, values]
 
     @pyaedt_function_handler()
     def _make_winding_follow_chamfer(self, chamfer, sr, wire_diameter, layer_number):
         w_rad_inc = layer_number * sr * wire_diameter / 2
-        distance = sqrt(2 * w_rad_inc**2) - w_rad_inc + sqrt(2 * chamfer**2) / 2
+        distance = sqrt(2 * w_rad_inc ** 2) - w_rad_inc + sqrt(2 * chamfer ** 2) / 2
         return sqrt(2) * distance
 
     @pyaedt_function_handler()
     def _check_value_type(self, taken_value, value_type, are_inequations_checkable, part_message1, part_message2):
         are_inequations_checkable = are_inequations_checkable
         if value_type == int:
             try:
```

### Comparing `pyaedt-0.8.7/pyaedt/modeler/cad/component_array.py` & `pyaedt-0.8.8/pyaedt/modeler/cad/component_array.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/modeler/cad/components_3d.py` & `pyaedt-0.8.8/pyaedt/modeler/cad/components_3d.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,14 +4,15 @@
 import os
 import random
 import re
 import warnings
 
 from pyaedt import Edb
 from pyaedt import pyaedt_function_handler
+from pyaedt.generic.desktop_sessions import _edb_sessions
 from pyaedt.generic.general_methods import _uname
 from pyaedt.modeler.cad.elements3d import BinaryTreeNode
 from pyaedt.modeler.cad.elements3d import _dict2arg
 
 
 class UserDefinedComponentParameters(dict):
     def __setitem__(self, key, value):
@@ -889,15 +890,15 @@
             project_name = project.GetName()
             project.GetDesigns()[0].GetName()
             design_name = project.GetDesigns()[0].GetName()
             # if is_linux:
             #     design_name = project.GetDesigns()[0].GetName()
             # else:
             #     design_name = project.GetActiveDesign().GetName()
-            return get_pyaedt_app(project_name, design_name)
+            return get_pyaedt_app(project_name, design_name, desktop=self._primitives._app.desktop_class)
         return False
 
 
 class LayoutComponent(object):
     """Manages object attributes for Layout components.
 
     Parameters
@@ -917,18 +918,66 @@
         self._show_layout = None
         self._fast_transformation = None
         self._show_dielectric = None
         self._display_mode = None
         self.layers = {}
         self.nets = {}
         self.objects = {}
-        if self.edb_definition:
+        self._edb_object = None
+        self._edb_path = None
+        if self.edb_definition and self.edb_path:
             self._get_edb_info()
 
     @property
+    def edb_path(self):
+        """EDB path.
+
+        Returns
+        -------
+        str
+           EDB file path.
+
+        """
+        return self._edb_path
+
+    @property
+    def edb_object(self):
+        """EDB object.
+
+        Returns
+        -------
+        :class:`pyaedt.edb.Edb`
+           EDB object.
+
+        """
+        if not self._edb_object:
+            aedb_component_path = self._edb_path
+
+            for edb_object in _edb_sessions:
+                if edb_object.edbpath == aedb_component_path:
+                    self._edb_object = edb_object
+                    return self._edb_object
+
+            if not aedb_component_path or not os.path.exists(aedb_component_path):  # pragma: no cover
+                return False
+
+            app = Edb(
+                edbpath=aedb_component_path,
+                isreadonly=False,
+                edbversion=self._primitives._app._aedt_version,
+                student_version=self._primitives._app.student_version,
+            )
+
+            _edb_sessions.append(app)
+
+            self._edb_object = app
+
+        return self._edb_object
+
+    @property
     def edb_definition(self):
         """Edb definition.
 
         Returns
         -------
         str
            EDB definition.
@@ -936,14 +985,28 @@
         """
         key = "EDB Definition"
         if key in self._primitives._app.get_oo_properties(self._primitives.oeditor, self._component.definition_name):
             edb_definition = self._primitives._app.get_oo_property_value(
                 self._primitives.oeditor, self._component.definition_name, key
             )
             self._edb_definition = edb_definition
+            aedb_folder = os.path.abspath(
+                os.path.join(
+                    self._primitives._app.project_path,
+                    self._primitives._app.project_name + ".aedb",
+                    "LayoutComponents",
+                    edb_definition,
+                )
+            )
+            if os.path.exists(aedb_folder):
+                subdirs = next(os.walk(aedb_folder))[1]
+                for subdir in subdirs:
+                    if subdir.endswith(".aedb"):
+                        self._edb_path = os.path.abspath(os.path.join(aedb_folder, subdir))
+                        break
             return edb_definition
         else:
             return None
 
     @property
     def show_layout(self):
         """Show layout flag.
@@ -1054,43 +1117,37 @@
         if isinstance(display_mode, int) and key in self._primitives._app.get_oo_properties(
             self._primitives.oeditor, self._name
         ):
             self._primitives.oeditor.GetChildObject(self._name).SetPropValue(key, display_mode)
             self._display_mode = display_mode
 
     @pyaedt_function_handler()
-    def _get_edb_info(self):
-        """Get Edb information."""
-
-        # Open Layout component and get information
-        aedb_component_path = os.path.join(
-            self._primitives._app.project_file[:-1] + "b",
-            "LayoutComponents",
-            self._edb_definition,
-            self._edb_definition + ".aedb",
-        )
-
-        if not os.path.exists(aedb_component_path):  # pragma: no cover
+    def close_edb_object(self):
+        """Close EDB object."""
+        if self.edb_object:
+            try:
+                self.edb_object.close()
+                return True
+            except Exception:  # pragma: no cover
+                self._logger.error("EDB object cannot be closed.")
+                return False
+        else:  # pragma: no cover
+            self._logger.warning("EDB object was not created.")
             return False
 
-        component_obj = Edb(
-            edbpath=aedb_component_path,
-            isreadonly=True,
-            edbversion=self._primitives._app._aedt_version,
-            student_version=self._primitives._app.student_version,
-        )
-
-        # Get objects, nets and layers
-        self.nets = {key: [True, False, 60] for key in component_obj.nets.netlist}
-        self.layers = {key: [True, False, 60] for key in list(component_obj.stackup.stackup_layers.keys())}
-        self.objects = {key: [True, False, 60] for key in list(component_obj.components.instances.keys())}
-
-        component_obj.close_edb()
-
-        return True
+    @pyaedt_function_handler()
+    def _get_edb_info(self):
+        """Get EDB information."""
+        if self.edb_object:
+            self.nets = {key: [True, False, 60] for key in self.edb_object.nets.netlist}
+            self.layers = {key: [True, False, 60] for key in list(self.edb_object.stackup.stackup_layers.keys())}
+            self.objects = {key: [True, False, 60] for key in list(self.edb_object.components.instances.keys())}
+            return True
+        else:  # pragma: no cover
+            return False
 
     @pyaedt_function_handler()
     def update_visibility(self):
         """Update layer visibility.
 
         Returns
         -------
```

### Comparing `pyaedt-0.8.7/pyaedt/modeler/cad/elements3d.py` & `pyaedt-0.8.8/pyaedt/modeler/cad/elements3d.py`

 * *Files 0% similar despite different names*

```diff
@@ -46,23 +46,23 @@
                 arg_out.append([i for i in v])
         elif isinstance(v, (OrderedDict, dict)):
             arg = ["NAME:" + k]
             _dict2arg(v, arg)
             arg_out.append(arg)
         elif v is None:
             arg_out.append(["NAME:" + k])
-        elif type(v) is list and len(v) > 0 and isinstance(v[0], (OrderedDict, dict)):
+        elif isinstance(v, list) and len(v) > 0 and isinstance(v[0], (OrderedDict, dict)):
             for el in v:
                 arg = ["NAME:" + k]
                 _dict2arg(el, arg)
                 arg_out.append(arg)
 
         else:
             arg_out.append(k + ":=")
-            if type(v) is EdgePrimitive or type(v) is FacePrimitive or type(v) is VertexPrimitive:
+            if isinstance(v, (EdgePrimitive, FacePrimitive, VertexPrimitive)):
                 arg_out.append(v.id)
             else:
                 arg_out.append(v)
 
 
 class EdgeTypePrimitive(object):
     """Provides common methods for EdgePrimitive and FacePrimitive."""
@@ -901,18 +901,16 @@
             n = [0, 1, 0]
         elif cv2[1] == cv1[1] == 0.0 and cv2[2] == cv1[2] == 0.0:
             n = [1, 0, 0]
         else:
             n = GeometryOperators.v_cross(cv1, cv2)
         normal = GeometryOperators.normalize_vector(n)
 
-        """
-        Try to move the face center twice, the first with the normal vector, and the second with its inverse.
-        Measures which is closer to the center point of the bounding box.
-        """
+        # Try to move the face center twice, the first with the normal vector, and the second with its inverse.
+        # Measures which is closer to the center point of the bounding box.
         inv_norm = [-i for i in normal]
         mv1 = GeometryOperators.v_sum(fc, normal)
         mv2 = GeometryOperators.v_sum(fc, inv_norm)
         bb_center = GeometryOperators.get_mid_point(self._object3d.bounding_box[0:3], self._object3d.bounding_box[3:6])
         d1 = GeometryOperators.points_distance(mv1, bb_center)
         d2 = GeometryOperators.points_distance(mv2, bb_center)
         if d1 > d2:
@@ -925,15 +923,15 @@
         """Return a new object from the selected face.
 
         Returns
         -------
         :class:`pyaedt.modeler.cad.object3d.Object3d`
             3D object.
         non_model : bool, optional
-            Either if create the new object as model or non-model. Default is `False`.
+            Either to create the new object as model or non-model. Default is ``False``.
 
         References
         ----------
 
         >>> oEditor.CreateObjectFromFaces
         """
         return self._object3d._primitives.create_object_from_face(self, non_model)
```

### Comparing `pyaedt-0.8.7/pyaedt/modeler/cad/object3d.py` & `pyaedt-0.8.8/pyaedt/modeler/cad/object3d.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 # -*- coding: utf-8 -*-
 """
 This module contains these classes: `Components3DLayout`,`CircuitComponent',
 `EdgePrimitive`, `EdgeTypePrimitive`, `FacePrimitive`, `Geometries3DLayout`,
-`Nets3DLayout`, `Objec3DLayout`, `Object3d`, `Padstack`, `PDSHole`, `PDSLayer`,
+`Nets3DLayout`, `Object3DLayout`, `Object3d`, `Padstack`, `PDSHole`, `PDSLayer`,
 `Pins3DLayout', and `VertexPrimitive`.
 
 This module provides methods and data structures for managing all properties of
-objects (points, lines, sheeets, and solids) within the AEDT 3D Modeler.
+objects (points, lines, sheets, and solids) within the AEDT 3D Modeler.
 
 """
 from __future__ import absolute_import  # noreorder
 
 import os
 import re
 
@@ -689,15 +689,15 @@
             result = sorted(result, key=lambda tup: tup[0])
             return result[-1][1]
         except Exception:
             return None
 
     @property
     def bottom_edge_y(self):
-        """Bottom edge in the X direction of the object. Midpoint is used as criteria to find the edge.
+        """Bottom edge in the Y direction of the object. Midpoint is used as criteria to find the edge.
 
         Returns
         -------
         :class:`pyaedt.modeler.elements3d.EdgePrimitive`
 
         """
         try:
```

### Comparing `pyaedt-0.8.7/pyaedt/modeler/cad/polylines.py` & `pyaedt-0.8.8/pyaedt/modeler/cad/polylines.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/modeler/calculators.py` & `pyaedt-0.8.8/pyaedt/modeler/calculators.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/modeler/circuits/PrimitivesCircuit.py` & `pyaedt-0.8.8/pyaedt/modeler/circuits/PrimitivesCircuit.py`

 * *Files 1% similar despite different names*

```diff
@@ -229,15 +229,15 @@
         comp_id = "CompInst@" + name + ";" + str(id_num) + ";395"
         arg1 = ["Name:Selections", "Selections:=", [comp_id]]
         self.oeditor.AddPinIPorts(arg1)
         self.refresh_all_ids()
         return True
 
     @pyaedt_function_handler()
-    def create_interface_port(self, name, location=[], angle=0):
+    def create_interface_port(self, name, location=None, angle=0):
         """Create an interface port.
 
         Parameters
         ----------
         name : str
             Name of the port.
         location : list, optional
@@ -251,30 +251,33 @@
             Circuit Excitation Object.
 
         References
         ----------
 
         >>> oEditor.CreateIPort
         """
-        if name in self._app.excitation_names:
+        if location is None:
+            location = []
+
+        if name in self._app.excitations:
             self.logger.warning("Port name already assigned.")
             return False
 
         xpos, ypos = self._get_location(location)
         id = self.create_unique_id()
         arg1 = ["NAME:IPortProps", "Name:=", name, "Id:=", id]
         arg2 = ["NAME:Attributes", "Page:=", 1, "X:=", xpos, "Y:=", ypos, "Angle:=", angle, "Flip:=", False]
         id = self.oeditor.CreateIPort(arg1, arg2)
 
         id = int(id.split(";")[1])
         self.add_id_to_component(id)
         # return id, self.components[id].composed_name
         for el in self.components:
             if ("IPort@" + name + ";" + str(id)) in self.components[el].composed_name:
-                return self._app.excitations[name]
+                return self._app.excitation_objects[name]
         return False
 
     @pyaedt_function_handler()
     def create_page_port(self, name, location=[], angle=0):
         """Create a page port.
 
         Parameters
@@ -305,15 +308,15 @@
         )
         id = int(id.split(";")[1])
         # self.refresh_all_ids()
         self.add_id_to_component(id)
         return self.components[id]
 
     @pyaedt_function_handler()
-    def create_gnd(self, location=[], angle=0):
+    def create_gnd(self, location=None, angle=0):
         """Create a ground.
 
         Parameters
         ----------
         location : list, optional
             Position on the X and Y axis. The default is ``None``.
         angle : optional
@@ -324,14 +327,17 @@
         :class:`pyaedt.modeler.cad.object3dcircuit.CircuitComponent`
             Circuit Component Object.
 
         References
         ----------
         >>> oEditor.CreateGround
         """
+        if location is None:
+            location = []
+
         xpos, ypos = self._get_location(location)
         id = self.create_unique_id()
 
         name = self.oeditor.CreateGround(
             ["NAME:GroundProps", "Id:=", id],
             ["NAME:Attributes", "Page:=", 1, "X:=", xpos, "Y:=", ypos, "Angle:=", angle, "Flip:=", False],
         )
@@ -626,15 +632,15 @@
         self.o_component_manager.Add(arg)
         return model_name
 
     @pyaedt_function_handler()
     def create_touchstone_component(
         self,
         model_name,
-        location=[],
+        location=None,
         angle=0,
         show_bitmap=True,
     ):
         """Create a component from a Touchstone model.
 
         Parameters
         ----------
@@ -666,14 +672,16 @@
 
         >>> from pyaedt import Circuit
         >>> cir = Circuit()
         >>> comps = cir.modeler.components
         >>> s_parameter_path = os.path.join("your_path", "s_param_file_name.s4p")
         >>> circuit_comp = comps.create_touchstone_component(s_parameter_path, location=[0.0, 0.0], show_bitmap=False)
         """
+        if location is None:
+            location = []
         xpos, ypos = self._get_location(location)
         id = self.create_unique_id()
         if os.path.exists(model_name):
             model_name = self.create_model_from_touchstone(model_name, show_bitmap=show_bitmap)
         arg1 = ["NAME:ComponentProps", "Name:=", model_name, "Id:=", str(id)]
         arg2 = ["NAME:Attributes", "Page:=", 1, "X:=", xpos, "Y:=", ypos, "Angle:=", angle, "Flip:=", False]
         id = self.oeditor.CreateComponent(arg1, arg2)
@@ -1227,15 +1235,15 @@
     def props(self):
         """Retrieve the component properties."""
         if not self._props:
             self._props = load_keyword_in_aedt_file(self.file_name, self.name)
         return self._props
 
     @pyaedt_function_handler()
-    def place(self, inst_name, location=[], angle=0, use_instance_id_netlist=False):
+    def place(self, inst_name, location=None, angle=0, use_instance_id_netlist=False):
         """Create a component from a library.
 
         Parameters
         ----------
         inst_name : str, optional
             Name of the instance. The default is ``None.``
         location : list of float, optional
@@ -1252,14 +1260,16 @@
             Circuit Component Object.
 
         References
         ----------
 
         >>> oEditor.CreateComponent
         """
+        if location is None:
+            location = []
         return self._component_manager.create_component(
             inst_name=inst_name,
             component_library=self.component_library,
             component_name=self.name,
             location=location,
             angle=angle,
             use_instance_id_netlist=use_instance_id_netlist,
```

### Comparing `pyaedt-0.8.7/pyaedt/modeler/circuits/PrimitivesEmit.py` & `pyaedt-0.8.8/pyaedt/modeler/circuits/PrimitivesEmit.py`

 * *Files 1% similar despite different names*

```diff
@@ -1129,32 +1129,34 @@
             sampling_props["SpecifyPercentage"] = "false"
             sampling_props["NumberChannels"] = "1000"
         if seed is not None:
             sampling_props["RandomSeed"] = "{}".format(seed)
         self._set_prop_value(sampling_props)
 
     @pyaedt_function_handler()
-    def _set_prop_value(self, props={}):
+    def _set_prop_value(self, props=None):
         """Sets the property values for this node.
 
         Parameters
         ----------
         props : dict
             Sets the property values for this node to the
             values specified in the dictionary.
 
         Returns
         -------
         None
         """
+        if props is None:
+            props = {}
         comp_name = self.parent_component.name
         prop_list = ["NAME:properties"]
         for prop_name, value in props.items():
             prop_list.append("{}:=".format(prop_name))
-            if type(value) is not str:
+            if not isinstance(value, str):
                 raise TypeError("Value for key {} is not a string.".format(prop_name))
             prop_list.append(value)
         properties_to_set = [
             ["NAME:node", "fullname:=", self.node_name, prop_list],
             [],  # Property does not get set without this empty list
         ]
         nodes_to_delete = []  # No nodes to delete
```

### Comparing `pyaedt-0.8.7/pyaedt/modeler/circuits/PrimitivesMaxwellCircuit.py` & `pyaedt-0.8.8/pyaedt/modeler/circuits/PrimitivesMaxwellCircuit.py`

 * *Files 2% similar despite different names*

```diff
@@ -138,15 +138,15 @@
         )
 
         id.set_property("L", value)
         id.set_property("Name", compname)
         return id
 
     @pyaedt_function_handler()
-    def create_capacitor(self, compname=None, value=50, location=[], angle=0, use_instance_id_netlist=False):
+    def create_capacitor(self, compname=None, value=50, location=None, angle=0, use_instance_id_netlist=False):
         """Create a capacitor.
 
         Parameters
         ----------
         compname : str, optional
             Name of the capacitor. The default is ``None``.
         value : float, optional
@@ -164,14 +164,16 @@
             Circuit Component Object.
 
         References
         ----------
 
         >>> oEditor.CreateComponent
         """
+        if location is None:
+            location = []
         id = self.create_component(
             compname,
             component_library="Passive Elements",
             component_name="Cap",
             location=location,
             angle=angle,
             use_instance_id_netlist=use_instance_id_netlist,
@@ -218,15 +220,15 @@
             use_instance_id_netlist=use_instance_id_netlist,
         )
 
         id.set_property("Name", compname)
         return id
 
     @pyaedt_function_handler()
-    def create_winding(self, compname=None, location=[], angle=0, use_instance_id_netlist=False):
+    def create_winding(self, compname=None, location=None, angle=0, use_instance_id_netlist=False):
         """Create an NPN transistor.
 
         Parameters
         ----------
         compname : str, optional
             Name of the NPN transistor. The default is ``None``.
         location : list of float, optional
@@ -242,14 +244,16 @@
             Circuit Component Object.
 
         References
         ----------
 
         >>> oEditor.CreateComponent
         """
+        if location is None:
+            location = []
         id = self.create_component(
             compname,
             component_library="Dedicated Elements",
             component_name="Winding",
             location=location,
             angle=angle,
             use_instance_id_netlist=use_instance_id_netlist,
```

### Comparing `pyaedt-0.8.7/pyaedt/modeler/circuits/PrimitivesNexxim.py` & `pyaedt-0.8.8/pyaedt/modeler/circuits/PrimitivesNexxim.py`

 * *Files 1% similar despite different names*

```diff
@@ -50,15 +50,15 @@
             Part ID or object name.
 
         Returns
         -------
         :class:`pyaedt.modeler.cad.object3dcircuit.CircuitComponent`
             Circuit Component Object.
         """
-        if type(partname) is int:
+        if isinstance(partname, int):
             return self.components[partname]
         for el in self.components:
             if self.components[el].name == partname or self.components[el].composed_name == partname or el == partname:
                 return self.components[el]
 
         return None
 
@@ -597,15 +597,15 @@
         self.refresh_all_ids()
         for el in self.components:
             if component_name in self.components[el].composed_name:
                 return el, self.components[el].composed_name
         return False
 
     @pyaedt_function_handler()
-    def create_resistor(self, compname=None, value=50, location=[], angle=0, use_instance_id_netlist=False):
+    def create_resistor(self, compname=None, value=50, location=None, angle=0, use_instance_id_netlist=False):
         """Create a resistor.
 
         Parameters
         ----------
         compname : str, optional
             Name of the resistor. The default is ``None``.
         value : float, optional
@@ -624,23 +624,25 @@
             Circuit Component Object.
 
         References
         ----------
 
         >>> oEditor.CreateComponent
         """
+        if location is None:
+            location = []
         cmpid = self.create_component(
             compname, location=location, angle=angle, use_instance_id_netlist=use_instance_id_netlist
         )
 
         cmpid.set_property("R", value)
         return cmpid
 
     @pyaedt_function_handler()
-    def create_inductor(self, compname=None, value=50, location=[], angle=0, use_instance_id_netlist=False):
+    def create_inductor(self, compname=None, value=50, location=None, angle=0, use_instance_id_netlist=False):
         """Create an inductor.
 
         Parameters
         ----------
         compname : str, optional
             Name of the inductor. The default is ``None``.
         value : float, optional
@@ -659,14 +661,16 @@
             Circuit Component Object.
 
         References
         ----------
 
         >>> oEditor.CreateComponent
         """
+        if location is None:
+            location = []
         cmpid = self.create_component(
             compname,
             component_library="Inductors",
             component_name="IND_",
             location=location,
             angle=angle,
             use_instance_id_netlist=use_instance_id_netlist,
@@ -803,15 +807,17 @@
             use_instance_id_netlist=use_instance_id_netlist,
         )
 
         cmpid.set_property("Name", probe_name)
         return cmpid
 
     @pyaedt_function_handler()
-    def create_current_pulse(self, compname=None, value_lists=[], location=[], angle=0, use_instance_id_netlist=False):
+    def create_current_pulse(
+        self, compname=None, value_lists=None, location=None, angle=0, use_instance_id_netlist=False
+    ):
         """Create a current pulse.
 
         Parameters
         ----------
         compname : str, optional
             Name of the current pulse. The default is ``None``.
         value_lists : list, optional
@@ -830,14 +836,18 @@
             Circuit Component Object.
 
         References
         ----------
 
         >>> oEditor.CreateComponent
         """
+        if value_lists is None:
+            value_lists = []
+        if location is None:
+            location = []
         cmpid = self.create_component(
             compname,
             component_library="Independent Sources",
             component_name="I_PULSE",
             location=location,
             angle=angle,
             use_instance_id_netlist=use_instance_id_netlist,
@@ -857,15 +867,17 @@
             cmpid.set_property("PW", value_lists[5])
         if len(value_lists) > 6:
             cmpid.set_property("PER", value_lists[6])
 
         return cmpid
 
     @pyaedt_function_handler()
-    def create_voltage_pulse(self, compname=None, value_lists=[], location=[], angle=0, use_instance_id_netlist=False):
+    def create_voltage_pulse(
+        self, compname=None, value_lists=None, location=None, angle=0, use_instance_id_netlist=False
+    ):
         """Create a voltage pulse.
 
         Parameters
         ----------
         compname : str, optional
             Name of the voltage pulse. The default is ``None``.
         value_lists : list, optional
@@ -884,14 +896,18 @@
             Circuit Component Object.
 
         References
         ----------
 
         >>> oEditor.CreateComponent
         """
+        if value_lists is None:
+            value_lists = []
+        if location is None:
+            location = []
         cmpid = self.create_component(
             compname,
             component_library="Independent Sources",
             component_name="V_PULSE",
             location=location,
             angle=angle,
             use_instance_id_netlist=use_instance_id_netlist,
@@ -966,15 +982,15 @@
                 for nr, pair in enumerate(zip(time_list, voltage_list)):
                     cmpid.set_property(property_name="time" + str(nr + 1), property_value=pair[0])
                     cmpid.set_property(property_name="val" + str(nr + 1), property_value=pair[1])
 
         return cmpid
 
     @pyaedt_function_handler()
-    def create_current_dc(self, compname=None, value=1, location=[], angle=0, use_instance_id_netlist=False):
+    def create_current_dc(self, compname=None, value=1, location=None, angle=0, use_instance_id_netlist=False):
         """Create a current DC source.
 
         Parameters
         ----------
         compname : str, optional
             Name of the current DC source. The default is ``None``.
         value : float, optional
@@ -993,14 +1009,16 @@
             Circuit Component Object.
 
         References
         ----------
 
         >>> oEditor.CreateComponent
         """
+        if location is None:
+            location = []
         cmpid = self.create_component(
             compname,
             component_library="Independent Sources",
             component_name="I_DC",
             location=location,
             angle=angle,
             use_instance_id_netlist=use_instance_id_netlist,
@@ -1056,15 +1074,15 @@
 
         cmpid.set_property("Inductor1", l1)
         cmpid.set_property("Inductor2", l2)
         cmpid.set_property("CouplingFactor", value)
         return cmpid
 
     @pyaedt_function_handler()
-    def create_diode(self, compname=None, model_name="required", location=[], angle=0, use_instance_id_netlist=False):
+    def create_diode(self, compname=None, model_name="required", location=None, angle=0, use_instance_id_netlist=False):
         """Create a diode.
 
         Parameters
         ----------
         compname : str
             Name of the diode. The default is ``None``.
         model_name : str, optional
@@ -1083,28 +1101,30 @@
             Circuit Component Object.
 
         References
         ----------
 
         >>> oEditor.CreateComponent
         """
+        if location is None:
+            location = []
         cmpid = self.create_component(
             compname,
             component_library="Diodes",
             component_name="DIODE_Level1",
             location=location,
             angle=angle,
             use_instance_id_netlist=use_instance_id_netlist,
         )
 
         cmpid.set_property("MOD", model_name)
         return cmpid
 
     @pyaedt_function_handler()
-    def create_npn(self, compname=None, value=None, location=[], angle=0, use_instance_id_netlist=False):
+    def create_npn(self, compname=None, value=None, location=None, angle=0, use_instance_id_netlist=False):
         """Create an NPN transistor.
 
         Parameters
         ----------
         compname : str
             Name of the NPN transistor. The default is ``None``.
         value : float, optional
@@ -1123,28 +1143,30 @@
             Circuit Component Object.
 
         References
         ----------
 
         >>> oEditor.CreateComponent
         """
+        if location is None:
+            location = []
         id = self.create_component(
             compname,
             component_library="BJTs",
             component_name="Level01_NPN",
             location=location,
             angle=angle,
             use_instance_id_netlist=use_instance_id_netlist,
         )
         if value:
             id.set_property("MOD", value)
         return id
 
     @pyaedt_function_handler()
-    def create_pnp(self, compname=None, value=50, location=[], angle=0, use_instance_id_netlist=False):
+    def create_pnp(self, compname=None, value=50, location=None, angle=0, use_instance_id_netlist=False):
         """Create a PNP transistor.
 
         Parameters
         ----------
         compname : str
             Name of the PNP transistor. The default is ``None``.
         value : float, optional
@@ -1163,14 +1185,16 @@
             Circuit Component Object.
 
         References
         ----------
 
         >>> oEditor.CreateComponent
         """
+        if location is None:
+            location = []
         id = self.create_component(
             compname,
             component_library="BJTs",
             component_name="Level01_PNP",
             location=location,
             angle=angle,
             use_instance_id_netlist=use_instance_id_netlist,
```

### Comparing `pyaedt-0.8.7/pyaedt/modeler/circuits/PrimitivesTwinBuilder.py` & `pyaedt-0.8.8/pyaedt/modeler/circuits/PrimitivesTwinBuilder.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/modeler/circuits/object3dcircuit.py` & `pyaedt-0.8.8/pyaedt/modeler/circuits/object3dcircuit.py`

 * *Files 4% similar despite different names*

```diff
@@ -128,32 +128,37 @@
         if move_y:
             deltay = point[1] + delta
         else:
             deltay = point[1]
         return deltax, deltay
 
     @pyaedt_function_handler()
-    def connect_to_component(self, component_pin, page_name=None, use_wire=False, wire_name="", clearance_units=1):
+    def connect_to_component(
+        self, component_pin, page_name=None, use_wire=False, wire_name="", clearance_units=1, page_port_angle=None
+    ):
         """Connect schematic components.
 
         Parameters
         ----------
         component_pin : :class:`pyaedt.modeler.circuits.PrimitivesNexxim.CircuitPins`
            Component pin to attach.
         page_name : str, optional
             Page port name. The default value is ``None``, in which case
             a name is automatically generated.
         use_wire : bool, optional
             Whether to use wires or a page port to connect the pins.
             The default is ``False``, in which case a page port is used. Note
             that if wires are used but not well placed, shorts can result.
         wire_name : str, optional
-            Wire name used only when user_wire is ``True``. Default value is ``""``.
+            Wire name used only when ``user_wire=True``. The default is ``""``.
         clearance_units : int, optional
             Number of snap units (100mil each) around the object to overcome pins and wires.
+        page_port_angle : int, optional
+            Page port angle on the source pin. The default is ``None``, in which case
+            the angle is automatically computed.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         References
@@ -268,15 +273,17 @@
                         continue
         try:
             x_loc = AEDT_UNITS["Length"][decompose_variable_value(self._circuit_comp.location[0])[1]] * float(
                 decompose_variable_value(self._circuit_comp.location[1])[0]
             )
         except Exception:
             x_loc = float(self._circuit_comp.location[0])
-        if self.location[0] < x_loc:
+        if page_port_angle is not None:
+            angle = page_port_angle * math.pi / 180
+        elif self.location[0] < x_loc:
             angle = comp_angle
         else:
             angle = math.pi + comp_angle
         ret1 = self._circuit_comp._circuit_components.create_page_port(page_name, self.location, angle=angle)
         for cmp in component_pin:
             try:
                 x_loc = AEDT_UNITS["Length"][decompose_variable_value(cmp._circuit_comp.location[0])[1]] * float(
@@ -291,15 +298,15 @@
                 angle = comp_pin_angle
             else:
                 angle = math.pi + comp_pin_angle
             ret2 = self._circuit_comp._circuit_components.create_page_port(
                 page_name, location=cmp.location, angle=angle
             )
         if ret1 and ret2:
-            return True
+            return True, ret1, ret2
         else:
             return False
 
 
 class ComponentParameters(dict):
     """Manages component parameters."""
 
@@ -324,15 +331,15 @@
                     != value
                 ):
                     try:
                         self._component._oeditor.SetPropertyValue(
                             self._tab, self._component.composed_name, key, str(value)
                         )
                         dict.__setitem__(self, key, value)
-                    except:
+                    except Exception:
                         self._component._circuit_components.logger.warning(
                             "Property %s has not been edited.Check if readonly", key
                         )
                 dict.__setitem__(self, key, value)
             except Exception:
                 self._component._circuit_components.logger.warning(
                     "Property %s has not been edited. Check if read-only.", key
@@ -777,15 +784,15 @@
             ``True`` when successful, ``False`` when failed.
 
         References
         ----------
 
         >>> oEditor.ChangeProperty
         """
-        if type(property_name) is list:
+        if isinstance(property_name, list):
             for p, v in zip(property_name, property_value):
                 v_prop = ["NAME:" + p, "Value:=", v]
                 self.change_property(v_prop)
                 if self.__dict__.get("_parameters", None) and p in self.__dict__["_parameters"]:
                     self.__dict__["_parameters"][p] = v
                 else:
                     self.__dict__[p] = v
```

### Comparing `pyaedt-0.8.7/pyaedt/modeler/geometry_operators.py` & `pyaedt-0.8.8/pyaedt/modeler/geometry_operators.py`

 * *Files 1% similar despite different names*

```diff
@@ -70,15 +70,15 @@
 
         Use the optional argument ``scale_to_unit`` to specify the destination unit.
 
         >>> go.parse_dim_arg('2mm', scale_to_unit='mm')
         >>> 2.0
 
         """
-        if type(string) is not str:
+        if not isinstance(string, str):
             try:
                 return float(string)
             except ValueError:  # pragma: no cover
                 raise TypeError("Input argument is not string nor number")
         sunit = 1.0
         if scale_to_unit:
             sunit = scale_units(scale_to_unit)
@@ -708,15 +708,15 @@
             List of ``[x, y, z]`` coordinates for the first point of the other segment.
         b2 : List
             List of ``[x, y, z]`` coordinates for the second point of the other segment.
 
         Returns
         -------
         bool
-            ``True`` when the projected segment is inside the other segmennt, ``False`` otherwise.
+            ``True`` when the projected segment is inside the other segment, ``False`` otherwise.
 
         """
         if not GeometryOperators.is_parallel(a1, a2, b1, b2):
             return False
         d = GeometryOperators.distance_vector(a1, b1, b2)
         a1n = GeometryOperators.v_sum(a1, d)
         a2n = GeometryOperators.v_sum(a2, d)
@@ -1347,15 +1347,15 @@
 
         return [x_pointing, y_pointing]
 
     @staticmethod
     @pyaedt_function_handler()
     def get_numeric(s):
         """Convert a string to a numeric value. Discard the suffix."""
-        if type(s) == str:
+        if isinstance(s, str):
             if s == "Global":
                 return 0.0
             else:
                 return float("".join(c for c in s if c.isdigit() or c == "."))
         elif s is None:
             return 0.0
         else:
@@ -1385,22 +1385,22 @@
         """Return a list of [x,y,z] numeric values given a coordinate system as input.
 
         Parameters
         ----------
         cs_in : List of str or str
             ``["x", "y", "z"]`` or "Global".
         """
-        if type(cs_in) is str:
+        if isinstance(cs_in, str):
             if cs_in == "Global":
                 return [0.0, 0.0, 0.0]
             else:
                 return None
-        elif type(cs_in) is list:
+        elif isinstance(cs_in, list):
             if len(cs_in) == 3:
-                return [GeometryOperators.get_numeric(s) if type(s) is str else s for s in cs_in]
+                return [GeometryOperators.get_numeric(s) if isinstance(s, str) else s for s in cs_in]
             else:
                 return [0, 0, 0]
 
     @staticmethod
     @pyaedt_function_handler()
     def orient_polygon(x, y, clockwise=True):
         """
@@ -1554,14 +1554,16 @@
     @staticmethod
     @pyaedt_function_handler()
     def point_in_polygon(point, polygon, tolerance=1e-8):
         """Determine if a point is inside, outside the polygon or at exactly at the border.
 
         The method implements the radial algorithm (https://es.wikipedia.org/wiki/Algoritmo_radial)
 
+        This version supports also self-intersecting polygons.
+
         point : List
             List of ``[x, y]`` coordinates.
         polygon : List
             [[x1, x2, ..., xn],[y1, y2, ..., yn]]
         tolerance : float
             tolerance used for the algorithm. Default value is 1e-8.
 
@@ -1587,17 +1589,18 @@
                 return 0  # point is one of polyline vertices
             vpj = GeometryOperators.v_points(point, vj)
             vpi = GeometryOperators.v_points(point, vi)
             a = GeometryOperators.v_angle_sign_2D(vpj, vpi)
             if abs(abs(a) - math.pi) < tol:
                 return 0
             asum += a
+        r = asum % (2*math.pi)
         if abs(asum) < tol:
             return -1
-        elif abs(abs(asum) - 2*math.pi) < tol:
+        elif r < tol or (2*math.pi - r) < tol:
             return 1
         else:  # pragma: no cover
             raise Exception("Unexpected error!")
         # fmt: on
 
     @staticmethod
     @pyaedt_function_handler()
```

### Comparing `pyaedt-0.8.7/pyaedt/modeler/modeler2d.py` & `pyaedt-0.8.8/pyaedt/modeler/modeler2d.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/modeler/modeler3d.py` & `pyaedt-0.8.8/pyaedt/modeler/modeler3d.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,14 +5,15 @@
 import json
 import os.path
 import warnings
 
 from pyaedt.application.Variables import generate_validation_errors
 from pyaedt.generic.general_methods import GrpcApiError
 from pyaedt.generic.general_methods import generate_unique_name
+from pyaedt.generic.general_methods import open_file
 from pyaedt.generic.general_methods import pyaedt_function_handler
 from pyaedt.modeler.cad.Primitives3D import Primitives3D
 from pyaedt.modeler.geometry_operators import GeometryOperators
 
 
 class Modeler3D(Primitives3D):
     """Provides the Modeler 3D application interface.
@@ -326,15 +327,15 @@
                 monitor_objects = self._app.odesign.GetChildObject("Monitor").GetChildNames()
             if datasets is None:
                 datasets = {}
                 datasets.update(self._app.project_datasets)
                 datasets.update(self._app.design_datasets)
             if native_components is None:
                 native_components = self._app.native_components
-            with open(configfile) as f:
+            with open_file(configfile) as f:
                 config_dict = json.load(f)
             out_dict = {}
             if monitor_objects:
                 out_dict["monitors"] = config_dict["monitors"]
                 to_remove = []
                 for i, mon in enumerate(out_dict["monitors"]):
                     if mon["Name"] not in monitor_objects:
@@ -366,15 +367,15 @@
                                 while config_dict["coordinatesystems"][cs]["Reference CS"] != "Global":
                                     cs = config_dict["coordinatesystems"][cs]["Reference CS"]
                                     cs_set.add(cs)
                 out_dict["coordinatesystems"] = copy.deepcopy(config_dict["coordinatesystems"])
                 for cs in list(out_dict["coordinatesystems"]):
                     if cs not in cs_set:
                         del out_dict["coordinatesystems"][cs]
-            with open(auxiliary_dict, "w") as outfile:
+            with open_file(auxiliary_dict, "w") as outfile:
                 json.dump(out_dict, outfile)
         if not os.path.isdir(os.path.dirname(component_file)):
             self.logger.warning("Folder '" + os.path.dirname(component_file) + "' doesn't exist.")
             if create_folder:  # Folder doesn't exist.
                 os.mkdir(os.path.dirname(component_file))
                 self.logger.warning("Created folder '" + os.path.dirname(component_file) + "'")
             else:
@@ -759,34 +760,34 @@
                 wb = wgmodel + "_W + " + self._arg_with_dim(2 * wg_thickness)
             else:
                 w = self._arg_with_dim(wgwidth)
                 wb = self._arg_with_dim(wgwidth) + " + 2*" + self._arg_with_dim(wg_thickness)
             if wg_direction_axis == self._app.AXIS.Z:
                 airbox = self.create_box(origin, [w, h, wg_length])
 
-                if type(wg_thickness) is str:
+                if isinstance(wg_thickness, str):
                     origin[0] = str(origin[0]) + "-" + wg_thickness
                     origin[1] = str(origin[1]) + "-" + wg_thickness
                 else:
                     origin[0] -= wg_thickness
                     origin[1] -= wg_thickness
 
             elif wg_direction_axis == self._app.AXIS.Y:
                 airbox = self.create_box(origin, [w, wg_length, h])
 
-                if type(wg_thickness) is str:
+                if isinstance(wg_thickness, str):
                     origin[0] = str(origin[0]) + "-" + wg_thickness
                     origin[2] = str(origin[2]) + "-" + wg_thickness
                 else:
                     origin[0] -= wg_thickness
                     origin[2] -= wg_thickness
             else:
                 airbox = self.create_box(origin, [wg_length, w, h])
 
-                if type(wg_thickness) is str:
+                if isinstance(wg_thickness, str):
                     origin[2] = str(origin[2]) + "-" + wg_thickness
                     origin[1] = str(origin[1]) + "-" + wg_thickness
                 else:
                     origin[2] -= wg_thickness
                     origin[1] -= wg_thickness
             centers = [f.center for f in airbox.faces]
             xpos = [i[wg_direction_axis] for i in centers]
@@ -896,15 +897,15 @@
         -------
         List of :class:`pyaedt.modeler.Object3d.Object3d`
         """
         nas_to_dict = {"Points": {}, "PointsId": {}, "Triangles": {}, "Lines": {}, "Solids": {}}
 
         self.logger.reset_timer()
         self.logger.info("Loading file")
-        with open(file_path, "r") as f:
+        with open_file(file_path, "r") as f:
             lines = f.read().splitlines()
             id = 0
             for lk in range(len(lines)):
                 line = lines[lk]
                 line_type = line[:8].strip()
                 if line.startswith("$") or line.startswith("*"):
                     continue
@@ -1085,15 +1086,15 @@
                     out_poly = self.unite(polys, purge=not lines_thickness)
                     if not lines_thickness and out_poly:
                         self.generate_object_history(out_poly)
 
         if import_solids and nas_to_dict["Solids"]:
             self.logger.reset_timer()
             self.logger.info("Loading solids")
-            for solid_pid in nas_to_dict["Solids"].keys():
+            for solid_pid in nas_to_dict["Solids"]:
                 for solid in nas_to_dict["Solids"][solid_pid]:
                     points = [nas_to_dict["Points"][id] for id in solid[1:]]
                     if solid[0] == "CPENTA":
                         element1 = self._app.modeler.create_polyline(
                             position_list=[points[0], points[1], points[2]], close_surface=True, cover_surface=True
                         )
                         element2 = self._app.modeler.create_polyline(
@@ -1236,15 +1237,15 @@
             "center_lat_lon": latitude_longitude,
             "radius": terrain_radius,
             "include_buildings": include_osm_buildings,
             "include_roads": including_osm_roads,
             "parts": parts_dict,
         }
 
-        with open(json_path, "w", encoding="utf-8") as f:
+        with open_file(json_path, "w", encoding="utf-8") as f:
             json.dump(scene, f, indent=4)
 
         self.logger.info("Done...")
         if plot_before_importing:
             import pyvista as pv
 
             self.logger.info("Viewing Geometry...")
@@ -1263,18 +1264,15 @@
 
         if import_in_aedt:
             self.model_units = "meter"
             for part in parts_dict:
                 if not os.path.exists(parts_dict[part]["file_name"]):
                     continue
                 obj_names = [i for i in self.object_names]
-                self.import_3d_cad(
-                    parts_dict[part]["file_name"],
-                    create_lightweigth_part=create_lightweigth_part,
-                )
+                self.import_3d_cad(parts_dict[part]["file_name"], create_lightweigth_part=create_lightweigth_part)
                 added_objs = [i for i in self.object_names if i not in obj_names]
                 if part == "terrain":
                     transparency = 0.2
                     color = [0, 125, 0]
                 elif part == "buildings":
                     transparency = 0.6
                     color = [0, 0, 255]
```

### Comparing `pyaedt-0.8.7/pyaedt/modeler/modelerpcb.py` & `pyaedt-0.8.8/pyaedt/modeler/modelerpcb.py`

 * *Files 0% similar despite different names*

```diff
@@ -209,15 +209,15 @@
         pur = bb.BBoxUR()
         return [pll.GetX(), pll.GetY(), pur.GetX(), pur.GetY()]
 
     @pyaedt_function_handler()
     def _arg_with_dim(self, value, units=None):
         if units is None:
             units = self.model_units
-        if type(value) is str:
+        if isinstance(value, str):
             try:
                 float(value)
                 val = "{0}{1}".format(value, units)
             except Exception:
                 val = value
         else:
             val = "{0}{1}".format(value, units)
@@ -910,15 +910,15 @@
         with open_file(model_path, "r") as f:
             for line in f:
                 if "subckt" in line.lower():
                     pinNames = [i.strip() for i in re.split(" |\t", line) if i]
                     pinNames.remove(pinNames[0])
                     pinNames.remove(pinNames[0])
                     break
-        componentPins = self.components[component_name].pins
+        componentPins = list(self.components[component_name].pins.keys())
         componentPins.reverse()
         if not pin_map:
             pin_map = []
             i = 0
             if len(componentPins) >= len(pinNames):
                 for pn in pinNames:
                     pin_map.append(pn + ":=")
```

### Comparing `pyaedt-0.8.7/pyaedt/modeler/pcb/Primitives3DLayout.py` & `pyaedt-0.8.8/pyaedt/modeler/pcb/Primitives3DLayout.py`

 * *Files 1% similar despite different names*

```diff
@@ -748,15 +748,15 @@
                     if p[0] == "NAME:psd":
                         props = p
                 except Exception:
                     pass
             self._padstacks[name] = Padstack(name, self.opadstackmanager, self.model_units)
 
             for prop in props:
-                if type(prop) is str:
+                if isinstance(prop, str):
                     if prop == "mat:=":
                         self._padstacks[name].mat = props[props.index(prop) + 1]
                     elif prop == "plt:=":
                         self._padstacks[name].plating = props[props.index(prop) + 1]
                     elif prop == "hRg:=":
                         self._padstacks[name].holerange = props[props.index(prop) + 1]
                     elif prop == "sbsh:=":
@@ -1377,22 +1377,15 @@
             Whether if the component is placed on a layer or arbitrary.
         pos_z : float, optional
             Z placement. When enabled, 3d placement will be automatically enabled too.
              The default is ``False``.
 
         Returns
         -------
-
-        """
-        """
-
-        :param component_path:
-        :param number_of_terminals:
-        :param placement_layer:
-        :return:
+            :class:`pyaedt.modeler.pcb.object3dlayout.ComponentsSubCircuit3DLayout`
         """
         if not component_name:
             component_name = os.path.basename(component_path).split(".")[0]
         args = ["NAME:" + component_name]
         infos = [
             "Type:=",
             27,
@@ -1485,14 +1478,68 @@
             if pos_z:
                 comp.location = [arg_x, arg_y, self.modeler._arg_with_dim(pos_z)]
         self.components_3d[comp_name.split(";")[-1]] = comp
         if create_ports:
             self.oeditor.CreatePortsOnComponentsByNet(["NAME:Components", comp.name], [], "Port", "0", "0", "0")
         return comp  #
 
+    @pyaedt_function_handler()
+    def create_component_on_pins(
+        self,
+        pins,
+        definition_name=None,
+        component_type="Other",
+        ref_des="U100",
+    ):
+        """Create a component based on a pin list.
+
+        Parameters
+        ----------
+        pins : list
+            Pins to include in the new component.
+        definition_name : str, optional
+            Name of the component definition. If no name is provided, a
+            name is automatically assigned.
+        component_type : str, optional
+            Component type. The default is ``"Other"``.
+        ref_des : str, optional
+            Reference designator. The default is ``"U100"``.
+
+        Returns
+        -------
+        :class:`pyaedt.modeler.cad.object3dlayout.Components3DLayout`
+
+        """
+        if not definition_name:
+            definition_name = generate_unique_name("COMP")
+        placement_layer = list(self.layers.signals.keys())[0]
+        for pin in self.pins.items():
+            if pin[0] == pins[0]:
+                placement_layer = pin[1].start_layer
+                break
+        comp_name = self.modeler.oeditor.CreateComponent(
+            [
+                "NAME:Contents",
+                "isRCS:=",
+                True,
+                "definition_name:=",
+                definition_name,
+                "type:=",
+                component_type,
+                "ref_des:=",
+                ref_des,
+                "placement_layer:=",
+                placement_layer,
+                "elements:=",
+                pins,
+            ]
+        )
+        comp = Components3DLayout(self, comp_name.split(";")[-1])
+        return comp
+
     def create_text(self, text, position, placement_layer="PostProcessing", angle=0, font_size=12):
         """Create a text primitive object.
 
         Parameters
         ----------
         text : str
             Name for the text primitive object.
```

### Comparing `pyaedt-0.8.7/pyaedt/modeler/pcb/object3dlayout.py` & `pyaedt-0.8.8/pyaedt/modeler/pcb/object3dlayout.py`

 * *Files 0% similar despite different names*

```diff
@@ -11,15 +11,15 @@
 
 from pyaedt import pyaedt_function_handler
 from pyaedt.generic.constants import unit_converter
 from pyaedt.generic.general_methods import _dim_arg
 from pyaedt.modeler.geometry_operators import GeometryOperators
 
 
-class Objec3DLayout(object):
+class Object3DLayout(object):
     """Manages properties of objects in HFSS 3D Layout.
 
     Parameters
     -----------
     primitives : :class:`pyaedt.modeler.Model3DLayout.Modeler3dLayout`
     """
 
@@ -427,21 +427,22 @@
 
     @property
     def is_parallel(self):
         if self.rlc_model_type:
             return self.rlc_model_type[6]
 
 
-class Components3DLayout(Objec3DLayout, object):
+class Components3DLayout(Object3DLayout, object):
     """Contains components in HFSS 3D Layout."""
 
     def __init__(self, primitives, name="", edb_object=None):
-        Objec3DLayout.__init__(self, primitives, "component")
+        Object3DLayout.__init__(self, primitives, "component")
         self.name = name
         self.edb_object = edb_object
+        self._pins = {}
 
     @property
     def part(self):
         """Retrieve the component part.
 
         Returns
         -------
@@ -625,15 +626,21 @@
                 4,
             ],
         ]
         return self.change_property(args)
 
     @pyaedt_function_handler()
     def set_solderball(
-        self, solderball_type="Cyl", diameter="0.1mm", mid_diameter="0.1mm", height="0.2mm", material="solder"
+        self,
+        solderball_type="Cyl",
+        diameter="0.1mm",
+        mid_diameter="0.1mm",
+        height="0.2mm",
+        material="solder",
+        reference_offset=None,
     ):
         """Set solderball on the active component.
 
         The method applies to these component types: ``Other``, ``IC`` and ``IO``.
 
         Parameters
         ----------
@@ -644,44 +651,48 @@
             Ball diameter. The default is ``"0.1mm"``.
         mid_diameter : str, optional
             Ball mid diameter. The default is ``"0.1mm"``.
         height : str, optional
             Ball height. The default is height="0.2mm".
         material : str, optional
             Ball material. The default is ``"solder"``.
+        reference_offset : str, optional.
+            Reference offset for port creation.  The default is ``"0mm"``
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed or the wrong component type.
         """
         if self._part_type_id not in [0, 4, 5]:
             return False
+        props = self._oeditor.GetComponentInfo(self.name)
+        model = ""
+        for p in props:
+            if "PortProp(" in p:
+                model = p
+                break
+        s = r".+PortProp\(rh='(.+?)', rsa=(.+?), rsx='(.+?)', rsy='(.+?)'\)"
+        m = re.search(s, model)
+        rsx = "0"
+        rsy = "0"
+        rsa = True
+        rh = "0"
+        if m:
+            rh = m.group(1)
+            rsx = m.group(3)
+            rsy = m.group(4)
+            if m.group(2) == "false":
+                rsa = False
+        if reference_offset:
+            rh = reference_offset
         if self._part_type_id == 4:
             prop_name = "ICProp:="
             if not self.die_enabled:
                 self.set_die_type()
-            props = self._oeditor.GetComponentInfo(self.name)
-            model = ""
-            for p in props:
-                if "PortProp(" in p:
-                    model = p
-                    break
-            s = r".+PortProp\(rh='(.+?)', rsa=(.+?), rsx='(.+?)', rsy='(.+?)'\)"
-            m = re.search(s, model)
-            rh = "0"
-            rsx = "0"
-            rsy = "0"
-            rsa = True
-            if m:
-                rh = m.group(1)
-                rsx = m.group(3)
-                rsy = m.group(4)
-                if m.group(2) == "false":
-                    rsa = False
             s = r".+DieProp\(dt=(.+?), do=(.+?), dh='(.+?)', lid=(.+?)\)"
             m = re.search(s, model)
             dt = 0
             do = 0
             dh = "0"
             lid = -100
             if m:
@@ -735,28 +746,34 @@
                             "sbr:=",
                             diameter,
                             "sb2:=",
                             mid_diameter,
                             "sbn:=",
                             material,
                         ],
+                        "PortProp:=",
+                        ["rh:=", rh, "rsa:=", rsa, "rsx:=", rsx, "rsy:=", rsy],
                     ],
                 ],
             ]
         return self.change_property(args)
 
     @property
     def pins(self):
         """Component pins.
 
         Returns
         -------
-        List of str
+        dict
+            Dictionary of pins.
         """
-        return list(self._oeditor.GetComponentPins(self.name))
+        if self._pins:
+            return self._pins
+        self._pins = {i: Pins3DLayout(self._primitives, i) for i in list(self._oeditor.GetComponentPins(self.name))}
+        return self._pins
 
     @property
     def model(self):
         """RLC model if available.
 
         Returns
         -------
@@ -785,19 +802,19 @@
         """
         comps = {}
         for c in self._oeditor.FilterObjectList("Type", "component", self._oeditor.FindObjects("Net", self.name)):
             comps[c] = self._primitives.components[c]
         return comps
 
 
-class Pins3DLayout(Objec3DLayout, object):
+class Pins3DLayout(Object3DLayout, object):
     """Contains the pins in HFSS 3D Layout."""
 
     def __init__(self, primitives, name="", component_name=None, is_pin=True):
-        Objec3DLayout.__init__(self, primitives, "pin" if is_pin else "via")
+        Object3DLayout.__init__(self, primitives, "pin" if is_pin else "via")
         self.componentname = "-".join(name.split("-")[:-1]) if not component_name else component_name
         self.name = name
         self.is_pin = is_pin
 
     @property
     def start_layer(self):
         """Retrieve the starting layer of the pin.
@@ -843,19 +860,19 @@
         ----------
 
         >>> oEditor.GetPropertyValue
         """
         return self._oeditor.GetPropertyValue("BaseElementTab", self.name, "HoleDiameter")
 
 
-class Geometries3DLayout(Objec3DLayout, object):
+class Geometries3DLayout(Object3DLayout, object):
     """Contains geometries in HFSS 3D Layout."""
 
     def __init__(self, primitives, name, prim_type="poly", is_void=False):
-        Objec3DLayout.__init__(self, primitives, prim_type)
+        Object3DLayout.__init__(self, primitives, prim_type)
         self.is_void = is_void
         self._name = name
 
     @property
     def obounding_box(self):
         """Bounding box of a specified object.
 
@@ -1651,28 +1668,28 @@
             ``True`` if the point was moved to the new location.
 
         """
         if self.point.Move(self._primitives.oeditor.Point().Set(new_position[0], new_position[1])):
             return True
 
 
-class ComponentsSubCircuit3DLayout(Objec3DLayout, object):
+class ComponentsSubCircuit3DLayout(Object3DLayout, object):
     """Contains 3d Components in HFSS 3D Layout.
 
     Parameters
     ----------
     parent :
 
     name : string, optional
         The default is ``""``.
 
     """
 
     def __init__(self, primitives, name=""):
-        Objec3DLayout.__init__(self, primitives, "component")
+        Object3DLayout.__init__(self, primitives, "component")
         self.name = name
 
     @property
     def component_info(self):
         """Retrieve all component info."""
         return self._oeditor.GetComponentInfo(self.name)
```

### Comparing `pyaedt-0.8.7/pyaedt/modeler/schematic.py` & `pyaedt-0.8.8/pyaedt/modeler/schematic.py`

 * *Files 0% similar despite different names*

```diff
@@ -442,15 +442,15 @@
             return ", ".join(sels)
         return sels
 
     @pyaedt_function_handler()
     def _arg_with_dim(self, value, units=None):
         if units is None:
             units = self.schematic_units
-        if type(value) is str:
+        if isinstance(value, str):
             try:
                 float(value)
                 val = "{0}{1}".format(value, units)
             except Exception:
                 val = value
         else:
             val = "{0}{1}".format(value, units)
```

### Comparing `pyaedt-0.8.7/pyaedt/modules/AdvancedPostProcessing.py` & `pyaedt-0.8.8/pyaedt/modules/AdvancedPostProcessing.py`

 * *Files 3% similar despite different names*

```diff
@@ -125,21 +125,17 @@
                     mag = 0
                 phase = 0
                 edit_sources_ctxt.append(
                     ["Name:=", "{}".format(each), "Magnitude:=", "{}W".format(mag), "Phase:=", "{}deg".format(phase)]
                 )
             self.post_osolution.EditSources(edit_sources_ctxt)
 
-            ctxt = ["Context:=", ff_setup]
-
-            sweeps = ["Theta:=", ["All"], "Phi:=", ["All"], "Freq:=", [freq]]
-
             trace_name = "rETheta"
             solnData = self.get_far_field_data(
-                setup_sweep_name=setup_sweep_name, domain=ff_setup, expression=trace_name
+                expressions=trace_name, setup_sweep_name=setup_sweep_name, domain=ff_setup
             )
 
             data = solnData.nominal_variation
 
             theta_vals = np.degrees(np.array(data.GetSweepValues("Theta")))
             phi_vals = np.degrees(np.array(data.GetSweepValues("Phi")))
             # phi is outer loop
@@ -148,15 +144,15 @@
             theta_range = np.linspace(np.min(theta_vals), np.max(theta_vals), np.size(theta_unique))
             phi_range = np.linspace(np.min(phi_vals), np.max(phi_vals), np.size(phi_unique))
             real_theta = np.array(data.GetRealDataValues(trace_name))
             imag_theta = np.array(data.GetImagDataValues(trace_name))
 
             trace_name = "rEPhi"
             solnData = self.get_far_field_data(
-                setup_sweep_name=setup_sweep_name, domain=ff_setup, expression=trace_name
+                expressions=trace_name, setup_sweep_name=setup_sweep_name, domain=ff_setup
             )
             data = solnData.nominal_variation
 
             real_phi = np.array(data.GetRealDataValues(trace_name))
             imag_phi = np.array(data.GetImagDataValues(trace_name))
 
             Etheta = np.vectorize(complex)(real_theta, imag_theta)
@@ -204,17 +200,15 @@
         """
 
         assert self._app._aedt_version >= "2021.2", self.logger.error("Object is supported from AEDT 2021 R2.")
 
         files = []
         if get_objects_from_aedt and self._app.solution_type not in ["HFSS3DLayout", "HFSS 3D Layout Design"]:
             files = self.export_model_obj(
-                obj_list=objects,
-                export_as_single_objects=plot_as_separate_objects,
-                air_objects=plot_air_objects,
+                assignment=objects, export_as_single_objects=plot_as_separate_objects, air_objects=plot_air_objects
             )
 
         model = ModelPlotter()
         model.off_screen = True
         units = self.modeler.model_units
         for file in files:
             if force_opacity_value:
@@ -306,21 +300,21 @@
             model.plot(export_path)
         elif show:
             model.plot()
         if clean_files:
             model.clean_cache_and_files(clean_cache=False)
         return model
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(plotname="plot_name", meshplot="mesh_plot", imageformat="image_format")
     def plot_field_from_fieldplot(
         self,
-        plotname,
+        plot_name,
         project_path="",
-        meshplot=False,
-        imageformat="jpg",
+        mesh_plot=False,
+        image_format="jpg",
         view="isometric",
         plot_label="Temperature",
         plot_folder=None,
         show=True,
         scale_min=None,
         scale_max=None,
         plot_cad_objs=True,
@@ -335,22 +329,22 @@
         """Export a field plot to an image file (JPG or PNG) using Python PyVista.
 
         .. note::
            The PyVista module rebuilds the mesh and the overlap fields on the mesh.
 
         Parameters
         ----------
-        plotname : str
+        plot_name : str
             Name of the field plot to export.
         project_path : str, optional
             Path for saving the image file. The default is ``""``.
-        meshplot : bool, optional
+        mesh_plot : bool, optional
             Whether to create and plot the mesh over the fields. The
             default is ``False``.
-        imageformat : str, optional
+        image_format : str, optional
             Format of the image file. Options are ``"jpg"``,
             ``"png"``, ``"svg"``, and ``"webp"``. The default is
             ``"jpg"``.
         view : str, optional
            View to export. Options are ``"isometric"``, ``"xy"``, ``"xz"``, ``"yz"``.
         plot_label : str, optional
             Type of the plot. The default is ``"Temperature"``.
@@ -394,17 +388,17 @@
         if self._app.solution_type in ["HFSS3DLayout", "HFSS 3D Layout Design"]:
             is_pcb = True
         if not plot_folder:
             self.ofieldsreporter.UpdateAllFieldsPlots()
         else:
             self.ofieldsreporter.UpdateQuantityFieldsPlots(plot_folder)
 
-        if self.field_plots[plotname].field_type == "DC R/L Fields":
+        if self.field_plots[plot_name].field_type == "DC R/L Fields":
             file_format = "fldplt"
-        file_to_add = self.export_field_plot(plotname, self._app.working_directory, file_format=file_format)
+        file_to_add = self.export_field_plot(plot_name, self._app.working_directory, file_format=file_format)
         model = self.get_model_plotter_geometries(
             generate_mesh=False,
             get_objects_from_aedt=plot_cad_objs,
             plot_as_separate_objects=plot_as_separate_objects,
         )
         model.show_legend = show_legend
         model.off_screen = not show
@@ -412,15 +406,15 @@
             model.background_color = [40, 40, 40]
         model.bounding_box = show_bounding
         model.show_grid = show_grid
         if file_to_add:
             model.add_field_from_file(
                 file_to_add,
                 coordinate_units=self.modeler.model_units,
-                show_edges=meshplot,
+                show_edges=mesh_plot,
                 log_scale=log_scale,
             )
             if plot_label:
                 model.fields[0].label = plot_label
 
         if view != "isometric" and view in ["xy", "xz", "yz"]:
             model.camera_position = view
@@ -429,59 +423,60 @@
         if is_pcb:
             model.z_scale = 5
 
         if scale_min and scale_max:
             model.range_min = scale_min
             model.range_max = scale_max
         if project_path:
-            model.plot(os.path.join(project_path, plotname + "." + imageformat))
+            model.plot(os.path.join(project_path, plot_name + "." + image_format))
         elif show:
             model.plot()
         return model
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(object_list="assignment", imageformat="image_format", setup_name="setup")
     def plot_field(
         self,
         quantity,
-        object_list,
+        assignment,
         plot_type="Surface",
-        setup_name=None,
+        setup=None,
         intrinsics=None,
         mesh_on_fields=False,
         view="isometric",
         plot_label=None,
         show=True,
         scale_min=None,
         scale_max=None,
         plot_cad_objs=True,
         log_scale=False,
         export_path="",
-        imageformat="jpg",
+        image_format="jpg",
         keep_plot_after_generation=False,
         dark_mode=False,
         show_bounding=False,
         show_grid=False,
         show_legend=True,
-        filter_objects=[],
+        filter_objects=None,
         plot_as_separate_objects=True,
     ):
         """Create a field plot  using Python PyVista and export to an image file (JPG or PNG).
 
         .. note::
            The PyVista module rebuilds the mesh and the overlap fields on the mesh.
 
         Parameters
         ----------
         quantity : str
-            Quantity to plot (e.g. ``"Mag_E"``).
-        object_list : str, list
-            Objects or faces to which apply the Field Plot.
+            Quantity to plot. For example, ``"Mag_E"``.
+        assignment : str, list
+            One or more objects or faces to apply the field plot to.
         plot_type  : str, optional
-            Plot type. Options are ``"Surface"``, ``"Volume"``, ``"CutPlane"``.
-        setup_name : str, optional
+            Plot type. The default is ``Surface``. Options are
+            ``"CutPlane"``, ``"Surface"``, and ``"Volume"``.
+        setup : str, optional
             Setup and sweep name on which create the field plot. Default is None for nominal setup usage.
         intrinsics : dict, optional.
             Intrinsic dictionary that is needed for the export.
             The default is ``None`` which try to retrieve intrinsics from setup.
         mesh_on_fields : bool, optional
             Whether to create and plot the mesh over the fields. The
             default is ``False``.
@@ -497,15 +492,15 @@
             Fix the Scale Maximum value.
         plot_cad_objs : bool, optional
             Whether to include objects in the plot. The default is ``True``.
         log_scale : bool, optional
             Whether to plot fields in log scale. The default is ``False``.
         export_path : str, optional
             Image export path. Default is ``None`` to not export the image.
-        imageformat : str, optional
+        image_format : str, optional
             Format of the image file. Options are ``"jpg"``,
             ``"png"``, ``"svg"``, and ``"webp"``. The default is
             ``"jpg"``.
         keep_plot_after_generation : bool, optional
             Either to keep the Field Plot in AEDT after the generation is completed. Default is ``False``.
         dark_mode : bool, optional
             Whether to display the model in dark mode or not. The default is ``False``.
@@ -521,40 +516,42 @@
             Plot each object separately. It may require more time to export from AEDT.
 
         Returns
         -------
         :class:`pyaedt.generic.plot.ModelPlotter`
             Model Object.
         """
+        if filter_objects is None:
+            filter_objects = []
         if os.getenv("PYAEDT_DOC_GENERATION", "False").lower() in ("true", "1", "t"):  # pragma: no cover
             show = False
-        if not setup_name:
-            setup_name = self._app.existing_analysis_sweeps[0]
+        if not setup:
+            setup = self._app.existing_analysis_sweeps[0]
         if not intrinsics:
             for i in self._app.setups:
-                if i.name == setup_name.split(" : ")[0]:
+                if i.name == setup.split(" : ")[0]:
                     intrinsics = i.default_intrinsics
 
         # file_to_add = []
         if plot_type == "Surface":
-            plotf = self.create_fieldplot_surface(object_list, quantity, setup_name, intrinsics)
+            plotf = self.create_fieldplot_surface(assignment, quantity, setup, intrinsics)
         elif plot_type == "Volume":
-            plotf = self.create_fieldplot_volume(object_list, quantity, setup_name, intrinsics)
+            plotf = self.create_fieldplot_volume(assignment, quantity, setup, intrinsics)
         else:
             plotf = self.create_fieldplot_cutplane(
-                object_list, quantity, setup_name, intrinsics, filter_objects=filter_objects
+                assignment, quantity, setup, intrinsics, filter_objects=filter_objects
             )
         # if plotf:
         #     file_to_add = self.export_field_plot(plotf.name, self._app.working_directory, plotf.name)
 
         model = self.plot_field_from_fieldplot(
             plotf.name,
             export_path,
             mesh_on_fields,
-            imageformat,
+            image_format,
             view,
             plot_label if plot_label else quantity,
             None,
             show,
             scale_min,
             scale_max,
             plot_cad_objs,
@@ -565,24 +562,24 @@
             show_legend=show_legend,
             plot_as_separate_objects=plot_as_separate_objects,
         )
         if not keep_plot_after_generation:
             plotf.delete()
         return model
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(object_list="assignment", variation_list="variations", setup_name="setup")
     def plot_animated_field(
         self,
         quantity,
-        object_list,
+        assignment,
         plot_type="Surface",
-        setup_name=None,
+        setup=None,
         intrinsics=None,
         variation_variable="Phi",
-        variation_list=["0deg"],
+        variations=None,
         view="isometric",
         show=True,
         scale_min=None,
         scale_max=None,
         plot_cad_objs=True,
         log_scale=True,
         zoom=None,
@@ -599,29 +596,29 @@
 
         .. note::
            The PyVista module rebuilds the mesh and the overlap fields on the mesh.
 
         Parameters
         ----------
         quantity : str
-            Quantity to plot (e.g. ``"Mag_E"``).
-        object_list : list, str
-            List of objects or faces to which apply the Field Plot.
+            Quantity to plot (for example, ``"Mag_E"``).
+        assignment : list, str
+            One or more objects or faces to apply the field plot to.
         plot_type  : str, optional
-            Plot type. Options are ``"Surface"``, ``"Volume"``, ``"CutPlane"``.
-        setup_name : str, optional
+            Plot type. The default is ``Surface``. Options are
+            ``"CutPlane"``, ``"Surface"``, and ``"Volume"``.
+        setup : str, optional
             Setup and sweep name on which create the field plot. Default is None for nominal setup usage.
         intrinsics : dict, optional.
             Intrinsic dictionary that is needed for the export.
             The default is ``None`` which try to retrieve intrinsics from setup.
         variation_variable : str, optional
             Variable to vary. The default is ``"Phi"``.
-        variation_list : list, optional
-            List of variation values with units. The default is
-            ``["0deg"]``.
+        variations : list, optional
+            List of variation values with units. The default is ``["0deg"]``.
         view : str, optional
            View to export. Options are ``"isometric"``, ``"xy"``, ``"xz"``, ``"yz"``.
         show : bool, optional
             Export Image without plotting on UI.
         scale_min : float, optional
             Fix the Scale Minimum value.
         scale_max : float, optional
@@ -652,40 +649,42 @@
             The default is ``None`` in which case an empty list is passed.
 
         Returns
         -------
         :class:`pyaedt.generic.plot.ModelPlotter`
             Model Object.
         """
+        if variations is None:
+            variations = ["0deg"]
         if os.getenv("PYAEDT_DOC_GENERATION", "False").lower() in ("true", "1", "t"):  # pragma: no cover
             show = False
         if intrinsics is None:
             intrinsics = {}
         if not export_path:
             export_path = self._app.working_directory
         if not filter_objects:
             filter_objects = []
 
         v = 0
         fields_to_add = []
         is_intrinsics = True
         if variation_variable in self._app.variable_manager.independent_variables:
             is_intrinsics = False
-        for el in variation_list:
+        for el in variations:
             if is_intrinsics:
                 intrinsics[variation_variable] = el
             else:
                 self._app[variation_variable] = el
             if plot_type == "Surface":
-                plotf = self.create_fieldplot_surface(object_list, quantity, setup_name, intrinsics)
+                plotf = self.create_fieldplot_surface(assignment, quantity, setup, intrinsics)
             elif plot_type == "Volume":
-                plotf = self.create_fieldplot_volume(object_list, quantity, setup_name, intrinsics)
+                plotf = self.create_fieldplot_volume(assignment, quantity, setup, intrinsics)
             else:
                 plotf = self.create_fieldplot_cutplane(
-                    object_list, quantity, setup_name, intrinsics, filter_objects=filter_objects
+                    assignment, quantity, setup, intrinsics, filter_objects=filter_objects
                 )
             if plotf:
                 file_to_add = self.export_field_plot(plotf.name, export_path, plotf.name + str(v))
                 if file_to_add:
                     fields_to_add.append(file_to_add)
                 plotf.delete()
             v += 1
@@ -712,53 +711,50 @@
             model.range_max = scale_max
         if zoom:
             model.zoom = zoom
         if show or export_gif:
             model.animate()
         return model
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(plotname="plot_name", variation_list="variations")
     def animate_fields_from_aedtplt(
         self,
-        plotname,
+        plot_name,
         plot_folder=None,
-        meshplot=False,
         variation_variable="Phase",
-        variation_list=["0deg"],
+        variations=["0deg"],
         project_path="",
         export_gif=False,
         show=True,
         dark_mode=False,
         show_bounding=False,
         show_grid=False,
     ):
         """Generate a field plot to an image file (JPG or PNG) using PyVista.
 
         .. note::
            The PyVista module rebuilds the mesh and the overlap fields on the mesh.
 
         Parameters
         ----------
-        plotname : str
+        plot_name : str
             Name of the plot or the name of the object.
         plot_folder : str, optional
             Name of the folder in which the plot resides. The default
             is ``None``.
         variation_variable : str, optional
             Variable to vary. The default is ``"Phase"``.
-        variation_list : list, optional
+        variations : list, optional
             List of variation values with units. The default is
             ``["0deg"]``.
         project_path : str, optional
-            Path for the export. The default is ``""`` which export file in working_directory.
-        meshplot : bool, optional
-             The default is ``False``. Valid from Version 2021.2.
+            Path for the export. The default is ``""``, in which case the file is exported
+            to the working directory.
         export_gif : bool, optional
-             The default is ``False``.
-                show=False,
+             Whether to export the GIF file. The default is ``False``.
         show : bool, optional
              Generate the animation without showing an interactive plot.  The default is ``True``.
         dark_mode : bool, optional
             Whether to display the model in dark mode or not. The default is ``False``.
         show_grid : bool, optional
             Whether to display the axes grid or not. The default is ``False``.
         show_bounding : bool, optional
@@ -773,32 +769,32 @@
             self.ofieldsreporter.UpdateAllFieldsPlots()
         else:
             self.ofieldsreporter.UpdateQuantityFieldsPlots(plot_folder)
 
         fields_to_add = []
         if not project_path:
             project_path = self._app.working_directory
-        for el in variation_list:
-            if plotname in self.field_plots and variation_variable in self.field_plots[plotname].intrinsincList:
-                self.field_plots[plotname].intrinsincList[variation_variable] = el
-                self.field_plots[plotname].update()
+        for el in variations:
+            if plot_name in self.field_plots and variation_variable in self.field_plots[plot_name].intrinsics:
+                self.field_plots[plot_name].intrinsics[variation_variable] = el
+                self.field_plots[plot_name].update()
             else:
                 self._app._odesign.ChangeProperty(
                     [
                         "NAME:AllTabs",
                         [
                             "NAME:FieldsPostProcessorTab",
-                            ["NAME:PropServers", "FieldsReporter:" + plotname],
+                            ["NAME:PropServers", "FieldsReporter:" + plot_name],
                             ["NAME:ChangedProps", ["NAME:" + variation_variable, "Value:=", el]],
                         ],
                     ]
                 )
             fields_to_add.append(
                 self.export_field_plot(
-                    plotname, project_path, plotname + variation_variable + str(el), file_format="case"
+                    plot_name, project_path, plot_name + variation_variable + str(el), file_format="case"
                 )
             )
 
         model = self.get_model_plotter_geometries(generate_mesh=False)
         model.off_screen = not show
         if dark_mode:
             model.background_color = [40, 40, 40]
@@ -810,108 +806,14 @@
             model.gif_file = os.path.join(self._app.working_directory, self._app.project_name + ".gif")
 
         if show or export_gif:
             model.animate()
         return model
 
     @pyaedt_function_handler()
-    def animate_fields_from_aedtplt_2(
-        self,
-        quantityname,
-        object_list,
-        plottype,
-        meshplot=False,
-        setup_name=None,
-        intrinsic_dict={},
-        variation_variable="Phi",
-        variation_list=["0deg"],
-        project_path="",
-        export_gif=False,
-        show=True,
-        zoom=None,
-        log_scale=False,
-        dark_mode=False,
-        show_grid=False,
-        show_bounding=False,
-    ):
-        """Generate a field plot to an animated gif file using PyVista.
-
-        .. deprecated:: 0.6.83
-            No need to use primitives anymore. You can instantiate primitives methods directly from modeler instead.
-
-         .. note::
-            The PyVista module rebuilds the mesh and the overlap fields on the mesh.
-
-        This method creates the plot and exports it.
-        It is an alternative to the method :func:`animate_fields_from_aedtplt`,
-        which uses an existing plot.
-
-        Parameters
-        ----------
-        quantityname : str
-            Name of the plot or the name of the object.
-        object_list : list, optional
-            Name of the ``folderplot`` folder.
-        plottype : str
-            Type of the plot. Options are ``"Surface"``, ``"Volume"``, and
-            ``"CutPlane"``.
-        meshplot : bool, optional
-            The default is ``False``.
-        setup_name : str, optional
-            Name of the setup (sweep) to use for the export. The default is
-            ``None``.
-        intrinsic_dict : dict, optional
-            Intrinsic dictionary that is needed for the export.
-            The default is ``{}``.
-        variation_variable : str, optional
-            Variable to vary. The default is ``"Phi"``.
-        variation_list : list, option
-            List of variation values with units. The default is
-            ``["0deg"]``.
-        project_path : str, optional
-            Path for the export. The default is ``""`` which export file in working_directory.
-        export_gif : bool, optional
-            Whether to export to a GIF file. The default is ``False``,
-            in which case the plot is exported to a JPG file.
-        show : bool, optional
-            Generate the animation without showing an interactive plot.  The default is ``True``.
-        zoom : float, optional
-            Zoom factor.
-        log_scale : bool, optional
-            Whether to plot fields in log scale. The default is ``True``.
-
-        Returns
-        -------
-        :class:`pyaedt.generic.plot.ModelPlotter`
-            Model Object.
-        """
-        warnings.warn(
-            "`animate_fields_from_aedtplt_2` is deprecated. Use `plot_animated_field` property instead.",
-            DeprecationWarning,
-        )
-
-        return self.plot_animated_field(
-            quantity=quantityname,
-            object_list=object_list,
-            plot_type=plottype,
-            setup_name=setup_name,
-            intrinsics=intrinsic_dict,
-            variation_variable=variation_variable,
-            variation_list=variation_list,
-            export_path=project_path,
-            log_scale=log_scale,
-            show=show,
-            export_gif=export_gif,
-            zoom=zoom,
-            show_bounding=show_bounding,
-            show_grid=show_grid,
-            dark_mode=dark_mode,
-        )
-
-    @pyaedt_function_handler()
     def create_3d_plot(
         self, solution_data, nominal_sweep=None, nominal_value=None, primary_sweep="Theta", secondary_sweep="Phi"
     ):
         """Create a 3D plot using Matplotlib.
 
         Parameters
         ----------
@@ -933,40 +835,40 @@
         """
         if nominal_value:
             solution_data.intrinsics[nominal_sweep] = nominal_value
         if nominal_value:
             solution_data.primary_sweep = primary_sweep
         return solution_data.plot_3d(x_axis=primary_sweep, y_axis=secondary_sweep)
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(frames_list="frames", output_gif_path="gif_path")
     def plot_scene(
         self,
-        frames_list,
-        output_gif_path,
+        frames,
+        gif_path,
         norm_index=0,
         dy_rng=0,
         fps=30,
         show=True,
         view="yz",
         zoom=2.0,
         convert_fields_in_db=False,
         log_multiplier=10.0,
     ):
         """Plot the current model 3D scene with overlapping animation coming from a file list and save the gif.
 
 
         Parameters
         ----------
-        frames_list : list or str
-            File list containing animation frames to plot in csv format or
-            path to a txt index file containing full path to csv files.
-        output_gif_path : str
-            Full path to output gif file.
+        frames : list or str
+            File list containing animation frames to plot in CSV format or
+            path to a text index file containing the full path to CSV files.
+        gif_path : str
+            Full path for outputting the GIF file.
         norm_index : int, optional
-            Pick the frame to use to normalize your images.
+            Frame to use to normalize your images.
             Data is already saved as dB : 100 for usual traffic scenes.
         dy_rng : int, optional
             Specify how many dB below you would like to specify the range_min.
             Tweak this a couple of times with small number of frames.
         fps : int, optional
             Frames per Second.
         show : bool, optional
@@ -981,24 +883,24 @@
         log_multiplier : float, optional
             Field multiplier if field in dB. Default Value is `10.0`.
 
         Returns
         -------
 
         """
-        if isinstance(frames_list, str) and os.path.exists(frames_list):
-            with open_file(frames_list, "r") as f:
+        if isinstance(frames, str) and os.path.exists(frames):
+            with open_file(frames, "r") as f:
                 lines = f.read()
                 temp_list = lines.splitlines()
             frames_paths_list = [i for i in temp_list]
-        elif isinstance(frames_list, str):
+        elif isinstance(frames, str):
             self.logger.error("Path doesn't exists")
             return False
         else:
-            frames_paths_list = frames_list
+            frames_paths_list = frames
         scene = self.get_model_plotter_geometries(generate_mesh=False)
 
         norm_data = np.loadtxt(frames_paths_list[norm_index], skiprows=1, delimiter=",")
         norm_val = norm_data[:, -1]
         v_max = np.max(norm_val)
         v_min = v_max - dy_rng
         scene.add_frames_from_file(frames_paths_list, log_scale=False, color_map="jet", header_lines=1, opacity=0.8)
@@ -1014,46 +916,46 @@
         scene.show_legend = False
         scene.show_boundingbox = False
         scene.legend = False
         scene.frame_per_seconds = fps
         scene.zoom = zoom
         scene.bounding_box = False
         scene.color_bar = False
-        scene.gif_file = output_gif_path  # This gif may be a bit slower so we can speed it up a bit
+        scene.gif_file = gif_path  # This GIF file may be a bit slower so it can be speed it up a bit
         scene.convert_fields_in_db = convert_fields_in_db
         scene.log_multiplier = log_multiplier
         scene.animate()
 
 
 class IcepakPostProcessor(PostProcessor, object):
     def __init__(self, app):
         PostProcessor.__init__(self, app)
 
     @pyaedt_function_handler()
     def create_field_summary(self):
         return FieldSummary(self._app)
 
-    @pyaedt_function_handler()
-    def get_fans_operating_point(self, export_file=None, setup_name=None, timestep=None, design_variation=None):
+    @pyaedt_function_handler(timestep="time_step", design_variation="variation")
+    def get_fans_operating_point(self, export_file=None, setup_name=None, time_step=None, variation=None):
         """
         Get the operating point of the fans in the design.
 
         Parameters
         ----------
         export_file : str, optional
             Name of the file to save the operating point of the fans to. The default is
             ``None``, in which case the filename is automatically generated.
         setup_name : str, optional
             Setup name to determine the operating point of the fans. The default is
             ``None``, in which case the first available setup is used.
-        timestep : str, optional
+        time_step : str, optional
             Time, with units, at which to determine the operating point of the fans. The default
             is ``None``, in which case the first available timestep is used. This parameter is
             only relevant in transient simulations.
-        design_variation : str, optional
+        variation : str, optional
             Design variation to determine the operating point of the fans from. The default is
             ``None``, in which case the nominal variation is used.
 
         Returns
         -------
         list
             First element of the list is the CSV filename. The second and third elements
@@ -1080,87 +982,87 @@
             base_name = "{}_{}_FanOpPoint".format(self._app.project_name, self._app.design_name)
             export_file = os.path.join(path, base_name + ".csv")
             while os.path.exists(export_file):
                 file_name = generate_unique_name(base_name)
                 export_file = os.path.join(path, file_name + ".csv")
         if setup_name is None:
             setup_name = "{} : {}".format(self._app.get_setups()[0], self._app.solution_type)
-        if timestep is None:
-            timestep = ""
+        if time_step is None:
+            time_step = ""
             if self._app.solution_type == "Transient":
                 self._app.logger.warning("No timestep is specified. First timestep is exported.")
         else:
             if not self._app.solution_type == "Transient":
                 self._app.logger.warning("Simulation is steady-state. Timestep argument is ignored.")
-                timestep = ""
-        if design_variation is None:
-            design_variation = ""
+                time_step = ""
+        if variation is None:
+            variation = ""
         self._app.osolution.ExportFanOperatingPoint(
             [
                 "SolutionName:=",
                 setup_name,
                 "DesignVariationKey:=",
-                design_variation,
+                variation,
                 "ExportFilePath:=",
                 export_file,
                 "Overwrite:=",
                 True,
                 "TimeStep:=",
-                timestep,
+                time_step,
             ]
         )
-        with open(export_file, "r") as f:
+        with open_file(export_file, "r") as f:
             reader = csv.reader(f)
             for line in reader:
                 if "Fan Instances" in line:
                     vol_flow = line[1]
                     p_rise = line[2]
                     break
             var = {line[0]: [float(line[1]), float(line[2])] for line in reader}
         return [export_file, vol_flow, p_rise, var]
 
     @pyaedt_function_handler
     def _parse_field_summary_content(self, fs, setup_name, design_variation, quantity_name):
-        content = fs.get_field_summary_data(setup_name=setup_name, design_variation=design_variation)
+        content = fs.get_field_summary_data(setup=setup_name, variation=design_variation)
         pattern = r"\[([^]]*)\]"
         match = re.search(pattern, content["Quantity"][0])
         if match:
             content["Unit"] = [match.group(1)]
         else:  # pragma: no cover
             content["Unit"] = [None]
 
         if quantity_name in TOTAL_QUANTITIES:
             return {i: content[i][0] for i in ["Total", "Unit"]}
         return {i: content[i][0] for i in ["Min", "Max", "Mean", "Stdev", "Unit"]}
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(faces_list="faces", quantity_name="quantity", design_variation="variation")
     def evaluate_faces_quantity(
         self,
-        faces_list,
-        quantity_name,
+        faces,
+        quantity,
         side="Default",
         setup_name=None,
-        design_variation=None,
+        variations=None,
         ref_temperature="",
     ):
         """Export the field surface output.
 
         Parameters
         ----------
-        faces_list : list
+        faces : list
             List of faces to apply.
-        quantity_name : str
+        quantity : str
             Name of the quantity to export.
         side : str, optional
             Which side of the mesh face to use. The default is ``Default``.
             Options are ``"Adjacent"``, ``"Combined"``, and ``"Default"``.
         setup_name : str, optional
             Name of the setup and name of the sweep. For example, ``"IcepakSetup1 : SteatyState"``.
             The default is ``None``, in which case the active setup and active sweep are used.
-        design_variation : dict, optional
+        variations : dict, optional
             Dictionary of parameters defined for the specific setup with values. The default is ``{}``.
         ref_temperature: str, optional
             Reference temperature to use for heat transfer coefficient computation. The default is ``""``.
 
         Returns
         -------
         dict
@@ -1171,56 +1073,54 @@
             - ``"Total"`` and ``"Unit"``
 
         References
         ----------
 
         >>> oModule.ExportFieldsSummary
         """
-        if design_variation is None:
-            design_variation = {}
-        facelist_name = generate_unique_name(quantity_name)
-        self._app.modeler.create_face_list(faces_list, facelist_name)
+        if variations is None:
+            variations = {}
+        facelist_name = generate_unique_name(quantity)
+        self._app.modeler.create_face_list(faces, facelist_name)
         fs = self.create_field_summary()
-        fs.add_calculation(
-            "Object", "Surface", facelist_name, quantity_name, side=side, ref_temperature=ref_temperature
-        )
-        out = self._parse_field_summary_content(fs, setup_name, design_variation, quantity_name)
+        fs.add_calculation("Object", "Surface", facelist_name, quantity, side=side, ref_temperature=ref_temperature)
+        out = self._parse_field_summary_content(fs, setup_name, variations, quantity)
         self._app.oeditor.Delete(["NAME:Selections", "Selections:=", facelist_name])
         return out
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(boundary_name="boundary", quantity_name="quantity", design_variation="variations")
     def evaluate_boundary_quantity(
         self,
-        boundary_name,
-        quantity_name,
+        boundary,
+        quantity,
         side="Default",
         volume=False,
         setup_name=None,
-        design_variation=None,
+        variations=None,
         ref_temperature="",
     ):
         """Export the field output on a boundary.
 
         Parameters
         ----------
-        boundary_name : str
+        boundary : str
             Name of boundary to perform the computation on.
-        quantity_name : str
+        quantity : str
             Name of the quantity to export.
         side : str, optional
             Side of the mesh face to use. The default is ``"Default"``.
             Options are ``"Adjacent"``, ``"Combined"``, and ``"Default"``.
         volume : bool, optional
             Whether to compute the quantity on the volume or on the surface.
             The default is ``False``, in which case the quantity will be evaluated
             only on the surface .
         setup_name : str, optional
             Name of the setup and name of the sweep. For example, ``"IcepakSetup1 : SteatyState"``.
             The default is ``None``, in which case the active setup and active sweep are used.
-        design_variation : dict, optional
+        variations : dict, optional
             Dictionary of parameters defined for the specific setup with values. The default is ``{}``.
         ref_temperature: str, optional
             Reference temperature to use for heat transfer coefficient computation. The default is ``""``.
 
         Returns
         -------
         dict
@@ -1230,52 +1130,52 @@
             - ``"Total"`` and ``"Unit"``
 
         References
         ----------
 
         >>> oModule.ExportFieldsSummary
         """
-        if design_variation is None:
-            design_variation = {}
+        if variations is None:
+            variations = {}
         fs = self.create_field_summary()
         fs.add_calculation(
             "Boundary",
             ["Surface", "Volume"][int(volume)],
-            boundary_name,
-            quantity_name,
+            boundary,
+            quantity,
             side=side,
             ref_temperature=ref_temperature,
         )
-        return self._parse_field_summary_content(fs, setup_name, design_variation, quantity_name)
+        return self._parse_field_summary_content(fs, setup_name, variations, quantity)
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(monitor_name="monitor", quantity_name="quantity", design_variation="variations")
     def evaluate_monitor_quantity(
         self,
-        monitor_name,
-        quantity_name,
+        monitor,
+        quantity,
         side="Default",
         setup_name=None,
-        design_variation=None,
+        variations=None,
         ref_temperature="",
     ):
         """Export monitor field output.
 
         Parameters
         ----------
-        monitor_name : str
+        monitor : str
             Name of monitor to perform the computation on.
-        quantity_name : str
+        quantity : str
             Name of the quantity to export.
         side : str, optional
             Side of the mesh face to use. The default is ``"Default"``.
             Options are ``"Adjacent"``, ``"Combined"``, and ``"Default"``.
         setup_name : str, optional
             Name of the setup and name of the sweep. For example, ``"IcepakSetup1 : SteatyState"``.
             The default is ``None``, in which case the active setup and active sweep are used.
-        design_variation : dict, optional
+        variations : dict, optional
             Dictionary of parameters defined for the specific setup with values. The default is ``{}``.
         ref_temperature: str, optional
             Reference temperature to use for heat transfer coefficient computation. The default is ``""``.
 
         Returns
         -------
         dict
@@ -1286,40 +1186,38 @@
             - ``"Total"`` and ``"Unit"``
 
         References
         ----------
 
         >>> oModule.ExportFieldsSummary
         """
-        if design_variation is None:
-            design_variation = {}
+        if variations is None:
+            variations = {}
         if settings.aedt_version < "2024.1":
             raise NotImplementedError("Monitors are not supported in field summary in versions earlier than 2024 R1.")
         else:  # pragma: no cover
-            if self._app.monitor.face_monitors.get(monitor_name, None):
+            if self._app.monitor.face_monitors.get(monitor, None):
                 field_type = "Surface"
-            elif self._app.monitor.point_monitors.get(monitor_name, None):
+            elif self._app.monitor.point_monitors.get(monitor, None):
                 field_type = "Volume"
             else:
-                raise AttributeError("Monitor {} is not found in the design.".format(monitor_name))
+                raise AttributeError("Monitor {} is not found in the design.".format(monitor))
             fs = self.create_field_summary()
-            fs.add_calculation(
-                "Monitor", field_type, monitor_name, quantity_name, side=side, ref_temperature=ref_temperature
-            )
-            return self._parse_field_summary_content(fs, setup_name, design_variation, quantity_name)
+            fs.add_calculation("Monitor", field_type, monitor, quantity, side=side, ref_temperature=ref_temperature)
+            return self._parse_field_summary_content(fs, setup_name, variations, quantity)
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(design_variation="variations")
     def evaluate_object_quantity(
         self,
         object_name,
         quantity_name,
         side="Default",
         volume=False,
         setup_name=None,
-        design_variation=None,
+        variations=None,
         ref_temperature="",
     ):
         """Export the field output on or in an object.
 
         Parameters
         ----------
         object_name : str
@@ -1330,15 +1228,15 @@
             Side of the mesh face to use. The default is ``"Default"``.
             Options are ``"Adjacent"``, ``"Combined"``, and ``"Default"``.
         volume : bool, optional
             Whether to compute the quantity on the volume or on the surface. The default is ``False``.
         setup_name : str, optional
             Name of the setup and name of the sweep. For example, ``"IcepakSetup1 : SteatyState"``.
             The default is ``None``, in which case the active setup and active sweep are used.
-        design_variation : dict, optional
+        variations : dict, optional
             Dictionary of parameters defined for the specific setup with values. The default is ``{}``.
         ref_temperature: str, optional
             Reference temperature to use for heat transfer coefficient computation. The default is ``""``.
 
         Returns
         -------
         dict
@@ -1349,19 +1247,19 @@
             - ``"Total"`` and ``"Unit"``
 
         References
         ----------
 
         >>> oModule.ExportFieldsSummary
         """
-        if design_variation is None:
-            design_variation = {}
+        if variations is None:
+            variations = {}
         fs = self.create_field_summary()
         fs.add_calculation(
             "Boundary",
             ["Surface", "Volume"][int(volume)],
             object_name,
             quantity_name,
             side=side,
             ref_temperature=ref_temperature,
         )
-        return self._parse_field_summary_content(fs, setup_name, design_variation, quantity_name)
+        return self._parse_field_summary_content(fs, setup_name, variations, quantity_name)
```

### Comparing `pyaedt-0.8.7/pyaedt/modules/Boundary.py` & `pyaedt-0.8.8/pyaedt/modules/Boundary.py`

 * *Files 0% similar despite different names*

```diff
@@ -91,17 +91,15 @@
             ``True`` when successful, ``False`` when failed.
 
         """
         if self.type == "Matrix" or self.type == "Force" or self.type == "Torque":
             self._app.o_maxwell_parameters.DeleteParameters([self.name])
         else:
             self._app.oboundary.DeleteBoundaries([self.name])
-        for el in self._app.boundaries[:]:
-            if el.name == self.name:
-                del self._app._boundaries[el.name]
+        self._app.boundaries
         return True
 
     def _get_boundary_data(self, ds):
         try:
             if "MaxwellParameterSetup" in self._app.design_properties:
                 param = "MaxwellParameters"
                 setup = "MaxwellParameterSetup"
@@ -350,15 +348,15 @@
     operation and coat will return a ``pyaedt.modules.Boundary.BoundaryObject``
 
     >>> from pyaedt import Hfss
     >>> hfss =Hfss()
     >>> origin = hfss.modeler.Position(0, 0, 0)
     >>> inner = hfss.modeler.create_cylinder(hfss.PLANE.XY, origin, 3, 200, 0, "inner")
     >>> inner_id = hfss.modeler.get_obj_id("inner")
-    >>> coat = hfss.assign_coating([inner_id], "copper", usethickness=True, thickness="0.2mm")
+    >>> coat = hfss.assign_coating([inner_id],"copper",use_thickness=True,thickness="0.2mm")
     """
 
     def __init__(self, app, name, props=None, boundarytype=None, auto_update=True):
         self.auto_update = False
         self._app = app
         self._name = name
         self._props = None
@@ -826,18 +824,18 @@
         """
 
         out = ["Name:" + self.name]
 
         if "Faces" in self.props:
             faces = self.props["Faces"]
             faces_out = []
-            if type(faces) is not list:
+            if not isinstance(faces, list):
                 faces = [faces]
             for f in faces:
-                if type(f) is EdgePrimitive or type(f) is FacePrimitive or type(f) is VertexPrimitive:
+                if isinstance(f, (EdgePrimitive, FacePrimitive, VertexPrimitive)):
                     faces_out.append(f.id)
                 else:
                     faces_out.append(f)
             out += ["Faces:=", faces_out]
 
         if "Objects" in self.props:
             pr = []
@@ -1936,22 +1934,22 @@
     @name.setter
     def name(self, source_name):
         if source_name not in self._app.source_names:
             if source_name != self._name:
                 original_name = self._name
                 self._name = source_name
                 for port in self._app.excitations:
-                    if original_name in self._app.excitations[port].props["EnabledPorts"]:
-                        self._app.excitations[port].props["EnabledPorts"] = [
+                    if original_name in self._app.excitation_objects[port].props["EnabledPorts"]:
+                        self._app.excitation_objects[port].props["EnabledPorts"] = [
                             w.replace(original_name, source_name)
-                            for w in self._app.excitations[port].props["EnabledPorts"]
+                            for w in self._app.excitation_objects[port].props["EnabledPorts"]
                         ]
-                    if original_name in self._app.excitations[port].props["EnabledAnalyses"]:
-                        self._app.excitations[port].props["EnabledAnalyses"][source_name] = (
-                            self._app.excitations[port].props["EnabledAnalyses"].pop(original_name)
+                    if original_name in self._app.excitation_objects[port].props["EnabledAnalyses"]:
+                        self._app.excitation_objects[port].props["EnabledAnalyses"][source_name] = (
+                            self._app.excitation_objects[port].props["EnabledAnalyses"].pop(original_name)
                         )
                 self.update(original_name)
         else:
             self._logger.warning("Name %s already assigned in the design", source_name)
 
     @property
     def _logger(self):
@@ -2120,15 +2118,15 @@
         arg2 = ["NAME:ComponentConfigurationData"]
 
         # Check Ports with Sources
         arg3 = ["NAME:EnabledPorts"]
         for source_name in self._app.sources:
             excitation_source = []
             for port in self._app.excitations:
-                if source_name in self._app.excitations[port]._props["EnabledPorts"]:
+                if source_name in self._app.excitation_objects[port]._props["EnabledPorts"]:
                     excitation_source.append(port)
             arg3.append(source_name + ":=")
             arg3.append(excitation_source)
 
         if new_source and new_source not in self._app.sources:
             arg3.append(new_source + ":=")
             arg3.append([])
@@ -2142,17 +2140,17 @@
             arg4.append(new_source + ":=")
             arg4.append([])
 
         arg5 = ["NAME:EnabledAnalyses"]
         for source_name in self._app.sources:
             arg6 = ["NAME:" + source_name]
             for port in self._app.excitations:
-                if source_name in self._app.excitations[port]._props["EnabledAnalyses"]:
+                if source_name in self._app.excitation_objects[port]._props["EnabledAnalyses"]:
                     arg6.append(port + ":=")
-                    arg6.append(self._app.excitations[port]._props["EnabledAnalyses"][source_name])
+                    arg6.append(self._app.excitation_objects[port]._props["EnabledAnalyses"][source_name])
                 else:
                     arg6.append(port + ":=")
                     arg6.append([])
             arg5.append(arg6)
 
         if new_source and new_source not in self._app.sources:
             arg6 = ["NAME:" + new_source]
@@ -2175,18 +2173,18 @@
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         """
         self._app.modeler._odesign.DeleteSource(self.name)
         for port in self._app.excitations:
-            if self.name in self._app.excitations[port].props["EnabledPorts"]:
-                self._app.excitations[port].props["EnabledPorts"].remove(self.name)
-            if self.name in self._app.excitations[port].props["EnabledAnalyses"]:
-                del self._app.excitations[port].props["EnabledAnalyses"][self.name]
+            if self.name in self._app.excitation_objects[port].props["EnabledPorts"]:
+                self._app.excitation_objects[port].props["EnabledPorts"].remove(self.name)
+            if self.name in self._app.excitation_objects[port].props["EnabledAnalyses"]:
+                del self._app.excitation_objects[port].props["EnabledAnalyses"][self.name]
         return True
 
     @pyaedt_function_handler()
     def create(self):
         """Create a new source in AEDT.
 
         Returns
@@ -3201,15 +3199,15 @@
         -------
         str
         """
         return self._name
 
     @name.setter
     def name(self, port_name):
-        if port_name not in self._app.excitation_names:
+        if port_name not in self._app.excitations:
             if port_name != self._name:
                 # Take previous properties
                 self._app.odesign.RenamePort(self._name, port_name)
                 self._name = port_name
                 self._app.modeler.schematic.components[self.schematic_id].name = "IPort@" + port_name
                 self.pins[0].name = "IPort@" + port_name + ";" + str(self.schematic_id)
         else:
@@ -4315,15 +4313,15 @@
             ``True`` when successful, ``False`` when failed.
 
         """
         if self.name in [b.name for b in self._app.boundaries]:
             self.delete()
             try:
                 self.create()
-                self._app.boundaries.append(self)
+                self._app._boundaries[self.name] = self
                 return True
             except Exception:  # pragma : no cover
                 self._app.odesign.Undo()
                 self._app.logger.error("Update of network object failed.")
                 return False
         else:  # pragma : no cover
             self._app.logger.warning("Network object not yet created in design.")
```

### Comparing `pyaedt-0.8.7/pyaedt/modules/CableModeling.py` & `pyaedt-0.8.8/pyaedt/modules/CableModeling.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,14 +1,15 @@
 import itertools
 import json
 import os
 
 from pyaedt.application.Variables import decompose_variable_value
 from pyaedt.generic.LoadAEDTFile import load_entire_aedt_file
 from pyaedt.generic.general_methods import generate_unique_name
+from pyaedt.generic.general_methods import open_file
 from pyaedt.generic.general_methods import read_configuration_file
 
 
 class Cable:
     """Contains all common Cable features.
 
     Parameters
@@ -1405,10 +1406,10 @@
                 self._app.logger.error(str(e))
 
     def _cable_properties_parser(self, omodule, working_dir):
         file_path_export = os.path.join(working_dir, "export_cable_library_test.txt")
         omodule.ExportCableLibrary(file_path_export)
         file_path_export_as_json = os.path.join(working_dir, "export_cable_library_as_json_test.json")
         data = load_entire_aedt_file(file_path_export)
-        with open(file_path_export_as_json, "w") as f:
+        with open_file(file_path_export_as_json, "w") as f:
             json.dump(data, f)
         return data
```

### Comparing `pyaedt-0.8.7/pyaedt/modules/CircuitTemplates.py` & `pyaedt-0.8.8/pyaedt/modules/CircuitTemplates.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/modules/DesignXPloration.py` & `pyaedt-0.8.8/pyaedt/modules/DesignXPloration.py`

 * *Files 0% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 import copy
 import csv
 
 from pyaedt.generic.DataHandlers import _arg2dict
 from pyaedt.generic.DataHandlers import _dict2arg
 from pyaedt.generic.general_methods import PropsManager
 from pyaedt.generic.general_methods import generate_unique_name
+from pyaedt.generic.general_methods import open_file
 from pyaedt.generic.general_methods import pyaedt_function_handler
 from pyaedt.modules.OptimetricsTemplates import defaultdoeSetup
 from pyaedt.modules.OptimetricsTemplates import defaultdxSetup
 from pyaedt.modules.OptimetricsTemplates import defaultoptiSetup
 from pyaedt.modules.OptimetricsTemplates import defaultparametricSetup
 from pyaedt.modules.OptimetricsTemplates import defaultsensitivitySetup
 from pyaedt.modules.OptimetricsTemplates import defaultstatisticalSetup
@@ -66,15 +67,15 @@
             self.props.pop("GoalSetupVersion", None)
             self.props.pop("Version", None)
             self.props.pop("SetupType", None)
             if inputd.get("Sim. Setups"):
                 setups = inputd["Sim. Setups"]
                 for el in setups:
                     try:
-                        if type(self._app.design_properties["SolutionManager"]["ID Map"]["Setup"]) is list:
+                        if isinstance(self._app.design_properties["SolutionManager"]["ID Map"]["Setup"], list):
                             for setup in self._app.design_properties["SolutionManager"]["ID Map"]["Setup"]:
                                 if setup["I"] == el:
                                     setups[setups.index(el)] = setup["I"]
                                     break
                         else:
                             if self._app.design_properties["SolutionManager"]["ID Map"]["Setup"]["I"] == el:
                                 setups[setups.index(el)] = self._app.design_properties["SolutionManager"]["ID Map"][
@@ -1209,15 +1210,15 @@
             `True` if the import is executed correctly.
         """
         if not parametricname:
             parametricname = generate_unique_name("Parametric")
         setup = SetupParam(self._app, parametricname, optim_type="OptiParametric")
         setup.auto_update = False
         setup.props["Sim. Setups"] = [setup_defined.name for setup_defined in self._app.setups]
-        with open(filename, "r") as csvfile:
+        with open_file(filename, "r") as csvfile:
             csvreader = csv.DictReader(csvfile)
             first_data_line = next(csvreader)
             setup.props["Sweeps"] = {"SweepDefinition": OrderedDict()}
             sweep_definition = []
             for var_name in csvreader.fieldnames:
                 if var_name != "*":
                     sweep_definition.append(
```

### Comparing `pyaedt-0.8.7/pyaedt/modules/LayerStackup.py` & `pyaedt-0.8.8/pyaedt/modules/LayerStackup.py`

 * *Files 0% similar despite different names*

```diff
@@ -904,15 +904,15 @@
         -------
         str
             String containing both the value and the unit properly formatted.
 
         """
         if units is None:
             units = self.LengthUnit
-        if type(value) is str:
+        if isinstance(value, str):
             try:
                 float(value)
                 val = "{0}{1}".format(value, units)
             except Exception:
                 val = value
         else:
             val = "{0}{1}".format(value, units)
```

### Comparing `pyaedt-0.8.7/pyaedt/modules/Material.py` & `pyaedt-0.8.8/pyaedt/modules/Material.py`

 * *Files 1% similar despite different names*

```diff
@@ -1297,29 +1297,32 @@
             self.physics_type = ["Electromagnetic", "Thermal", "Structural"]
             self._props["PhysicsTypes"] = OrderedDict({"set": ["Electromagnetic", "Thermal", "Structural"]})
         if "AttachedData" in self._props and "MatAppearanceData" in self._props["AttachedData"]:
             self._material_appearance = []
             self._material_appearance.append(self._props["AttachedData"]["MatAppearanceData"]["Red"])
             self._material_appearance.append(self._props["AttachedData"]["MatAppearanceData"]["Green"])
             self._material_appearance.append(self._props["AttachedData"]["MatAppearanceData"]["Blue"])
+            self._material_appearance.append(self._props["AttachedData"]["MatAppearanceData"].get("Transparency", 0.0))
         else:
             vals = list(CSS4_COLORS.values())
             if (materiallib._color_id) >= len(vals):
                 materiallib._color_id = 0
             h = vals[materiallib._color_id].lstrip("#")
             self._material_appearance = list(int(h[i : i + 2], 16) for i in (0, 2, 4))
             materiallib._color_id += 1
+            self._material_appearance.append(0)
             self._props["AttachedData"] = OrderedDict(
                 {
                     "MatAppearanceData": OrderedDict(
                         {
                             "property_data": "appearance_data",
                             "Red": self._material_appearance[0],
                             "Green": self._material_appearance[1],
                             "Blue": self._material_appearance[2],
+                            "Transparency": self._material_appearance[3],
                         }
                     )
                 }
             )
         if "stacking_type" in self._props:
             self.stacking_type = self._props["stacking_type"]["Choice"]
 
@@ -1362,54 +1365,69 @@
             property_value = (
                 self._props[property] if property in self._props else MatProperties.get_defaultvalue(aedtname=property)
             )
             self.__dict__["_" + property] = MatProperty(self, property, property_value, tmods, smods)
 
     @property
     def material_appearance(self):
-        """Material Appearance specified as an RGB list.
+        """Material appearance specified as a list where the first three items are
+        RGB color and the fourth one is transparency.
 
         Returns
         -------
         list
-            Color of the material in RGB.  Values are in the range ``[0, 255]``.
+            Color of the material in RGB and transparency.
+            Color values are in the range ``[0, 255]``.
+            Transparency is a float in the range ``[0,1]``.
 
         Examples
         --------
-        Create a new material with color ``[0, 153, 153]`` (darker cyan).
+        Create a material with color ``[0, 153, 153]`` (darker cyan) and transparency ``0.5``.
 
         >>> from pyaedt import Hfss
         >>> hfss = Hfss(specified_version="2021.2")
         >>> mat1 = hfss.materials.add_material("new_material")
-        >>> rgbcolor = mat1.material_appearance
-        >>> mat1.material_appearance = [0, 153, 153]
+        >>> appearance_props = mat1.material_appearance
+        >>> mat1.material_appearance = [0, 153, 153, 0.5]
         """
         return self._material_appearance
 
     @material_appearance.setter
-    def material_appearance(self, rgb):
-        if not isinstance(rgb, (list, tuple)):
-            raise TypeError("`material_apperance` must be a list or tuple")
-        if len(rgb) != 3:
-            raise ValueError("`material_appearance` must be three items (RGB)")
-        value_int = []
-        for rgb_item in rgb:
-            rgb_int = int(rgb_item)
-            if rgb_int < 0 or rgb_int > 255:
-                raise ValueError("RGB value must be between 0 and 255")
-            value_int.append(rgb_int)
-        self._material_appearance = value_int
+    def material_appearance(self, appearance_props):
+        if not isinstance(appearance_props, (list, tuple)):
+            raise TypeError("`material_appearance` must be a list or tuple.")
+        if len(appearance_props) != 3 and len(appearance_props) != 4:
+            raise ValueError("`material_appearance` must be four items (R, G, B, transparency).")
+        elif len(appearance_props) == 3:
+            transparency_value = self.material_appearance[3]
+            msg = "Only RGB specified. Transparency is set to " + str(transparency_value)
+            self.logger.info(msg)
+            appearance_props.append(transparency_value)
+        value = []
+        for i in range(len(appearance_props)):
+            if i < 3:
+                rgb_int = int(appearance_props[i])
+                if rgb_int < 0 or rgb_int > 255:
+                    raise ValueError("RGB value must be between 0 and 255.")
+                value.append(rgb_int)
+            else:
+                transparency = float(appearance_props[i])
+                if transparency < 0 or transparency > 1:
+                    raise ValueError("Transparency value must be between 0 and 1.")
+                value.append(transparency)
+        self._material_appearance = value
         self._props["AttachedData"] = OrderedDict(
             {
                 "MatAppearanceData": OrderedDict(
                     {
                         "property_data": "appearance_data",
-                        "Red": value_int[0],
-                        "Green": value_int[1],
-                        "Blue": value_int[2],
+                        "Red": value[0],
+                        "Green": value[1],
+                        "Blue": value[2],
+                        "Transparency": value[3],
                     }
                 )
             }
         )
         self.update()
 
     @property
```

### Comparing `pyaedt-0.8.7/pyaedt/modules/MaterialLib.py` & `pyaedt-0.8.8/pyaedt/modules/MaterialLib.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/modules/Mesh.py` & `pyaedt-0.8.8/pyaedt/modules/Mesh.py`

 * *Files 12% similar despite different names*

```diff
@@ -240,18 +240,18 @@
         """
 
         out = []
 
         if "Faces" in self.props:
             faces = self.props["Faces"]
             faces_out = []
-            if type(faces) is not list:
+            if not isinstance(faces, list):
                 faces = [faces]
             for f in faces:
-                if type(f) is EdgePrimitive or type(f) is FacePrimitive or type(f) is VertexPrimitive:
+                if isinstance(f, (EdgePrimitive, FacePrimitive, VertexPrimitive)):
                     faces_out.append(f.id)
                 else:
                     faces_out.append(f)
             out += ["Faces:=", faces_out]
 
         if "Objects" in self.props:
             pr = []
@@ -319,17 +319,17 @@
     app : :class:`pyaedt.application.Analysis3D.FieldAnalysis3D`
 
     Examples
     --------
     Basic usage demonstrated with an HFSS design:
 
     >>> from pyaedt import Hfss
-    >>> aedtapp = Hfss()
-    >>> cylinder = aedtapp.modeler.create_cylinder(0, [0, 0, 0], 3, 20, 0)
-    >>> model_resolution = aedtapp.mesh.assign_model_resolution(cylinder, 1e-4, "ModelRes1")
+    >>> hfss = Hfss()
+    >>> cylinder = hfss.modeler.create_cylinder(0, [0, 0, 0], 3, 20, 0)
+    >>> model_resolution = hfss.mesh.assign_model_resolution(cylinder,1e-4,"ModelRes1")
     """
 
     def __init__(self, app):
         app.logger.reset_timer()
         self._app = app
         self._odesign = self._app.odesign
         self.modeler = self._app.modeler
@@ -354,18 +354,18 @@
             Returns None if the part ID or the object name is not found.
 
         Examples
         --------
         Basic usage demonstrated with an HFSS design:
 
         >>> from pyaedt import Hfss
-        >>> aedtapp = Hfss()
-        >>> cylinder = aedtapp.modeler.create_cylinder(0, [0, 0, 0], 3, 20, 0)
-        >>> mr1 = aedtapp.mesh.assign_model_resolution(cylinder, 1e-4, "ModelRes1")
-        >>> mr2 = aedtapp.mesh[mr1.name]
+        >>> hfss = Hfss()
+        >>> cylinder = hfss.modeler.create_cylinder(0, [0, 0, 0], 3, 20, 0)
+        >>> mr1 = hfss.mesh.assign_model_resolution(cylinder,1e-4,"ModelRes1")
+        >>> mr2 = hfss.mesh[mr1.name]
         """
 
         if part_id in self.meshoperation_names:
             mesh_op_selected = [mesh_op for mesh_op in self.meshoperations if mesh_op.name == part_id]
             return mesh_op_selected[0]
         return None
 
@@ -380,18 +380,18 @@
                         List of mesh operation object.
 
         Examples
         --------
         Basic usage demonstrated with an HFSS design:
 
         >>> from pyaedt import Hfss
-        >>> aedtapp = Hfss()
-        >>> o = aedtapp.modeler.create_cylinder(0, [0, 0, 0], 3, 20, 0)
-        >>> mr1 = aedtapp.mesh.assign_model_resolution(o, 1e-4, "ModelRes1")
-        >>> mesh_operations_list = aedtapp.mesh.meshoperations
+        >>> hfss = Hfss()
+        >>> o = hfss.modeler.create_cylinder(0, [0, 0, 0], 3, 20, 0)
+        >>> mr1 = hfss.mesh.assign_model_resolution(o,1e-4,"ModelRes1")
+        >>> mesh_operations_list = hfss.mesh.meshoperations
         """
         if self._meshoperations is None:
             self._meshoperations = self._get_design_mesh_operations()
         return self._meshoperations
 
     @pyaedt_function_handler()
     def _refresh_mesh_operations(self):
@@ -410,19 +410,19 @@
             List of mesh operation names.
 
         Examples
         --------
         Basic usage demonstrated with an HFSS design:
 
         >>> from pyaedt import Hfss
-        >>> aedtapp = Hfss()
-        >>> o = aedtapp.modeler.create_cylinder(0, [0, 0, 0], 3, 20, 0)
-        >>> mr1 = aedtapp.mesh.assign_model_resolution(o, 1e-4, "ModelRes1")
-        >>> mr2 = aedtapp.mesh.assign_model_resolution(o, 1e-2, "ModelRes2")
-        >>> mesh_operations_names = aedtapp.mesh.meshoperation_names
+        >>> hfss = Hfss()
+        >>> o = hfss.modeler.create_cylinder(0, [0, 0, 0], 3, 20, 0)
+        >>> mr1 = hfss.mesh.assign_model_resolution(o,1e-4,"ModelRes1")
+        >>> mr2 = hfss.mesh.assign_model_resolution(o,1e-2,"ModelRes2")
+        >>> mesh_operations_names = hfss.mesh.meshoperation_names
         """
         if self._app._is_object_oriented_enabled():
             return list(self._app.odesign.GetChildObject("Mesh").GetChildNames())
         return []
 
     @property
     def initial_mesh_settings(self):
@@ -532,25 +532,25 @@
                                 continue
 
                 meshops.append(MeshOperation(self, ds, props, props["Type"]))
         except Exception:
             pass
         return meshops
 
-    @pyaedt_function_handler()
-    def assign_surface_mesh(self, names, level, meshop_name=None):
+    @pyaedt_function_handler(names="assignment", meshop_name="name")
+    def assign_surface_mesh(self, assignment, level, name=None):
         """Assign a surface mesh level to one or more objects.
 
         Parameters
         ----------
-        names : list
+        assignment : list
             One or more names of the objects.
         level : int
             Level of the surface mesh. Options are ``1`` through ``10``
-        meshop_name : str, optional
+        name : str, optional
             Name of the mesh operation. The default is ``None``.
 
         Returns
         -------
         :class:`pyaedt.modules.Mesh.MeshOperation`
             Mesh operation object.
 
@@ -560,60 +560,62 @@
         >>> oModule.AssignTrueSurfOp
 
         Examples
         --------
         Basic usage demonstrated with an HFSS design:
 
         >>> from pyaedt import Hfss
-        >>> aedtapp = Hfss()
-        >>> o = aedtapp.modeler.create_cylinder(0, [0, 0, 0], 3, 20, 0)
-        >>> surface = aedtapp.mesh.assign_surface_mesh(o.id, 3, "Surface")
+        >>> hfss = Hfss()
+        >>> o = hfss.modeler.create_cylinder(0, [0, 0, 0], 3, 20, 0)
+        >>> surface = hfss.mesh.assign_surface_mesh(o.id,3,"Surface")
         """
-        names = self.modeler.convert_to_selections(names, True)
-        if meshop_name:
+        assignment = self.modeler.convert_to_selections(assignment, True)
+        if name:
             for m in self.meshoperations:
-                if meshop_name == m.name:
-                    meshop_name = generate_unique_name(meshop_name)
+                if name == m.name:
+                    name = generate_unique_name(name)
         else:
-            meshop_name = generate_unique_name("SurfApprox")
-        self.logger.info("Assigning Mesh Level " + str(level) + " to " + str(names))
-        names = self._app.modeler.convert_to_selections(names, True)
+            name = generate_unique_name("SurfApprox")
+        self.logger.info("Assigning Mesh Level " + str(level) + " to " + str(assignment))
+        assignment = self._app.modeler.convert_to_selections(assignment, True)
 
-        if isinstance(names[0], int):
+        if isinstance(assignment[0], int):
             seltype = "Faces"
         else:
             seltype = "Objects"
         props = OrderedDict(
             {
                 "Type": "SurfApproxBased",
                 "CurvedSurfaceApproxChoice": "UseSlider",
-                seltype: names,
+                seltype: assignment,
                 "SliderMeshSettings": level,
             }
         )
-        mop = MeshOperation(self, meshop_name, props, "SurfApproxBased")
+        mop = MeshOperation(self, name, props, "SurfApproxBased")
         mop.create()
         self.meshoperations.append(mop)
         return mop
 
-    @pyaedt_function_handler()
-    def assign_surface_mesh_manual(self, names, surf_dev=None, normal_dev=None, aspect_ratio=None, meshop_name=None):
+    @pyaedt_function_handler(names="assignment", surf_dev="surface_deviation", meshop_name="name")
+    def assign_surface_mesh_manual(
+        self, assignment, surface_deviation=None, normal_dev=None, aspect_ratio=None, name=None
+    ):
         """Assign a surface mesh to a list of faces.
 
         Parameters
         ----------
-        names : list or str or :class:`pyaedt.modeler.elements3d.FacePrimitive`
+        assignment : list or str or :class:`pyaedt.modeler.elements3d.FacePrimitive`
             List of faces to apply the surface mesh to.
-        surf_dev : float or str, optional
-            Surface deviation. The default is ``None``. Allowed values are float, number with units or `"inf"`.
+        surface_deviation : float or str, optional
+            Surface deviation. The default is ``None``. You can specify a float value, a number with units, or `"inf"`.
         normal_dev : float or str, optional
             Normal deviation. The default is ``None``.
         aspect_ratio : int, optional
             Aspect ratio. The default is ``None``.
-        meshop_name : str, optional
+        name : str, optional
             Name of the mesh operation. The default is ``None``.
 
         Returns
         -------
         :class:`pyaedt.modules.Mesh.MeshOperation`
             Mesh operation object.
 
@@ -623,75 +625,74 @@
         >>> oModule.AssignTrueSurfOp
 
         Examples
         --------
         Basic usage demonstrated with an HFSS design:
 
         >>> from pyaedt import Hfss
-        >>> aedtapp = Hfss()
-        >>> o = aedtapp.modeler.create_cylinder(0, [0, 0, 0], 3, 20, 0)
-        >>> surface = self.aedtapp.mesh.assign_surface_mesh_manual(o.id, 1e-6, aspect_ratio=3,
-        ... meshop_name="Surface_Manual")
+        >>> hfss = Hfss()
+        >>> o = hfss.modeler.create_cylinder(0, [0, 0, 0], 3, 20, 0)
+        >>> surface = hfss.mesh.assign_surface_mesh_manual(o.id,1e-6,aspect_ratio=3,name="Surface_Manual")
         """
-        names = self.modeler.convert_to_selections(names, True)
-        if meshop_name:
+        assignment = self.modeler.convert_to_selections(assignment, True)
+        if name:
             for m in self.meshoperations:
-                if meshop_name == m.name:
-                    meshop_name = generate_unique_name(meshop_name)
+                if name == m.name:
+                    name = generate_unique_name(name)
         else:
-            meshop_name = generate_unique_name("ModelResolution")
+            name = generate_unique_name("ModelResolution")
 
         surf_dev_enable = 2
         normal_dev_enable = 2
         aspect_ratio_enable = 2
 
-        if not surf_dev:
+        if not surface_deviation:
             surf_dev_enable = 0
-            surf_dev = "0.0001mm"
-        elif surf_dev == "inf":
+            surface_deviation = "0.0001mm"
+        elif surface_deviation == "inf":
             surf_dev_enable = 1
         if not normal_dev:
             normal_dev_enable = 1
             normal_dev = "1"
 
         if not aspect_ratio:
             aspect_ratio_enable = 1
             aspect_ratio = "10"
 
         props = OrderedDict(
             {
                 "Type": "SurfApproxBased",
-                "Objects": names,
+                "Objects": assignment,
                 "CurvedSurfaceApproxChoice": "ManualSettings",
                 "SurfDevChoice": surf_dev_enable,
-                "SurfDev": surf_dev,
+                "SurfDev": surface_deviation,
                 "NormalDevChoice": normal_dev_enable,
                 "NormalDev": normal_dev,
                 "AspectRatioChoice": aspect_ratio_enable,
                 "AspectRatio": aspect_ratio,
             }
         )
 
-        mop = MeshOperation(self, meshop_name, props, "SurfApproxBased")
+        mop = MeshOperation(self, name, props, "SurfApproxBased")
         mop.create()
         self.meshoperations.append(mop)
         return mop
 
-    @pyaedt_function_handler()
-    def assign_model_resolution(self, names, defeature_length=None, meshop_name=None):
+    @pyaedt_function_handler(names="assignment", meshop_name="name")
+    def assign_model_resolution(self, assignment, defeature_length=None, name=None):
         """Assign the model resolution.
 
         Parameters
         ----------
-        names : list
+        assignment : list
             List of objects to defeature.
         defeature_length : float, optional
             Defeaturing length in millimeters. The default is ``None``, in which case
             automatic defeaturing is used.
-        meshop_name : str, optional
+        name : str, optional
             Name of the mesh operation. The default is ``None``.
 
         Returns
         -------
         :class:`pyaedt.modules.Mesh.MeshOperation`
             Mesh operation object.
 
@@ -701,42 +702,42 @@
         >>> oModule.AssignModelResolutionOp
 
         Examples
         --------
         Basic usage demonstrated with an HFSS design:
 
         >>> from pyaedt import Hfss
-        >>> aedtapp = Hfss()
-        >>> o = aedtapp.modeler.create_cylinder(0, [0, 0, 0], 3, 20, 0)
-        >>> surface = aedtapp.mesh.assign_model_resolution(o, 1e-4, "ModelRes1")
+        >>> hfss = Hfss()
+        >>> o = hfss.modeler.create_cylinder(0, [0, 0, 0], 3, 20, 0)
+        >>> surface = hfss.mesh.assign_model_resolution(o,1e-4,"ModelRes1")
         """
-        names = self.modeler.convert_to_selections(names, True)
-        if meshop_name:
+        assignment = self.modeler.convert_to_selections(assignment, True)
+        if name:
             for m in self.meshoperations:
-                if meshop_name == m.name:
-                    meshop_name = generate_unique_name(meshop_name)
+                if name == m.name:
+                    name = generate_unique_name(name)
         else:
-            meshop_name = generate_unique_name("ModelResolution")
-        for name in names:
+            name = generate_unique_name("ModelResolution")
+        for name in assignment:
             if isinstance(name, int):
                 self.logger.error("Mesh Operation Applies to Objects only")
                 return False
         if defeature_length is None:
-            props = OrderedDict({"Objects": names, "UseAutoLength": True})
+            props = OrderedDict({"Objects": assignment, "UseAutoLength": True})
         else:
             props = OrderedDict(
                 {
                     "Type": "DefeatureBased",
-                    "Objects": names,
+                    "Objects": assignment,
                     "UseAutoLength": False,
                     "DefeatureLength": str(defeature_length) + "mm",
                 }
             )
 
-        mop = MeshOperation(self, meshop_name, props, "DefeatureBased")
+        mop = MeshOperation(self, name, props, "DefeatureBased")
         mop.create()
         self.meshoperations.append(mop)
         return mop
 
     @pyaedt_function_handler()
     def assign_initial_mesh_from_slider(
         self,
@@ -825,61 +826,73 @@
             args.append("UseAlternativeMeshMethodsAsFallBack:=")
             args.append(usefallback)
             args.append("AllowPhiForLayeredGeometry:=")
             args.append(usephi)
         self.omeshmodule.InitialMeshSettings(args)
         return True
 
-    @pyaedt_function_handler()
-    def assign_surf_priority_for_tau(self, object_lists, surfpriority=0):
+    @pyaedt_function_handler(object_lists="assignment", surfpriority="surface_priority")
+    def assign_surf_priority_for_tau(self, assignment, surface_priority=0):
         """Assign a surface representation priority for the TAU mesh.
 
         Parameters
         ----------
-        object_lists : list
+        assignment : list
             List of objects to apply a surface representation
             priority to.
-        surfpriority : int, optional
+        surface_priority : int, optional
             Surface representation priority. The default is ``0``.
 
         Returns
         -------
         :class:`pyaedt.modules.Mesh.MeshOperation`
             Mesh operation object.
 
         References
         ----------
 
         >>> oModule.AssignSurfPriorityForTauOp
         """
         meshop_name = generate_unique_name("SurfaceRepPriority")
-        props = OrderedDict({"Type": "SurfaceRepPriority", "Objects": object_lists, "SurfaceRepPriority": surfpriority})
+        props = OrderedDict(
+            {"Type": "SurfaceRepPriority", "Objects": assignment, "SurfaceRepPriority": surface_priority}
+        )
         mop = MeshOperation(self, meshop_name, props, "SurfaceRepPriority")
         mop.create()
         self.meshoperations.append(mop)
         return mop
 
     @pyaedt_function_handler()
     def generate_mesh(self, name):
         """Generate the mesh for a design.
 
         Parameters
         ----------
         name : str
-            Name of the design.
+            Name of the simulation setup.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         References
         ----------
 
         >>> oDesign.GenerateMesh
+
+        Examples
+        --------
+
+        >>> from pyaedt import Maxwell3d
+        >>> m3d = Maxwell3d()
+        >>> m3d.create_setup(setupname="Setup1")
+        >>> m3d.mesh.assign_length_mesh(maxlength=5, maxel="None")
+        >>> m3d.mesh.generate_mesh("Setup1")
+
         """
         return self._odesign.GenerateMesh(name) == 0
 
     @pyaedt_function_handler()
     def delete_mesh_operations(self, mesh_type=None):
         """Remove mesh operations from a design.
 
@@ -912,465 +925,484 @@
                 self.omeshmodule.DeleteOp(opnames)
             for el in self.meshoperations[:]:
                 if el.name in opnames:
                     self.meshoperations.remove(el)
 
         return True
 
-    @pyaedt_function_handler()
-    def assign_length_mesh(self, names, isinside=True, maxlength=1, maxel=1000, meshop_name=None):
+    @pyaedt_function_handler(
+        names="assignment",
+        isinside="inside_selection",
+        maxlength="maximum_length",
+        maxel="maximum_elements",
+        meshop_name="name",
+    )
+    def assign_length_mesh(self, assignment, inside_selection=True, maximum_length=1, maximum_elements=1000, name=None):
         """Assign a length for the model resolution.
 
         Parameters
         ----------
-        names : list, str
+        assignment : list, str
             List of object names or face IDs.
-        isinside : bool, optional
+        inside_selection : bool, optional
             Whether the length mesh is inside the selection. The default is ``True``.
-        maxlength : str, float, optional
+        maximum_length : str, float, optional
             Maximum element length. The default is ``1``. When ``None``,
             this parameter is disabled.
-        maxel : int, optional
+        maximum_elements : int, optional
             Maximum number of elements. The default is ``1000``. When ``None``, this parameter
             is disabled.
-        meshop_name : str, optional
+        name : str, optional
             Name of the mesh operation. The default is ``None``.
 
         Returns
         -------
         :class:`pyaedt.modules.Mesh.MeshOperation`
             Mesh operation object.
 
         References
         ----------
 
         >>> oModule.AssignLengthOp
         """
-        names = self.modeler.convert_to_selections(names, True)
-        if meshop_name:
+        assignment = self.modeler.convert_to_selections(assignment, True)
+        if name:
             for m in self.meshoperations:
-                if meshop_name == m.name:
-                    meshop_name = generate_unique_name(meshop_name)
+                if name == m.name:
+                    name = generate_unique_name(name)
         else:
-            meshop_name = generate_unique_name("length")
+            name = generate_unique_name("length")
 
-        if maxlength is None:
+        if maximum_length is None:
             restrictlength = False
         else:
             restrictlength = True
-        length = self.modeler.modeler_variable(maxlength)
+        length = self.modeler.modeler_variable(maximum_length)
 
-        if maxel is None:
+        if maximum_elements is None:
             restrictel = False
             numel = "1000"
         else:
             restrictel = True
-            numel = str(maxel)
-        if maxlength is None and maxel is None:
+            numel = str(maximum_elements)
+        if maximum_length is None and maximum_elements is None:
             self.logger.error("mesh not assigned due to incorrect settings")
             return
-        names = self._app.modeler.convert_to_selections(names, True)
+        assignment = self._app.modeler.convert_to_selections(assignment, True)
 
-        if isinstance(names[0], int) and not isinside:
+        if isinstance(assignment[0], int) and not inside_selection:
             seltype = "Faces"
-        elif isinstance(names[0], str):
+        elif isinstance(assignment[0], str):
             seltype = "Objects"
         else:
             seltype = None
         if seltype is None:
             self.logger.error("Error in Assignment")
             return
         props = OrderedDict(
             {
                 "Type": "LengthBased",
-                "RefineInside": isinside,
+                "RefineInside": inside_selection,
                 "Enabled": True,
-                seltype: names,
+                seltype: assignment,
                 "RestrictElem": restrictel,
                 "NumMaxElem": numel,
                 "RestrictLength": restrictlength,
                 "MaxLength": length,
             }
         )
 
-        mop = MeshOperation(self, meshop_name, props, "LengthBased")
+        mop = MeshOperation(self, name, props, "LengthBased")
         for meshop in self.meshoperations[:]:
             if meshop.name == mop.name:
                 meshop.delete()
                 break
         mop.create()
         self.meshoperations.append(mop)
         return mop
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(
+        names="assignment",
+        skindepth="skin_depth",
+        maxelements="maximum_elements",
+        triangulation_max_length="0.1mm",
+        numlayers="layers_number",
+        meshop_name="name",
+    )
     def assign_skin_depth(
         self,
-        names,
-        skindepth="0.2mm",
-        maxelements=None,
+        assignment,
+        skin_depth="0.2mm",
+        maximum_elements=None,
         triangulation_max_length="0.1mm",
-        numlayers="2",
-        meshop_name=None,
+        layers_number="2",
+        name=None,
     ):
         """Assign a skin depth for the mesh refinement.
 
         Parameters
         ----------
-        names : list
+        assignment : list
            List of the object names or face IDs.
-        skindepth : str, float, optional
+        skin_depth : str, float, optional
             Skin depth value.
             It can be either provided as a float or as a string.
             The default is ``"0.2mm"``.
-        maxelements : int, optional
+        maximum_elements : int, optional
             Maximum number of elements. The default is ``None``, which means this parameter is disabled.
         triangulation_max_length : str, optional
             Maximum surface triangulation length with units. The default is ``"0.1mm"``.
-        numlayers : str, optional
+        layers_number : str, optional
             Number of layers. The default is ``"2"``.
-        meshop_name : str, optional
+        name : str, optional
             Name of the mesh operation. The default is ``None``.
 
         Returns
         -------
         :class:`pyaedt.modules.Mesh.MeshOperation`
             Mesh operation object.
 
         References
         ----------
 
         >>> oModule.AssignSkinDepthOp
         """
-        names = self.modeler.convert_to_selections(names, True)
+        assignment = self.modeler.convert_to_selections(assignment, True)
 
         if self._app.design_type != "HFSS" and self._app.design_type != "Maxwell 3D":
             raise MethodNotSupportedError
-        if meshop_name:
+        if name:
             for m in self.meshoperations:
-                if meshop_name == m.name:
-                    meshop_name = generate_unique_name(meshop_name)
+                if name == m.name:
+                    name = generate_unique_name(name)
         else:
-            meshop_name = generate_unique_name("SkinDepth")
+            name = generate_unique_name("SkinDepth")
 
-        if maxelements is None:
+        if maximum_elements is None:
             restrictlength = False
-            maxelements = "1000"
+            maximum_elements = "1000"
         else:
             restrictlength = True
-        names = self._app.modeler.convert_to_selections(names, True)
+        assignment = self._app.modeler.convert_to_selections(assignment, True)
 
-        if isinstance(names[0], int):
+        if isinstance(assignment[0], int):
             seltype = "Faces"
-        elif isinstance(names[0], str):
+        elif isinstance(assignment[0], str):
             seltype = "Objects"
         else:
             seltype = None
         if seltype is None:
             self.logger.error("Error in Assignment")
             return
 
         props = OrderedDict(
             {
                 "Type": "SkinDepthBased",
                 "Enabled": True,
-                seltype: names,
+                seltype: assignment,
                 "RestrictElem": restrictlength,
-                "NumMaxElem": str(maxelements),
-                "SkinDepth": skindepth,
+                "NumMaxElem": str(maximum_elements),
+                "SkinDepth": skin_depth,
                 "SurfTriMaxLength": triangulation_max_length,
-                "NumLayers": numlayers,
+                "NumLayers": layers_number,
             }
         )
 
-        mop = MeshOperation(self, meshop_name, props, "SkinDepthBased")
+        mop = MeshOperation(self, name, props, "SkinDepthBased")
         mop.create()
         self.meshoperations.append(mop)
         return mop
 
-    @pyaedt_function_handler()
-    def assign_curvilinear_elements(self, names, enable=True, meshop_name=None):
+    @pyaedt_function_handler(names="assignment", meshop_name="name")
+    def assign_curvilinear_elements(self, assignment, enable=True, name=None):
         """Assign curvilinear elements.
 
         Parameters
         ----------
-        names : list
+        assignment : list
             List of objects or faces.
         enable : bool, optional
             Whether to apply curvilinear elements. The default is ``True``.
-        meshop_name : str, optional
+        name : str, optional
             Name of the mesh operation. The default is ``None``.
 
         Returns
         -------
         :class:`pyaedt.modules.Mesh.MeshOperation`
             Mesh operation object.
 
         References
         ----------
 
         >>> oModule.AssignApplyCurvlinearElementsOp
         """
-        names = self.modeler.convert_to_selections(names, True)
+        assignment = self.modeler.convert_to_selections(assignment, True)
 
         if self._app.design_type != "HFSS" and self._app.design_type != "Maxwell 3D":
             raise MethodNotSupportedError
-        if meshop_name:
+        if name:
             for m in self.meshoperations:
-                if meshop_name == m.name:
-                    meshop_name = generate_unique_name(meshop_name)
+                if name == m.name:
+                    name = generate_unique_name(name)
         else:
-            meshop_name = generate_unique_name("CurvilinearElements")
-        names = self._app.modeler.convert_to_selections(names, True)
+            name = generate_unique_name("CurvilinearElements")
+        assignment = self._app.modeler.convert_to_selections(assignment, True)
 
-        if isinstance(names[0], int):
+        if isinstance(assignment[0], int):
             seltype = "Faces"
-        elif isinstance(names[0], str):
+        elif isinstance(assignment[0], str):
             seltype = "Objects"
         else:
             seltype = None
         if seltype is None:
             self.logger.error("Error in Assignment")
             return
-        props = OrderedDict({"Type": "Curvilinear", seltype: names, "Apply": enable})
-        mop = MeshOperation(self, meshop_name, props, "Curvilinear")
+        props = OrderedDict({"Type": "Curvilinear", seltype: assignment, "Apply": enable})
+        mop = MeshOperation(self, name, props, "Curvilinear")
         mop.create()
         self.meshoperations.append(mop)
         return mop
 
-    @pyaedt_function_handler()
-    def assign_curvature_extraction(self, names, disable_for_faceted_surf=True, meshop_name=None):
+    @pyaedt_function_handler(
+        names="assignment", disable_for_faceted_surf="disabled_for_faceted", meshoperation_names="name"
+    )
+    def assign_curvature_extraction(self, assignment, disabled_for_faceted=True, name=None):
         """Assign curvature extraction.
 
          Parameters
          ----------
-         names : list
+         assignment : list
             List of objects or faces.
-         disable_for_faceted_surf : bool, optional
+         disabled_for_faceted : bool, optional
             Whether curvature extraction is enabled for faceted surfaces.
             The default is ``True``.
-         meshop_name : str, optional
+         name : str, optional
             Name of the mesh operation. The default is ``None``.
 
          Returns
          -------
         :class:`pyaedt.modules.Mesh.MeshOperation`
             Mesh operation object.
 
         References
         ----------
 
         >>> oModule.AssignCurvatureExtractionOp
         """
-        names = self.modeler.convert_to_selections(names, True)
+        assignment = self.modeler.convert_to_selections(assignment, True)
 
         if self._app.solution_type != "SBR+":
             raise MethodNotSupportedError
-        if meshop_name:
+        if name:
             for m in self.meshoperations:
-                if meshop_name == m.name:
-                    meshop_name = generate_unique_name(meshop_name)
+                if name == m.name:
+                    name = generate_unique_name(name)
         else:
-            meshop_name = generate_unique_name("CurvilinearElements")
-        names = self._app.modeler.convert_to_selections(names, True)
-        if isinstance(names[0], int):
+            name = generate_unique_name("CurvilinearElements")
+        assignment = self._app.modeler.convert_to_selections(assignment, True)
+        if isinstance(assignment[0], int):
             seltype = "Faces"
-        elif isinstance(names[0], str):
+        elif isinstance(assignment[0], str):
             seltype = "Objects"
         else:
             seltype = None
         if seltype is None:
             self.logger.error("Error in Assignment")
             return
         props = OrderedDict(
-            {"Type": "CurvatureExtraction", seltype: names, "DisableForFacetedSurfaces": disable_for_faceted_surf}
+            {"Type": "CurvatureExtraction", seltype: assignment, "DisableForFacetedSurfaces": disabled_for_faceted}
         )
-        mop = MeshOperation(self, meshop_name, props, "CurvatureExtraction")
+        mop = MeshOperation(self, name, props, "CurvatureExtraction")
         mop.create()
         self.meshoperations.append(mop)
         return mop
 
-    @pyaedt_function_handler()
-    def assign_rotational_layer(self, names, num_layers=3, total_thickness="1mm", meshop_name=None):
+    @pyaedt_function_handler(names="assignment", num_layers="layers_number", meshop_name="name")
+    def assign_rotational_layer(self, assignment, layers_number=3, total_thickness="1mm", name=None):
         """Assign a rotational layer mesh.
 
         Parameters
         ----------
-        names : list
+        assignment : list
             List of objects.
-        num_layers : int, optional
+        layers_number : int, optional
             Number of layers to create in the radial direction, starting from
             the faces most adjacent to the band. The default is ``3``, which is the maximum.
         total_thickness : str, optional
             Total thickness of all layers with units. The default is ``"1mm"``.
-        meshop_name : str, optional
+        name : str, optional
             Name of the mesh operation. The default is ``None``.
 
         Returns
         -------
         :class:`pyaedt.modules.Mesh.MeshOperation`
             Mesh operation object.
 
         References
         ----------
 
         >>> oModule.AssignRotationalLayerOp
         """
-        names = self.modeler.convert_to_selections(names, True)
+        assignment = self.modeler.convert_to_selections(assignment, True)
 
         if self._app.design_type != "Maxwell 3D":
             raise MethodNotSupportedError
-        if meshop_name:
+        if name:
             for m in self.meshoperations:
-                if meshop_name == m.name:
-                    meshop_name = generate_unique_name(meshop_name)
+                if name == m.name:
+                    name = generate_unique_name(name)
         else:
-            meshop_name = generate_unique_name("RotationalLayer")
+            name = generate_unique_name("RotationalLayer")
         seltype = "Objects"
         props = OrderedDict(
             {
                 "Type": "RotationalLayerMesh",
-                seltype: names,
-                "Number of Layers": str(num_layers),
+                seltype: assignment,
+                "Number of Layers": str(layers_number),
                 "Total Layer Thickness": total_thickness,
             }
         )
 
-        mop = MeshOperation(self, meshop_name, props, "RotationalLayerMesh")
+        mop = MeshOperation(self, name, props, "RotationalLayerMesh")
         mop.create()
         mop.props["Total Layer Thickness"] = total_thickness
         self.meshoperations.append(mop)
         return mop
 
-    @pyaedt_function_handler()
-    def assign_edge_cut(self, names, layer_thickness="1mm", meshop_name=None):
+    @pyaedt_function_handler(names="assignment", meshop_name="name")
+    def assign_edge_cut(self, assignment, layer_thickness="1mm", name=None):
         """Assign an edge cut layer mesh.
 
         Parameters
         ----------
-        names : list
+        assignment : list
             List of objects.
         layer_thickness :
             Thickness of the layer with units. The default is ``"1mm"``.
-        meshop_name : str, optional
+        name : str, optional
             Name of the mesh operation. The default is ``None``.
 
         Returns
         -------
         :class:`pyaedt.modules.Mesh.MeshOperation`
             Mesh operation object.
 
         References
         ----------
 
         >>> oModule.AssignRotationalLayerOp
         """
-        names = self.modeler.convert_to_selections(names, True)
+        assignment = self.modeler.convert_to_selections(assignment, True)
 
         if self._app.design_type != "Maxwell 3D":
             raise MethodNotSupportedError
-        if meshop_name:
+        if name:
             for m in self.meshoperations:
-                if meshop_name == m.name:
-                    meshop_name = generate_unique_name(meshop_name)
+                if name == m.name:
+                    name = generate_unique_name(name)
         else:
-            meshop_name = generate_unique_name("EdgeCut")
+            name = generate_unique_name("EdgeCut")
         seltype = "Objects"
-        props = OrderedDict({"Type": "EdgeCutLayerMesh", seltype: names, "Layer Thickness": layer_thickness})
+        props = OrderedDict({"Type": "EdgeCutLayerMesh", seltype: assignment, "Layer Thickness": layer_thickness})
 
-        mop = MeshOperation(self, meshop_name, props, "EdgeCutLayerMesh")
+        mop = MeshOperation(self, name, props, "EdgeCutLayerMesh")
         mop.create()
         mop.props["Layer Thickness"] = layer_thickness
         self.meshoperations.append(mop)
         return mop
 
-    @pyaedt_function_handler()
-    def assign_density_control(self, names, refine_inside=True, maxelementlength=None, layerNum=None, meshop_name=None):
+    @pyaedt_function_handler(
+        names="assignment", maxelementlength="maximum_element_length", layerNum="layers_number", meshop_name="name"
+    )
+    def assign_density_control(
+        self, assignment, refine_inside=True, maximum_element_length=None, layers_number=None, name=None
+    ):
         """Assign density control.
 
         Parameters
         ----------
-        names : list
+        assignment : list
             List of objects.
         refine_inside : bool, optional
             Whether to refine inside objects. The default is ``True``.
-        maxelementlength : str, optional
+        maximum_element_length : str, optional
             Maximum element length with units. The default is ``None``,
             which disables this parameter.
-        layerNum : int, optional
+        layers_number : int, optional
             Number of layers. The default is ``None``, which disables
             this parameter.
-        meshop_name : str, optional
+        name : str, optional
             Name of the mesh operation. The default is ``None``.
 
         Returns
         -------
         :class:`pyaedt.modules.Mesh.MeshOperation`
             Mesh operation object.
 
         References
         ----------
 
         >>> oModule.AssignDensityControlOp
         """
-        names = self.modeler.convert_to_selections(names, True)
+        assignment = self.modeler.convert_to_selections(assignment, True)
 
         if self._app.design_type != "Maxwell 3D":
             raise MethodNotSupportedError
-        if meshop_name:
+        if name:
             for m in self.meshoperations:
-                if meshop_name == m.name:
-                    meshop_name = generate_unique_name(meshop_name)
+                if name == m.name:
+                    name = generate_unique_name(name)
         else:
-            meshop_name = generate_unique_name("CloneMeshDensity")
+            name = generate_unique_name("CloneMeshDensity")
         seltype = "Objects"
-        if not maxelementlength:
+        if not maximum_element_length:
             restr = False
             restrval = "0mm"
         else:
             restr = True
-            restrval = maxelementlength
-        if not layerNum:
+            restrval = maximum_element_length
+        if not layers_number:
             restrlay = False
             restrlaynum = "1"
         else:
             restrlay = True
-            restrlaynum = str(layerNum)
+            restrlaynum = str(layers_number)
         props = OrderedDict(
             {
                 "Type": "DensityControlBased",
                 "RefineInside": refine_inside,
-                seltype: names,
+                seltype: assignment,
                 "RestrictMaxElemLength": restr,
                 "MaxElemLength": restrval,
                 "RestrictLayersNum": restrlay,
                 "LayersNum": restrlaynum,
             }
         )
-        mop = MeshOperation(self, meshop_name, props, "DensityControlBased")
+        mop = MeshOperation(self, name, props, "DensityControlBased")
         mop.create()
         self.meshoperations.append(mop)
         return mop
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(obj="entity", meshop_name="name")
     def assign_cylindrical_gap(
         self,
-        obj,
-        meshop_name=None,
+        entity,
+        name=None,
         band_mapping_angle=None,
         clone_mesh=False,
         moving_side_layers=1,
         static_side_layers=1,
     ):
         """Assign a cylindrical gap for a 2D or 3D design to enable a clone mesh and associated band mapping angle.
 
         Parameters
         ----------
-        obj : int or str or :class:`pyaedt.modeler.cad.object3d.Object3d`
+        entity : int or str or :class:`pyaedt.modeler.cad.object3d.Object3d`
             Object to assign cylindrical gap to.
-        meshop_name : str, optional
+        name : str, optional
             Name of the mesh. The default is ``None``, in which
             case the default name is used.
         clone_mesh : bool, optional
             Whether to clone the mesh. This parameter is valid only for 3D design.
             The default is ``False``. If ``True``, the solid bodies adjacent to the band
             are detected to identify the clone object.
         band_mapping_angle : int, optional
@@ -1404,59 +1436,59 @@
 
         >>> oModule.AssignCylindricalGapOp
         """
         try:
             if self._app.design_type != "Maxwell 2D" and self._app.design_type != "Maxwell 3D":
                 raise MethodNotSupportedError
 
-            obj = self.modeler.convert_to_selections(obj, True)
-            if len(obj) > 1:
+            entity = self.modeler.convert_to_selections(entity, True)
+            if len(entity) > 1:
                 self.logger.error("Cylindrical gap treatment cannot be assigned to multiple objects.")
                 raise ValueError
             if [x for x in self.meshoperations if x.type == "Cylindrical Gap Based" or x.type == "CylindricalGap"]:
                 self.logger.error("Cylindrical gap treatment cannot be assigned to multiple objects.")
                 raise ValueError
             if band_mapping_angle and band_mapping_angle > 3:
                 self.logger.error("Band mapping angle must be between 0.0005 and 3 deg.")
                 raise ValueError
-            if not meshop_name:
-                meshop_name = generate_unique_name("CylindricalGap")
+            if not name:
+                name = generate_unique_name("CylindricalGap")
 
             if self._app.design_type == "Maxwell 3D":
                 if moving_side_layers < 1:
                     self.logger.error("Moving side layers must be an integer greater or equal to 1.")
                     raise ValueError
                 if static_side_layers < 1:
                     self.logger.error("Static side layers must be an integer greater or equal to 1.")
                     raise ValueError
                 if clone_mesh and not band_mapping_angle:
                     band_mapping_angle = 3
                 props = OrderedDict(
                     {
-                        "Name": meshop_name,
-                        "Objects": obj,
+                        "Name": name,
+                        "Objects": entity,
                         "CloneMesh": clone_mesh,
                         "BandMappingAngle": str(band_mapping_angle) + "deg",
                         "MovingSideLayers": moving_side_layers,
                         "StaticSideLayers": static_side_layers,
                     }
                 )
             elif self._app.design_type == "Maxwell 2D":
                 if band_mapping_angle:
                     use_band_mapping_angle = True
                 else:
                     use_band_mapping_angle = False
                     band_mapping_angle = 3
                 props = OrderedDict(
                     {
-                        "Name": meshop_name,
-                        "Objects": obj,
+                        "Name": name,
+                        "Objects": entity,
                         "UseBandMappingAngle": use_band_mapping_angle,
                         "BandMappingAngle": str(band_mapping_angle) + "deg",
                     }
                 )
-            mesh_operation = MeshOperation(self, meshop_name, props, "CylindricalGap")
+            mesh_operation = MeshOperation(self, name, props, "CylindricalGap")
             mesh_operation.create()
             self.meshoperations.append(mesh_operation)
             return mesh_operation
         except Exception:
             return False
```

### Comparing `pyaedt-0.8.7/pyaedt/modules/Mesh3DLayout.py` & `pyaedt-0.8.8/pyaedt/modules/Mesh3DLayout.py`

 * *Files 6% similar despite different names*

```diff
@@ -171,37 +171,37 @@
         References
         ----------
 
         >>> oDesign.GetModule("SolveSetups")
         """
         return self._app.omeshmodule
 
-    @pyaedt_function_handler()
-    def delete_mesh_operations(self, setup_name, mesh_name):
+    @pyaedt_function_handler(setup_name="setup", mesh_name="name")
+    def delete_mesh_operations(self, setup, name):
         """Remove mesh operations from a setup.
 
         Parameters
         ----------
-        setup_name : str
+        setup : str
             Name of the setup.
-        mesh_name : str
+        name : str
             Name of the mesh.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         References
         ----------
 
         >>> oModule.DeleteMeshOperation
         """
         for el in self.meshoperations:
-            if el.hfss_setup_name == setup_name and el.name == mesh_name:
+            if el.hfss_setup_name == setup and el.name == name:
                 el.delete()
                 self.meshoperations.remove(el)
 
         return True
 
     @pyaedt_function_handler()
     def _get_design_mesh_operations(self):
@@ -220,182 +220,196 @@
                     for ops in self._app.design_properties["Setup"]["Data"][ds]["MeshOps"]:
                         props = self._app.design_properties["Setup"]["Data"][ds]["MeshOps"][ops]
                         meshops.append(Mesh3DOperation(self, ds, ops, props))
         except Exception:
             pass
         return meshops
 
-    @pyaedt_function_handler()
-    def assign_length_mesh(
-        self, setupname, layer_name, net_name, isinside=True, maxlength=1, maxel=1000, meshop_name=None
-    ):
+    @pyaedt_function_handler(
+        setupname="setup",
+        layer_name="layer",
+        net_name="net",
+        isinside="is_inside",
+        maxlength="maximum_length",
+        maxel="maximum_elements",
+        meshop_name="name",
+    )
+    def assign_length_mesh(self, setup, layer, net, is_inside=True, maximum_length=1, maximum_elements=1000, name=None):
         """Assign mesh length.
 
         Parameters
         ----------
-        setupname : str
+        setup : str
             Name of the HFSS setup to apply.
-        layer_name : str
+        layer : str
            Name of the layer.
-        net_name : str
+        net : str
            Name of the net.
-        isinside : bool, optional
+        is_inside : bool, optional
             Whether the mesh length is inside the selection. The default is ``True``.
-        maxlength : float, optional
+        maximum_length : float, optional
             Maximum length of the element. The default is ``1`` When ``None``, this
             parameter is disabled.
-        maxel : int, optional
+        maximum_elements : int, optional
             Maximum number of elements. The default is ``1000``. When ``None``, this
             parameter is disabled.
-        meshop_name : str, optional
+        name : str, optional
             Name of the mesh operation. The default is ``None``.
 
         Returns
         -------
         type
             Mesh operation object.
 
         References
         ----------
 
         >>> oModule.AddMeshOperation
         """
-        if meshop_name:
+        if name:
             for el in self.meshoperations:
-                if el.name == meshop_name:
-                    meshop_name = generate_unique_name(meshop_name)
+                if el.name == name:
+                    name = generate_unique_name(name)
         else:
-            meshop_name = generate_unique_name("Length")
+            name = generate_unique_name("Length")
 
-        if maxlength is None:
+        if maximum_length is None:
             restrictlength = False
         else:
             restrictlength = True
-        length = self.modeler.modeler_variable(maxlength)
+        length = self.modeler.modeler_variable(maximum_length)
 
-        if maxel is None:
+        if maximum_elements is None:
             restrictel = False
             numel = "1000"
         else:
             restrictel = True
-            numel = str(maxel)
-        if maxlength is None and maxel is None:
+            numel = str(maximum_elements)
+        if maximum_length is None and maximum_elements is None:
             self.logger.error("mesh not assigned due to incorrect settings")
             return
-        if isinstance(layer_name, list) and isinstance(net_name, list):
+        if isinstance(layer, list) and isinstance(net, list):
             assignment = OrderedDict({"MeshEntityInfo": []})
-            for l, n in zip(layer_name, net_name):
+            for l, n in zip(layer, net):
                 meshbody = OrderedDict({"Id": -1, "Nam": "", "Layer": l, "Net": n, "OrigNet": n})
                 assignment["MeshEntityInfo"].append(
                     OrderedDict({"IsFcSel": False, "EntID": -1, "FcIDs": [], "MeshBody": meshbody, "BBox": []})
                 )
         else:
-            meshbody = OrderedDict({"Id": -1, "Nam": "", "Layer": layer_name, "Net": net_name, "OrigNet": net_name})
+            meshbody = OrderedDict({"Id": -1, "Nam": "", "Layer": layer, "Net": net, "OrigNet": net})
             assignment = OrderedDict(
                 {
                     "MeshEntityInfo": OrderedDict(
                         {"IsFcSel": False, "EntID": -1, "FcIDs": [], "MeshBody": meshbody, "BBox": []}
                     )
                 }
             )
         props = OrderedDict(
             {
                 "Type": "LengthBased",
-                "RefineInside": isinside,
+                "RefineInside": is_inside,
                 "Enabled": True,
                 "Assignment": assignment,
                 "Region": "",
                 "RestrictElem": restrictel,
                 "NumMaxElem": numel,
                 "RestrictLength": restrictlength,
                 "MaxLength": length,
             }
         )
 
-        mop = Mesh3DOperation(self, setupname, meshop_name, props)
+        mop = Mesh3DOperation(self, setup, name, props)
         mop.create()
         self.meshoperations.append(mop)
         return mop
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(
+        setupname="setup",
+        layer_name="layer",
+        net_name="net",
+        skindepth="skin_depth",
+        maxelements="maximum_elements",
+        numlayers="layers_number",
+        meshop_name="name",
+    )
     def assign_skin_depth(
         self,
-        setupname,
-        layer_name,
-        net_name,
-        skindepth=1,
-        maxelements=None,
+        setup,
+        layer,
+        net,
+        skin_depth=1,
+        maximum_elements=None,
         triangulation_max_length=0.1,
-        numlayers="2",
-        meshop_name=None,
+        layers_number="2",
+        name=None,
     ):
         """Assign skin depth to the mesh.
 
         Parameters
         ----------
-        setupname : str
+        setup : str
             Name of the setup.
-        layer_name : str
+        layer : str
             Name of the layer.
-        net_name : str
+        net : str
             Name of the net.
-        skindepth : int, optional
+        skin_depth : int, optional
             Depth of the skin. The default is ``1``.
-        maxelements : float, optional
+        maximum_elements : float, optional
             Maximum element length. The default is ``None``, which disables this parameter.
         triangulation_max_length : float, optional
             Maximum surface triangulation length. The default is ``0.1``.
-        numlayers : str, optional
+        layers_number : str, optional
             Number of layers. The default is ``"2"``.
-        meshop_name : str, optional
+        name : str, optional
              Name of the mesh operation. The default is ``None``.
 
         Returns
         -------
         type
             Mesh operation object.
 
         References
         ----------
 
         >>> oModule.AddMeshOperation
         """
-        if meshop_name:
+        if name:
             for el in self.meshoperations:
-                if el.name == meshop_name:
-                    meshop_name = generate_unique_name(meshop_name)
+                if el.name == name:
+                    name = generate_unique_name(name)
         else:
-            meshop_name = generate_unique_name("SkinDepth")
+            name = generate_unique_name("SkinDepth")
 
-        if maxelements is None:
+        if maximum_elements is None:
             restrictlength = False
-            maxelements = "1000"
+            maximum_elements = "1000"
         else:
             restrictlength = True
-        skindepth = self.modeler.modeler_variable(skindepth)
+        skin_depth = self.modeler.modeler_variable(skin_depth)
         triangulation_max_length = self.modeler.modeler_variable(triangulation_max_length)
-        meshbody = OrderedDict({"Id": -1, "Nam": "", "Layer": layer_name, "Net": net_name, "OrigNet": net_name})
+        meshbody = OrderedDict({"Id": -1, "Nam": "", "Layer": layer, "Net": net, "OrigNet": net})
         assignment = OrderedDict(
             {
                 "MeshEntityInfo": OrderedDict(
                     {"IsFcSel": False, "EntID": -1, "FcIDs": [], "MeshBody": meshbody, "BBox": []}
                 )
             }
         )
         props = OrderedDict(
             {
                 "Type": "SkinDepthLengthBased",
                 "Enabled": True,
                 "Assignment": assignment,
                 "Region": "",
-                "SkinDepth": skindepth,
+                "SkinDepth": skin_depth,
                 "SurfTriMaxLength": triangulation_max_length,
-                "NumLayers": numlayers,
+                "NumLayers": layers_number,
                 "RestrictElem": restrictlength,
-                "NumMaxElem": maxelements,
+                "NumMaxElem": maximum_elements,
             }
         )
 
-        mop = Mesh3DOperation(self, setupname, meshop_name, props)
+        mop = Mesh3DOperation(self, setup, name, props)
         mop.create()
         self.meshoperations.append(mop)
         return mop
```

### Comparing `pyaedt-0.8.7/pyaedt/modules/MeshIcepak.py` & `pyaedt-0.8.8/pyaedt/modules/MeshIcepak.py`

 * *Files 2% similar despite different names*

```diff
@@ -616,14 +616,15 @@
         References
         ----------
 
         >>> oModule.EditGlobalMeshRegion
         """
         args = ["NAME:Settings"]
         args += self.settings.parse_settings()
+        args += ["UserSpecifiedSettings:=", self.manual_settings]
         try:
             self._app.omeshmodule.EditGlobalMeshRegion(args)
             return True
         except GrpcApiError:  # pragma : no cover
             return False
 
     @property
@@ -742,15 +743,15 @@
         ----------
 
         >>> oModule.EditMeshRegion
         """
         args = ["NAME:" + self.name, "Enable:=", self.enable]
         args += self.settings.parse_settings()
         args += self._parse_assignment_value()
-        args += ["UserSpecifiedSettings:=", not self.manual_settings]
+        args += ["UserSpecifiedSettings:=", self.manual_settings]
         try:
             self._app.omeshmodule.EditMeshRegion(self.name, args)
             return True
         except GrpcApiError:  # pragma : no cover
             return False
 
     @pyaedt_function_handler()
@@ -1046,24 +1047,24 @@
                                 meshop.__dict__[el] = dict_prop[el]
                         meshops.append(meshop)
         except Exception as e:
             self._app.logger.error(e)
 
         return meshops
 
-    @pyaedt_function_handler()
-    def assign_mesh_level(self, mesh_order, meshop_name=None):
+    @pyaedt_function_handler(meshop_name="name")
+    def assign_mesh_level(self, mesh_order, name=None):
         """Assign a mesh level to objects.
 
         Parameters
         ----------
         mesh_order : dict
             Dictionary where the key is the object name and the value is
             the mesh level.
-        meshop_name :  str, optional
+        name :  str, optional
             Name of the mesh operation. The default is ``None``.
 
         Returns
         -------
         list of :class:`pyaedt.modules.Mesh.MeshOperation`
             ``True`` when successful, ``False`` when failed.
 
@@ -1075,64 +1076,64 @@
         level_order = {}
         for obj in mesh_order:
             if mesh_order[obj] not in level_order.keys():
                 level_order[mesh_order[obj]] = []
             level_order[mesh_order[obj]].append(obj)
         list_meshops = []
         for level in level_order:
-            if meshop_name:
-                meshop_name = generate_unique_name(meshop_name, "L_" + str(level))
+            if name:
+                name = generate_unique_name(name, "L_" + str(level))
             else:
-                meshop_name = generate_unique_name("Icepak", "L_" + str(level))
+                name = generate_unique_name("Icepak", "L_" + str(level))
             props = OrderedDict({"Enable": True, "Level": str(level), "Objects": level_order[level]})
-            mop = MeshOperation(self, meshop_name, props, "Icepak")
+            mop = MeshOperation(self, name, props, "Icepak")
             mop.create()
             self.meshoperations.append(mop)
-            list_meshops.append(meshop_name)
+            list_meshops.append(name)
         return list_meshops
 
-    @pyaedt_function_handler()
-    def assign_mesh_from_file(self, objects, filename, meshop_name=None):
-        """Assign a mesh from file to objects.
+    @pyaedt_function_handler(objects="assignment", filename="file_name", meshop_name="name")
+    def assign_mesh_from_file(self, assignment, file_name, name=None):
+        """Assign a mesh from a file to objects.
 
         Parameters
         ----------
-        objects : list
-            List of objects to which apply the mesh file.
-        filename :  str
-            Full path to .msh file.
-        meshop_name :  str, optional
+        assignment : list
+            List of objects to apply the mesh file to.
+        file_name :  str
+            Full path to the mesh (MSH) file.
+        name :  str, optional
             Name of the mesh operations. Default is ``None``.
 
         Returns
         -------
          :class:`pyaedt.modules.Mesh.MeshOperation`
             Mesh Operation object. ``False`` when failed.
 
         References
         ----------
 
         >>> oModule.AssignMeshOperation
         """
-        objs = self._app.modeler.convert_to_selections(objects, True)
-        if meshop_name:
-            meshop_name = generate_unique_name("MeshFile")
+        objs = self._app.modeler.convert_to_selections(assignment, True)
+        if name:
+            name = generate_unique_name("MeshFile")
         else:
-            meshop_name = generate_unique_name("MeshFile")
+            name = generate_unique_name("MeshFile")
         props = OrderedDict({"Enable": True, "MaxLevel": str(0), "MinLevel": str(0), "Objects": objs})
         props["Local Mesh Parameters Enabled"] = False
         props["Mesh Reuse Enabled"] = True
-        props["Mesh Reuse File"] = filename
+        props["Mesh Reuse File"] = file_name
         props["Local Mesh Parameters Type"] = "3DPolygon Local Mesh Parameters"
         props["Height count"] = "0"
         props["Top height"] = "0mm"
         props["Top ratio"] = "0"
         props["Bottom height"] = "0mm"
         props["Bottom ratio"] = "0"
-        mop = MeshOperation(self, meshop_name, props, "Icepak")
+        mop = MeshOperation(self, name, props, "Icepak")
         if mop.create():
             self.meshoperations.append(mop)
             return mop
         return False
 
     @pyaedt_function_handler()
     def automatic_mesh_pcb(self, accuracy=2):
@@ -1171,63 +1172,63 @@
         self.global_mesh_region.BufferLayers = 1
         self.global_mesh_region.MinGapX = str(xsize / 10)
         self.global_mesh_region.MinGapY = str(ysize / 10)
         self.global_mesh_region.MinGapZ = str(zsize / 10)
         self.global_mesh_region.update()
         return True
 
-    @pyaedt_function_handler()
-    def automatic_mesh_3D(self, accuracy2, stairStep=True):
+    @pyaedt_function_handler(accuracy2="accuracy", stairStep="enable_stair_step")
+    def automatic_mesh_3D(self, accuracy, enable_stair_step=True):
         """Create a generic custom mesh for a custom 3D object.
 
         Parameters
         ----------
-        accuracy2 : int
+        accuracy : int
             Type of the mesh. Options are ``1``, ``2``, and ``3``, which represent respectively
             a coarse, standard, or very accurate mesh.
-        stairStep : bool, optional
+        enable_stair_step : bool, optional
             Whether to enable a stair step. The default is ``True``.
 
         Returns
         -------
          bool
             ``True`` when successful, ``False`` when failed.
 
         References
         ----------
 
         >>> oModule.EditMeshOperation
         """
-        xsize = self.boundingdimension[0] / (10 * accuracy2 * accuracy2)
-        ysize = self.boundingdimension[1] / (10 * accuracy2 * accuracy2)
-        zsize = self.boundingdimension[2] / (10 * accuracy2)
+        xsize = self.boundingdimension[0] / (10 * accuracy * accuracy)
+        ysize = self.boundingdimension[1] / (10 * accuracy * accuracy)
+        zsize = self.boundingdimension[2] / (10 * accuracy)
         self.global_mesh_region.MaxElementSizeX = xsize
         self.global_mesh_region.MaxElementSizeY = ysize
         self.global_mesh_region.MaxElementSizeZ = zsize
         self.global_mesh_region.UserSpecifiedSettings = True
         self.global_mesh_region.MinGapX = str(xsize / 100)
         self.global_mesh_region.MinGapY = str(ysize / 100)
         self.global_mesh_region.MinGapZ = str(zsize / 100)
-        self.global_mesh_region.StairStepMeshing = stairStep
+        self.global_mesh_region.StairStepMeshing = enable_stair_step
         self.global_mesh_region.update()
         return True
 
-    @pyaedt_function_handler()
-    def add_priority(self, entity_type, obj_list=None, comp_name=None, priority=3):
+    @pyaedt_function_handler(obj_list="assignment", comp_name="component")
+    def add_priority(self, entity_type, assignment=None, component=None, priority=3):
         """Add priority to objects.
 
         Parameters
         ----------
         entity_type : int
             Type of the entity. Options are ``1`` and ``2``, which represent respectively
             an object and a component.
-        obj_list : list
+        assignment : list
             List of 3D objects, which can include conductors and dielectrics.
-            If the user pass a non 3D object, it will be excluded.
-        comp_name : str, optional
+            If a non-3D object is passed, it is excluded.
+        component : str, optional
             Name of the component. The default is ``None``.
         priority : int, optional
             Level of priority. The default is ``3``.
 
         Returns
         -------
         bool
@@ -1239,110 +1240,110 @@
         >>> oEditor.UpdatePriorityList
 
         Examples
         --------
 
         >>> from pyaedt import Icepak
         >>> app = Icepak()
-        >>> app.mesh.add_priority(entity_type=1, obj_list=app.modeler.object_names, priority=3)
-        >>> app.mesh.add_priority(entity_type=2, comp_name=app.modeler.user_defined_component_names[0], priority=2)
+        >>> app.mesh.add_priority(entity_type=1,assignment=app.modeler.object_names,priority=3)
+        >>> app.mesh.add_priority(entity_type=2,component=app.modeler.user_defined_component_names[0],priority=2)
         """
         i = priority
 
         args = ["NAME:UpdatePriorityListData"]
         if entity_type == 1:
             non_user_defined_component_parts = self._app.modeler.oeditor.GetChildNames()
             new_obj_list = []
-            for comp in obj_list:
+            for comp in assignment:
                 if comp != "Region" and comp in non_user_defined_component_parts:
                     new_obj_list.append(comp)
-            objects = ", ".join(new_obj_list)
+            assignment = ", ".join(new_obj_list)
             if not new_obj_list:
                 return False
             prio = [
                 "NAME:PriorityListParameters",
                 "EntityType:=",
                 "Object",
                 "EntityList:=",
-                objects,
+                assignment,
                 "PriorityNumber:=",
                 i,
                 "PriorityListType:=",
                 ["2D", "3D"][int(self._app.modeler[new_obj_list[0]].is3d)],
             ]
             self._priorities_args.append(prio)
             args += self._priorities_args
         elif entity_type == 2:
-            o = self.modeler.user_defined_components[comp_name]
+            o = self.modeler.user_defined_components[component]
             if (all(part.is3d for part in o.parts.values()) is False) and (
                 any(part.is3d for part in o.parts.values()) is True
             ):
                 prio_3d = [
                     "NAME:PriorityListParameters",
                     "EntityType:=",
                     "Component",
                     "EntityList:=",
-                    comp_name,
+                    component,
                     "PriorityNumber:=",
                     i,
                     "PriorityListType:=",
                     "3D",
                 ]
                 prio_2d = [
                     "NAME:PriorityListParameters",
                     "EntityType:=",
                     "Component",
                     "EntityList:=",
-                    comp_name,
+                    component,
                     "PriorityNumber:=",
                     i,
                     "PriorityListType:=",
                     "2D",
                 ]
                 self._priorities_args.append(prio_3d)
                 self._priorities_args.append(prio_2d)
             elif all(part.is3d for part in o.parts.values()) is True:
                 prio_3d = [
                     "NAME:PriorityListParameters",
                     "EntityType:=",
                     "Component",
                     "EntityList:=",
-                    comp_name,
+                    component,
                     "PriorityNumber:=",
                     i,
                     "PriorityListType:=",
                     "3D",
                 ]
                 self._priorities_args.append(prio_3d)
             else:
                 prio_2d = [
                     "NAME:PriorityListParameters",
                     "EntityType:=",
                     "Component",
                     "EntityList:=",
-                    comp_name,
+                    component,
                     "PriorityNumber:=",
                     i,
                     "PriorityListType:=",
                     "2D",
                 ]
                 self._priorities_args.append(prio_2d)
 
             args += self._priorities_args
         self.modeler.oeditor.UpdatePriorityList(["NAME:UpdatePriorityListData"])
         self.modeler.oeditor.UpdatePriorityList(args)
         return True
 
-    @pyaedt_function_handler()
-    def assign_mesh_region(self, objectlist=None, level=5, name=None, **kwargs):
+    @pyaedt_function_handler(objectlist="assignment")
+    def assign_mesh_region(self, assignment=None, level=5, name=None, **kwargs):
         """Assign a predefined surface mesh level to an object.
 
         Parameters
         ----------
-        objectlist : list, optional
+        assignment : list, optional
             List of objects to apply the mesh region to. The default
             is ``None``, in which case all objects are selected.
         level : int, optional
             Level of the surface mesh. Options are ``1`` through ``5``. The default
             is ``5``.
         name : str, optional
             Name of the mesh region. The default is ``"MeshRegion1"``.
@@ -1354,27 +1355,27 @@
         References
         ----------
 
         >>> oModule.AssignMeshRegion
         """
         if not name:
             name = generate_unique_name("MeshRegion")
-        if objectlist is None:
-            objectlist = [i for i in self.modeler.object_names]
-        meshregion = MeshRegion(self._app, objectlist, name)
+        if assignment is None:
+            assignment = [i for i in self.modeler.object_names]
+        meshregion = MeshRegion(self._app, assignment, name)
         meshregion.manual_settings = False
         meshregion.Level = level
         all_objs = [i for i in self.modeler.object_names]
         created = bool(meshregion)
         if created:
             if settings.aedt_version < "2024.1":
                 objectlist2 = self.modeler.object_names
                 added_obj = [i for i in objectlist2 if i not in all_objs]
                 if not added_obj:
-                    added_obj = [i for i in objectlist2 if i not in all_objs or i in objectlist]
+                    added_obj = [i for i in objectlist2 if i not in all_objs or i in assignment]
                 meshregion.Objects = added_obj
                 meshregion.SubModels = None
                 meshregion.update()
             return meshregion
         else:
             return False
 
@@ -1397,59 +1398,64 @@
 
         >>> oDesign.GenerateMesh
         """
         if name is None:
             name = []
         return self._odesign.GenerateMesh(name) == 0
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(
+        groupName="group_name",
+        localMeshParamEn="enable_local_mesh_parameters",
+        localMeshParameters="local_mesh_parameters",
+        meshop_name="name",
+    )
     def assign_mesh_level_to_group(
         self,
         mesh_level,
-        groupName,
-        localMeshParamEn=False,
-        localMeshParameters="No local mesh parameters",
-        meshop_name=None,
+        group_name,
+        enable_local_mesh_parameters=False,
+        local_mesh_parameters="No local mesh parameters",
+        name=None,
     ):
         """Assign a mesh level to a group.
 
         Parameters
         ----------
         mesh_level : int
             Level of mesh to assign. Options are ``1`` through ``5``.
-        groupName : str
+        group_name : str
             Name of the group.
-        localMeshParamEn : bool, optional
+        enable_local_mesh_parameters : bool, optional
             The default is ``False``.
-        localMeshParameters : str, optional
+        local_mesh_parameters : str, optional
             The default is ``"No Local Mesh Parameters"``.
-        meshop_name : str, optional
+        name : str, optional
             Name of the mesh operation. The default is ``None``.
 
         Returns
         -------
         :class:`pyaedt.modules.Mesh.MeshOperation`
 
         References
         ----------
 
         >>> oModule.AssignMeshOperation
         """
-        if meshop_name:
+        if name:
             for el in self.meshoperations:
-                if el.name == meshop_name:
-                    meshop_name = generate_unique_name(meshop_name)
+                if el.name == name:
+                    name = generate_unique_name(name)
         else:
-            meshop_name = generate_unique_name("MeshLevel")
+            name = generate_unique_name("MeshLevel")
         props = OrderedDict(
             {
                 "Enable": True,
                 "Level": mesh_level,
-                "Local Mesh Parameters Enabled": localMeshParamEn,
-                "Groups": [str(groupName)],
-                "Local Mesh Parameters Type": localMeshParameters,
+                "Local Mesh Parameters Enabled": enable_local_mesh_parameters,
+                "Groups": [str(group_name)],
+                "Local Mesh Parameters Type": local_mesh_parameters,
             }
         )
-        mop = MeshOperation(self, meshop_name, props, "Icepak")
+        mop = MeshOperation(self, name, props, "Icepak")
         mop.create()
         self.meshoperations.append(mop)
         return mop
```

### Comparing `pyaedt-0.8.7/pyaedt/modules/OptimetricsTemplates.py` & `pyaedt-0.8.8/pyaedt/modules/OptimetricsTemplates.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/modules/PostProcessor.py` & `pyaedt-0.8.8/pyaedt/modules/PostProcessor.py`

 * *Files 5% similar despite different names*

```diff
@@ -9,14 +9,15 @@
 
 import ast
 from collections import OrderedDict
 from collections import defaultdict
 import csv
 import os
 import random
+import re
 import string
 import tempfile
 
 from pyaedt import is_ironpython
 from pyaedt.application.Variables import decompose_variable_value
 from pyaedt.generic.DataHandlers import _dict_items_to_list_items
 from pyaedt.generic.constants import unit_converter
@@ -33,18 +34,18 @@
 from pyaedt.modules.solutions import VRTFieldPlot
 
 if not is_ironpython:
     try:
         from enum import Enum
 
         import pandas as pd
-    except ImportError:
+    except ImportError:  # pragma: no cover
         pd = None
         Enum = None
-else:
+else:  # pragma: no cover
     Enum = object
 
 TEMPLATES_BY_DESIGN = {
     "HFSS": [
         "Modal Solution Data",
         "Terminal Solution Data",
         "Eigenmode Parameters",
@@ -72,15 +73,15 @@
         "Electrostatic",
         "ElectricTransient",
         "ElectroDCConduction",
         "Fields",
         "Spectrum",
     ],
     "Icepak": ["Monitor", "Fields"],
-    "Circuit Design": ["Standard", "Eye Diagram", "Statistical Eye", "Spectrum"],
+    "Circuit Design": ["Standard", "Eye Diagram", "Statistical Eye", "Spectrum", "EMIReceiver"],
     "HFSS 3D Layout": ["Standard", "Fields", "Spectrum"],
     "HFSS 3D Layout Design": ["Standard", "Fields", "Spectrum"],
     "Mechanical": ["Standard", "Fields"],
     "Q3D Extractor": ["Matrix", "CG Fields", "DC R/L Fields", "AC R/L Fields"],
     "2D Extractor": ["Matrix", "CG Fields", "RL Fields"],
     "Twin Builder": ["Standard", "Spectrum"],
 }
@@ -97,14 +98,15 @@
     "Far Fields": rt.FarField,
     "Near Fields": rt.NearField,
     "Eye Diagram": rt.EyeDiagram,
     "Statistical Eye": rt.AMIEyeDiagram,
     "AMI Contour": rt.AMIConturEyeDiagram,
     "Eigenmode Parameters": rt.Standard,
     "Spectrum": rt.Spectral,
+    "EMIReceiver": rt.EMIReceiver,
 }
 
 
 class Reports(object):
     """Provides the names of default solution types."""
 
     def __init__(self, post_app, design_type):
@@ -115,482 +117,501 @@
     @pyaedt_function_handler()
     def _retrieve_default_expressions(self, expressions, report, setup_sweep_name):
         if expressions:
             return expressions
         setup_only_name = setup_sweep_name.split(":")[0].strip()
         get_setup = self._post_app._app.get_setup(setup_only_name)
         is_siwave_dc = False
-        if "SolveSetupType" in get_setup.props and get_setup.props["SolveSetupType"] == "SiwaveDCIR":
+        if (
+            "SolveSetupType" in get_setup.props and get_setup.props["SolveSetupType"] == "SiwaveDCIR"
+        ):  # pragma: no cover
             is_siwave_dc = True
         return self._post_app.available_report_quantities(
             solution=setup_sweep_name, context=report._context, is_siwave_dc=is_siwave_dc
         )
 
-    @pyaedt_function_handler()
-    def standard(self, expressions=None, setup_name=None):
+    @pyaedt_function_handler(setup_name="setup")
+    def standard(self, expressions=None, setup=None):
         """Create a standard or default report object.
 
         Parameters
         ----------
         expressions : str or list
             Expression List to add into the report. The expression can be any of the available formula
             you can enter into the Electronics Desktop Report Editor.
-        setup_name : str, optional
-            Name of the setup. The default is ``None`` which automatically take ``nominal_adaptive`` setup.
-            Please make sure to build a setup string in the form of ``"SetupName : SetupSweep"``
-            where ``SetupSweep`` is the Sweep name to use in the export or ``LastAdaptive``.
+        setup : str, optional
+            Name of the setup. The default is ``None``, in which case the ``nominal_adaptive``
+            setup is used. Be sure to build a setup string in the form of
+            ``"SetupName : SetupSweep"``, where ``SetupSweep`` is the sweep name to
+            use in the export or ``LastAdaptive``.
 
         Returns
         -------
         :class:`pyaedt.modules.report_templates.Standard`
 
         Examples
         --------
 
         >>> from pyaedt import Circuit
         >>> cir = Circuit(my_project)
-        >>> report = cir.post.reports_by_category.standard("dB(S(1,1))", "LNA")
+        >>> report = cir.post.reports_by_category.standard("dB(S(1,1))","LNA")
         >>> report.create()
         >>> solutions = report.get_solution_data()
-        >>> report2 = cir.post.reports_by_category.standard(["dB(S(2,1))", "dB(S(2,2))"] , "LNA")
+        >>> report2 = cir.post.reports_by_category.standard(["dB(S(2,1))", "dB(S(2,2))"],"LNA")
 
         """
-        if not setup_name:
-            setup_name = self._post_app._app.nominal_sweep
+        if not setup:
+            setup = self._post_app._app.nominal_sweep
         rep = None
         if "Standard" in self._templates:
-            rep = rt.Standard(self._post_app, "Standard", setup_name)
+            rep = rt.Standard(self._post_app, "Standard", setup)
 
         elif self._post_app._app.design_solutions.report_type:
-            rep = rt.Standard(self._post_app, self._post_app._app.design_solutions.report_type, setup_name)
-        rep.expressions = self._retrieve_default_expressions(expressions, rep, setup_name)
+            rep = rt.Standard(self._post_app, self._post_app._app.design_solutions.report_type, setup)
+        rep.expressions = self._retrieve_default_expressions(expressions, rep, setup)
         return rep
 
-    @pyaedt_function_handler()
-    def monitor(self, expressions=None, setup_name=None):
+    @pyaedt_function_handler(setup_name="setup")
+    def monitor(self, expressions=None, setup=None):
         """Create an Icepak Monitor Report object.
 
         Parameters
         ----------
         expressions : str or list
-            Expression List to add into the report. The expression can be any of the available formula
+            One or more expressions to add to the report. The expression can be any of the available formula
             you can enter into the Electronics Desktop Report Editor.
-        setup_name : str, optional
-            Name of the setup. The default is ``None`` which automatically take ``nominal_adaptive`` setup.
-            Please make sure to build a setup string in the form of ``"SetupName : SetupSweep"``
-            where ``SetupSweep`` is the Sweep name to use in the export or ``LastAdaptive``.
+        setup : str, optional
+            Name of the setup. The default is ``None``, in which case the ``nominal_adaptive``
+            setup is used. Be sure to build a setup string in the form of
+            ``"SetupName : SetupSweep"``, where ``SetupSweep`` is the sweep name to
+            use in the export or ``LastAdaptive``.
 
         Returns
         -------
         :class:`pyaedt.modules.report_templates.Standard`
 
         Examples
         --------
 
         >>> from pyaedt import Icepak
         >>> ipk = Icepak(my_project)
         >>> report = ipk.post.reports_by_category.monitor(["monitor_surf.Temperature","monitor_point.Temperature"])
         >>> report = report.create()
         """
-        if not setup_name:
-            setup_name = self._post_app._app.nominal_sweep
+        if not setup:
+            setup = self._post_app._app.nominal_sweep
+        rep = None
         if "Monitor" in self._templates:
-            rep = rt.Standard(self._post_app, "Monitor", setup_name)
-            rep.expressions = self._retrieve_default_expressions(expressions, rep, setup_name)
-
-            return rep
-        return
+            rep = rt.Standard(self._post_app, "Monitor", setup)
+            rep.expressions = self._retrieve_default_expressions(expressions, rep, setup)
+        return rep
 
-    @pyaedt_function_handler()
-    def fields(self, expressions=None, setup_name=None, polyline=None):
+    @pyaedt_function_handler(setup_name="setup")
+    def fields(self, expressions=None, setup=None, polyline=None):
         """Create a Field Report object.
 
         Parameters
         ----------
         expressions : str or list
-            Expression List to add into the report. The expression can be any of the available formula
+            One or more expressions to add to the report. The expression can be any of the available formula
             you can enter into the Electronics Desktop Report Editor.
-        setup_name : str, optional
-            Name of the setup. The default is ``None`` which automatically take ``nominal_adaptive`` setup.
-            Please make sure to build a setup string in the form of ``"SetupName : SetupSweep"``
-            where ``SetupSweep`` is the Sweep name to use in the export or ``LastAdaptive``.
+        setup : str, optional
+            Name of the setup. The default is ``None``, in which case the ``nominal_adaptive``
+            setup is used. Be sure to build a setup string in the form of
+            ``"SetupName : SetupSweep"``, where ``SetupSweep`` is the sweep name to
+            use in the export or ``LastAdaptive``.
+        polyline : str, optional
+            Name of the polyline to plot the field on.
+            If a name is not provided, the report might be incorrect.
+            The default value is ``None``.
 
         Returns
         -------
         :class:`pyaedt.modules.report_templates.Fields`
 
         Examples
         --------
 
         >>> from pyaedt import Hfss
-        >>> app = Hfss(my_project)
-        >>> report = app.post.reports_by_category.fields("Mag_E", "Setup : LastAdaptive", "Polyline1")
+        >>> hfss = Hfss(my_project)
+        >>> report = hfss.post.reports_by_category.fields("Mag_E", "Setup : LastAdaptive", "Polyline1")
         >>> report.create()
         >>> solutions = report.get_solution_data()
         """
-        if not setup_name:
-            setup_name = self._post_app._app.nominal_sweep
+        if not setup:
+            setup = self._post_app._app.nominal_sweep
+        rep = None
         if "Fields" in self._templates:
-            rep = rt.Fields(self._post_app, "Fields", setup_name)
+            rep = rt.Fields(self._post_app, "Fields", setup)
             rep.polyline = polyline
-            rep.expressions = self._retrieve_default_expressions(expressions, rep, setup_name)
-
-            return rep
-        return
+            rep.expressions = self._retrieve_default_expressions(expressions, rep, setup)
+        return rep
 
-    @pyaedt_function_handler()
-    def cg_fields(self, expressions=None, setup_name=None, polyline=None):
-        """Create a CG Field Report object in Q3d and Q2D.
+    @pyaedt_function_handler(setup_name="setup")
+    def cg_fields(self, expressions=None, setup=None, polyline=None):
+        """Create a CG Field Report object in Q3D and Q2D.
 
         Parameters
         ----------
         expressions : str or list
             Expression List to add into the report. The expression can be any of the available formula
             you can enter into the Electronics Desktop Report Editor.
-        setup_name : str, optional
-            Name of the setup. The default is ``None`` which automatically take ``nominal_adaptive`` setup.
-            Please make sure to build a setup string in the form of ``"SetupName : SetupSweep"``
-            where ``SetupSweep`` is the Sweep name to use in the export or ``LastAdaptive``.
+        setup : str, optional
+            Name of the setup. The default is ``None``, in which case the ``nominal_adaptive``
+            setup is used. Be sure to build a setup string in the form of
+            ``"SetupName : SetupSweep"``, where ``SetupSweep`` is the sweep name to
+            use in the export or ``LastAdaptive``.
+        polyline : str, optional
+            Name of the polyline to plot the field on.
+            If a name is not provided, the report might be incorrect.
+            The default value is ``None``.
 
         Returns
         -------
         :class:`pyaedt.modules.report_templates.Fields`
 
         Examples
         --------
 
         >>> from pyaedt import Q3d
-        >>> app = Q3d(my_project)
-        >>> report = app.post.reports_by_category.cg_fields("SmoothQ", "Setup : LastAdaptive", "Polyline1")
+        >>> q3d = Q3d(my_project)
+        >>> report = q3d.post.reports_by_category.cg_fields("SmoothQ", "Setup : LastAdaptive", "Polyline1")
         >>> report.create()
         >>> solutions = report.get_solution_data()
         """
-        if not setup_name:
-            setup_name = self._post_app._app.nominal_sweep
+        if not setup:
+            setup = self._post_app._app.nominal_sweep
+        rep = None
         if "CG Fields" in self._templates:
-            rep = rt.Fields(self._post_app, "CG Fields", setup_name)
+            rep = rt.Fields(self._post_app, "CG Fields", setup)
             rep.polyline = polyline
-            rep.expressions = self._retrieve_default_expressions(expressions, rep, setup_name)
-
-            return rep
-        return
+            rep.expressions = self._retrieve_default_expressions(expressions, rep, setup)
+        return rep
 
-    @pyaedt_function_handler()
-    def dc_fields(self, expressions=None, setup_name=None, polyline=None):
-        """Create a DC Field Report object in Q3d.
+    @pyaedt_function_handler(setup_name="setup")
+    def dc_fields(self, expressions=None, setup=None, polyline=None):
+        """Create a DC Field Report object in Q3D.
 
         Parameters
         ----------
         expressions : str or list
             Expression List to add into the report. The expression can be any of the available formula
             you can enter into the Electronics Desktop Report Editor.
-        setup_name : str, optional
-            Name of the setup. The default is ``None`` which automatically take ``nominal_adaptive`` setup.
-            Please make sure to build a setup string in the form of ``"SetupName : SetupSweep"``
-            where ``SetupSweep`` is the Sweep name to use in the export or ``LastAdaptive``.
+        setup : str, optional
+            Name of the setup. The default is ``None``, in which case the ``nominal_adaptive``
+            setup is used. Be sure to build a setup string in the form of
+            ``"SetupName : SetupSweep"``, where ``SetupSweep`` is the sweep name to
+            use in the export or ``LastAdaptive``.
+        polyline : str, optional
+            Name of the polyline to plot the field on.
+            If a name is not provided, the report might be incorrect.
+            The default value is ``None``.
 
         Returns
         -------
         :class:`pyaedt.modules.report_templates.Fields`
 
         Examples
         --------
 
         >>> from pyaedt import Q3d
-        >>> app = Q3d(my_project)
-        >>> report = app.post.reports_by_category.dc_fields("Mag_VolumeJdc", "Setup : LastAdaptive", "Polyline1")
+        >>> q3d = Q3d(my_project)
+        >>> report = q3d.post.reports_by_category.dc_fields("Mag_VolumeJdc", "Setup : LastAdaptive", "Polyline1")
         >>> report.create()
         >>> solutions = report.get_solution_data()
         """
-        if not setup_name:
-            setup_name = self._post_app._app.nominal_sweep
+        if not setup:
+            setup = self._post_app._app.nominal_sweep
+        rep = None
         if "DC R/L Fields" in self._templates:
-            rep = rt.Fields(self._post_app, "DC R/L Fields", setup_name)
+            rep = rt.Fields(self._post_app, "DC R/L Fields", setup)
             rep.polyline = polyline
-            rep.expressions = self._retrieve_default_expressions(expressions, rep, setup_name)
-
-            return rep
-        return
+            rep.expressions = self._retrieve_default_expressions(expressions, rep, setup)
+        return rep
 
-    @pyaedt_function_handler()
-    def rl_fields(self, expressions=None, setup_name=None, polyline=None):
-        """Create an AC RL Field Report object in Q3d and Q2D.
+    @pyaedt_function_handler(setup_name="setup")
+    def rl_fields(self, expressions=None, setup=None, polyline=None):
+        """Create an AC RL Field Report object in Q3D and Q2D.
 
         Parameters
         ----------
         expressions : str or list
             Expression List to add into the report. The expression can be any of the available formula
             you can enter into the Electronics Desktop Report Editor.
-        setup_name : str, optional
-            Name of the setup. The default is ``None`` which automatically take ``nominal_adaptive`` setup.
-            Please make sure to build a setup string in the form of ``"SetupName : SetupSweep"``
-            where ``SetupSweep`` is the Sweep name to use in the export or ``LastAdaptive``.
+        setup : str, optional
+            Name of the setup. The default is ``None``, in which case the ``nominal_adaptive``
+            setup is used. Be sure to build a setup string in the form of
+            ``"SetupName : SetupSweep"``, where ``SetupSweep`` is the sweep name to
+            use in the export or ``LastAdaptive``.
+        polyline : str, optional
+            Name of the polyline to plot the field on.
+            If a name is not provided, the report might be incorrect.
+            The default value is ``None``.
 
         Returns
         -------
         :class:`pyaedt.modules.report_templates.Fields`
 
         Examples
         --------
 
         >>> from pyaedt import Q3d
-        >>> app = Q3d(my_project)
-        >>> report = app.post.reports_by_category.rl_fields("Mag_SurfaceJac", "Setup : LastAdaptive", "Polyline1")
+        >>> q3d = Q3d(my_project)
+        >>> report = q3d.post.reports_by_category.rl_fields("Mag_SurfaceJac", "Setup : LastAdaptive", "Polyline1")
         >>> report.create()
         >>> solutions = report.get_solution_data()
         """
-        if not setup_name:
-            setup_name = self._post_app._app.nominal_sweep
+        if not setup:
+            setup = self._post_app._app.nominal_sweep
+        rep = None
         if "AC R/L Fields" in self._templates or "RL Fields" in self._templates:
             if self._post_app._app.design_type == "Q3D Extractor":
-                rep = rt.Fields(self._post_app, "AC R/L Fields", setup_name)
+                rep = rt.Fields(self._post_app, "AC R/L Fields", setup)
             else:
-                rep = rt.Fields(self._post_app, "RL Fields", setup_name)
+                rep = rt.Fields(self._post_app, "RL Fields", setup)
             rep.polyline = polyline
-            rep.expressions = self._retrieve_default_expressions(expressions, rep, setup_name)
-
-            return rep
-        return
+            rep.expressions = self._retrieve_default_expressions(expressions, rep, setup)
+        return rep
 
-    @pyaedt_function_handler()
-    def far_field(self, expressions=None, setup_name=None, sphere_name=None, source_context=None):
+    @pyaedt_function_handler(setup_name="setup")
+    def far_field(self, expressions=None, setup=None, sphere_name=None, source_context=None):
         """Create a Far Field Report object.
 
         Parameters
         ----------
         expressions : str or list
             Expression List to add into the report. The expression can be any of the available formula
             you can enter into the Electronics Desktop Report Editor.
-        setup_name : str, optional
-            Name of the setup. The default is ``None`` which automatically take ``nominal_adaptive`` setup.
-            Please make sure to build a setup string in the form of ``"SetupName : SetupSweep"``
-            where ``SetupSweep`` is the Sweep name to use in the export or ``LastAdaptive``.
+        setup : str, optional
+            Name of the setup. The default is ``None``, in which case the ``nominal_adaptive``
+            setup is used. Be sure to build a setup string in the form of
+            ``"SetupName : SetupSweep"``, where ``SetupSweep`` is the sweep name to
+            use in the export or ``LastAdaptive``.
         sphere_name : str, optional
             Name of the sphere to create the far field on.
         source_context : str, optional
             Name of the active source to create the far field on.
 
         Returns
         -------
         :class:`pyaedt.modules.report_templates.FarField`
 
         Examples
         --------
 
         >>> from pyaedt import Hfss
-        >>> app = Hfss(my_project)
-        >>> report = app.post.reports_by_category.far_field("GainTotal", "Setup : LastAdaptive", "3D_Sphere")
+        >>> hfss = Hfss(my_project)
+        >>> report = hfss.post.reports_by_category.far_field("GainTotal", "Setup : LastAdaptive", "3D_Sphere")
         >>> report.primary_sweep = "Phi"
         >>> report.create()
         >>> solutions = report.get_solution_data()
         """
-        if not setup_name:
-            setup_name = self._post_app._app.nominal_sweep
+        if not setup:
+            setup = self._post_app._app.nominal_sweep
+        rep = None
         if "Far Fields" in self._templates:
-            rep = rt.FarField(self._post_app, "Far Fields", setup_name)
+            rep = rt.FarField(self._post_app, "Far Fields", setup)
             rep.far_field_sphere = sphere_name
             rep.source_context = source_context
-            rep.expressions = self._retrieve_default_expressions(expressions, rep, setup_name)
-
-            return rep
-        return
+            rep.expressions = self._retrieve_default_expressions(expressions, rep, setup)
+        return rep
 
-    @pyaedt_function_handler()
-    def antenna_parameters(self, expressions=None, setup_name=None, sphere_name=None):
+    @pyaedt_function_handler(setup_name="setup", sphere_name="infinite_sphere")
+    def antenna_parameters(self, expressions=None, setup=None, infinite_sphere=None):
         """Create an Antenna Parameters Report object.
 
         Parameters
         ----------
         expressions : str or list
             Expression List to add into the report. The expression can be any of the available formula
             you can enter into the Electronics Desktop Report Editor.
-        setup_name : str, optional
-            Name of the setup. The default is ``None`` which automatically take ``nominal_adaptive`` setup.
-            Please make sure to build a setup string in the form of ``"SetupName : SetupSweep"``
-            where ``SetupSweep`` is the Sweep name to use in the export or ``LastAdaptive``.
-        sphere_name : str, optional
-            Name of the sphere on which compute antenna parameters.
+        setup : str, optional
+            Name of the setup. The default is ``None``, in which case the ``nominal_adaptive``
+            setup is used. Be sure to build a setup string in the form of
+            ``"SetupName : SetupSweep"``, where ``SetupSweep`` is the sweep name to
+            use in the export or ``LastAdaptive``.
+        infinite_sphere : str, optional
+            Name of the sphere to compute antenna parameters on.
 
         Returns
         -------
         :class:`pyaedt.modules.report_templates.AntennaParameters`
 
         Examples
         --------
 
         >>> from pyaedt import Hfss
-        >>> app = Hfss(my_project)
-        >>> report = app.post.reports_by_category.antenna_parameters("GainTotal", "Setup : LastAdaptive", "3D_Sphere")
+        >>> hfss = Hfss(my_project)
+        >>> report = hfss.post.reports_by_category.antenna_parameters("GainTotal", "Setup : LastAdaptive", "3D_Sphere")
         >>> report.create()
         >>> solutions = report.get_solution_data()
         """
-        if not setup_name:
-            setup_name = self._post_app._app.nominal_sweep
+        if not setup:
+            setup = self._post_app._app.nominal_sweep
+        rep = None
         if "Antenna Parameters" in self._templates:
-            rep = rt.AntennaParameters(self._post_app, "Antenna Parameters", setup_name, sphere_name)
-            rep.expressions = self._retrieve_default_expressions(expressions, rep, setup_name)
-
-            return rep
-        return
+            rep = rt.AntennaParameters(self._post_app, "Antenna Parameters", setup, infinite_sphere)
+            rep.expressions = self._retrieve_default_expressions(expressions, rep, setup)
+        return rep
 
-    @pyaedt_function_handler()
-    def near_field(self, expressions=None, setup_name=None):
+    @pyaedt_function_handler(setup_name="setup")
+    def near_field(self, expressions=None, setup=None):
         """Create a Field Report object.
 
         Parameters
         ----------
         expressions : str or list
             Expression List to add into the report. The expression can be any of the available formula
             you can enter into the Electronics Desktop Report Editor.
-        setup_name : str, optional
-            Name of the setup. The default is ``None`` which automatically take ``nominal_adaptive`` setup.
-            Please make sure to build a setup string in the form of ``"SetupName : SetupSweep"``
-            where ``SetupSweep`` is the Sweep name to use in the export or ``LastAdaptive``.
+        setup : str, optional
+            Name of the setup. The default is ``None``, in which case the ``nominal_adaptive``
+            setup is used. Be sure to build a setup string in the form of
+            ``"SetupName : SetupSweep"``, where ``SetupSweep`` is the sweep name to
+            use in the export or ``LastAdaptive``.
 
         Returns
         -------
         :class:`pyaedt.modules.report_templates.NearField`
 
         Examples
         --------
 
         >>> from pyaedt import Hfss
-        >>> app = Hfss(my_project)
-        >>> report = app.post.reports_by_category.near_field("GainTotal", "Setup : LastAdaptive", "NF_1")
+        >>> hfss = Hfss(my_project)
+        >>> report = hfss.post.reports_by_category.near_field("GainTotal", "Setup : LastAdaptive", "NF_1")
         >>> report.primary_sweep = "Phi"
         >>> report.create()
         >>> solutions = report.get_solution_data()
         """
-        if not setup_name:
-            setup_name = self._post_app._app.nominal_sweep
+        if not setup:
+            setup = self._post_app._app.nominal_sweep
+        rep = None
         if "Near Fields" in self._templates:
-            rep = rt.NearField(self._post_app, "Near Fields", setup_name)
-            rep.expressions = self._retrieve_default_expressions(expressions, rep, setup_name)
-
-            return rep
-        return
+            rep = rt.NearField(self._post_app, "Near Fields", setup)
+            rep.expressions = self._retrieve_default_expressions(expressions, rep, setup)
+        return rep
 
-    @pyaedt_function_handler()
-    def modal_solution(self, expressions=None, setup_name=None):
+    @pyaedt_function_handler(setup_name="setup")
+    def modal_solution(self, expressions=None, setup=None):
         """Create a Standard or Default Report object.
 
         Parameters
         ----------
         expressions : str or list
             Expression List to add into the report. The expression can be any of the available formula
             you can enter into the Electronics Desktop Report Editor.
-        setup_name : str, optional
-            Name of the setup. The default is ``None`` which automatically take ``nominal_adaptive`` setup.
-            Please make sure to build a setup string in the form of ``"SetupName : SetupSweep"``
-            where ``SetupSweep`` is the Sweep name to use in the export or ``LastAdaptive``.
+        setup : str, optional
+            Name of the setup. The default is ``None``, in which case the ``nominal_adaptive``
+            setup is used. Be sure to build a setup string in the form of
+            ``"SetupName : SetupSweep"``, where ``SetupSweep`` is the sweep name to
+            use in the export or ``LastAdaptive``.
 
         Returns
         -------
         :class:`pyaedt.modules.report_templates.Standard`
 
         Examples
         --------
 
         >>> from pyaedt import Hfss
-        >>> app = Hfss(my_project)
-        >>> report = app.post.reports_by_category.modal_solution("dB(S(1,1))")
+        >>> hfss = Hfss(my_project)
+        >>> report = hfss.post.reports_by_category.modal_solution("dB(S(1,1))")
         >>> report.create()
         >>> solutions = report.get_solution_data()
         """
-        if not setup_name:
-            setup_name = self._post_app._app.nominal_sweep
+        if not setup:
+            setup = self._post_app._app.nominal_sweep
+        rep = None
         if "Modal Solution Data" in self._templates:
-            rep = rt.Standard(self._post_app, "Modal Solution Data", setup_name)
-            rep.expressions = self._retrieve_default_expressions(expressions, rep, setup_name)
-
-            return rep
-        return
+            rep = rt.Standard(self._post_app, "Modal Solution Data", setup)
+            rep.expressions = self._retrieve_default_expressions(expressions, rep, setup)
+        return rep
 
-    @pyaedt_function_handler()
-    def terminal_solution(self, expressions=None, setup_name=None):
+    @pyaedt_function_handler(setup_name="setup")
+    def terminal_solution(self, expressions=None, setup=None):
         """Create a Standard or Default Report object.
 
         Parameters
         ----------
         expressions : str or list
             Expression List to add into the report. The expression can be any of the available formula
             you can enter into the Electronics Desktop Report Editor.
-        setup_name : str, optional
-            Name of the setup. The default is ``None`` which automatically take ``nominal_adaptive`` setup.
-            Please make sure to build a setup string in the form of ``"SetupName : SetupSweep"``
-            where ``SetupSweep`` is the Sweep name to use in the export or ``LastAdaptive``.
+        setup : str, optional
+            Name of the setup. The default is ``None``, in which case the ``nominal_adaptive``
+            setup is used. Be sure to build a setup string in the form of
+            ``"SetupName : SetupSweep"``, where ``SetupSweep`` is the sweep name to
+            use in the export or ``LastAdaptive``.
 
         Returns
         -------
         :class:`pyaedt.modules.report_templates.Standard`
 
         Examples
         --------
 
         >>> from pyaedt import Hfss
-        >>> app = Hfss(my_project)
-        >>> report = app.post.reports_by_category.terminal_solution("dB(S(1,1))")
+        >>> hfss = Hfss(my_project)
+        >>> report = hfss.post.reports_by_category.terminal_solution("dB(S(1,1))")
         >>> report.create()
         >>> solutions = report.get_solution_data()
         """
-        if not setup_name:
-            setup_name = self._post_app._app.nominal_sweep
+        if not setup:
+            setup = self._post_app._app.nominal_sweep
+        rep = None
         if "Terminal Solution Data" in self._templates:
-            rep = rt.Standard(self._post_app, "Terminal Solution Data", setup_name)
-            rep.expressions = self._retrieve_default_expressions(expressions, rep, setup_name)
-
-            return rep
-        return
+            rep = rt.Standard(self._post_app, "Terminal Solution Data", setup)
+            rep.expressions = self._retrieve_default_expressions(expressions, rep, setup)
+        return rep
 
-    @pyaedt_function_handler()
-    def eigenmode(self, expressions=None, setup_name=None):
+    @pyaedt_function_handler(setup_name="setup")
+    def eigenmode(self, expressions=None, setup=None):
         """Create a Standard or Default Report object.
 
         Parameters
         ----------
         expressions : str or list
             Expression List to add into the report. The expression can be any of the available formula
             you can enter into the Electronics Desktop Report Editor.
-        setup_name : str, optional
-            Name of the setup. The default is ``None`` which automatically take ``nominal_adaptive`` setup.
-            Please make sure to build a setup string in the form of ``"SetupName : SetupSweep"``
-            where ``SetupSweep`` is the Sweep name to use in the export or ``LastAdaptive``.
+        setup : str, optional
+            Name of the setup. The default is ``None``, in which case the ``nominal_adaptive``
+            setup is used. Be sure to build a setup string in the form of
+            ``"SetupName : SetupSweep"``, where ``SetupSweep`` is the sweep name to
+            use in the export or ``LastAdaptive``.
 
         Returns
         -------
         :class:`pyaedt.modules.report_templates.Standard`
 
         Examples
         --------
 
         >>> from pyaedt import Hfss
-        >>> app = Hfss(my_project)
-        >>> report = app.post.reports_by_category.eigenmode("dB(S(1,1))")
+        >>> hfss = Hfss(my_project)
+        >>> report = hfss.post.reports_by_category.eigenmode("dB(S(1,1))")
         >>> report.create()
         >>> solutions = report.get_solution_data()
         """
-        if not setup_name:
-            setup_name = self._post_app._app.nominal_sweep
+        if not setup:
+            setup = self._post_app._app.nominal_sweep
+        rep = None
         if "Eigenmode Parameters" in self._templates:
-            rep = rt.Standard(self._post_app, "Eigenmode Parameters", setup_name)
-            rep.expressions = self._retrieve_default_expressions(expressions, rep, setup_name)
-
-            return rep
-        return
+            rep = rt.Standard(self._post_app, "Eigenmode Parameters", setup)
+            rep.expressions = self._retrieve_default_expressions(expressions, rep, setup)
+        return rep
 
-    @pyaedt_function_handler()
-    def statistical_eye_contour(self, expressions=None, setup_name=None, quantity_type=3):
+    @pyaedt_function_handler(setup_name="setup")
+    def statistical_eye_contour(self, expressions=None, setup=None, quantity_type=3):
         """Create a standard statistical AMI contour plot.
 
         Parameters
         ----------
         expressions : str
             Expression to add into the report. The expression can be any of the available formula
             you can enter into the Electronics Desktop Report Editor.
-        setup_name : str, optional
+        setup : str, optional
             Name of the setup. The default is ``None``, in which case the ``nominal_adaptive``
             setup is used. Be sure to build a setup string in the form of
             ``"SetupName : SetupSweep"``, where ``SetupSweep`` is either the sweep
              name to use in the export or ``LastAdaptive``.
         quantity_type : int, optional
             For AMI analysis only, the quantity type. The default is ``3``. Options are:
 
@@ -610,47 +631,48 @@
         >>> cir= Circuit()
         >>> new_eye = cir.post.reports_by_category.statistical_eye_contour("V(Vout)")
         >>> new_eye.unit_interval = "1e-9s"
         >>> new_eye.time_stop = "100ns"
         >>> new_eye.create()
 
         """
-        if not setup_name:
+        if not setup:
             for setup in self._post_app._app.setups:
                 if "AMIAnalysis" in setup.props:
-                    setup_name = setup.name
-            if not setup_name:
+                    setup = setup.name
+            if not setup:
                 self._post_app._app.logger.error("AMI analysis is needed to create this report.")
                 return False
 
             if isinstance(expressions, list):
                 expressions = expressions[0]
             report_cat = "Standard"
-            rep = rt.AMIConturEyeDiagram(self._post_app, report_cat, setup_name)
+            rep = rt.AMIConturEyeDiagram(self._post_app, report_cat, setup)
             rep.quantity_type = quantity_type
-            rep.expressions = self._retrieve_default_expressions(expressions, rep, setup_name)
+            rep.expressions = self._retrieve_default_expressions(expressions, rep, setup)
 
             return rep
         return
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(setup_name="setup")
     def eye_diagram(
-        self, expressions=None, setup_name=None, quantity_type=3, statistical_analysis=True, unit_interval="1ns"
+        self, expressions=None, setup=None, quantity_type=3, statistical_analysis=True, unit_interval="1ns"
     ):
         """Create a Standard or Default Report object.
 
         Parameters
         ----------
         expressions : str
             Expression to add into the report. The expression can be any of the available formula
             you can enter into the Electronics Desktop Report Editor.
-        setup_name : str, optional
-            Name of the setup. The default is ``None`` which automatically take ``nominal_adaptive`` setup.
-            Please make sure to build a setup string in the form of ``"SetupName : SetupSweep"``
-            where ``SetupSweep`` is the Sweep name to use in the export or ``LastAdaptive``.
+        setup : str, optional
+            Name of the setup. The default is ``None``, in which case the ``nominal_adaptive``
+            setup is used. Be sure to build a setup string in the form of
+            ``"SetupName : SetupSweep"``, where ``SetupSweep`` is the sweep name to
+            use in the export or ``LastAdaptive``.
         quantity_type : int, optional
             For AMI Analysis only, specify the quantity type. Options are: 0 for Initial Wave,
             1 for Wave after Source, 2 for Wave after Channel and 3 for Wave after Probe. Default is 3.
         statistical_analysis : bool, optional
             For AMI Analysis only, whether to plot the statistical eye plot or transient eye plot.
             The default is ``True``.
         unit_interval : str, optional
@@ -667,71 +689,120 @@
         >>> cir= Circuit()
         >>> new_eye = cir.post.reports_by_category.eye_diagram("V(Vout)")
         >>> new_eye.unit_interval = "1e-9s"
         >>> new_eye.time_stop = "100ns"
         >>> new_eye.create()
 
         """
-        if not setup_name:
-            setup_name = self._post_app._app.nominal_sweep
+        if not setup:
+            setup = self._post_app._app.nominal_sweep
         if "Eye Diagram" in self._templates:
-            if "AMIAnalysis" in self._post_app._app.get_setup(setup_name).props:
+            if "AMIAnalysis" in self._post_app._app.get_setup(setup).props:
 
                 report_cat = "Eye Diagram"
                 if statistical_analysis:
                     report_cat = "Statistical Eye"
-                rep = rt.AMIEyeDiagram(self._post_app, report_cat, setup_name)
+                rep = rt.AMIEyeDiagram(self._post_app, report_cat, setup)
                 rep.quantity_type = quantity_type
-                expressions = self._retrieve_default_expressions(expressions, rep, setup_name)
+                expressions = self._retrieve_default_expressions(expressions, rep, setup)
                 if isinstance(expressions, list):
                     rep.expressions = expressions[0]
                 return rep
 
             else:
-                rep = rt.EyeDiagram(self._post_app, "Eye Diagram", setup_name)
+                rep = rt.EyeDiagram(self._post_app, "Eye Diagram", setup)
             rep.unit_interval = unit_interval
-            rep.expressions = self._retrieve_default_expressions(expressions, rep, setup_name)
+            rep.expressions = self._retrieve_default_expressions(expressions, rep, setup)
             return rep
 
         return
 
-    @pyaedt_function_handler()
-    def spectral(self, expressions=None, setup_name=None):
+    @pyaedt_function_handler(setup_name="setup")
+    def spectral(self, expressions=None, setup=None):
         """Create a Spectral Report object.
 
         Parameters
         ----------
         expressions : str or list, optional
             Expression List to add into the report. The expression can be any of the available formula
             you can enter into the Electronics Desktop Report Editor.
-        setup_name : str, optional
-            Name of the setup. The default is ``None`` which automatically take ``nominal_adaptive`` setup.
-            Please make sure to build a setup string in the form of ``"SetupName : SetupSweep"``
-            where ``SetupSweep`` is the Sweep name to use in the export or ``LastAdaptive``.
+        setup : str, optional
+            Name of the setup. The default is ``None``, in which case the ``nominal_adaptive``
+            setup is used. Be sure to build a setup string in the form of
+            ``"SetupName : SetupSweep"``, where ``SetupSweep`` is the sweep name to
+            use in the export or ``LastAdaptive``.
 
         Returns
         -------
         :class:`pyaedt.modules.report_templates.Spectrum`
 
         Examples
         --------
 
         >>> from pyaedt import Circuit
         >>> cir= Circuit()
         >>> new_eye = cir.post.reports_by_category.spectral("V(Vout)")
         >>> new_eye.create()
 
         """
+        if not setup:
+            setup = self._post_app._app.nominal_sweep
+        rep = None
+        if "Spectrum" in self._templates:
+            rep = rt.Spectral(self._post_app, "Spectrum", setup)
+            rep.expressions = self._retrieve_default_expressions(expressions, rep, setup)
+        return rep
+
+    @pyaedt_function_handler()
+    def emi_receiver(self, expressions=None, setup_name=None):
+        """Create an EMI receiver report.
+
+        Parameters
+        ----------
+        expressions : str or list, optional
+            One or more expressions to add into the report. An expression can be any of the formulas that
+            can be entered into the Electronics Desktop Report Editor.
+        setup_name : str, optional
+            Name of the setup. The default is ``None``, in which case the ``nominal_adaptive``
+            setup is used. Be sure to build a setup string in the form of
+            ``"SetupName : SetupSweep"``, where ``SetupSweep`` is either the sweep name
+            to use in the export or ``LastAdaptive``.
+
+        Returns
+        -------
+        :class:`pyaedt.modules.report_templates.EMIReceiver`
+
+        Examples
+        --------
+
+        >>> from pyaedt import Circuit
+        >>> cir= Circuit()
+        >>> new_eye = cir.post.emi_receiver()
+        >>> new_eye.create()
+
+        """
         if not setup_name:
             setup_name = self._post_app._app.nominal_sweep
-        if "Spectrum" in self._templates:
-            rep = rt.Spectral(self._post_app, "Spectrum", setup_name)
+        rep = None
+        if "EMIReceiver" in self._templates and self._post_app._app.desktop_class.aedt_version_id > "2023.2":
+            rep = rt.EMIReceiver(self._post_app, setup_name)
+            if not expressions:
+                expressions = "Average[{}]".format(rep.net)
+            else:
+                if not isinstance(expressions, list):
+                    expressions = [expressions]
+                pattern = r"\w+\[(.*?)\]"
+                for expression in expressions:
+                    match = re.search(pattern, expression)
+                    if match:
+                        net_name = match.group(1)
+                        rep.net = net_name
             rep.expressions = self._retrieve_default_expressions(expressions, rep, setup_name)
-            return rep
-        return
+
+        return rep
 
 
 orientation_to_view = {
     "isometric": "iso",
     "top": "XY",
     "bottom": "XY",
     "right": "XZ",
@@ -744,15 +815,15 @@
 @pyaedt_function_handler()
 def _convert_dict_to_report_sel(sweeps):
     if isinstance(sweeps, list):
         return sweeps
     sweep_list = []
     for el in sweeps:
         sweep_list.append(el + ":=")
-        if type(sweeps[el]) is list:
+        if isinstance(sweeps[el], list):
             sweep_list.append(sweeps[el])
         else:
             sweep_list.append([sweeps[el]])
     return sweep_list
 
 
 class PostProcessorCommon(object):
@@ -771,15 +842,15 @@
         Inherited parent object. The parent object must provide the members
         ``_modeler``, ``_desktop``, ``_odesign``, and ``logger``.
 
     Examples
     --------
     >>> from pyaedt import Q3d
     >>> q3d = Q3d()
-    >>> q3d = q.post.get_solution_data(expression="C(Bar1,Bar1)", domain="Original")
+    >>> q3d = q.post.get_solution_data(domain="Original")
     """
 
     def __init__(self, app):
         self._app = app
         self.oeditor = self.modeler.oeditor
         self._scratch = self._app.working_directory
         self.plots = self._get_plot_inputs()
@@ -815,15 +886,15 @@
 
     @update_report_dynamically.setter
     def update_report_dynamically(self, value):
         if value:
             self._app.odesktop.SetRegistryInt(
                 "Desktop/Settings/ProjectOptions/{}/UpdateReportsDynamicallyOnEdits".format(self._app.design_type), 1
             )
-        else:
+        else:  # pragma: no cover
             self._app.odesktop.SetRegistryInt(
                 "Desktop/Settings/ProjectOptions/{}/UpdateReportsDynamicallyOnEdits".format(self._app.design_type), 0
             )
 
     @pyaedt_function_handler()
     def available_display_types(self, report_category=None):
         """Retrieve display types for a report categories.
@@ -842,15 +913,15 @@
         ----------
         >>> oModule.GetAvailableDisplayTypes
         """
         if not report_category:
             report_category = self.available_report_types[0]
         if report_category:
             return list(self.oreportsetup.GetAvailableDisplayTypes(report_category))
-        return []
+        return []  # pragma: no cover
 
     @pyaedt_function_handler()
     def available_quantities_categories(
         self, report_category=None, display_type=None, solution=None, context="", is_siwave_dc=False
     ):
         """Compute the list of all available report categories.
 
@@ -901,15 +972,15 @@
             ]
 
         elif not context:  # pragma: no cover
             context = ""
 
         if solution and report_category and display_type:
             return list(self.oreportsetup.GetAllCategories(report_category, display_type, solution, context))
-        return []
+        return []  # pragma: no cover
 
     @pyaedt_function_handler()
     def available_report_quantities(
         self,
         report_category=None,
         display_type=None,
         solution=None,
@@ -977,15 +1048,15 @@
                 quantities_category = "All" if "All" in categories else categories[0]
         if quantities_category and display_type and report_category and solution:
             return list(
                 self.oreportsetup.GetAllQuantities(
                     report_category, display_type, solution, context, quantities_category
                 )
             )
-        return []
+        return []  # pragma: no cover
 
     @pyaedt_function_handler()
     def available_report_solutions(self, report_category=None):
         """Get the list of available solutions that can be used for the reports.
         This list differs from the one obtained with ``app.existing_analysis_sweeps``,
         because it includes additional elements like "AdaptivePass".
 
@@ -1002,15 +1073,15 @@
         ----------
         >>> oModule.GetAvailableSolutions
         """
         if not report_category:
             report_category = self.available_report_types[0]
         if report_category:
             return list(self.oreportsetup.GetAvailableSolutions(report_category))
-        return None
+        return None  # pragma: no cover
 
     @pyaedt_function_handler()
     def _get_plot_inputs(self):
         names = self._app.get_oo_name(self.oreportsetup)
         plots = []
         if names:
             for name in names:
@@ -1089,35 +1160,35 @@
         References
         ----------
 
         >>> oModule.GetAllReportNames()
         """
         return list(self.oreportsetup.GetAllReportNames())
 
-    @pyaedt_function_handler()
-    def copy_report_data(self, PlotName):
+    @pyaedt_function_handler(PlotName="plot_name")
+    def copy_report_data(self, plot_name):
         """Copy report data as static data.
 
         Parameters
         ----------
-        PlotName : str
+        plot_name : str
             Name of the report.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         References
         ----------
 
         >>> oModule.CopyReportsData
         >>> oModule.PasteReports
         """
-        self.oreportsetup.CopyReportsData([PlotName])
+        self.oreportsetup.CopyReportsData([plot_name])
         self.oreportsetup.PasteReports()
         return True
 
     @pyaedt_function_handler()
     def delete_report(self, plot_name=None):
         """Delete all reports or specific report.
 
@@ -1140,20 +1211,20 @@
             if plot_name:
                 self.oreportsetup.DeleteReports([plot_name])
                 for plot in self.plots:
                     if plot.plot_name == plot_name:
                         self.plots.remove(plot)
             else:
                 self.oreportsetup.DeleteAllReports()
-                if is_ironpython:
+                if is_ironpython:  # pragma: no cover
                     del self.plots[:]
                 else:
                     self.plots.clear()
             return True
-        except Exception:
+        except Exception:  # pragma: no cover
             return False
 
     @pyaedt_function_handler()
     def rename_report(self, plot_name, new_name):
         """Rename a plot.
 
         Parameters
@@ -1178,59 +1249,61 @@
             for plot in self.plots:
                 if plot.plot_name == plot_name:
                     plot.plot_name = self.oreportsetup.GetChildObject(new_name).GetPropValue("Name")
             return True
         except Exception:
             return False
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(soltype="solution_type", ctxt="context", expression="expressions")
     def get_solution_data_per_variation(
-        self, soltype="Far Fields", setup_sweep_name="", ctxt=None, sweeps=None, expression=""
+        self, solution_type="Far Fields", setup_sweep_name="", context=None, sweeps=None, expressions=""
     ):
         """Retrieve solution data for each variation.
 
         Parameters
         ----------
-        soltype : str, optional
+        solution_type : str, optional
             Type of the solution. For example, ``"Far Fields"`` or ``"Modal Solution Data"``. The default
             is ``"Far Fields"``.
         setup_sweep_name : str, optional
             Name of the setup for computing the report. The default is ``""``,
             in which case ``"nominal adaptive"`` is used.
-        ctxt : list, optional
+        context : list, optional
             List of context variables. The default is ``None``.
         sweeps : dict, optional
             Dictionary of variables and values. The default is ``None``,
             in which case this list is used:
             ``{'Theta': 'All', 'Phi': 'All', 'Freq': 'All'}``.
-        expression : str or list, optional
+        expressions : str or list, optional
             One or more traces to include. The default is ``""``.
 
         Returns
         -------
         pyaedt.modules.solutions.SolutionData
 
 
         References
         ----------
 
         >>> oModule.GetSolutionDataPerVariation
         """
         if sweeps is None:
             sweeps = {"Theta": "All", "Phi": "All", "Freq": "All"}
-        if not ctxt:
-            ctxt = []
-        if not isinstance(expression, list):
-            expression = [expression]
+        if not context:
+            context = []
+        if not isinstance(expressions, list):
+            expressions = [expressions]
         if not setup_sweep_name:
             setup_sweep_name = self._app.nominal_adaptive
         sweep_list = _convert_dict_to_report_sel(sweeps)
         try:
             data = list(
-                self.oreportsetup.GetSolutionDataPerVariation(soltype, setup_sweep_name, ctxt, sweep_list, expression)
+                self.oreportsetup.GetSolutionDataPerVariation(
+                    solution_type, setup_sweep_name, context, sweep_list, expressions
+                )
             )
             self.logger.info("Solution Data Correctly Loaded.")
             return SolutionData(data)
         except Exception:
             self.logger.warning("Solution Data failed to load. Check solution, context or expression.")
             return None
 
@@ -1321,24 +1394,24 @@
         >>> from pyaedt import Circuit
         >>> cir = Circuit("my_project.aedt")
         >>> report = cir.post.create_report("MyScattering")
         >>> cir.post.export_report_to_file("C:\\temp", "MyTestScattering", ".csv")
         """
         npath = output_dir
 
-        if "." not in extension:
+        if "." not in extension:  # pragma: no cover
             extension = "." + extension
 
         supported_ext = [".csv", ".tab", ".txt", ".exy", ".dat", ".rdat"]
-        if extension not in supported_ext:
+        if extension not in supported_ext:  # pragma: no cover
             msg = "Extension {} is not supported. Use one of {}".format(extension, ", ".join(supported_ext))
             raise ValueError(msg)
 
         file_path = os.path.join(npath, plot_name + extension)
-        if unique_file:
+        if unique_file:  # pragma: no cover
             while os.path.exists(file_path):
                 file_name = generate_unique_name(plot_name)
                 file_path = os.path.join(npath, file_name + extension)
 
         if extension == ".rdat":
             self.oreportsetup.ExportReportDataToFile(plot_name, file_path)
         elif uniform:
@@ -1398,21 +1471,21 @@
             uniform=uniform,
             start=start,
             end=end,
             step=step,
             use_trace_number_format=use_trace_number_format,
         )
 
-    @pyaedt_function_handler()
-    def export_report_to_jpg(self, project_dir, plot_name, width=0, height=0):
+    @pyaedt_function_handler(project_dir="project_path")
+    def export_report_to_jpg(self, project_path, plot_name, width=0, height=0):
         """Export the SParameter plot to a JPG file.
 
         Parameters
         ----------
-        project_dir : str
+        project_path : str
             Path to the project directory.
         plot_name : str
             Name of the plot to export.
         width : int, optional
             Image width. Default is ``0`` which takes Desktop size or 1980 pixel in case of non-graphical mode.
         height : int, optional
             Image height. Default is ``0`` which takes Desktop size or 1020 pixel in case of non-graphical mode.
@@ -1424,39 +1497,39 @@
 
         References
         ----------
 
         >>> oModule.ExportImageToFile
         """
         # path
-        npath = project_dir
+        npath = project_path
         file_name = os.path.join(npath, plot_name + ".jpg")  # name of the image file
         if self._app.desktop_class.non_graphical:  # pragma: no cover
             if width == 0:
                 width = 1980
             if height == 0:
                 height = 1020
         self.oreportsetup.ExportImageToFile(plot_name, file_name, width, height)
         return True
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(plotname="plot_name")
     def _get_report_inputs(
         self,
         expressions,
         setup_sweep_name=None,
         domain="Sweep",
         variations=None,
         primary_sweep_variable=None,
         secondary_sweep_variable=None,
         report_category=None,
         plot_type="Rectangular Plot",
         context=None,
         subdesign_id=None,
         polyline_points=0,
-        plotname=None,
+        plot_name=None,
         only_get_method=False,
     ):
         ctxt = []
         if not setup_sweep_name:
             setup_sweep_name = self._app.nominal_sweep
         elif setup_sweep_name not in self._app.existing_analysis_sweeps:
             self.logger.error("Sweep not Available.")
@@ -1559,16 +1632,16 @@
         if not report_category and not self._app.design_solutions.report_type:
             self.logger.error("Solution not supported")
             return False
         if not report_category:
             modal_data = self._app.design_solutions.report_type
         else:
             modal_data = report_category
-        if not plotname:
-            plotname = generate_unique_name("Plot")
+        if not plot_name:
+            plot_name = generate_unique_name("Plot")
 
         arg = ["X Component:=", primary_sweep_variable, "Y Component:=", expressions]
         if plot_type in ["3D Polar Plot", "3D Spherical Plot"]:
             if not primary_sweep_variable:
                 primary_sweep_variable = "Phi"
             if not secondary_sweep_variable:
                 secondary_sweep_variable = "Theta"
@@ -1591,33 +1664,33 @@
                 "X Component:=",
                 primary_sweep_variable,
                 "Y Component:=",
                 secondary_sweep_variable,
                 "Z Component:=",
                 expressions,
             ]
-        return [plotname, modal_data, plot_type, setup_sweep_name, ctxt, families_input, arg]
+        return [plot_name, modal_data, plot_type, setup_sweep_name, ctxt, families_input, arg]
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(plotname="plot_name")
     def create_report(
         self,
         expressions=None,
         setup_sweep_name=None,
         domain="Sweep",
         variations=None,
         primary_sweep_variable=None,
         secondary_sweep_variable=None,
         report_category=None,
         plot_type="Rectangular Plot",
         context=None,
         subdesign_id=None,
         polyline_points=1001,
-        plotname=None,
+        plot_name=None,
     ):
-        """Create a report in AEDT. It can be a 2D plot, 3D plot, polar plots or data tables.
+        """Create a report in AEDT. It can be a 2D plot, 3D plot, polar plot, or a data table.
 
         Parameters
         ----------
         expressions : str or list, optional
             One or more formulas to add to the report. Example is value = ``"dB(S(1,1))"``.
         setup_sweep_name : str, optional
             Setup name with the sweep. The default is ``""``.
@@ -1635,21 +1708,23 @@
             For example for a Far Field Plot in HFSS the UI shows the report category as "Create Far Fields Report".
             The report category will be in this case "Far Fields".
             Depending on the setup different categories are available.
             If `None` default category will be used (the first item in the Results drop down menu in AEDT).
         plot_type : str, optional
             The format of Data Visualization. Default is ``Rectangular Plot``.
         context : str, optional
-            The default is ``None``. It can be `None`, `"Differential Pairs"`,`"RL"`,
-            `"Sources"`, `"Vias"`,`"Bondwires"`, `"Probes"` for Hfss3dLayout or
-            Reduce Matrix Name for Q2d/Q3d solution or Infinite Sphere name for Far Fields Plot.
-        plotname : str, optional
+            The default is ``None``.
+            - For HFSS 3D Layout, options are ``"Bondwires"``, ``"Differential Pairs"``,
+              ``None``, ``"Probes"``, ``"RL"``, ``"Sources"``, and ``"Vias"``.
+            - For Q2D or Q3D, specify the name of a reduced matrix.
+            - For a far fields plot, specify the name of an infinite sphere.
+        plot_name : str, optional
             Name of the plot. The default is ``None``.
         polyline_points : int, optional,
-            Number of points on which create the report for plots on polylines.
+            Number of points to create the report for plots on polylines on.
         subdesign_id : int, optional
             Specify a subdesign ID to export a Touchstone file of this subdesign. Valid for Circuit Only.
             The default value is ``None``.
         context : str, optional
 
         Returns
         -------
@@ -1661,44 +1736,37 @@
         ----------
 
         >>> oModule.CreateReport
 
         Examples
         --------
         >>> from pyaedt import Hfss
-        >>> aedtapp = Hfss()
-        >>> aedtapp.post.create_report("dB(S(1,1))")
-
-        >>> variations = aedtapp.available_variations.nominal_w_values_dict
+        >>> hfss = Hfss()
+        >>> hfss.post.create_report("dB(S(1,1))")
+        >>> variations = hfss.available_variations.nominal_w_values_dict
         >>> variations["Theta"] = ["All"]
         >>> variations["Phi"] = ["All"]
         >>> variations["Freq"] = ["30GHz"]
-        >>> aedtapp.post.create_report(
-        ...    "db(GainTotal)",
-        ...    aedtapp.nominal_adaptive,
-        ...    variations=variations,
-        ...    primary_sweep_variable="Phi",
-        ...    secondary_sweep_variable="Theta",
-        ...    plot_type="3D Polar Plot",
-        ...    context="3D",
-        ...    report_category="Far Fields",
-        ...)
+        >>> hfss.post.create_report(expressions="db(GainTotal)",
+        ...                            setup_sweep_name=hfss.nominal_adaptive,
+        ...                            variations=variations,
+        ...                            primary_sweep_variable="Phi",
+        ...                            secondary_sweep_variable="Theta",
+        ...                            report_category="Far Fields",
+        ...                            plot_type="3D Polar Plot",
+        ...                            context="3D")
 
-        >>> aedtapp.post.create_report(
-        ...    "S(1,1)",
-        ...    aedtapp.nominal_sweep,
-        ...    variations=variations,
-        ...    plot_type="Smith Chart",
-        ...)
+        >>> hfss.post.create_report("S(1,1)",hfss.nominal_sweep,variations=variations,plot_type="Smith Chart")
 
         >>> from pyaedt import Maxwell2d
-        >>> maxwell_2d = Maxwell2d()
-        >>> maxwell_2d.post.create_report(
-        ...     "InputCurrent(PHA)", domain="Time", primary_sweep_variable="Time", plotname="Winding Plot 1"
-        ... )
+        >>> m2d = Maxwell2d()
+        >>> m2d.post.create_report(expressions="InputCurrent(PHA)",
+        ...                               domain="Time",
+        ...                               primary_sweep_variable="Time",
+        ...                               plot_name="Winding Plot 1")
         """
         if not setup_sweep_name:
             setup_sweep_name = self._app.nominal_sweep
         if not domain:
             domain = "Sweep"
             setup_name = setup_sweep_name.split(":")[0]
             if setup_name:
@@ -1783,15 +1851,15 @@
                     report.far_field_sphere = context
         elif report_category == "Near Fields":
             report.near_field = context
         elif context:
             if context in self.modeler.line_names or context in self.modeler.point_names:
                 report.polyline = context
 
-        result = report.create(plotname)
+        result = report.create(plot_name)
         if result:
             return report
         return False
 
     @pyaedt_function_handler()
     def get_solution_data(
         self,
@@ -1813,17 +1881,18 @@
 
         Parameters
         ----------
         expressions : str or list, optional
             One or more formulas to add to the report. Example is value ``"dB(S(1,1))"`` or a list of values.
             Default is `None` which will return all traces.
         setup_sweep_name : str, optional
-            Name of the setup. The default is ``None`` which automatically take ``nominal_adaptive`` setup.
-            Please make sure to build a setup string in the form of ``"SetupName : SetupSweep"``
-            where ``SetupSweep`` is the Sweep name to use in the export or ``LastAdaptive``.
+            Name of the setup. The default is ``None``, in which case the ``nominal_adaptive``
+            setup is used. Be sure to build a setup string in the form of
+            ``"SetupName : SetupSweep"``, where ``SetupSweep`` is the sweep name to
+            use in the export or ``LastAdaptive``.
         domain : str, optional
             Plot Domain. Options are "Sweep" for frequency domain related results and "Time" for transient related data.
         variations : dict, optional
             Dictionary of all families including the primary sweep.
             The default is ``None`` which will use the nominal variations of the setup.
         primary_sweep_variable : str, optional
             Name of the primary sweep. The default is ``"None"`` which, depending on the context,
@@ -1868,52 +1937,49 @@
         ----------
 
         >>> oModule.GetSolutionDataPerVariation
 
         Examples
         --------
         >>> from pyaedt import Hfss
-        >>> aedtapp = Hfss()
-        >>> aedtapp.post.create_report("dB(S(1,1))")
-
-        >>> variations = aedtapp.available_variations.nominal_w_values_dict
+        >>> hfss = Hfss()
+        >>> hfss.post.create_report("dB(S(1,1))")
+        >>> variations = hfss.available_variations.nominal_w_values_dict
         >>> variations["Theta"] = ["All"]
         >>> variations["Phi"] = ["All"]
         >>> variations["Freq"] = ["30GHz"]
-        >>> data1 = aedtapp.post.get_solution_data(
+        >>> data1 = hfss.post.get_solution_data(
         ...    "GainTotal",
-        ...    aedtapp.nominal_adaptive,
+        ...    hfss.nominal_adaptive,
         ...    variations=variations,
         ...    primary_sweep_variable="Phi",
         ...    secondary_sweep_variable="Theta",
         ...    context="3D",
         ...    report_category="Far Fields",
         ...)
 
-        >>> data2 =aedtapp.post.get_solution_data(
+        >>> data2 =hfss.post.get_solution_data(
         ...    "S(1,1)",
-        ...    aedtapp.nominal_sweep,
+        ...    hfss.nominal_sweep,
         ...    variations=variations,
         ...)
         >>> data2.plot()
 
         >>> from pyaedt import Maxwell2d
-        >>> maxwell_2d = Maxwell2d()
-        >>> data3 = maxwell_2d.post.get_solution_data(
+        >>> m2d = Maxwell2d()
+        >>> data3 = m2d.post.get_solution_data(
         ...     "InputCurrent(PHA)", domain="Time", primary_sweep_variable="Time",
         ... )
         >>> data3.plot("InputCurrent(PHA)")
 
         >>> from pyaedt import Circuit
         >>> circuit = Circuit()
         >>> context = {"algorithm": "FFT", "max_frequency": "100MHz", "time_stop": "2.5us", "time_start": "0ps"}
-        >>> spectralPlotData = circuit.post.get_solution_data(
-        ...     expressions="V(Vprobe1)", primary_sweep_variable="Spectrum", domain="Spectral",
-        ...     context=context
-        ...)
+        >>> spectralPlotData = circuit.post.get_solution_data(expressions="V(Vprobe1)", domain="Spectral",
+        ...                                                   primary_sweep_variable="Spectrum", context=context)
         """
         expressions = [expressions] if isinstance(expressions, str) else expressions
         if not setup_sweep_name:
             setup_sweep_name = self._app.nominal_sweep
         if not domain:
             domain = "Sweep"
             setup_name = setup_sweep_name.split(":")[0]
@@ -1999,46 +2065,47 @@
                     "Vias",
                     "Bondwires",
                     "Probes",
                 ].index(context)
         solution_data = report.get_solution_data()
         return solution_data
 
-    @pyaedt_function_handler()
-    def create_report_from_configuration(self, input_file=None, input_dict=None, solution_name=None):
+    @pyaedt_function_handler(input_dict="report_settings")
+    def create_report_from_configuration(self, input_file=None, report_settings=None, solution_name=None):
         """Create a report based on a JSON file, TOML file, or dictionary of properties.
 
         Parameters
         ----------
         input_file : str, optional
             Path to the JSON or TOML file containing report settings.
-        input_dict : dict, optional
+        report_settings : dict, optional
             Dictionary containing report settings.
-        solution_name : setup name to use.
+        solution_name : str, optional
+            Setup name to use.
 
         Returns
         -------
         :class:`pyaedt.modules.report_templates.Standard`
             Report object if succeeded.
 
         Examples
         --------
 
         >>> from pyaedt import Hfss
-        >>> aedtapp = Hfss()
-        >>> aedtapp.post.create_report_from_configuration(r'C:\\temp\\my_report.json',
-        ...                                               solution_name="Setup1 : LastAdpative")
+        >>> hfss = Hfss()
+        >>> hfss.post.create_report_from_configuration(r'C:\\temp\\my_report.json',
+        >>>                                            solution_name="Setup1 : LastAdpative")
         """
-        if not input_dict and not input_file:  # pragma: no cover
+        if not report_settings and not input_file:  # pragma: no cover
             self.logger.error("Either a JSON file or a dictionary must be passed as input.")
             return False
         if input_file:
             props = read_configuration_file(input_file)
         else:
-            props = input_dict
+            props = report_settings
         _dict_items_to_list_items(props, "expressions")
         if not solution_name:
             solution_name = self._app.nominal_sweep
         if props.get("report_category", None) and props["report_category"] in TEMPLATES_BY_NAME:
             if (
                 "AMIAnalysis" in self._app.get_setup(solution_name.split(":")[0].strip()).props
                 and props["report_category"] == "Standard"
@@ -2084,16 +2151,16 @@
         ``_modeler``, ``_desktop``, ``_odesign``, and ``logger``.
 
     Examples
     --------
     Basic usage demonstrated with an HFSS, Maxwell, or any other design:
 
     >>> from pyaedt import Hfss
-    >>> aedtapp = Hfss()
-    >>> post = aedtapp.post
+    >>> hfss = Hfss()
+    >>> post = hfss.post
     """
 
     def __init__(self, app):
         app.logger.reset_timer()
         self._app = app
         self._post_osolution = self._app.osolution
         self.field_plots = self._get_fields_plot()
@@ -2153,15 +2220,15 @@
     def _get_base_name(self, setup):
         setups_data = self._app.design_properties["FieldsReporter"]["FieldsPlotManagerID"]
         if "SimDataExtractors" in self._app.design_properties["SolutionManager"]:
             sim_data = self._app.design_properties["SolutionManager"]["SimDataExtractors"]
         else:
             sim_data = self._app.design_properties["SolutionManager"]
         if "SimSetup" in sim_data:
-            if isinstance(sim_data["SimSetup"], list):
+            if isinstance(sim_data["SimSetup"], list):  # pragma: no cover
                 for solution in sim_data["SimSetup"]:
                     base_name = solution["Name"]
                     if isinstance(solution["Solution"], (dict, OrderedDict)):
                         sols = [solution["Solution"]]
                     else:
                         sols = solution["Solution"]
                     for sol in sols:
@@ -2176,66 +2243,66 @@
                             base_name += " : " + sol["Name"]
                             return base_name
                 else:
                     sol = sim_data["SimSetup"]["Solution"]
                     if sol["ID"] == setups_data[setup]["SolutionId"]:
                         base_name += " : " + sol["Name"]
                         return base_name
-        return ""
+        return ""  # pragma: no cover
 
     @pyaedt_function_handler()
     def _get_intrinsic(self, setup):
         setups_data = self._app.design_properties["FieldsReporter"]["FieldsPlotManagerID"]
         intrinsics = [i.split("=") for i in setups_data[setup]["IntrinsicVar"].split(" ")]
         intr_dict = {}
         if intrinsics:
             for intr in intrinsics:
                 if isinstance(intr, list) and len(intr) == 2:
                     intr_dict[intr[0]] = intr[1].replace("\\", "").replace("'", "")
-        return intr_dict
+        return intr_dict  # pragma: no cover
 
-    @pyaedt_function_handler()
-    def _get_volume_objects(self, list_objs):
+    @pyaedt_function_handler(list_objs="assignment")
+    def _get_volume_objects(self, assignment):
         if self._app.solution_type not in ["HFSS3DLayout", "HFSS 3D Layout Design"]:
             obj_list = []
             editor = self._app._odesign.SetActiveEditor("3D Modeler")
-            for obj in list_objs:
+            for obj in assignment:
                 obj_list.append(editor.GetObjectNameByID(int(obj)))
         if obj_list:
             return obj_list
         else:
-            return list_objs
+            return assignment
 
-    @pyaedt_function_handler()
-    def _get_surface_objects(self, list_objs):
-        faces = [int(i) for i in list_objs]
+    @pyaedt_function_handler(list_objs="assignment")
+    def _get_surface_objects(self, assignment):
+        faces = [int(i) for i in assignment]
         if self._app.solution_type not in ["HFSS3DLayout", "HFSS 3D Layout Design"]:
             planes = self._get_cs_plane_ids()
             objs = []
             for face in faces:
                 if face in list(planes.keys()):
                     objs.append(planes[face])
             if objs:
                 return "CutPlane", objs
         return "FacesList", faces
 
     @pyaedt_function_handler()
     def _get_cs_plane_ids(self):
         name2refid = {-4: "Global:XY", -3: "Global:YZ", -2: "Global:XZ"}
-        if self._app.design_properties and "ModelSetup" in self._app.design_properties:
+        if self._app.design_properties and "ModelSetup" in self._app.design_properties:  # pragma: no cover
             cs = self._app.design_properties["ModelSetup"]["GeometryCore"]["GeometryOperations"]["CoordinateSystems"]
             for ds in cs:
                 try:
                     if isinstance(cs[ds], (OrderedDict, dict)):
                         name = cs[ds]["Attributes"]["Name"]
                         cs_id = cs[ds]["XYPlaneID"]
                         name2refid[cs_id] = name + ":XY"
                         name2refid[cs_id + 1] = name + ":YZ"
                         name2refid[cs_id + 2] = name + ":XZ"
-                    elif type(cs[ds]) is list:
+                    elif isinstance(cs[ds], list):
                         for el in cs[ds]:
                             cs_id = el["XYPlaneID"]
                             name = el["Attributes"]["Name"]
                             name2refid[cs_id] = name + ":XY"
                             name2refid[cs_id + 1] = name + ":YZ"
                             name2refid[cs_id + 2] = name + ":XZ"
                 except Exception:
@@ -2252,38 +2319,36 @@
         ):
             setups_data = self._app.design_properties["FieldsReporter"]["FieldsPlotManagerID"]
             for setup in setups_data:
                 try:
                     if isinstance(setups_data[setup], (OrderedDict, dict)) and "PlotDefinition" in setup:
                         plot_name = setups_data[setup]["PlotName"]
                         plots[plot_name] = FieldPlot(self)
-                        plots[plot_name].solutionName = self._get_base_name(setup)
-                        plots[plot_name].quantityName = self.ofieldsreporter.GetFieldPlotQuantityName(
+                        plots[plot_name].solution = self._get_base_name(setup)
+                        plots[plot_name].quantity = self.ofieldsreporter.GetFieldPlotQuantityName(
                             setups_data[setup]["PlotName"]
                         )
-                        plots[plot_name].intrinsincList = self._get_intrinsic(setup)
+                        plots[plot_name].intrinsics = self._get_intrinsic(setup)
                         list_objs = setups_data[setup]["FieldPlotGeometry"][1:]
                         while list_objs:
                             id = list_objs[0]
                             num_objects = list_objs[2]
                             if id == 64:
-                                plots[plot_name].volume_indexes = self._get_volume_objects(
-                                    list_objs[3 : num_objects + 3]
-                                )
+                                plots[plot_name].volumes = self._get_volume_objects(list_objs[3 : num_objects + 3])
                             elif id == 128:
                                 out, faces = self._get_surface_objects(list_objs[3 : num_objects + 3])
                                 if out == "CutPlane":
-                                    plots[plot_name].cutplane_indexes = faces
+                                    plots[plot_name].cutplanes = faces
                                 else:
-                                    plots[plot_name].surfaces_indexes = faces
+                                    plots[plot_name].surfaces = faces
                             elif id == 256:
-                                plots[plot_name].line_indexes = self._get_volume_objects(list_objs[3 : num_objects + 3])
+                                plots[plot_name].lines = self._get_volume_objects(list_objs[3 : num_objects + 3])
                             list_objs = list_objs[num_objects + 3 :]
                         plots[plot_name].name = setups_data[setup]["PlotName"]
-                        plots[plot_name].plotFolder = setups_data[setup]["PlotFolder"]
+                        plots[plot_name].plot_folder = setups_data[setup]["PlotFolder"]
                         surf_setts = setups_data[setup]["PlotOnSurfaceSettings"]
                         plots[plot_name].Filled = surf_setts["Filled"]
                         plots[plot_name].IsoVal = surf_setts["IsoValType"]
                         plots[plot_name].AddGrid = surf_setts["AddGrid"]
                         plots[plot_name].MapTransparency = surf_setts["MapTransparency"]
                         plots[plot_name].Refinement = surf_setts["Refinement"]
                         plots[plot_name].Transparency = surf_setts["Transparency"]
@@ -2295,21 +2360,21 @@
                         plots[plot_name].MaxArrowSpacing = arrow_setts["MaxArrowSpacing"]
                         plots[plot_name].GridColor = surf_setts["GridColor"]
                 except Exception:
                     pass
         return plots
 
     # TODO: define a fields calculator module and make robust !!
-    @pyaedt_function_handler()
-    def volumetric_loss(self, object_name):
+    @pyaedt_function_handler(object_name="assignment")
+    def volumetric_loss(self, assignment):
         """Use the field calculator to create a variable for volumetric losses.
 
         Parameters
         ----------
-        object_name : str
+        assignment : str
             Name of the object to compute volumetric losses on.
 
         Returns
         -------
         str
             Name of the variable created.
 
@@ -2319,31 +2384,31 @@
         >>> oModule.EnterQty
         >>> oModule.EnterVol
         >>> oModule.CalcOp
         >>> oModule.AddNamedExpression
         """
         oModule = self.ofieldsreporter
         oModule.EnterQty("OhmicLoss")
-        oModule.EnterVol(object_name)
+        oModule.EnterVol(assignment)
         oModule.CalcOp("Integrate")
-        name = "P_{}".format(object_name)  # Need to check for uniqueness !
+        name = "P_{}".format(assignment)  # Need to check for uniqueness !
         oModule.AddNamedExpression(name, "Fields")
         return name
 
-    @pyaedt_function_handler()
-    def change_field_property(self, plotname, propertyname, propertyval):
+    @pyaedt_function_handler(plotname="plot_name", propertyname="property_name", propertyval="property_value")
+    def change_field_property(self, plot_name, property_name, property_value):
         """Modify a field plot property.
 
         Parameters
         ----------
-        plotname : str
+        plot_name : str
             Name of the field plot.
-        propertyname : str
+        property_name : str
             Name of the property.
-        propertyval :
+        property_value :
             Value for the property.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
@@ -2353,54 +2418,54 @@
         >>> oDesign.ChangeProperty
         """
         self._odesign.ChangeProperty(
             [
                 "NAME:AllTabs",
                 [
                     "NAME:FieldsPostProcessorTab",
-                    ["NAME:PropServers", "FieldsReporter:" + plotname],
-                    ["NAME:ChangedProps", ["NAME:" + propertyname, "Value:=", propertyval]],
+                    ["NAME:PropServers", "FieldsReporter:" + plot_name],
+                    ["NAME:ChangedProps", ["NAME:" + property_name, "Value:=", property_value]],
                 ],
             ]
         )
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(quantity_name="quantity", variation_dict="variations", isvector="is_vector")
     def get_scalar_field_value(
         self,
-        quantity_name,
+        quantity,
         scalar_function="Maximum",
         solution=None,
-        variation_dict=None,
-        isvector=False,
+        variations=None,
+        is_vector=False,
         intrinsics=None,
         phase=None,
         object_name="AllObjects",
         object_type="volume",
         adjacent_side=False,
     ):
         """Use the field calculator to Compute Scalar of a Field.
 
         Parameters
         ----------
-        quantity_name : str
+        quantity : str
             Name of the quantity to export. For example, ``"Temp"``.
         scalar_function : str, optional
             The name of the scalar function. For example, ``"Maximum"``, ``"Integrate"``.
             The default is ``"Maximum"``.
         solution : str, optional
             Name of the solution in the format ``"solution : sweep"``. The default is ``None``.
-        variation_dict : dict, optional
+        variations : dict, optional
             Dictionary of all variation variables with their values.
             e.g. ``['power_block:=', ['0.6W'], 'power_source:=', ['0.15W']]``
             The default is ``None``.
-        isvector : bool, optional
+        is_vector : bool, optional
             Whether the quantity is a vector. The  default is ``False``.
         intrinsics : str, optional
-            This parameter is mandatory for a frequency field
-            calculation. The default is ``None``.
+            This parameter is mandatory for a frequency field calculation.
+            The default is ``None``.
         phase : str, optional
             Field phase. The default is ``None``.
         object_name : str, optional
             Name of the object. For example, ``"Box1"``.
             The default is ``"AllObjects"``.
         object_type : str, optional
             Type of the object - ``"volume"``, ``"surface"``, ``"point"``.
@@ -2421,63 +2486,63 @@
         >>> oModule.CopyNamedExprToStack
         >>> oModule.CalcOp
         >>> oModule.EnterQty
         >>> oModule.EnterVol
         >>> oModule.ClcEval
         >>> GetTopEntryValue
         """
-        self.logger.info("Exporting {} field. Be patient".format(quantity_name))
+        self.logger.info("Exporting {} field. Be patient".format(quantity))
         if not solution:
             solution = self._app.existing_analysis_sweeps[0]
         self.ofieldsreporter.CalcStack("clear")
-        if isvector:
+        if is_vector:
             try:
-                self.ofieldsreporter.EnterQty(quantity_name)
+                self.ofieldsreporter.EnterQty(quantity)
             except Exception:
-                self.ofieldsreporter.CopyNamedExprToStack(quantity_name)
+                self.ofieldsreporter.CopyNamedExprToStack(quantity)
             self.ofieldsreporter.CalcOp("Smooth")
             self.ofieldsreporter.EnterScalar(0)
             self.ofieldsreporter.CalcOp("AtPhase")
             self.ofieldsreporter.CalcOp("Mag")
         else:
             try:
-                self.ofieldsreporter.EnterQty(quantity_name)
+                self.ofieldsreporter.EnterQty(quantity)
             except Exception:
-                self.logger.info("Quantity {} not present. Trying to get it from Stack".format(quantity_name))
-                self.ofieldsreporter.CopyNamedExprToStack(quantity_name)
+                self.logger.info("Quantity {} not present. Trying to get it from Stack".format(quantity))
+                self.ofieldsreporter.CopyNamedExprToStack(quantity)
         obj_list = object_name
         if scalar_function:
             if object_type == "volume":
                 self.ofieldsreporter.EnterVol(obj_list)
             elif object_type == "surface":
                 if adjacent_side:
                     self.ofieldsreporter.EnterAdjacentSurf(obj_list)
                 else:
                     self.ofieldsreporter.EnterSurf(obj_list)
             elif object_type == "point":
                 self.ofieldsreporter.EnterPoint(obj_list)
             self.ofieldsreporter.CalcOp(scalar_function)
 
-        if not variation_dict:
-            variation_dict = self._app.available_variations.nominal_w_values_dict
+        if not variations:
+            variations = self._app.available_variations.nominal_w_values_dict
 
         variation = []
-        for el, value in variation_dict.items():
+        for el, value in variations.items():
             variation.append(el + ":=")
             variation.append(value)
 
         if intrinsics:
-            if "Transient" in solution:
+            if "Transient" in solution:  # pragma: no cover
                 variation.append("Time:=")
                 variation.append(intrinsics)
             else:
                 variation.append("Freq:=")
                 variation.append(intrinsics)
                 variation.append("Phase:=")
-                if phase:
+                if phase:  # pragma: no cover
                     variation.append(phase)
                 else:
                     variation.append("0deg")
 
         file_name = os.path.join(self._app.working_directory, generate_unique_name("temp_fld") + ".fld")
         self.ofieldsreporter.CalculatorWrite(file_name, ["Solution:=", solution], variation)
         value = None
@@ -2486,68 +2551,75 @@
                 lines = f.readlines()
                 lines = [line.strip() for line in lines]
                 value = lines[-1]
             os.remove(file_name)
         self.ofieldsreporter.CalcStack("clear")
         return float(value)
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(
+        quantity_name="quantity",
+        variation_dict="variations",
+        filename="file_name",
+        gridtype="grid_type",
+        isvector="is_vector",
+    )
     def export_field_file_on_grid(
         self,
-        quantity_name,
+        quantity,
         solution=None,
-        variation_dict=None,
-        filename=None,
-        gridtype="Cartesian",
+        variations=None,
+        file_name=None,
+        grid_type="Cartesian",
         grid_center=None,
         grid_start=None,
         grid_stop=None,
         grid_step=None,
-        isvector=False,
+        is_vector=False,
         intrinsics=None,
         phase=None,
         export_with_sample_points=True,
         reference_coordinate_system="Global",
         export_in_si_system=True,
         export_field_in_reference=True,
     ):
         """Use the field calculator to create a field file on a grid based on a solution and variation.
 
         Parameters
         ----------
-        quantity_name : str
+        quantity : str
             Name of the quantity to export. For example, ``"Temp"``.
         solution : str, optional
             Name of the solution in the format ``"solution : sweep"``. The default is ``None``.
-        variation_dict : dict, optional
+        variations : dict, optional
             Dictionary of all variation variables with their values.
             The default is ``None``.
-        filename : str, optional
+        file_name : str, optional
             Full path and name to save the file to.
-            The default is ``None`` which export file in working_directory.
-        gridtype : str, optional
+            The default is ``None``, in which case the file is exported
+            to the working directory.
+        grid_type : str, optional
             Type of the grid to export. The default is ``"Cartesian"``.
         grid_center : list, optional
             The ``[x, y, z]`` coordinates for the center of the grid.
             The default is ``[0, 0, 0]``. This parameter is disabled if ``gridtype=
             "Cartesian"``.
         grid_start : list, optional
             The ``[x, y, z]`` coordinates for the starting point of the grid.
             The default is ``[0, 0, 0]``.
         grid_stop : list, optional
             The ``[x, y, z]`` coordinates for the stopping point of the grid.
             The default is ``[0, 0, 0]``.
         grid_step : list, optional
             The ``[x, y, z]`` coordinates for the step size of the grid.
             The default is ``[0, 0, 0]``.
-        isvector : bool, optional
+        is_vector : bool, optional
             Whether the quantity is a vector. The  default is ``False``.
         intrinsics : str, optional
-            This parameter is mandatory for a frequency field
-            calculation. The default is ``None``.
+            This parameter is mandatory for a frequency field calculation.
+            The default is ``None``.
         phase : str, optional
             Field phase. The default is ``None``.
         export_with_sample_points : bool, optional
             Whether to include the sample points in the file to export.
             The default is ``True``.
         reference_coordinate_system : str, optional
             Reference coordinate system in the file to export.
@@ -2577,70 +2649,70 @@
         Examples
         --------
         >>> from pyaedt import Hfss
         >>> hfss = Hfss()
         >>> var = hfss.available_variations.nominal_w_values
         >>> setup = "Setup1 : LastAdaptive"
         >>> path = "Field.fld"
-        >>> hfss.post.export_field_file_on_grid("E", setup, var, path, 'Cartesian', [0, 0, 0],  intrinsics="8GHz")
+        >>> hfss.post.export_field_file_on_grid("E",setup,var,path,'Cartesian',[0, 0, 0],intrinsics="8GHz")
         """
         if grid_step is None:
             grid_step = [0, 0, 0]
         if grid_start is None:
             grid_start = [0, 0, 0]
         if grid_stop is None:
             grid_stop = [0, 0, 0]
         if grid_center is None:
             grid_center = [0, 0, 0]
-        self.logger.info("Exporting %s field. Be patient", quantity_name)
+        self.logger.info("Exporting %s field. Be patient", quantity)
         if not solution:
             solution = self._app.existing_analysis_sweeps[0]
-        if not filename:
-            filename = os.path.join(
-                self._app.working_directory, "{}_{}.fld".format(quantity_name, solution.replace(" : ", "_"))
+        if not file_name:
+            file_name = os.path.join(
+                self._app.working_directory, "{}_{}.fld".format(quantity, solution.replace(" : ", "_"))
             )
-        elif os.path.isdir(filename):
-            filename = os.path.join(filename, "{}_{}.fld".format(quantity_name, solution.replace(" : ", "_")))
+        elif os.path.isdir(file_name):
+            file_name = os.path.join(file_name, "{}_{}.fld".format(quantity, solution.replace(" : ", "_")))
         self.ofieldsreporter.CalcStack("clear")
         try:
-            self.ofieldsreporter.EnterQty(quantity_name)
+            self.ofieldsreporter.EnterQty(quantity)
         except Exception:
-            self.ofieldsreporter.CopyNamedExprToStack(quantity_name)
-        if isvector:
+            self.ofieldsreporter.CopyNamedExprToStack(quantity)
+        if is_vector:
             self.ofieldsreporter.CalcOp("Smooth")
             if phase:
                 self.ofieldsreporter.EnterScalar(0)
                 self.ofieldsreporter.CalcOp("AtPhase")
                 self.ofieldsreporter.CalcOp("Mag")
         units = self.modeler.model_units
         ang_units = "deg"
-        if gridtype == "Cartesian":
+        if grid_type == "Cartesian":
             grid_center = ["0mm", "0mm", "0mm"]
             grid_start_wu = [str(i) + units for i in grid_start]
             grid_stop_wu = [str(i) + units for i in grid_stop]
             grid_step_wu = [str(i) + units for i in grid_step]
-        elif gridtype == "Cylindrical":
+        elif grid_type == "Cylindrical":
             grid_center = [str(i) + units for i in grid_center]
             grid_start_wu = [str(grid_start[0]) + units, str(grid_start[1]) + ang_units, str(grid_start[2]) + units]
             grid_stop_wu = [str(grid_stop[0]) + units, str(grid_stop[1]) + ang_units, str(grid_stop[2]) + units]
             grid_step_wu = [str(grid_step[0]) + units, str(grid_step[1]) + ang_units, str(grid_step[2]) + units]
-        elif gridtype == "Spherical":
+        elif grid_type == "Spherical":
             grid_center = [str(i) + units for i in grid_center]
             grid_start_wu = [str(grid_start[0]) + units, str(grid_start[1]) + ang_units, str(grid_start[2]) + ang_units]
             grid_stop_wu = [str(grid_stop[0]) + units, str(grid_stop[1]) + ang_units, str(grid_stop[2]) + ang_units]
             grid_step_wu = [str(grid_step[0]) + units, str(grid_step[1]) + ang_units, str(grid_step[2]) + ang_units]
         else:
             self.logger.error("Error in the type of the grid.")
             return False
 
-        if not variation_dict:
-            variation_dict = self._app.available_variations.nominal_w_values_dict
+        if not variations:
+            variations = self._app.available_variations.nominal_w_values_dict
 
         variation = []
-        for el, value in variation_dict.items():
+        for el, value in variations.items():
             variation.append(el + ":=")
             variation.append(value)
 
         if intrinsics:
             if "Transient" in solution:
                 variation.append("Time:=")
                 variation.append(intrinsics)
@@ -2662,75 +2734,83 @@
             "PtInSI:=",
             export_in_si_system,
             "FieldInRefCS:=",
             export_field_in_reference,
         ]
 
         self.ofieldsreporter.ExportOnGrid(
-            filename,
+            file_name,
             grid_start_wu,
             grid_stop_wu,
             grid_step_wu,
             solution,
             variation,
             export_options,
-            gridtype,
+            grid_type,
             grid_center,
             False,
         )
-        if os.path.exists(filename):
-            return filename
+        if os.path.exists(file_name):
+            return file_name
         return False  # pragma: no cover
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(
+        quantity_name="quantity",
+        variation_dict="variations",
+        filename="output_dir",
+        obj_list="assignment",
+        obj_type="objects_type",
+        sample_points_lists="sample_points",
+    )
     def export_field_file(
         self,
-        quantity_name,
+        quantity,
         solution=None,
-        variation_dict=None,
-        filename=None,
-        obj_list="AllObjects",
-        obj_type="Vol",
+        variations=None,
+        output_dir=None,
+        assignment="AllObjects",
+        objects_type="Vol",
         intrinsics=None,
         phase=None,
         sample_points_file=None,
-        sample_points_lists=None,
+        sample_points=None,
         export_with_sample_points=True,
         reference_coordinate_system="Global",
         export_in_si_system=True,
         export_field_in_reference=True,
     ):
         """Use the field calculator to create a field file based on a solution and variation.
 
         Parameters
         ----------
-        quantity_name :
+        quantity :
             Name of the quantity to export. For example, ``"Temp"``.
         solution : str, optional
             Name of the solution in the format ``"solution: sweep"``.
             The default is ``None``.
-        variation_dict : dict, optional
+        variations : dict, optional
             Dictionary of all variation variables with their values.
             The default is ``None``.
-        filename : str, optional
+        output_dir : str, optional
             Full path and name to save the file to.
             The default is ``None`` which export file in working_directory.
-        obj_list : str, optional
+        assignment : str, optional
             List of objects to export. The default is ``"AllObjects"``.
-        obj_type : str, optional
-            Type of objects to export. Options are ``"Vol"`` for volume and
-            ``"Surf"`` for surface. The default is ``"Vol"``.
+        objects_type : str, optional
+            Type of objects to export. The default is ``"Vol"``.
+            Options are ``"Surf"`` for surface and ``"Vol"`` for
+            volume.
         intrinsics : str, optional
-            This parameter is mandatory for a frequency or transient field
-            calculation. The default is ``None``.
+            This parameter is mandatory for a frequency or transient field calculation.
+            The default is ``None``.
         phase : str, optional
             Field phase. The default is ``None``.
         sample_points_file : str, optional
             Name of the file with sample points. The default is ``None``.
-        sample_points_lists : list, optional
+        sample_points : list, optional
             List of the sample points. The default is ``None``.
         export_with_sample_points : bool, optional
             Whether to include the sample points in the file to export.
             The default is ``True``.
         reference_coordinate_system : str, optional
             Reference coordinate system in the file to export.
             The default is ``"Global"``.
@@ -2753,37 +2833,37 @@
         >>> oModule.CopyNamedExprToStack
         >>> oModule.CalcOp
         >>> oModule.EnterQty
         >>> oModule.EnterVol
         >>> oModule.CalculatorWrite
         >>> oModule.ExportToFile
         """
-        self.logger.info("Exporting %s field. Be patient", quantity_name)
+        self.logger.info("Exporting %s field. Be patient", quantity)
         if not solution:
             if not self._app.existing_analysis_sweeps:
                 self.logger.error("There are no existing sweeps.")
                 return False
             solution = self._app.existing_analysis_sweeps[0]
-        if not filename:
+        if not output_dir:
             appendix = ""
             ext = ".fld"
-            filename = os.path.join(self._app.working_directory, solution.replace(" : ", "_") + appendix + ext)
+            output_dir = os.path.join(self._app.working_directory, solution.replace(" : ", "_") + appendix + ext)
         else:
-            filename = filename.replace("//", "/").replace("\\", "/")
+            output_dir = output_dir.replace("//", "/").replace("\\", "/")
         self.ofieldsreporter.CalcStack("clear")
         try:
-            self.ofieldsreporter.EnterQty(quantity_name)
+            self.ofieldsreporter.EnterQty(quantity)
         except Exception:
-            self.ofieldsreporter.CopyNamedExprToStack(quantity_name)
+            self.ofieldsreporter.CopyNamedExprToStack(quantity)
 
-        if not variation_dict:
-            variation_dict = self._app.available_variations.nominal_w_values_dict
+        if not variations:
+            variations = self._app.available_variations.nominal_w_values_dict
 
         variation = []
-        for el, value in variation_dict.items():
+        for el, value in variations.items():
             variation.append(el + ":=")
             variation.append(value)
 
         if intrinsics:
             if "Transient" in solution:
                 variation.append("Time:=")
                 variation.append(intrinsics)
@@ -2791,108 +2871,105 @@
                 variation.append("Freq:=")
                 variation.append(intrinsics)
                 variation.append("Phase:=")
                 if phase:
                     variation.append(phase)
                 else:
                     variation.append("0deg")
-        if not sample_points_file and not sample_points_lists:
-            if obj_type == "Vol":
-                self.ofieldsreporter.EnterVol(obj_list)
-            elif obj_type == "Surf":
-                self.ofieldsreporter.EnterSurf(obj_list)
+        if not sample_points_file and not sample_points:
+            if objects_type == "Vol":
+                self.ofieldsreporter.EnterVol(assignment)
+            elif objects_type == "Surf":
+                self.ofieldsreporter.EnterSurf(assignment)
             else:
                 self.logger.error("No correct choice.")
                 return False
             self.ofieldsreporter.CalcOp("Value")
-            self.ofieldsreporter.CalculatorWrite(filename, ["Solution:=", solution], variation)
+            self.ofieldsreporter.CalculatorWrite(output_dir, ["Solution:=", solution], variation)
         elif sample_points_file:
             export_options = [
                 "NAME:ExportOption",
                 "IncludePtInOutput:=",
                 export_with_sample_points,
                 "RefCSName:=",
                 reference_coordinate_system,
                 "PtInSI:=",
                 export_in_si_system,
                 "FieldInRefCS:=",
                 export_field_in_reference,
             ]
             self.ofieldsreporter.ExportToFile(
-                filename,
+                output_dir,
                 sample_points_file,
                 solution,
                 variation,
                 export_options,
             )
         else:
             sample_points_file = os.path.join(self._app.working_directory, "temp_points.pts")
             with open_file(sample_points_file, "w") as f:
                 f.write("Unit={}\n".format(self.model_units))
-                for point in sample_points_lists:
+                for point in sample_points:
                     f.write(" ".join([str(i) for i in point]) + "\n")
             export_options = [
                 "NAME:ExportOption",
                 "IncludePtInOutput:=",
                 export_with_sample_points,
                 "RefCSName:=",
                 reference_coordinate_system,
                 "PtInSI:=",
                 export_in_si_system,
                 "FieldInRefCS:=",
                 export_field_in_reference,
             ]
             self.ofieldsreporter.ExportToFile(
-                filename,
+                output_dir,
                 sample_points_file,
                 solution,
                 variation,
                 export_options,
             )
 
-        if os.path.exists(filename):
-            return filename
+        if os.path.exists(output_dir):
+            return output_dir
         return False  # pragma: no cover
 
-    @pyaedt_function_handler()
-    def export_field_plot(self, plotname, filepath, filename="", file_format="aedtplt"):
+    @pyaedt_function_handler(plotname="plot_name", filepath="output_dir", filename="file_name")
+    def export_field_plot(self, plot_name, output_dir, file_name="", file_format="aedtplt"):
         """Export a field plot.
 
         Parameters
         ----------
-        plotname : str
+        plot_name : str
             Name of the plot.
-
-        filepath : str
+        output_dir : str
             Path for saving the file.
-
-        filename : str, optional
-            Name of the file. The default is ``""``.
-
+        file_name : str, optional
+            Name of the file. The default is ``""``, in which case a name is automatically assigned.
         file_format : str, optional
             Name of the file extension. The default is ``"aedtplt"``. Options are ``"case"`` and ``"fldplt"``.
 
         Returns
         -------
         str
             File path when successful.
 
         References
         ----------
         >>> oModule.ExportFieldPlot
         """
-        if not filename:
-            filename = plotname
-        filepath = os.path.join(filepath, filename + "." + file_format)
+        if not file_name:
+            file_name = plot_name
+        output_dir = os.path.join(output_dir, file_name + "." + file_format)
         try:
-            self.ofieldsreporter.ExportFieldPlot(plotname, False, filepath)
+            self.ofieldsreporter.ExportFieldPlot(plot_name, False, output_dir)
             if settings.remote_rpc_session_temp_folder:  # pragma: no cover
-                local_path = os.path.join(settings.remote_rpc_session_temp_folder, filename + "." + file_format)
-                filepath = check_and_download_file(local_path, filepath)
-            return filepath
+                local_path = os.path.join(settings.remote_rpc_session_temp_folder, file_name + "." + file_format)
+                output_dir = check_and_download_file(local_path, output_dir)
+            return output_dir
         except Exception:  # pragma: no cover
             self.logger.error("{} file format is not supported for this plot.".format(file_format))
             return False
 
     @pyaedt_function_handler()
     def change_field_plot_scale(self, plot_name, minimum_value, maximum_value, is_log=False, is_db=False):
         """Change Field Plot Scale.
@@ -2948,215 +3025,199 @@
                 "ScaleType:=",
                 1,
             ]
         ]
         self.ofieldsreporter.SetPlotFolderSettings(plot_name, args)
         return True
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(objlist="assignment", quantityName="quantity", listtype="list_type", setup_name="setup")
     def _create_fieldplot(
-        self, objlist, quantityName, setup_name, intrinsics, listtype, plot_name=None, filter_boxes=[], field_type=None
+        self,
+        assignment,
+        quantity,
+        setup,
+        intrinsics,
+        list_type,
+        plot_name=None,
+        filter_boxes=None,
+        field_type=None,
     ):
-        if not listtype.startswith("Layer") and self._app.design_type != "HFSS 3D Layout Design":
-            objlist = self._app.modeler.convert_to_selections(objlist, True)
-        if not setup_name:
-            setup_name = self._app.existing_analysis_sweeps[0]
+        if not list_type.startswith("Layer") and self._app.design_type != "HFSS 3D Layout Design":
+            assignment = self._app.modeler.convert_to_selections(assignment, True)
+        if not setup:
+            setup = self._app.existing_analysis_sweeps[0]
         if not intrinsics:
             for i in self._app.setups:
-                if i.name == setup_name.split(" : ")[0]:
+                if i.name == setup.split(" : ")[0]:
                     intrinsics = i.default_intrinsics
         self._desktop.CloseAllWindows()
         try:
             self._app.modeler.fit_all()
         except Exception:
             pass
         self._desktop.TileWindows(0)
         self._oproject.SetActiveDesign(self._app.design_name)
 
         char_set = string.ascii_uppercase + string.digits
         if not plot_name:
-            plot_name = quantityName + "_" + "".join(random.sample(char_set, 6))
-        if listtype == "CutPlane":
-            plot = FieldPlot(
-                self,
-                cutplanelist=objlist,
-                solutionName=setup_name,
-                quantityName=quantityName,
-                intrinsincList=intrinsics,
-            )
-        elif listtype == "FacesList":
+            plot_name = quantity + "_" + "".join(random.sample(char_set, 6))
+        filter_boxes = [] if filter_boxes is None else filter_boxes
+        if list_type == "CutPlane":
+            plot = FieldPlot(self, cutplanes=assignment, solution=setup, quantity=quantity, intrinsics=intrinsics)
+        elif list_type == "FacesList":
+            plot = FieldPlot(self, surfaces=assignment, solution=setup, quantity=quantity, intrinsics=intrinsics)
+        elif list_type == "ObjList":
+            plot = FieldPlot(self, objects=assignment, solution=setup, quantity=quantity, intrinsics=intrinsics)
+        elif list_type == "Line":
+            plot = FieldPlot(self, lines=assignment, solution=setup, quantity=quantity, intrinsics=intrinsics)
+        elif list_type.startswith("Layer"):
             plot = FieldPlot(
                 self,
-                surfacelist=objlist,
-                solutionName=setup_name,
-                quantityName=quantityName,
-                intrinsincList=intrinsics,
-            )
-        elif listtype == "ObjList":
-            plot = FieldPlot(
-                self,
-                objlist=objlist,
-                solutionName=setup_name,
-                quantityName=quantityName,
-                intrinsincList=intrinsics,
-            )
-        elif listtype == "Line":
-            plot = FieldPlot(
-                self,
-                linelist=objlist,
-                solutionName=setup_name,
-                quantityName=quantityName,
-                intrinsincList=intrinsics,
-            )
-        elif listtype.startswith("Layer"):
-            plot = FieldPlot(
-                self,
-                layers_nets=objlist,
-                solutionName=setup_name,
-                quantityName=quantityName,
-                intrinsincList=intrinsics,
-                layers_plot_type=listtype,
+                solution=setup,
+                quantity=quantity,
+                intrinsics=intrinsics,
+                layer_nets=assignment,
+                layer_plot_type=list_type,
             )
         if self._app.design_type == "Q3D Extractor":  # pragma: no cover
             plot.field_type = field_type
         plot.name = plot_name
-        plot.plotFolder = plot_name
+        plot.plot_folder = plot_name
         plot.filter_boxes = filter_boxes
         plt = plot.create()
         if "Maxwell" in self._app.design_type and "Transient" in self.post_solution_type:
-            self.ofieldsreporter.SetPlotsViewSolutionContext([plot_name], setup_name, "Time:" + intrinsics["Time"])
+            self.ofieldsreporter.SetPlotsViewSolutionContext([plot_name], setup, "Time:" + intrinsics["Time"])
         if plt:
             self.field_plots[plot_name] = plot
             return plot
         else:
             return False
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(quantityName="quantity", setup_name="setup")
     def _create_fieldplot_line_traces(
         self,
         seeding_faces_ids,
         in_volume_tracing_ids,
         surface_tracing_ids,
-        quantityName,
-        setup_name,
+        quantity,
+        setup,
         intrinsics,
         plot_name=None,
         field_type="",
     ):
-        if not setup_name:
-            setup_name = self._app.existing_analysis_sweeps[0]
+        if not setup:
+            setup = self._app.existing_analysis_sweeps[0]
         if not intrinsics:
             for i in self._app.setups:
-                if i.name == setup_name.split(" : ")[0]:
+                if i.name == setup.split(" : ")[0]:
                     intrinsics = i.default_intrinsics
         self._desktop.CloseAllWindows()
         try:
             self._app._modeler.fit_all()
         except Exception:
             pass
         self._desktop.TileWindows(0)
         self._oproject.SetActiveDesign(self._app.design_name)
 
         char_set = string.ascii_uppercase + string.digits
         if not plot_name:
-            plot_name = quantityName + "_" + "".join(random.sample(char_set, 6))
+            plot_name = quantity + "_" + "".join(random.sample(char_set, 6))
         plot = FieldPlot(
             self,
-            objlist=in_volume_tracing_ids,
-            surfacelist=surface_tracing_ids,
-            solutionName=setup_name,
-            quantityName=quantityName,
-            intrinsincList=intrinsics,
-            seedingFaces=seeding_faces_ids,
+            objects=in_volume_tracing_ids,
+            surfaces=surface_tracing_ids,
+            solution=setup,
+            quantity=quantity,
+            intrinsics=intrinsics,
+            seeding_faces=seeding_faces_ids,
         )
         if field_type:
             plot.field_type = field_type
         plot.name = plot_name
-        plot.plotFolder = plot_name
+        plot.plot_folder = plot_name
 
         plt = plot.create()
         if "Maxwell" in self._app.design_type and self.post_solution_type == "Transient":
-            self.ofieldsreporter.SetPlotsViewSolutionContext([plot_name], setup_name, "Time:" + intrinsics["Time"])
+            self.ofieldsreporter.SetPlotsViewSolutionContext([plot_name], setup, "Time:" + intrinsics["Time"])
         if plt:
             self.field_plots[plot_name] = plot
             return plot
         else:
             return False
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(objlist="assignment", quantityName="quantity", setup_name="setup")
     def create_fieldplot_line(
-        self, objlist, quantityName, setup_name=None, intrinsincDict=None, plot_name=None, field_type="DC R/L Fields"
+        self, assignment, quantity, setup=None, intrinsics=None, plot_name=None, field_type="DC R/L Fields"
     ):
         """Create a field plot of the line.
 
         Parameters
         ----------
-        objlist : list
-            List of polyline to plot.
-        quantityName : str
+        assignment : list
+            List of polylines to plot.
+        quantity : str
             Name of the quantity to plot.
-        setup_name : str, optional
-            Name of the setup. The default is ``None`` which automatically take ``nominal_adaptive`` setup.
-            Please make sure to build a setup string in the form of ``"SetupName : SetupSweep"``
-            where ``SetupSweep`` is the Sweep name to use in the export or ``LastAdaptive``.
-        intrinsincDict : dict, optional
-            Dictionary containing all intrinsic variables. The default
-            is ``{}``.
+        setup : str, optional
+            Name of the setup. The default is ``None``, in which case the ``nominal_adaptive``
+            setup is used. Be sure to build a setup string in the form of
+            ``"SetupName : SetupSweep"``, where ``SetupSweep`` is the sweep name to
+            use in the export or ``LastAdaptive``.
+        intrinsics : dict, optional
+            Dictionary containing all intrinsic variables.
+            The default is ``None``.
         plot_name : str, optional
-            Name of the fieldplot to create.
+            Name of the field plot to create.
         field_type : str, optional
             Field type to plot. Valid only for Q3D Field plots.
 
         Returns
         -------
         type
             Plot object.
 
         References
         ----------
 
         >>> oModule.CreateFieldPlot
         """
-        if intrinsincDict is None:
-            intrinsincDict = {}
+        if intrinsics is None:
+            intrinsics = {}
         if plot_name and plot_name in list(self.field_plots.keys()):
             self.logger.info("Plot {} exists. returning the object.".format(plot_name))
             return self.field_plots[plot_name]
-        return self._create_fieldplot(
-            objlist, quantityName, setup_name, intrinsincDict, "Line", plot_name, field_type=field_type
-        )
+        return self._create_fieldplot(assignment, quantity, setup, intrinsics, "Line", plot_name, field_type=field_type)
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(IntrinsincDict="intrinsics", setup_name="setup")
     def create_fieldplot_line_traces(
         self,
         seeding_faces,
         in_volume_tracing_objs=None,
         surface_tracing_objs=None,
-        setup_name=None,
-        intrinsinc_dict=None,
+        setup=None,
+        intrinsics=None,
         plot_name=None,
         field_type="DC R/L Fields",
     ):
         """
         Create a field plot of the line.
 
         Parameters
         ----------
         seeding_faces : list
             List of seeding faces.
         in_volume_tracing_objs : list
             List of the in-volume tracing objects.
         surface_tracing_objs : list
             List of the surface tracing objects.
-        setup_name : str, optional
+        setup : str, optional
             Name of the setup in the format ``"setupName : sweepName"``. The default
             is ``None``.
-        intrinsinc_dict : dict, optional
-            Dictionary containing all intrinsic variables. The default
-            is ``{}``.
+        intrinsics : dict, optional
+            Dictionary containing all intrinsic variables.
+            The default is ``None``.
         plot_name : str, optional
             Name of the field plot to create. The default is ``None``.
         field_type : str, optional
             Field type to plot. Valid only for Q3D Field plots.
 
         Returns
         -------
@@ -3167,16 +3228,16 @@
         ----------
 
         >>> oModule.CreateFieldPlot
         """
         if self._app.solution_type != "Electrostatic":
             self.logger.error("Field line traces is valid only for electrostatic solution")
             return False
-        if intrinsinc_dict is None:
-            intrinsinc_dict = {}
+        if intrinsics is None:
+            intrinsics = {}
         if plot_name and plot_name in list(self.field_plots.keys()):
             self.logger.info("Plot {} exists. returning the object.".format(plot_name))
             return self.field_plots[plot_name]
         if not isinstance(seeding_faces, list):
             seeding_faces = [seeding_faces]
         seeding_faces_ids = []
         for face in seeding_faces:
@@ -3223,44 +3284,44 @@
         if surface_tracing_ids != [0]:
             surface_tracing_ids.insert(0, len(surface_tracing_ids))
         return self._create_fieldplot_line_traces(
             seeding_faces_ids,
             in_volume_tracing_ids,
             surface_tracing_ids,
             "FieldLineTrace",
-            setup_name,
-            intrinsinc_dict,
+            setup,
+            intrinsics,
             plot_name,
             field_type=field_type,
         )
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(quantity_name="quantity", setup_name="setup")
     def create_fieldplot_layers_nets(
-        self, layers_nets, quantity_name, setup_name=None, intrinsics=None, plot_on_surface=True, plot_name=None
+        self, layers_nets, quantity, setup=None, intrinsics=None, plot_on_surface=True, plot_name=None
     ):  # pragma: no cover
         # type: (list, str, str, dict, bool, str) -> FieldPlot
         """Create a field plot of stacked layer plot.
         This plot is valid from AEDT 2023 R2 and later in HFSS 3D Layout
         and any modeler where a layout component is used.
 
         Parameters
         ----------
         layers_nets : list
             List of layers and nets to plot. For example:
             ``[["Layer1", "GND", "PWR"], ["Layer2", "VCC"], ...]``.
-        quantity_name : str
+        quantity : str
             Name of the quantity to plot.
-        setup_name : str, optional
+        setup : str, optional
             Name of the setup. The default is ``None``, in which case the ``nominal_adaptive``
             setup is used. Make sure to build a setup string in the form of
             ``"SetupName : SetupSweep"``, where ``SetupSweep`` is the sweep name to
             use in the export or ``LastAdaptive``.
         intrinsics : dict, optional
-            Dictionary containing all intrinsic variables. The default
-            is ``{}``.
+            Dictionary containing all intrinsic variables.
+            The default is ``None``.
         plot_on_surface : bool, optional
             Whether the plot is to be on the surface or volume of traces.
         plot_name : str, optional
             Name of the field plot to create.
 
         Returns
         -------
@@ -3279,213 +3340,216 @@
             return False
         if intrinsics is None:
             intrinsics = {}
         if plot_name and plot_name in list(self.field_plots.keys()):
             self.logger.info("Plot {} exists. returning the object.".format(plot_name))
             return self.field_plots[plot_name]
         if self._app.design_type == "HFSS 3D Layout Design":
-            if not setup_name:
-                setup_name = self._app.existing_analysis_sweeps[0]
+            if not setup:
+                setup = self._app.existing_analysis_sweeps[0]
             lst = []
             for layer in layers_nets:
                 for el in layer[1:]:
-                    get_ids = self._odesign.GetGeometryIdsForNetLayerCombination(el, layer[0], setup_name)
+                    get_ids = self._odesign.GetGeometryIdsForNetLayerCombination(el, layer[0], setup)
                     if isinstance(get_ids, (tuple, list)) and len(get_ids) > 2:
                         lst.extend([int(i) for i in get_ids[2:]])
-            return self._create_fieldplot(lst, quantity_name, setup_name, intrinsics, "FacesList", plot_name)
+            return self._create_fieldplot(lst, quantity, setup, intrinsics, "FacesList", plot_name)
         if plot_on_surface:
             plot_type = "LayerNetsExtFace"
         else:
             plot_type = "LayerNets"
-        return self._create_fieldplot(layers_nets, quantity_name, setup_name, intrinsics, plot_type, plot_name)
+        return self._create_fieldplot(layers_nets, quantity, setup, intrinsics, plot_type, plot_name)
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(
+        objlist="assignment", quantityName="quantity", IntrinsincDict="intrinsics", setup_name="setup"
+    )
     def create_fieldplot_surface(
-        self, objlist, quantityName, setup_name=None, intrinsincDict=None, plot_name=None, field_type="DC R/L Fields"
+        self, assignment, quantity, setup=None, intrinsics=None, plot_name=None, field_type="DC R/L Fields"
     ):
         """Create a field plot of surfaces.
 
         Parameters
         ----------
-        objlist : list
+        assignment : list
             List of surfaces to plot.
-        quantityName : str
+        quantity : str
             Name of the quantity to plot.
-        setup_name : str, optional
-            Name of the setup. The default is ``None`` which automatically take ``nominal_adaptive`` setup.
-            Please make sure to build a setup string in the form of ``"SetupName : SetupSweep"``
-            where ``SetupSweep`` is the Sweep name to use in the export or ``LastAdaptive``.
-        intrinsincDict : dict, optional
-            Dictionary containing all intrinsic variables. The default
-            is ``{}``.
+        setup : str, optional
+            Name of the setup. The default is ``None``, in which case the ``nominal_adaptive``
+            setup is used. Be sure to build a setup string in the form of
+            ``"SetupName : SetupSweep"``, where ``SetupSweep`` is the sweep name to
+            use in the export or ``LastAdaptive``.
+        intrinsics : dict, optional
+            Dictionary containing all intrinsic variables.
+            The default is ``None``.
         plot_name : str, optional
-            Name of the fieldplot to create.
+            Name of the field plot to create.
         field_type : str, optional
             Field type to plot. Valid only for Q3D Field plots.
 
         Returns
         -------
         :class:``pyaedt.modules.solutions.FieldPlot``
             Plot object.
 
         References
         ----------
 
         >>> oModule.CreateFieldPlot
         """
-        if intrinsincDict is None:
-            intrinsincDict = {}
+        if intrinsics is None:
+            intrinsics = {}
         if plot_name and plot_name in list(self.field_plots.keys()):
             self.logger.info("Plot {} exists. returning the object.".format(plot_name))
             return self.field_plots[plot_name]
-        if not isinstance(objlist, (list, tuple)):
-            objlist = [objlist]
+        if not isinstance(assignment, (list, tuple)):
+            assignment = [assignment]
         new_obj_list = []
-        for obj in objlist:
+        for obj in assignment:
             if isinstance(obj, (int, FacePrimitive)):
                 new_obj_list.append(obj)
             elif self._app.modeler[obj]:
                 new_obj_list.extend([face for face in self._app.modeler[obj].faces if face.id not in new_obj_list])
         return self._create_fieldplot(
-            new_obj_list, quantityName, setup_name, intrinsincDict, "FacesList", plot_name, field_type=field_type
+            new_obj_list, quantity, setup, intrinsics, "FacesList", plot_name, field_type=field_type
         )
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(
+        objlist="assignment", quantityName="quantity", IntrinsincDict="intrinsics", setup_name="setup"
+    )
     def create_fieldplot_cutplane(
         self,
-        objlist,
-        quantityName,
-        setup_name=None,
-        intrinsincDict=None,
+        assignment,
+        quantity,
+        setup=None,
+        intrinsics=None,
         plot_name=None,
-        filter_objects=[],
+        filter_objects=None,
         field_type="DC R/L Fields",
     ):
         """Create a field plot of cut planes.
 
         Parameters
         ----------
-        objlist : list
+        assignment : list
             List of cut planes to plot.
-        quantityName : str
+        quantity : str
             Name of the quantity to plot.
-        setup_name : str, optional
-            Name of the setup. The default is ``None`` which automatically take ``nominal_adaptive`` setup.
-            Please make sure to build a setup string in the form of ``"SetupName : SetupSweep"``
-            where ``SetupSweep`` is the Sweep name to use in the export or ``LastAdaptive``.
-        intrinsincDict : dict, optional
+        setup : str, optional
+            Name of the setup. The default is ``None``, in which case the ``nominal_adaptive`` setup
+            is used. Be sure to build a setup string in the form of ``"SetupName : SetupSweep"``,
+            where ``SetupSweep`` is the sweep name to use in the export or ``LastAdaptive``.
+        intrinsics : dict, optional
             Dictionary containing all intrinsic variables.
-            The default is ``{}``.
+            The default is ``None``.
         plot_name : str, optional
-            Name of the fieldplot to create.
+            Name of the field plot to create.
         filter_objects : list, optional
             Objects list on which filter the plot.
+            The default value is ``None``, in which case an empty list is passed.
         field_type : str, optional
-            Field type to plot. Valid only for Q3D Field plots.
+            Field type to plot. This parameter is valid only for Q3D field plots.
 
         Returns
         -------
         :class:``pyaedt.modules.solutions.FieldPlot``
             Plot object.
 
         References
         ----------
 
         >>> oModule.CreateFieldPlot
         """
-        if intrinsincDict is None:
-            intrinsincDict = {}
+        if intrinsics is None:
+            intrinsics = {}
         if plot_name and plot_name in list(self.field_plots.keys()):
             self.logger.info("Plot {} exists. returning the object.".format(plot_name))
             return self.field_plots[plot_name]
         if filter_objects:
             filter_objects = self._app.modeler.convert_to_selections(filter_objects, True)
         return self._create_fieldplot(
-            objlist,
-            quantityName,
-            setup_name,
-            intrinsincDict,
+            assignment,
+            quantity,
+            setup,
+            intrinsics,
             "CutPlane",
             plot_name,
             filter_boxes=filter_objects,
             field_type=field_type,
         )
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(
+        objlist="assignment", quantityName="quantity", IntrinsincDict="intrinsics", setup_name="setup"
+    )
     def create_fieldplot_volume(
-        self,
-        objlist,
-        quantityName,
-        setup_name=None,
-        intrinsincDict=None,
-        plot_name=None,
-        field_type="DC R/L Fields",
+        self, assignment, quantity, setup=None, intrinsics=None, plot_name=None, field_type="DC R/L Fields"
     ):
         """Create a field plot of volumes.
 
         Parameters
         ----------
-        objlist : list
+        assignment : list
             List of volumes to plot.
-        quantityName :
+        quantity :
             Name of the quantity to plot.
-        setup_name : str, optional
-            Name of the setup. The default is ``None`` which automatically take ``nominal_adaptive`` setup.
-            Please make sure to build a setup string in the form of ``"SetupName : SetupSweep"``
-            where ``SetupSweep`` is the Sweep name to use in the export or ``LastAdaptive``.
-        intrinsincDict : dict, optional
-            Dictionary containing all intrinsic variables. The default
-            is ``{}``.
+        setup : str, optional
+            Name of the setup. The default is ``None``, in which case the ``nominal_adaptive``
+            setup is used. Be sure to build a setup string in the form of
+            ``"SetupName : SetupSweep"``, where ``SetupSweep`` is the sweep name to
+            use in the export or ``LastAdaptive``.
+        intrinsics : dict, optional
+            Dictionary containing all intrinsic variables.
+            The default is ``None``.
         plot_name : str, optional
-            Name of the fieldplot to create.
+            Name of the field plot to create.
 
         Returns
         -------
         :class:``pyaedt.modules.solutions.FieldPlot``
             Plot object.
 
         References
         ----------
 
         >>> oModule.CreateFieldPlot
         """
-        if intrinsincDict is None:
-            intrinsincDict = {}
+        if intrinsics is None:
+            intrinsics = {}
         if plot_name and plot_name in list(self.field_plots.keys()):
             self.logger.info("Plot {} exists. returning the object.".format(plot_name))
             return self.field_plots[plot_name]
         return self._create_fieldplot(
-            objlist, quantityName, setup_name, intrinsincDict, "ObjList", plot_name, field_type=field_type
+            assignment, quantity, setup, intrinsics, "ObjList", plot_name, field_type=field_type
         )
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(fileName="file_name", plotName="plot_name", foldername="folder_name")
     def export_field_jpg(
         self,
-        fileName,
-        plotName,
-        foldername,
+        file_name,
+        plot_name,
+        folder_name,
         orientation="isometric",
         width=1920,
         height=1080,
         display_wireframe=True,
         selections=None,
         show_axis=True,
         show_grid=True,
         show_ruler=True,
         show_region="Default",
     ):
         """Export a field plot and coordinate system to a JPG file.
 
         Parameters
         ----------
-        fileName : str
+        file_name : str
             Full path and name to save the JPG file to.
-        plotName : str
+        plot_name : str
             Name of the plot.
-        foldername : str
+        folder_name : str
             Name of the folder plot.
         orientation : str, optional
             Name of the orientation to apply. The default is ``"isometric"``.
         width : int, optional
             Plot Width. The default is ``1920``.
         height : int, optional
             Plot Height. The default is ``1080``.
@@ -3531,35 +3595,35 @@
                 center = [
                     (float(bound[0]) + float(bound[3])) / 2,
                     (float(bound[1]) + float(bound[4])) / 2,
                     (float(bound[2]) + float(bound[5])) / 2,
                 ]
                 view = orientation_to_view.get(orientation, "iso")
                 cs = self.modeler.create_coordinate_system(origin=center, mode="view", view=view)
-                self.ofieldsreporter.ExportPlotImageToFile(fileName, foldername, plotName, cs.name)
+                self.ofieldsreporter.ExportPlotImageToFile(file_name, folder_name, plot_name, cs.name)
                 cs.delete()
             else:
                 self.export_model_picture(
-                    full_name=fileName,
+                    full_name=file_name,
                     width=width,
                     height=height,
                     orientation=orientation,
-                    field_selections=plotName,
+                    field_selections=plot_name,
                     selections=selections,
                     show_axis=show_axis,
                     show_grid=show_grid,
                     show_ruler=show_ruler,
                     show_region=show_region,
                 )
 
             for solid in wireframes:
                 self._primitives[solid].display_wireframe = False
         else:
             self.ofieldsreporter.ExportPlotImageWithViewToFile(
-                fileName, foldername, plotName, width, height, orientation
+                file_name, folder_name, plot_name, width, height, orientation
             )
         return True
 
     @pyaedt_function_handler()
     def delete_field_plot(self, name):
         """Delete a field plot.
 
@@ -3698,173 +3762,174 @@
                 if width == 0:
                     width = 500
                 if height == 0:
                     height = 500
             self.oeditor.ExportModelImageToFile(full_name, width, height, arg)
         return full_name
 
-    @pyaedt_function_handler()
-    def get_far_field_data(
-        self, expression="GainTotal", setup_sweep_name="", domain="Infinite Sphere1", families_dict=None
-    ):
-        """Generate far field data using ``GetSolutionDataPerVariation``.
+    @pyaedt_function_handler(expression="expressions", families_dict="sweeps")
+    def get_far_field_data(self, expressions="GainTotal", setup_sweep_name="", domain="Infinite Sphere1", sweeps=None):
+        """Generate far field data using the ``GetSolutionDataPerVariation()`` method.
 
         This method returns the data ``solData``, ``ThetaVals``,
         ``PhiVals``, ``ScanPhiVals``, ``ScanThetaVals``, and
         ``FreqVals``.
 
         Parameters
         ----------
-        expression : str or list, optional
+        expressions : str or list, optional
             One or more formulas to add to the report. The default is ``"GainTotal"``.
         setup_sweep_name : str, optional
             Name of the setup for computing the report. The default is ``""``,
             in which case the nominal sweep is used.
         domain : str, dict, optional
             Context type (sweep or time). The default is ``"Infinite Sphere1"``.
-        families_dict : dict, optional
+        sweeps : dict, optional
             Dictionary of variables and values. The default is ``{"Freq": ["All"]}``.
 
         Returns
         -------
         :class:`pyaedt.modules.solutions.SolutionData`
 
         References
         ----------
 
         >>> oModule.GetSolutionDataPerVariation
         """
-        if type(expression) is not list:
-            expression = [expression]
+        if not isinstance(expressions, list):
+            expressions = [expressions]
         if not setup_sweep_name:
             setup_sweep_name = self._app.nominal_adaptive
-        if families_dict is None:
-            families_dict = {"Theta": ["All"], "Phi": ["All"], "Freq": ["All"]}
+        if sweeps is None:
+            sweeps = {"Theta": ["All"], "Phi": ["All"], "Freq": ["All"]}
         context = ["Context:=", domain]
         if isinstance(domain, dict):
             if "Context" in domain.keys() and "SourceContext" in domain.keys():
                 context = ["Context:=", domain["Context"], "Context:=", domain["SourceContext"]]
 
         solution_data = self.get_solution_data_per_variation(
-            "Far Fields", setup_sweep_name, context, families_dict, expression
+            "Far Fields", setup_sweep_name, context, sweeps, expressions
         )
         if not solution_data:
             print("No Data Available. Check inputs")
             return False
         return solution_data
 
-    @pyaedt_function_handler()
-    def export_model_obj(self, obj_list=None, export_path=None, export_as_single_objects=False, air_objects=False):
+    @pyaedt_function_handler(obj_list="assignment")
+    def export_model_obj(self, assignment=None, export_path=None, export_as_single_objects=False, air_objects=False):
         """Export the model.
 
         Parameters
         ----------
-        obj_list : list, optional
-            List of objects to export. Export every model object except 3D ones, vacuum and air objects.
+        assignment : list, optional
+            List of objects to export. Export every model object except 3D ones and
+            vacuum and air objects.
         export_path : str, optional
-            Full path of the exported obj file.
+            Full path of the exported OBJ file.
         export_as_single_objects : bool, optional
-            Define if the model will be exported as single obj or list of objs for each object.
+           Whether to export the model as single object. The default is ``False``, in which
+           case is exported asa list of objects for each object.
         air_objects : bool, optional
-            Define if air and vacuum objects will be exported.
+            Whether to export air and vacuum objects. The default is ``False``.
 
         Returns
         -------
         list
-            Files obj path.
+            List of paths for OBJ files.
         """
-        if obj_list and not isinstance(obj_list, (list, tuple)):
-            obj_list = [obj_list]
+        if assignment and not isinstance(assignment, (list, tuple)):
+            assignment = [assignment]
         assert self._app._aedt_version >= "2021.2", self.logger.error("Object is supported from AEDT 2021 R2.")
         if not export_path:
             export_path = self._app.working_directory
-        if not obj_list:
+        if not assignment:
             self._app.modeler.refresh_all_ids()
             non_model = self._app.modeler.non_model_objects[:]
-            obj_list = [i for i in self._app.modeler.object_names if i not in non_model]
+            assignment = [i for i in self._app.modeler.object_names if i not in non_model]
             if not air_objects:
-                obj_list = [
+                assignment = [
                     i
-                    for i in obj_list
+                    for i in assignment
                     if not self._app.modeler[i].is3d
                     or (
                         self._app.modeler[i].material_name.lower() != "vacuum"
                         and self._app.modeler[i].material_name.lower() != "air"
                     )
                 ]
         if export_as_single_objects:
             files_exported = []
-            for el in obj_list:
+            for el in assignment:
                 fname = os.path.join(export_path, "{}.obj".format(el))
                 self._app.modeler.oeditor.ExportModelMeshToFile(fname, [el])
-                if settings.remote_rpc_session_temp_folder:
-                    local_path = "{}/{}".format(settings.remote_rpc_session_temp_folder, "{}.obj".format(el))
-                    fname = check_and_download_file(local_path, fname)
+
+                fname = check_and_download_file(fname)
 
                 if not self._app.modeler[el].display_wireframe:
                     transp = 0.6
                     t = self._app.modeler[el].transparency
                     if t is not None:
                         transp = t
                     files_exported.append([fname, self._app.modeler[el].color, 1 - transp])
                 else:
                     files_exported.append([fname, self._app.modeler[el].color, 0.05])
             return files_exported
         else:
             fname = os.path.join(export_path, "Model_AllObjs_AllMats.obj")
-            self._app.modeler.oeditor.ExportModelMeshToFile(fname, obj_list)
+            self._app.modeler.oeditor.ExportModelMeshToFile(fname, assignment)
             return [[fname, "aquamarine", 0.3]]
 
-    @pyaedt_function_handler()
-    def export_mesh_obj(self, setup_name=None, intrinsic_dict=None):
-        """Export the mesh in ``aedtplt`` format.
+    @pyaedt_function_handler(setup_name="setup")
+    def export_mesh_obj(self, setup=None, intrinsics=None):
+        """Export the mesh in AEDTPLT format.
         The mesh has to be available in the selected setup.
-        If a parametric model is provided user can choose the mesh to export providing a specific set of variations.
+        If a parametric model is provided, you can choose the mesh to export by providing a specific set of variations.
         This method applies only to ``Hfss``, ``Q3d``, ``Q2D``, ``Maxwell3d``, ``Maxwell2d``, ``Icepak``
         and ``Mechanical`` objects. This method is calling ``create_fieldplot_surface`` to create a mesh plot and
         ``export_field_plot`` to export it as ``aedtplt`` file.
 
         Parameters
         ----------
-        setup_name : str, optional
-            Name of the setup. The default is ``None`` which automatically take ``nominal_adaptive`` setup.
-            Please make sure to build a setup string in the form of ``"SetupName : SetupSweep"``
-            where ``SetupSweep`` is the Sweep name to use in the export or ``LastAdaptive``.
-        intrinsic_dict : dict, optional.
+        setup : str, optional
+            Name of the setup. The default is ``None``, in which case the ``nominal_adaptive``
+            setup is used. Be sure to build a setup string in the form of
+            ``"SetupName : SetupSweep"``, where ``SetupSweep`` is the sweep name to
+            use in the export or ``LastAdaptive``.
+        intrinsics : dict, optional.
             Intrinsic dictionary that is needed for the export.
-            The default is ``{}`` which assumes no variables are present in the dict or nominal values are used.
+            The default is ``None``, which assumes that no variables are present in
+            the dictionary or nominal values are used.
 
         Returns
         -------
         str
             File Generated with full path.
 
         Examples
         --------
         >>> from pyaedt import Hfss
         >>> hfss = Hfss()
         >>> hfss.analyze()
         >>> # Export report using defaults.
-        >>> hfss.post.export_mesh_obj(setup_name=None, intrinsic_dict=None)
+        >>> hfss.post.export_mesh_obj(setup=None,intrinsics=None)
         >>> # Export report using arguments.
-        >>> hfss.post.export_mesh_obj(setup_name="MySetup : LastAdaptive", intrinsic_dict={"w1":"5mm", "l1":"3mm"})
+        >>> hfss.post.export_mesh_obj(setup="MySetup : LastAdaptive",intrinsics={"w1":"5mm", "l1":"3mm"})
         """
-        if intrinsic_dict is None:
-            intrinsic_dict = {}
+        if intrinsics is None:
+            intrinsics = {}
         project_path = self._app.working_directory
 
-        if not setup_name:
-            setup_name = self._app.nominal_adaptive
+        if not setup:
+            setup = self._app.nominal_adaptive
         face_lists = []
         obj_list = self._app.modeler.object_names
         for el in obj_list:
             object3d = self._app.modeler[el]
             if not object3d.is3d or object3d.material_name not in ["vacuum", "air"]:
                 face_lists += [i.id for i in object3d.faces]
-        plot = self.create_fieldplot_surface(face_lists, "Mesh", setup_name, intrinsic_dict)
+        plot = self.create_fieldplot_surface(face_lists, "Mesh", setup, intrinsics)
         if plot:
             file_to_add = self.export_field_plot(plot.name, project_path)
             plot.delete()
             return file_to_add
         return None
 
     @pyaedt_function_handler()
@@ -4232,14 +4297,15 @@
                 self.logger.info("The power of {} is {} {}".format(comp, str(round(power_dict[comp], 3)), units))
             self.logger.info("The total power is {} {}".format(str(round(sum(power_dict.values()), 3)), units))
             for comp in power_dict_obj.keys():
                 self.logger.info("The power of {} is {} {}".format(comp, str(round(power_dict_obj[comp], 3)), units))
             self.logger.info("The total power is {} {}".format(str(round(sum(power_dict_obj.values()), 3)), units))
             return power_dict_obj, sum(power_dict_obj.values()), power_dict, sum(power_dict.values())
 
+    @pyaedt_function_handler()
     def create_creeping_plane_visual_ray_tracing(
         self,
         max_frequency="1GHz",
         ray_density=1,
         sample_density=10,
         ray_cutoff=40,
         irregular_surface_tolerance=50,
@@ -4281,14 +4347,15 @@
         vrt.is_plane_wave = True
         vrt.incident_theta = incident_theta
         vrt.incident_phi = incident_phi
         vrt.vertical_polarization = is_vertical_polarization
         vrt.create()
         return vrt
 
+    @pyaedt_function_handler()
     def create_creeping_point_visual_ray_tracing(
         self,
         max_frequency="1GHz",
         ray_density=1,
         sample_density=10,
         ray_cutoff=40,
         irregular_surface_tolerance=50,
@@ -4313,28 +4380,26 @@
 
         Returns
         -------
         :class:` pyaedt.modules.solutions.VRTFieldPlot`
         """
         if custom_location is None:
             custom_location = [0, 0, 0]
-        vrt = VRTFieldPlot(
-            self,
-            is_creeping_wave=True,
-        )
+        vrt = VRTFieldPlot(self, is_creeping_wave=True)
         vrt.max_frequency = max_frequency
         vrt.sample_density = sample_density
         vrt.ray_density = ray_density
         vrt.ray_cutoff = ray_cutoff
         vrt.irregular_surface_tolerance = irregular_surface_tolerance
         vrt.is_plane_wave = False
         vrt.custom_location = custom_location
         vrt.create()
         return vrt
 
+    @pyaedt_function_handler()
     def create_sbr_plane_visual_ray_tracing(
         self,
         max_frequency="1GHz",
         ray_density=2,
         number_of_bounces=5,
         multi_bounce=False,
         mbrd_max_sub_division=2,
@@ -4400,14 +4465,15 @@
         vrt.start_index = ray_index_start
         vrt.stop_index = ray_index_stop
         vrt.step_index = ray_index_step
         vrt.ray_box = ray_box
         vrt.create()
         return vrt
 
+    @pyaedt_function_handler()
     def create_sbr_point_visual_ray_tracing(
         self,
         max_frequency="1GHz",
         ray_density=2,
         number_of_bounces=5,
         multi_bounce=False,
         mbrd_max_sub_division=2,
@@ -4487,30 +4553,31 @@
         `_modeler`, `_desktop`, `_odesign`, and `logger`.
 
     """
 
     def __init__(self, app):
         PostProcessorCommon.__init__(self, app)
 
+    @pyaedt_function_handler(setupname="setup", plotname="plot_name")
     def create_ami_initial_response_plot(
         self,
-        setupname,
+        setup,
         ami_name,
         variation_list_w_value,
         plot_type="Rectangular Plot",
         plot_initial_response=True,
         plot_intermediate_response=False,
         plot_final_response=False,
-        plotname=None,
+        plot_name=None,
     ):
         """Create an AMI initial response plot.
 
         Parameters
         ----------
-        setupname : str
+        setup : str
             Name of the setup.
         ami_name : str
             AMI probe name to use.
         variation_list_w_value : list
             List of variations with relative values.
         plot_type : str
             String containing the report type. Default is ``"Rectangular Plot"``. It can be ``"Data Table"``,
@@ -4518,24 +4585,25 @@
             The default is ``"Rectangular Plot"``.
         plot_initial_response : bool, optional
             Set either to plot the initial input response.  Default is ``True``.
         plot_intermediate_response : bool, optional
             Set whether to plot the intermediate input response.  Default is ``False``.
         plot_final_response : bool, optional
             Set whether to plot the final input response.  Default is ``False``.
-        plotname : str, optional
-            The plot name.  Default is a unique name.
+        plot_name : str, optional
+            Plot name.  The default is ``None``, in which case
+            a unique name is automatically assigned.
 
         Returns
         -------
         str
             Name of the plot.
         """
-        if not plotname:
-            plotname = generate_unique_name("AMIAnalysis")
+        if not plot_name:
+            plot_name = generate_unique_name("AMIAnalysis")
         variations = ["__InitialTime:=", ["All"]]
         i = 0
         for a in variation_list_w_value:
             if (i % 2) == 0:
                 if ":=" in a:
                     variations.append(a)
                 else:
@@ -4550,18 +4618,18 @@
         if plot_initial_response:
             ycomponents.append("InitialImpulseResponse<{}.int_ami_rx>".format(ami_name))
         if plot_intermediate_response:
             ycomponents.append("IntermediateImpulseResponse<{}.int_ami_rx>".format(ami_name))
         if plot_final_response:
             ycomponents.append("FinalImpulseResponse<{}.int_ami_rx>".format(ami_name))
         self.oreportsetup.CreateReport(
-            plotname,
+            plot_name,
             "Standard",
             plot_type,
-            setupname,
+            setup,
             [
                 "NAME:Context",
                 "SimValueContext:=",
                 [
                     55824,
                     0,
                     2,
@@ -4592,47 +4660,50 @@
                     False,
                     "0",
                 ],
             ],
             variations,
             ["X Component:=", "__InitialTime", "Y Component:=", ycomponents],
         )
-        return plotname
+        return plot_name
 
+    @pyaedt_function_handler(setupname="setup", plotname="plot_name")
     def create_ami_statistical_eye_plot(
-        self, setupname, ami_name, variation_list_w_value, ami_plot_type="InitialEye", plotname=None
+        self, setup, ami_name, variation_list_w_value, ami_plot_type="InitialEye", plot_name=None
     ):
         """Create an AMI statistical eye plot.
 
         Parameters
         ----------
-        setupname : str
+        setup : str
             Name of the setup.
         ami_name : str
             AMI probe name to use.
         variation_list_w_value : list
             Variations with relative values.
         ami_plot_type : str, optional
-            String containing the report AMI type. Default is ``"InitialEye"``. It can be ``"EyeAfterSource"``,
-            ``"EyeAfterChannel"`` or ``"EyeAfterProbe"``.
-        plotname : str, optional
-            The name of the plot.  Defaults to a unique name starting with ``"Plot"``.
+            String containing the report AMI type. The default is ``"InitialEye"``.
+            Options are ``"EyeAfterChannel"``, ``"EyeAfterProbe"````"EyeAfterSource"``,
+            and ``"InitialEye"``..
+        plot_name : str, optional
+            Plot name.  The default is ``None``, in which case
+            a unique name starting with ``"Plot"`` is automatically assigned.
 
         Returns
         -------
         str
            The name of the plot.
 
         References
         ----------
 
         >>> oModule.CreateReport
         """
-        if not plotname:
-            plotname = generate_unique_name("AMYAanalysis")
+        if not plot_name:
+            plot_name = generate_unique_name("AMYAanalysis")
         variations = [
             "__UnitInterval:=",
             ["All"],
             "__Amplitude:=",
             ["All"],
         ]
         i = 0
@@ -4659,18 +4730,18 @@
         if ami_plot_type == "EyeAfterSource":
             ami_id = "1"
         elif ami_plot_type == "EyeAfterChannel":
             ami_id = "2"
         elif ami_plot_type == "EyeAfterProbe":
             ami_id = "3"
         self.oreportsetup.CreateReport(
-            plotname,
+            plot_name,
             "Statistical Eye",
             "Statistical Eye Plot",
-            setupname,
+            setup,
             [
                 "NAME:Context",
                 "SimValueContext:=",
                 [
                     55819,
                     0,
                     2,
@@ -4698,42 +4769,43 @@
                     False,
                     "0",
                 ],
             ],
             variations,
             ["X Component:=", "__UnitInterval", "Y Component:=", "__Amplitude", "Eye Diagram Component:=", ycomponents],
         )
-        return plotname
+        return plot_name
 
-    def create_statistical_eye_plot(self, setupname, probe_names, variation_list_w_value, plotname=None):
+    @pyaedt_function_handler(setupname="setup", plotname="plot_name")
+    def create_statistical_eye_plot(self, setup, probe_names, variation_list_w_value, plot_name=None):
         """Create a statistical QuickEye, VerifEye, and/or Statistical Eye plot.
 
         Parameters
         ----------
-        setupname : str
+        setup : str
             Name of the setup.
         probe_names : str or list
-            Name of the probe to plot in the EYE diagram.
+            One or more names of the probes to plot in the eye diagram.
         variation_list_w_value : list
             List of variations with relative values.
-        plotname : str, optional
-            The name of the plot.
+        plot_name : str, optional
+            Plot name. The default is ``None``, in which case a name is automatically assigned.
 
         Returns
         -------
         str
             The name of the plot.
 
         References
         ----------
 
         >>> oModule.CreateReport
         """
-        if not plotname:
-            plotname = generate_unique_name("AMIAanalysis")
+        if not plot_name:
+            plot_name = generate_unique_name("AMIAanalysis")
         variations = [
             "__UnitInterval:=",
             ["All"],
             "__Amplitude:=",
             ["All"],
         ]
         i = 0
@@ -4751,18 +4823,18 @@
             i += 1
         if isinstance(probe_names, list):
             ycomponents = probe_names
         else:
             ycomponents = [probe_names]
 
         self.oreportsetup.CreateReport(
-            plotname,
+            plot_name,
             "Statistical Eye",
             "Statistical Eye Plot",
-            setupname,
+            setup,
             [
                 "NAME:Context",
                 "SimValueContext:=",
                 [
                     55819,
                     0,
                     2,
@@ -4790,16 +4862,17 @@
                     False,
                     "0",
                 ],
             ],
             variations,
             ["X Component:=", "__UnitInterval", "Y Component:=", "__Amplitude", "Eye Diagram Component:=", ycomponents],
         )
-        return plotname
+        return plot_name
 
+    @pyaedt_function_handler()
     def sample_waveform(
         self,
         waveform_data,
         waveform_sweep,
         waveform_unit="V",
         waveform_sweep_unit="s",
         unit_interval=1e-9,
@@ -4829,16 +4902,17 @@
         Returns
         -------
         list or :class:`pandas.Series`
             Sampled waveform in ``Volts`` at different times in ``seconds``.
 
         Examples
         --------
-        >>> aedtapp = Circuit()
-        >>> aedtapp.post.sample_ami_waveform(setup_name, probe_name, source_name, aedtapp.available_variations.nominal)
+        >>> from pyaedt import Circuit
+        >>> circuit = Circuit()
+        >>> circuit.post.sample_ami_waveform(setup_name,probe_name,source_name,circuit.available_variations.nominal)
 
         """
 
         new_tic = []
         for tic in clock_tics:
             new_tic.append(unit_converter(tic, unit_system="Time", input_units="s", output_units=waveform_sweep_unit))
         new_ui = unit_converter(unit_interval, unit_system="Time", input_units="s", output_units=waveform_sweep_unit)
@@ -4879,34 +4953,35 @@
                     del sweep_filtered[0]
                 else:
                     break
         if pandas_enabled:
             return pd.Series(new_voltage, index=tic_in_s)
         return outputdata
 
+    @pyaedt_function_handler(setupname="setup", probe_name="probe", source_name="source")
     def sample_ami_waveform(
         self,
-        setupname,
-        probe_name,
-        source_name,
+        setup,
+        probe,
+        source,
         variation_list_w_value,
         unit_interval=1e-9,
         ignore_bits=0,
         plot_type=None,
         clock_tics=None,
     ):
         """Sampling a waveform at clock times plus half unit interval.
 
         Parameters
         ----------
-        setupname : str
+        setup : str
             Name of the setup.
-        probe_name : str
+        probe : str
             Name of the AMI probe.
-        source_name : str
+        source : str
             Name of the AMI source.
         variation_list_w_value : list
             Variations with relative values.
         unit_interval : float, optional
             Unit interval in seconds. The default is ``1e-9``.
         ignore_bits : int, optional
             Number of initial bits to ignore. The default is ``0``.
@@ -4921,39 +4996,39 @@
         Returns
         -------
         list
             Sampled waveform in ``Volts`` at different times in ``seconds``.
 
         Examples
         --------
-        >>> aedtapp = Circuit()
-        >>> aedtapp.post.sample_ami_waveform(setupname, probe_name, source_name, aedtapp.available_variations.nominal)
+        >>> circuit = Circuit()
+        >>> circuit.post.sample_ami_waveform(setupname,probe_name,source_name,circuit.available_variations.nominal)
 
         """
         initial_solution_type = self.post_solution_type
         self._app.solution_type = "NexximAMI"
 
         if plot_type == "InitialWave" or plot_type == "WaveAfterSource":
-            plot_expression = [plot_type + "<" + source_name + ".int_ami_tx>"]
+            plot_expression = [plot_type + "<" + source + ".int_ami_tx>"]
         elif plot_type == "WaveAfterChannel" or plot_type == "WaveAfterProbe":
-            plot_expression = [plot_type + "<" + probe_name + ".int_ami_rx>"]
+            plot_expression = [plot_type + "<" + probe + ".int_ami_rx>"]
         else:
             plot_expression = [
-                "InitialWave<" + source_name + ".int_ami_tx>",
-                "WaveAfterSource<" + source_name + ".int_ami_tx>",
-                "WaveAfterChannel<" + probe_name + ".int_ami_rx>",
-                "WaveAfterProbe<" + probe_name + ".int_ami_rx>",
+                "InitialWave<" + source + ".int_ami_tx>",
+                "WaveAfterSource<" + source + ".int_ami_tx>",
+                "WaveAfterChannel<" + probe + ".int_ami_rx>",
+                "WaveAfterProbe<" + probe + ".int_ami_rx>",
             ]
         waveform = []
         waveform_sweep = []
         waveform_unit = []
         waveform_sweep_unit = []
         for exp in plot_expression:
             waveform_data = self.get_solution_data(
-                expressions=exp, setup_sweep_name=setupname, domain="Time", variations=variation_list_w_value
+                expressions=exp, setup_sweep_name=setup, domain="Time", variations=variation_list_w_value
             )
             samples_per_bit = 0
             for sample in waveform_data.primary_sweep_values:
                 sample_seconds = unit_converter(
                     sample, unit_system="Time", input_units=waveform_data.units_sweeps["Time"], output_units="s"
                 )
                 if sample_seconds > unit_interval:
@@ -4968,18 +5043,18 @@
             waveform.append(waveform_data.data_real()[samples_per_bit * ignore_bits :])
             waveform_sweep.append(waveform_data.primary_sweep_values[samples_per_bit * ignore_bits :])
             waveform_unit.append(waveform_data.units_data[exp])
             waveform_sweep_unit.append(waveform_data.units_sweeps["Time"])
 
         tics = clock_tics
         if not clock_tics:
-            clock_expression = "ClockTics<" + probe_name + ".int_ami_rx>"
+            clock_expression = "ClockTics<" + probe + ".int_ami_rx>"
             clock_tic = self.get_solution_data(
                 expressions=clock_expression,
-                setup_sweep_name=setupname,
+                setup_sweep_name=setup,
                 domain="Clock Times",
                 variations=variation_list_w_value,
             )
             tics = clock_tic.data_real()
 
         outputdata = [[] for i in range(len(waveform))]
         for w in range(0, len(waveform)):
@@ -5022,15 +5097,15 @@
     "SurfUy",
     "SurfUz",
     "Pressure",
     "SurfPressure",
     "MassFlowRate",
     "VolumeFlowRate",
     "MassFlux",
-    "ViscocityRatio",
+    "ViscosityRatio",
     "WallYPlus",
     "TKE",
     "Epsilon",
     "Kx",
     "Ky",
     "Kz",
     "SurfElectricPotential",
@@ -5115,98 +5190,102 @@
         if isinstance(geometry_name, str):
             geometry_name = [geometry_name]
         self.calculations.append(
             [entity, geometry, ",".join(geometry_name), quantity, normal, side, mesh, ref_temperature, False]
         )  # TODO : last argument not documented
         return True
 
-    @pyaedt_function_handler()
-    def get_field_summary_data(self, setup_name=None, design_variation={}, intrinsic_value="", pandas_output=False):
+    @pyaedt_function_handler(IntrinsincDict="intrinsics", setup_name="setup", design_variation="variation")
+    def get_field_summary_data(self, setup=None, variation=None, intrinsics="", pandas_output=False):
         """
         Get  field summary output computation.
 
         Parameters
         ----------
-        setup_name : str, optional
+        setup : str, optional
             Setup name to use for the computation. The
             default is ``None``, in which case the nominal variation is used.
-        design_variation : dict, optional
+        variation : dict, optional
             Dictionary containing the design variation to use for the computation.
             The default is  ``{}``, in which case nominal variation is used.
-        intrinsic_value : str, optional
+        intrinsics : str, optional
             Intrinsic values to use for the computation. The default is ``""``,
-            suitable when no frequency needs to be selected.
+            which is suitable when no frequency needs to be selected.
         pandas_output : bool, optional
             Whether to use pandas output. The default is ``False``, in
             which case the dictionary output is used.
 
         Returns
         -------
         dict or pandas.DataFrame
             Output type depending on the Boolean ``pandas_output`` parameter.
             The output consists of information exported from the field summary.
         """
+        if variation is None:
+            variation = {}
         with tempfile.NamedTemporaryFile(mode="w+", delete=False) as temp_file:
             temp_file.close()
-            self.export_csv(temp_file.name, setup_name, design_variation, intrinsic_value)
-            with open(temp_file.name, "r") as f:
+            self.export_csv(temp_file.name, setup, variation, intrinsics)
+            with open_file(temp_file.name, "r") as f:
                 for _ in range(4):
                     _ = next(f)
                 reader = csv.DictReader(f)
                 out_dict = defaultdict(list)
                 for row in reader:
                     for key in row.keys():
                         out_dict[key].append(row[key])
             os.remove(temp_file.name)
             if pandas_output:
                 if pd is None:
                     raise ImportError("pandas package is needed.")
                 return pd.DataFrame.from_dict(out_dict)
         return out_dict
 
-    @pyaedt_function_handler()
-    def export_csv(self, filename, setup_name=None, design_variation={}, intrinsic_value=""):
+    @pyaedt_function_handler(filename="output_file", design_variation="variations", setup_name="setup")
+    def export_csv(self, output_file, setup=None, variations=None, intrinsics=""):
         """
         Get the field summary output computation.
 
         Parameters
         ----------
-        filename : str
+        output_file : str
             Path and filename to write the output file to.
-        setup_name : str, optional
+        setup : str, optional
             Setup name to use for the computation. The
             default is ``None``, in which case the nominal variation is used.
-        design_variation : dict, optional
+        variations : dict, optional
             Dictionary containing the design variation to use for the computation.
             The default is  ``{}``, in which case the nominal variation is used.
-        intrinsic_value : str, optional
+        intrinsics : str, optional
             Intrinsic values to use for the computation. The default is ``""``,
-            suitable when no frequency needs to be selected.
+            which is suitable when no frequency needs to be selected.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
         """
-        if not setup_name:
-            setup_name = self._app.nominal_sweep
+        if variations is None:
+            variations = {}
+        if not setup:
+            setup = self._app.nominal_sweep
         dv_string = ""
-        for el in design_variation:
-            dv_string += el + "='" + design_variation[el] + "' "
-        self._create_field_summary(setup_name, dv_string)
+        for el in variations:
+            dv_string += el + "='" + variations[el] + "' "
+        self._create_field_summary(setup, dv_string)
         self._app.osolution.ExportFieldsSummary(
             [
                 "SolutionName:=",
-                setup_name,
+                setup,
                 "DesignVariationKey:=",
                 dv_string,
                 "ExportFileName:=",
-                filename,
+                output_file,
                 "IntrinsicValue:=",
-                intrinsic_value,
+                intrinsics,
             ]
         )
         return True
 
     @pyaedt_function_handler()
     def _create_field_summary(self, setup, variation):
         arg = ["SolutionName:=", setup, "Variation:=", variation]
```

### Comparing `pyaedt-0.8.7/pyaedt/modules/SetupTemplates.py` & `pyaedt-0.8.8/pyaedt/modules/SetupTemplates.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/modules/SolveSetup.py` & `pyaedt-0.8.8/pyaedt/modules/SolveSetup.py`

 * *Files 6% similar despite different names*

```diff
@@ -27,30 +27,30 @@
 from pyaedt.modules.SolveSweeps import SweepHFSS
 from pyaedt.modules.SolveSweeps import SweepHFSS3DLayout
 from pyaedt.modules.SolveSweeps import SweepMatrix
 from pyaedt.modules.SolveSweeps import identify_setup
 
 
 class CommonSetup(PropsManager, object):
-    def __init__(self, app, solutiontype, setupname="MySetupAuto", isnewsetup=True):
+    def __init__(self, app, solution_type, name="MySetupAuto", is_new_setup=True):
         self.auto_update = False
         self._app = None
         self.p_app = app
-        if solutiontype is None:
+        if solution_type is None:
             self.setuptype = self.p_app.design_solutions.default_setup
-        elif isinstance(solutiontype, int):
-            self.setuptype = solutiontype
-        elif solutiontype in SetupKeys.SetupNames:
-            self.setuptype = SetupKeys.SetupNames.index(solutiontype)
+        elif isinstance(solution_type, int):
+            self.setuptype = solution_type
+        elif solution_type in SetupKeys.SetupNames:
+            self.setuptype = SetupKeys.SetupNames.index(solution_type)
         else:
-            self.setuptype = self.p_app.design_solutions._solution_options[solutiontype]["default_setup"]
-        self._setupname = setupname
+            self.setuptype = self.p_app.design_solutions._solution_options[solution_type]["default_setup"]
+        self._name = name
         self.props = {}
         self.sweeps = []
-        self._init_props(isnewsetup)
+        self._init_props(is_new_setup)
         self.auto_update = True
 
     @property
     def default_intrinsics(self):
         """Retrieve default intrinsic for actual setup.
 
         Returns
@@ -134,16 +134,16 @@
             machine=machine,
             run_in_thread=run_in_thread,
             revert_to_initial_mesh=revert_to_initial_mesh,
             blocking=blocking,
         )
 
     @pyaedt_function_handler()
-    def _init_props(self, isnewsetup=False):
-        if isnewsetup:
+    def _init_props(self, is_new_setup=False):
+        if is_new_setup:
             setup_template = SetupKeys.get_setup_templates()[self.setuptype]
             self.props = SetupProps(self, setup_template)
         else:
             try:
                 setups_data = self.p_app.design_properties["AnalysisSetup"]["SolveSetups"]
                 if self.name in setups_data:
                     setup_data = setups_data[self.name]
@@ -173,30 +173,30 @@
     @property
     def is_solved(self):
         """Verify if solutions are available for given setup.
 
         Returns
         -------
         bool
-            `True` if solutions are available.
+            ``True`` if solutions are available, ``False`` otherwise.
         """
         if self.p_app.design_solutions.default_adaptive:
             expressions = [
                 i
                 for i in self.p_app.post.available_report_quantities(
                     solution="{} : {}".format(self.name, self.p_app.design_solutions.default_adaptive)
                 )
             ]
             sol = self.p_app.post.reports_by_category.standard(
-                setup_name="{} : {}".format(self.name, self.p_app.design_solutions.default_adaptive),
                 expressions=expressions[0],
+                setup="{} : {}".format(self.name, self.p_app.design_solutions.default_adaptive),
             )
         else:
             expressions = [i for i in self.p_app.post.available_report_quantities(solution=self.name)]
-            sol = self.p_app.post.reports_by_category.standard(setup_name=self.name, expressions=expressions[0])
+            sol = self.p_app.post.reports_by_category.standard(expressions=expressions[0], setup=self.name)
         if identify_setup(self.props):
             sol.domain = "Time"
         return True if sol.get_solution_data() else False
 
     @property
     def p_app(self):
         """Parent."""
@@ -210,33 +210,33 @@
     def omodule(self):
         """Analysis module."""
         return self._app.oanalysis
 
     @property
     def name(self):
         """Name."""
-        return self._setupname
+        return self._name
 
     @name.setter
     def name(self, name):
-        self._setupname = name
+        self._name = name
         self.props["Name"] = name
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(sweep_name="sweep")
     def get_solution_data(
         self,
         expressions=None,
         domain=None,
         variations=None,
         primary_sweep_variable=None,
         report_category=None,
         context=None,
         polyline_points=1001,
         math_formula=None,
-        sweep_name=None,
+        sweep=None,
     ):
         """Get a simulation result from a solved setup and cast it in a ``SolutionData`` object.
         Data to be retrieved from Electronics Desktop are any simulation results available in that
         specific simulation context.
         Most of the argument have some defaults which works for most of the ``Standard`` report quantities.
 
         Parameters
@@ -271,16 +271,16 @@
             2. Infinite Sphere name for Far Fields Plot.
             3. Dictionary. If dictionary is passed, key is the report property name and value is property value.
         polyline_points : int, optional
             Number of points on which to create the report for plots on polylines.
             This parameter is valid for ``Fields`` plot only.
         math_formula : str, optional
             One of the available AEDT mathematical formulas to apply. For example, ``abs, dB``.
-        sweep_name : str, optional
-            Name of the sweep adaptive setup from which get solutions. Default is ``LastAdaptive``.
+        sweep : str, optional
+            Name of the sweep adaptive setup to get solutions from. the default is ``LastAdaptive``.
 
         Returns
         -------
         :class:`pyaedt.modules.solutions.SolutionData`
             Solution Data object.
 
         References
@@ -294,83 +294,69 @@
         >>> aedtapp = Hfss()
         >>> aedtapp.post.create_report("dB(S(1,1))")
 
         >>> variations = aedtapp.available_variations.nominal_w_values_dict
         >>> variations["Theta"] = ["All"]
         >>> variations["Phi"] = ["All"]
         >>> variations["Freq"] = ["30GHz"]
-        >>> data1 = aedtapp.post.get_solution_data(
-        ...    "GainTotal",
-        ...    aedtapp.nominal_adaptive,
-        ...    variations=variations,
-        ...    primary_sweep_variable="Phi",
-        ...    secondary_sweep_variable="Theta",
-        ...    context="3D",
-        ...    report_category="Far Fields",
-        ...)
-
-        >>> data2 =aedtapp.post.get_solution_data(
-        ...    "S(1,1)",
-        ...    aedtapp.nominal_sweep,
-        ...    variations=variations,
-        ...)
+        >>> data1 = aedtapp.post.get_solution_data("GainTotal", aedtapp.nominal_adaptive,
+        ...                                        variations=variations, primary_sweep_variable="Phi",
+        ...                                        report_category="Far Fields", context="3D")
+
+        >>> data2 =aedtapp.post.get_solution_data("S(1,1)",aedtapp.nominal_sweep,variations=variations)
         >>> data2.plot()
 
         >>> from pyaedt import Maxwell2d
         >>> maxwell_2d = Maxwell2d()
-        >>> data3 = maxwell_2d.post.get_solution_data(
-        ...     "InputCurrent(PHA)", domain="Time", primary_sweep_variable="Time",
-        ... )
+        >>> data3 = maxwell_2d.post.get_solution_data("InputCurrent(PHA)",domain="Time",primary_sweep_variable="Time")
         >>> data3.plot("InputCurrent(PHA)")
 
         >>> from pyaedt import Circuit
         >>> circuit = Circuit()
         >>> context = {"algorithm": "FFT", "max_frequency": "100MHz", "time_stop": "2.5us", "time_start": "0ps"}
-        >>> spectralPlotData = circuit.post.get_solution_data(
-        ...     expressions="V(Vprobe1)", primary_sweep_variable="Spectrum", domain="Spectral",
-        ...     context=context
-        ...)
+        >>> spectralPlotData = circuit.post.get_solution_data(expressions="V(Vprobe1)", domain="Spectral",
+        ...                                                   primary_sweep_variable="Spectrum", context=context)
         """
-        if sweep_name:
+        if sweep:
             setup_sweep_name = [
-                i for i in self._app.existing_analysis_sweeps if self.name == i.split(" : ")[0] and sweep_name in i
+                i for i in self._app.existing_analysis_sweeps if self.name == i.split(" : ")[0] and sweep in i
             ]
         else:
             setup_sweep_name = [i for i in self._app.existing_analysis_sweeps if self.name == i.split(" : ")[0]]
         if setup_sweep_name:
             return self._app.post.get_solution_data(
                 expressions=expressions,
                 domain=domain,
                 variations=variations,
                 primary_sweep_variable=primary_sweep_variable,
                 report_category=report_category,
                 context=context,
                 polyline_points=polyline_points,
                 math_formula=math_formula,
-                setup_sweep_name=setup_sweep_name[0],
+                setup_sweep_name=sweep,
             )
         return None
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(sweep_name="sweep", plotname="name")
     def create_report(
         self,
         expressions=None,
         domain="Sweep",
         variations=None,
         primary_sweep_variable=None,
         secondary_sweep_variable=None,
         report_category=None,
         plot_type="Rectangular Plot",
         context=None,
         subdesign_id=None,
         polyline_points=1001,
-        plotname=None,
-        sweep_name=None,
+        name=None,
+        sweep=None,
     ):
-        """Create a report in AEDT. It can be a 2D plot, 3D plot, polar plots or data tables.
+        """Create a report in AEDT. It can be a 2D plot, 3D plot, polar plot, or data table.
 
         Parameters
         ----------
         expressions : str or list, optional
             One or more formulas to add to the report. Example is value = ``"dB(S(1,1))"``.
         domain : str, optional
             Plot Domain. Options are "Sweep", "Time", "DCIR".
@@ -389,24 +375,25 @@
             If `None` default category will be used (the first item in the Results drop down menu in AEDT).
         plot_type : str, optional
             The format of Data Visualization. Default is ``Rectangular Plot``.
         context : str, optional
             The default is ``None``. It can be `None`, `"Differential Pairs"`,`"RL"`,
             `"Sources"`, `"Vias"`,`"Bondwires"`, `"Probes"` for Hfss3dLayout or
             Reduce Matrix Name for Q2d/Q3d solution or Infinite Sphere name for Far Fields Plot.
-        plotname : str, optional
+        name : str, optional
             Name of the plot. The default is ``None``.
         polyline_points : int, optional,
-            Number of points on which create the report for plots on polylines.
+            Number of points for creating the report for plots on polylines.
         subdesign_id : int, optional
-            Specify a subdesign ID to export a Touchstone file of this subdesign. Valid for Circuit Only.
+            Specify a subdesign ID to export a Touchstone file of this subdesign to.
+            This parameter is valid only for a circuit.
             The default value is ``None``.
         context : str, optional
-        sweep_name : str, optional
-            Name of the sweep adaptive setup from which get solutions. Default is ``LastAdaptive``.
+        sweep : str, optional
+            Name of the sweep adaptive setup to get solutions from. The default is ``LastAdaptive``.
 
         Returns
         -------
         :class:`pyaedt.modules.report_templates.Standard`
             ``True`` when successful, ``False`` when failed.
 
 
@@ -418,68 +405,58 @@
         Examples
         --------
         >>> from pyaedt import Circuit
         >>> aedtapp = Circuit()
         >>> aedtapp.post.create_report("dB(S(1,1))")
 
         >>> variations = aedtapp.available_variations.nominal_w_values_dict
-        >>> aedtapp.post.setups[0].create_report(
-        ...    "dB(S(1,1))",
-        ...    variations=variations,
-        ...    primary_sweep_variable="Freq",
-        ...)
-
-        >>> aedtapp.post.create_report(
-        ...    "S(1,1)",
-        ...    variations=variations,
-        ...    plot_type="Smith Chart",
-        ...)
+        >>> aedtapp.post.setups[0].create_report("dB(S(1,1))",variations=variations,primary_sweep_variable="Freq")
+
+        >>> aedtapp.post.create_report("S(1,1)",variations=variations,plot_type="Smith Chart")
         """
-        if sweep_name:
+        if sweep:
             setup_sweep_name = [
-                i for i in self._app.existing_analysis_sweeps if self.name == i.split(" : ")[0] and sweep_name in i
+                i for i in self._app.existing_analysis_sweeps if self.name == i.split(" : ")[0] and sweep in i
             ]
         else:
             setup_sweep_name = [i for i in self._app.existing_analysis_sweeps if self.name == i.split(" : ")[0]]
         if setup_sweep_name:
             return self._app.post.create_report(
                 expressions=expressions,
                 domain=domain,
                 variations=variations,
                 primary_sweep_variable=primary_sweep_variable,
                 secondary_sweep_variable=secondary_sweep_variable,
                 report_category=report_category,
                 plot_type=plot_type,
                 context=context,
                 polyline_points=polyline_points,
-                plotname=plotname,
-                setup_sweep_name=setup_sweep_name[0],
             )
         return None
 
 
 class Setup(CommonSetup):
     """Initializes, creates, and updates a 3D setup.
 
     Parameters
     ----------
-    app : :class:`pyaedt.application.Analysis3D.FieldAnalysis3D`
+    app : :class:`pyaedt.application.Analysis.Analysis`
         Inherited app object.
-    solutiontype : int, str
+    solution_type : int, str
         Type of the setup.
-    setupname : str, optional
+    name : str, optional
         Name of the setup. The default is ``"MySetupAuto"``.
-    isnewsetup : bool, optional
+    is_new_setup : bool, optional
         Whether to create the setup from a template. The default is ``True``.
         If ``False``, access is to the existing setup.
 
     """
 
-    def __init__(self, app, solutiontype, setupname="MySetupAuto", isnewsetup=True):
-        CommonSetup.__init__(self, app, solutiontype, setupname, isnewsetup)
+    def __init__(self, app, solution_type, name="MySetupAuto", is_new_setup=True):
+        CommonSetup.__init__(self, app, solution_type, name, is_new_setup)
 
     @pyaedt_function_handler()
     def create(self):
         """Add a new setup based on class settings in AEDT.
 
         Returns
         -------
@@ -598,15 +575,15 @@
                     report_type = report_type_list[i]
                 else:
                     report_type = report_type_list
                 if isinstance(isconvergence_list, list):
                     isconvergence = isconvergence_list[i]
                 else:
                     isconvergence = isconvergence_list
-                if type(intrinsics_list) is list:
+                if isinstance(intrinsics_list, list):
                     intrinsics = intrinsics_list[i]
                 else:
                     intrinsics = intrinsics_list
                 list_data.append(
                     [
                         "NAME:CacheItem",
                         "Title:=",
@@ -719,89 +696,91 @@
         expression_cache = self._expression_cache(
             expressions, report_type, intrinsics, isconvergence, isrelativeconvergence, conv_criteria
         )
         arg.append(expression_cache)
         self.omodule.EditSetup(self.name, arg)
         return True
 
-    @pyaedt_function_handler()
-    def enable(self, setup_name=None):
+    @pyaedt_function_handler(setup_name="name")
+    def enable(self, name=None):
         """Enable a setup.
 
         Parameters
         ----------
-        setup_name : str, optional
+        name : str, optional
             Name of the setup. The default is ``None``.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         References
         ----------
 
         >>> oModule.EditSetup
         """
-        if not setup_name:
-            setup_name = self.name
+        if not name:
+            name = self.name
 
-        self.omodule.EditSetup(setup_name, ["NAME:" + setup_name, "IsEnabled:=", True])
+        self.omodule.EditSetup(name, ["NAME:" + name, "IsEnabled:=", True])
         return True
 
-    @pyaedt_function_handler()
-    def disable(self, setup_name=None):
+    @pyaedt_function_handler(setup_name="name")
+    def disable(self, name=None):
         """Disable a setup.
 
         Parameters
         ----------
-        setup_name : str, optional
+        name : str, optional
             Name of the setup. The default is ``None``.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         References
         ----------
 
         >>> oModule.EditSetup
         """
-        if not setup_name:
-            setup_name = self.name
+        if not name:
+            name = self.name
 
-        self.omodule.EditSetup(setup_name, ["NAME:" + setup_name, "IsEnabled:", False])
+        self.omodule.EditSetup(name, ["NAME:" + name, "IsEnabled:", False])
         return True
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(
+        design_name="design", solution_name="solution", parameters_dict="parameters", project_name="project"
+    )
     def add_mesh_link(
         self,
-        design_name,
-        solution_name=None,
-        parameters_dict=None,
-        project_name="This Project*",
+        design,
+        solution=None,
+        parameters=None,
+        project="This Project*",
         force_source_to_solve=True,
         preserve_partner_solution=True,
         apply_mesh_operations=True,
         adapt_port=True,
     ):
         """Add a mesh link to another design.
 
         Parameters
         ----------
-        design_name : str
+        design : str
             Name of the design.
-        solution_name : str, optional
-            Name of the solution in the format ``"setupname : solutionname"``.
-            If ``None`` the default value is ``setupname : LastAdaptive``.
-        parameters_dict : dict, optional
+        solution : str, optional
+            Name of the solution in the format ``"setup_name : solution_name"``.
+            If ``None``, the default value is ``setup_name : LastAdaptive``.
+        parameters : dict, optional
             Dictionary of the parameters.
-            If ``None`` the default value is `appname.available_variations.nominal_w_values_dict`.
-        project_name : str, optional
+            If ``None``, the default is `appname.available_variations.nominal_w_values_dict`.
+        project : str, optional
             Name of the project with the design. The default is ``"This Project*"``.
             However, you can supply the full path and name to another project.
         force_source_to_solve : bool, optional
             Default value is ``True``.
         preserve_partner_solution : bool, optional
             Default value is ``True``.
         apply_mesh_operations : bool, optional
@@ -830,96 +809,97 @@
                 design_type = "ElectronicsDesktop"
             elif self.p_app.design_type == "Maxwell 2D" or self.p_app.design_type == "Maxwell 3D":
                 design_type = "Maxwell"
             else:
                 design_type = self.p_app.design_type
             meshlinks["Product"] = design_type
             # design name
-            if not design_name or design_name is None:
+            if not design or design is None:
                 raise ValueError("Provide design name to add mesh link to.")
-            elif design_name not in self.p_app.design_list:
+            elif design not in self.p_app.design_list:
                 raise ValueError("Design does not exist in current project.")
             else:
-                meshlinks["Design"] = design_name
+                meshlinks["Design"] = design
             # project name
-            if project_name != "This Project*":
-                if os.path.exists(project_name):
-                    meshlinks["Project"] = project_name
+            if project != "This Project*":
+                if os.path.exists(project):
+                    meshlinks["Project"] = project
                     meshlinks["PathRelativeTo"] = "SourceProduct"
                 else:
                     raise ValueError("Project file path provided does not exist.")
             else:
-                meshlinks["Project"] = project_name
+                meshlinks["Project"] = project
                 meshlinks["PathRelativeTo"] = "TargetProject"
             # if self.p_app.solution_type == "SBR+":
             meshlinks["ImportMesh"] = True
             # solution name
-            if solution_name is None:
+            if solution is None:
                 meshlinks["Soln"] = "{} : LastAdaptive".format(
-                    self.p_app.oproject.GetDesign(design_name).GetChildObject("Analysis").GetChildNames()[0]
+                    self.p_app.oproject.GetDesign(design).GetChildObject("Analysis").GetChildNames()[0]
                 )
             elif (
-                solution_name.split()[0]
-                in self.p_app.oproject.GetDesign(design_name).GetChildObject("Analysis").GetChildNames()
+                solution.split()[0] in self.p_app.oproject.GetDesign(design).GetChildObject("Analysis").GetChildNames()
             ):
-                meshlinks["Soln"] = "{} : LastAdaptive".format(solution_name.split()[0])
+                meshlinks["Soln"] = "{} : LastAdaptive".format(solution.split()[0])
             else:
                 raise ValueError("Setup does not exist in current design.")
             # parameters
             meshlinks["Params"] = OrderedDict({})
-            if parameters_dict is None:
-                parameters_dict = self.p_app.available_variations.nominal_w_values_dict
-                for el in parameters_dict:
+            if parameters is None:
+                parameters = self.p_app.available_variations.nominal_w_values_dict
+                for el in parameters:
                     meshlinks["Params"][el] = el
             else:
-                for el in parameters_dict:
+                for el in parameters:
                     if el in list(self._app.available_variations.nominal_w_values_dict.keys()):
                         meshlinks["Params"][el] = el
                     else:
-                        meshlinks["Params"][el] = parameters_dict[el]
+                        meshlinks["Params"][el] = parameters[el]
             meshlinks["ForceSourceToSolve"] = force_source_to_solve
             meshlinks["PreservePartnerSoln"] = preserve_partner_solution
             meshlinks["ApplyMeshOp"] = apply_mesh_operations
             if self.p_app.design_type != "Maxwell 2D" or self.p_app.design_type != "Maxwell 3D":
                 meshlinks["AdaptPort"] = adapt_port
             self.update()
             self.auto_update = auto_update
             return True
         except Exception:
             self.auto_update = auto_update
             return False
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(
+        design_name="design", solution_name="solution", parameters_dict="parameters", project_name="project"
+    )
     def start_continue_from_previous_setup(
         self,
-        design_name,
-        solution_name,
+        design,
+        solution,
         map_variables_by_name=True,
-        parameters_dict=None,
-        project_name="This Project*",
+        parameters=None,
+        project="This Project*",
         force_source_to_solve=True,
         preserve_partner_solution=True,
     ):
         """Start or continue from a previously solved setup.
 
         Parameters
         ----------
-        design_name : str
+        design : str
             Name of the design.
-        solution_name : str, optional
-            Name of the solution in the format ``"setupname : solutionname"``.
+        solution : str, optional
+            Name of the solution in the format ``"setup_name : solution_name"``.
             For example, ``"Setup1 : Transient", "MySetup : LastAdaptive"``.
         map_variables_by_name : bool, optional
             Whether variables are mapped by name from the source design. The default is
             ``True``.
-        parameters_dict : dict, optional
+        parameters : dict, optional
             Dictionary of the parameters. This parameter is not considered if
-            ``map_variables_by_name = True``. If ``None``, the default value is
+            ``map_variables_by_name=True``. If ``None``, the default is
             ``appname.available_variations.nominal_w_values_dict``.
-        project_name : str, optional
+        project : str, optional
             Name of the project with the design. The default is ``"This Project*"``.
             However, you can supply the full path and name to another project.
         force_source_to_solve : bool, optional
             The default is ``True``.
         preserve_partner_solution : bool, optional
             The default is ``True``.
 
@@ -933,63 +913,63 @@
 
         >>> oModule.EditSetup
 
         Examples
         --------
         >>> m2d = pyaedt.Maxwell2d()
         >>> setup = m2d.get_setup("Setup1")
-        >>> setup.start_continue_from_previous_setup(design_name="IM", solution_name="Setup1 : Transient")
+        >>> setup.start_continue_from_previous_setup(design="IM",solution="Setup1 : Transient")
 
         """
 
         auto_update = self.auto_update
         try:
             self.auto_update = False
 
             # parameters
             params = OrderedDict({})
             if map_variables_by_name:
-                parameters_dict = self.p_app.available_variations.nominal_w_values_dict
-                for k, v in parameters_dict.items():
+                parameters = self.p_app.available_variations.nominal_w_values_dict
+                for k, v in parameters.items():
                     params[k] = k
-            elif parameters_dict is None:
-                parameters_dict = self.p_app.available_variations.nominal_w_values_dict
-                for k, v in parameters_dict.items():
+            elif parameters is None:
+                parameters = self.p_app.available_variations.nominal_w_values_dict
+                for k, v in parameters.items():
                     params[k] = v
             else:
-                for k, v in parameters_dict.items():
+                for k, v in parameters.items():
                     if k in list(self._app.available_variations.nominal_w_values_dict.keys()):
                         params[k] = v
                     else:
-                        params[k] = parameters_dict[v]
+                        params[k] = parameters[v]
 
             prev_solution = OrderedDict({})
 
             # project name
-            if project_name != "This Project*":
-                if os.path.exists(project_name):
-                    prev_solution["Project"] = project_name
+            if project != "This Project*":
+                if os.path.exists(project):
+                    prev_solution["Project"] = project
                     self.props["PathRelativeTo"] = "SourceProduct"
                 else:
                     raise ValueError("Project file path provided does not exist.")
             else:
-                prev_solution["Project"] = project_name
+                prev_solution["Project"] = project
                 self.props["PathRelativeTo"] = "TargetProject"
 
             # design name
-            if not design_name or design_name is None:
+            if not design or design is None:
                 raise ValueError("Provide design name to add mesh link to.")
-            elif design_name not in self.p_app.design_list:
+            elif design not in self.p_app.design_list:
                 raise ValueError("Design does not exist in current project.")
             else:
-                prev_solution["Design"] = design_name
+                prev_solution["Design"] = design
 
             # solution name
-            if solution_name:
-                prev_solution["Soln"] = solution_name
+            if solution:
+                prev_solution["Soln"] = solution
             else:
                 raise ValueError("Provide a valid solution name.")
 
             self.props["PrevSoln"] = prev_solution
 
             self.props["PrevSoln"]["Params"] = params
             self.props["ForceSourceToSolve"] = force_source_to_solve
@@ -1013,38 +993,38 @@
 class SetupCircuit(CommonSetup):
     """Manages a circuit setup.
 
     Parameters
     ----------
     app : :class:`pyaedt.application.AnalysisNexxim.FieldAnalysisCircuit`
         Inherited app object.
-    solutiontype : str, int
+    solution_type : str, int
         Type of the setup.
-    setupname : str, optional
+    name : str, optional
         Name of the setup. The default is ``"MySetupAuto"``.
-    isnewsetup : bool, optional
+    is_new_setup : bool, optional
       Whether to create the setup from a template. The default is ``True.``
       If ``False``, access is to the existing setup.
 
     """
 
-    def __init__(self, app, solutiontype, setupname="MySetupAuto", isnewsetup=True):
-        CommonSetup.__init__(self, app, solutiontype, setupname, isnewsetup)
+    def __init__(self, app, solution_type, name="MySetupAuto", is_new_setup=True):
+        CommonSetup.__init__(self, app, solution_type, name, is_new_setup)
 
-    @pyaedt_function_handler()
-    def _init_props(self, isnewsetup=False):
+    @pyaedt_function_handler(isnewsetup="is_new_setup")
+    def _init_props(self, is_new_setup=False):
         props = {}
-        if isnewsetup:
+        if is_new_setup:
             setup_template = SetupKeys.get_setup_templates()[self.setuptype]
             self.props = SetupProps(self, setup_template)
         else:
             self.props = SetupProps(self, OrderedDict())
             try:
                 setups_data = self.p_app.design_properties["SimSetups"]["SimSetup"]
-                if type(setups_data) is not list:
+                if not isinstance(setups_data, list):
                     setups_data = [setups_data]
                 for setup in setups_data:
                     if self.name == setup["Name"]:
                         setup_data = setup
                         setup_data.pop("Sweeps", None)
                         self.props = SetupProps(self, setup_data)
             except Exception:
@@ -1485,74 +1465,74 @@
         expression_cache = self._expression_cache(
             expressions, report_type, intrinsics, isconvergence, isrelativeconvergence, conv_criteria
         )
         arg.append(expression_cache)
         self.omodule.EditSetup(self.name, arg)
         return True
 
-    @pyaedt_function_handler()
-    def enable(self, setup_name=None):
+    @pyaedt_function_handler(setup_name="name")
+    def enable(self, name=None):
         """Enable a setup.
 
         Parameters
         ----------
-        setup_name : str, optional
+        name : str, optional
             Name of the setup. The default is ``None``.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         References
         ----------
 
         >>> oModule.EditSetup
         """
-        if not setup_name:
-            setup_name = self.name
-        self._odesign.EnableSolutionSetup(setup_name, True)
+        if not name:
+            name = self.name
+        self._odesign.EnableSolutionSetup(name, True)
         return True
 
-    @pyaedt_function_handler()
-    def disable(self, setup_name=None):
+    @pyaedt_function_handler(setup_name="name")
+    def disable(self, name=None):
         """Disable a setup.
 
         Parameters
         ----------
-        setup_name : str, optional
+        name : str, optional
             Name of the setup. The default is ``None``.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         References
         ----------
 
         >>> oModule.EditSetup
         """
-        if not setup_name:
-            setup_name = self.name
-        self._odesign.EnableSolutionSetup(setup_name, False)
+        if not name:
+            name = self.name
+        self._odesign.EnableSolutionSetup(name, False)
         return True
 
     @pyaedt_function_handler()
     def get_solution_data(
         self,
         expressions=None,
         domain=None,
         variations=None,
         primary_sweep_variable=None,
         report_category=None,
         context=None,
-        subdesign_id=None,
         polyline_points=1001,
         math_formula=None,
+        sweep=None,
     ):
         """Get a simulation result from a solved setup and cast it in a ``SolutionData`` object.
         Data to be retrieved from Electronics Desktop are any simulation results available in that
         specific simulation context.
         Most of the argument have some defaults which works for most of the ``Standard`` report quantities.
 
         Parameters
@@ -1584,22 +1564,20 @@
             This is the context of the report.
             The default is ``None``. It can be:
             1. `None`
             2. ``"Differential Pairs"``
             3. Reduce Matrix Name for Q2d/Q3d solution
             4. Infinite Sphere name for Far Fields Plot.
             5. Dictionary. If dictionary is passed, key is the report property name and value is property value.
-        subdesign_id : int, optional
-            Subdesign ID for exporting a Touchstone file of this subdesign.
-            This parameter is valid for ``Circuit`` only.
-            The default value is ``None``.
+        math_formula : str, optional
+            One of the available AEDT mathematical formulas to apply. For example, ``abs, dB``.
         polyline_points : int, optional
             Number of points on which to create the report for plots on polylines.
             This parameter is valid for ``Fields`` plot only.
-        math_formula : str, optional
+        sweep : str, optional
             One of the available AEDT mathematical formulas to apply. For example, ``abs, dB``.
 
 
         Returns
         -------
         :class:`pyaedt.modules.solutions.SolutionData`
             Solution Data object.
@@ -1612,18 +1590,17 @@
         return self._app.post.get_solution_data(
             expressions=expressions,
             domain=domain,
             variations=variations,
             primary_sweep_variable=primary_sweep_variable,
             report_category=report_category,
             context=context,
-            subdesign_id=subdesign_id,
             polyline_points=polyline_points,
             math_formula=math_formula,
-            setup_sweep_name=self.name,
+            sweep=sweep,
         )
 
     @pyaedt_function_handler()
     def create_report(
         self,
         expressions=None,
         domain="Sweep",
@@ -1631,15 +1608,15 @@
         primary_sweep_variable=None,
         secondary_sweep_variable=None,
         report_category=None,
         plot_type="Rectangular Plot",
         context=None,
         subdesign_id=None,
         polyline_points=1001,
-        plotname=None,
+        name=None,
     ):
         """Create a report in AEDT. It can be a 2D plot, 3D plot, polar plots or data tables.
 
         Parameters
         ----------
         expressions : str or list, optional
             One or more formulas to add to the report. Example is value = ``"dB(S(1,1))"``.
@@ -1660,18 +1637,18 @@
             If `None` default category will be used (the first item in the Results drop down menu in AEDT).
         plot_type : str, optional
             The format of Data Visualization. Default is ``Rectangular Plot``.
         context : str, optional
             The default is ``None``. It can be `None`, `"Differential Pairs"`,`"RL"`,
             `"Sources"`, `"Vias"`,`"Bondwires"`, `"Probes"` for Hfss3dLayout or
             Reduce Matrix Name for Q2d/Q3d solution or Infinite Sphere name for Far Fields Plot.
-        plotname : str, optional
+        name : str, optional
             Name of the plot. The default is ``None``.
         polyline_points : int, optional,
-            Number of points on which create the report for plots on polylines.
+            Number of points for creating the report for plots on polylines.
         subdesign_id : int, optional
             Specify a subdesign ID to export a Touchstone file of this subdesign. Valid for Circuit Only.
             The default value is ``None``.
         context : str, optional
 
         Returns
         -------
@@ -1689,44 +1666,42 @@
             domain=domain,
             variations=variations,
             primary_sweep_variable=primary_sweep_variable,
             secondary_sweep_variable=secondary_sweep_variable,
             report_category=report_category,
             plot_type=plot_type,
             context=context,
-            polyline_points=polyline_points,
-            plotname=plotname,
             subdesign_id=subdesign_id,
-            setup_sweep_name=self.name,
+            polyline_points=polyline_points,
         )
 
 
 class Setup3DLayout(CommonSetup):
     """Initializes, creates, and updates a 3D Layout setup.
 
     Parameters
     ----------
     app : :class:`pyaedt.application.Analysis3DLayout.FieldAnalysis3DLayout`
         Inherited app object.
-    solutiontype : int or str
+    solution_type : int or str
         Type of the setup.
-    setupname : str, optional
+    name : str, optional
         Name of the setup. The default is ``"MySetupAuto"``.
-    isnewsetup : bool, optional
+    is_new_setup : bool, optional
         Whether to create the setup from a template. The default is ``True.``
         If ``False``, access is to the existing setup.
 
     """
 
-    def __init__(self, app, solutiontype, setupname="MySetupAuto", isnewsetup=True):
-        CommonSetup.__init__(self, app, solutiontype, setupname, isnewsetup)
+    def __init__(self, app, solution_type, name="MySetupAuto", is_new_setup=True):
+        CommonSetup.__init__(self, app, solution_type, name, is_new_setup)
 
-    @pyaedt_function_handler()
-    def _init_props(self, isnewsetup=False):
-        if isnewsetup:
+    @pyaedt_function_handler(isnewsetup="is_new_setup")
+    def _init_props(self, is_new_setup=False):
+        if is_new_setup:
             setup_template = SetupKeys.get_setup_templates()[self.setuptype]
             self.props = SetupProps(self, setup_template)
         else:
             try:
                 setups_data = self._app.design_properties["Setup"]["Data"]
                 if self.name in setups_data:
                     setup_data = setups_data[self.name]
@@ -1749,32 +1724,26 @@
         -------
         bool
             `True` if solutions are available.
         """
         if self.props.get("SolveSetupType", "HFSS") == "HFSS":
             combined_name = "{} : Last Adaptive".format(self.name)
             expressions = [i for i in self.p_app.post.available_report_quantities(solution=combined_name)]
-            sol = self._app.post.reports_by_category.standard(setup_name=combined_name, expressions=expressions[0])
+            sol = self._app.post.reports_by_category.standard(expressions=expressions[0], setup=combined_name)
         elif self.props.get("SolveSetupType", "HFSS") == "SIwave":
             combined_name = "{} : {}".format(self.name, self.sweeps[0].name)
             expressions = [i for i in self.p_app.post.available_report_quantities(solution=combined_name)]
-            sol = self._app.post.reports_by_category.standard(
-                setup_name=combined_name,
-                expressions=expressions[0],
-            )
+            sol = self._app.post.reports_by_category.standard(expressions=expressions[0], setup=combined_name)
         elif self.props.get("SolveSetupType", "HFSS") == "SIwaveDCIR":
             expressions = self.p_app.post.available_report_quantities(solution=self.name, is_siwave_dc=True)
-            sol = self._app.post.reports_by_category.standard(
-                setup_name=self.name,
-                expressions=expressions[0],
-            )
+            sol = self._app.post.reports_by_category.standard(expressions=expressions[0], setup=self.name)
         else:
             expressions = [i for i in self.p_app.post.available_report_quantities(solution=self.name)]
 
-            sol = self._app.post.reports_by_category.standard(setup_name=self.name, expressions=expressions[0])
+            sol = self._app.post.reports_by_category.standard(expressions=expressions[0], setup=self.name)
         if identify_setup(self.props):
             sol.domain = "Time"
         return True if sol.get_solution_data() else False
 
     @property
     def solver_type(self):
         """Setup type.
@@ -2146,69 +2115,71 @@
                 from pyaedt import Q3d
 
                 self._get_net_names(Q3d, file_fullname)
             else:
                 self.p_app.logger.error("Exporting layout while keeping net name is not supported with IronPython")
         return succeeded
 
-    @pyaedt_function_handler()
-    def add_sweep(self, sweepname=None, sweeptype="Interpolating"):
+    @pyaedt_function_handler(sweepname="name", sweeptype="sweep_type")
+    def add_sweep(self, name=None, sweep_type="Interpolating"):
         """Add a frequency sweep.
 
         Parameters
         ----------
-        sweepname : str, optional
-            Name of the sweep. The default is ``None``.
-        sweeptype : str, optional
+        name : str, optional
+            Name of the sweep. The default is ``None``, in which
+            case a name is automatically assigned.
+        sweep_type : str, optional
             Type of the sweep. Options are ``"Fast"``,
             ``"Interpolating"``, and ``"Discrete"``.
             The default is ``"Interpolating"``.
 
         Returns
         -------
         :class:`pyaedt.modules.SolveSweeps.SweepHFSS3DLayout`
             Sweep object.
 
         References
         ----------
 
         >>> oModule.AddSweep
         """
-        if not sweepname:
-            sweepname = generate_unique_name("Sweep")
-        sweep_n = SweepHFSS3DLayout(self, sweepname, sweeptype)
+        if not name:
+            name = generate_unique_name("Sweep")
+        sweep_n = SweepHFSS3DLayout(self, name, sweep_type)
         if sweep_n.create():
             self.sweeps.append(sweep_n)
             return sweep_n
         return False
 
-    @pyaedt_function_handler()
-    def get_sweep(self, sweepname=None):
+    @pyaedt_function_handler(sweepname="name")
+    def get_sweep(self, name=None):
         """Return frequency sweep object of a given sweep.
 
         Parameters
         ----------
-        sweepname : str, optional
-            Name of the sweep. the default is ``None`` which returns the first sweep.
+        name : str, optional
+            Name of the sweep. The default is ``None``, in which case
+            the first sweep is used.
 
         Returns
         -------
         :class:`pyaedt.modules.SolveSweeps.SweepHFSS3DLayout`
 
         Examples
         --------
         >>> h3d = Hfss3dLayout()
         >>> setup = h3d.get_setup('Pyaedt_setup')
         >>> sweep = setup.get_sweep('Sweep1')
-        >>> sweep.add_subrange("LinearCount", 0, 10, 1, "Hz")
-        >>> sweep.add_subrange("LogScale", 10, 1E8, 100, "Hz")
+        >>> sweep.add_subrange("LinearCount",0,10,1,"Hz")
+        >>> sweep.add_subrange("LogScale",10,1E8,100,"Hz")
         """
-        if sweepname:
+        if name:
             for sweep in self.sweeps:
-                if sweepname == sweep.name:
+                if name == sweep.name:
                     return sweep
         else:
             if self.sweeps:
                 return self.sweeps[0]
         return False
 
     @pyaedt_function_handler()
@@ -2251,28 +2222,28 @@
 
 
 class SetupHFSS(Setup, object):
     """Initializes, creates, and updates an HFSS setup.
 
     Parameters
     ----------
-    app : :class:`pyaedt.application.Analysis3D.FieldAnalysis3D`
+    app : :class:`pyaedt.application.Analysis.Analysis`
         Inherited app object.
-    solutiontype : int, str
+    solution_type : int, str
         Type of the setup.
-    setupname : str, optional
+    name : str, optional
         Name of the setup. The default is ``"MySetupAuto"``.
-    isnewsetup : bool, optional
+    is_new_setup : bool, optional
         Whether to create the setup from a template. The default is ``True``.
         If ``False``, access is to the existing setup.
 
     """
 
-    def __init__(self, app, solutiontype, setupname="MySetupAuto", isnewsetup=True):
-        Setup.__init__(self, app, solutiontype, setupname, isnewsetup)
+    def __init__(self, app, solution_type, name="MySetupAuto", is_new_setup=True):
+        Setup.__init__(self, app, solution_type, name, is_new_setup)
 
     @pyaedt_function_handler()
     def get_derivative_variables(self):
         """Return Derivative Enabled variables.
 
         Returns
         -------
@@ -2305,46 +2276,47 @@
         if not isinstance(derivative_list, list):
             derivative_list = [derivative_list]
         self.auto_update = False
         self.props["VariablesForDerivatives"] = derivative_list + self.get_derivative_variables()
         self.auto_update = True
         return self.update()
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(freqstart="start_frequency", freqstop="stop_frequency", sweepname="name")
     def create_frequency_sweep(
         self,
         unit=None,
-        freqstart=1,
-        freqstop=10,
+        start_frequency=1.0,
+        stop_frequency=10.0,
         num_of_freq_points=None,
-        sweepname=None,
+        name=None,
         save_fields=True,
         save_rad_fields=False,
         sweep_type="Discrete",
         interpolation_tol=0.5,
         interpolation_max_solutions=250,
     ):
         """Create a sweep with the specified number of points.
 
         Parameters
         ----------
         unit : str, optional
-            Frequency Units. The default is ``None`` which takes the Default Desktop units.
-        freqstart : float, str, optional
-            Starting frequency of the sweep. The default is ``1``.
-            If a unit is passed with number, such as ``"1MHz"``, the unit will be ignored.
-        freqstop : float, str, optional
-            Stopping frequency of the sweep. The default is ``10``.
+            Unit of the frequency.. The default is ``None``, in which case the default desktop units are used.
+        start_frequency : float, str, optional
+            Starting frequency of the sweep. The default is ``1.0``.
+            If a unit is passed with number, such as ``"1MHz"``, the unit is ignored.
+        stop_frequency : float, str, optional
+            Stopping frequency of the sweep. The default is ``10.0``.
             If a unit is passed with number, such as ``"1MHz"`, the unit is ignored.
         num_of_freq_points : int
             Number of frequency points in the range. The default is ``401`` for
             a sweep type of ``"Interpolating"`` or ``"Fast"``. The default is ``5`` for a sweep
             type of ``"Discrete"``.
-        sweepname : str, optional
-            Name of the sweep. The default is ``None``.
+        name : str, optional
+            Name of the sweep. The default is ``None``, in which
+            case a name is automatically assigned.
         save_fields : bool, optional
             Whether to save the fields. The default is ``True``.
         save_rad_fields : bool, optional
             Whether to save the radiating fields. The default is ``False``.
         sweep_type : str, optional
             Type of the sweep. Options are ``"Fast"``, ``"Interpolating"``,
             and ``"Discrete"``. The default is ``"Discrete"``.
@@ -2368,85 +2340,83 @@
         Examples
         --------
 
         Create a setup named ``"LinearCountSetup"`` and use it in a linear count sweep
         named ``"LinearCountSweep"``.
 
         >>> setup = hfss.create_setup("LinearCountSetup")
-        >>> linear_count_sweep = hfss.create_linear_count_sweep(setupname="LinearCountSetup",
-        ...                                                     sweepname="LinearCountSweep",
-        ...                                                     unit="MHz", freqstart=1.1e3,
-        ...                                                     freqstop=1200.1, num_of_freq_points=1658)
+        >>> linear_count_sweep = setup.create_linear_count_sweep(,,
         >>> type(linear_count_sweep)
         <class 'pyaedt.modules.SetupTemplates.SweepHFSS'>
 
         """
 
         # Set default values for num_of_freq_points if a value was not passed. Also,
         # check that sweep_type is valid.
         if sweep_type in ["Interpolating", "Fast"]:
             num_of_freq_points = num_of_freq_points or 401
         elif sweep_type == "Discrete":
             num_of_freq_points = num_of_freq_points or 5
         else:  # pragma: no cover
-            raise ValueError("Invalid `sweep_type`. It has to be either 'Discrete', 'Interpolating', or 'Fast'")
+            raise ValueError("Invalid `sweep_type`. It has to be 'Discrete', 'Interpolating', or 'Fast'")
 
-        if sweepname is None:
-            sweepname = generate_unique_name("Sweep")
+        if name is None:
+            name = generate_unique_name("Sweep")
 
-        if sweepname in [sweep.name for sweep in self.sweeps]:
-            oldname = sweepname
-            sweepname = generate_unique_name(oldname)
-            self._app.logger.warning("Sweep %s is already present. Sweep has been renamed in %s.", oldname, sweepname)
-        sweepdata = self.add_sweep(sweepname, sweep_type)
+        if name in [sweep.name for sweep in self.sweeps]:
+            oldname = name
+            name = generate_unique_name(oldname)
+            self._app.logger.warning("Sweep %s is already present. Sweep has been renamed in %s.", oldname, name)
+        sweepdata = self.add_sweep(name, sweep_type)
         if not sweepdata:
             return False
         sweepdata.props["RangeType"] = "LinearCount"
-        sweepdata.props["RangeStart"] = self.p_app.value_with_units(freqstart, unit, "Frequency")
-        sweepdata.props["RangeEnd"] = self.p_app.value_with_units(freqstop, unit, "Frequency")
+        sweepdata.props["RangeStart"] = self.p_app.value_with_units(start_frequency, unit, "Frequency")
+        sweepdata.props["RangeEnd"] = self.p_app.value_with_units(stop_frequency, unit, "Frequency")
 
         sweepdata.props["RangeCount"] = num_of_freq_points
         sweepdata.props["Type"] = sweep_type
         if sweep_type == "Interpolating":
             sweepdata.props["InterpTolerance"] = interpolation_tol
             sweepdata.props["InterpMaxSolns"] = interpolation_max_solutions
             sweepdata.props["InterpMinSolns"] = 0
             sweepdata.props["InterpMinSubranges"] = 1
         sweepdata.props["SaveFields"] = save_fields
         sweepdata.props["SaveRadFields"] = save_rad_fields
         sweepdata.update()
-        self._app.logger.info("Linear count sweep {} has been correctly created".format(sweepname))
+        self._app.logger.info("Linear count sweep {} has been correctly created".format(name))
         return sweepdata
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(freqstart="start_frequency", freqstop="stop_frequency", sweepname="name")
     def create_linear_step_sweep(
         self,
         unit="GHz",
-        freqstart=0.1,
-        freqstop=2,
+        start_frequency=0.1,
+        stop_frequency=2.0,
         step_size=0.05,
-        sweepname=None,
+        name=None,
         save_fields=True,
         save_rad_fields=False,
         sweep_type="Discrete",
     ):
         """Create a Sweep with a specified frequency step.
 
         Parameters
         ----------
         unit : str
             Unit of the frequency. For example, ``"MHz`` or ``"GHz"``.
-        freqstart : float
-            Starting frequency of the sweep.
-        freqstop : float
-            Stopping frequency of the sweep.
-        step_size : float
-            Frequency size of the step.
-        sweepname : str, optional
-            Name of the sweep. The default is ``None``.
+        start_frequency : float, optional
+            Starting frequency of the sweep. The default is ``0.1``.
+        stop_frequency : float, optional
+            Stopping frequency of the sweep. The default is ``2.0``.
+        step_size : float, optional
+            Frequency size of the step. The default is ``0.05``.
+        name : str, optional
+            Name of the sweep. The default is ``None``, in which
+            case a name is automatically assigned.
         save_fields : bool, optional
             Whether to save the fields. The default is ``True``.
         save_rad_fields : bool, optional
             Whether to save the radiating fields. The default is ``False``.
         sweep_type : str, optional
             Whether to create a ``"Discrete"``,``"Interpolating"`` or ``"Fast"`` sweep.
             The default is ``"Discrete"``.
@@ -2464,75 +2434,74 @@
         Examples
         --------
 
         Create a setup named ``"LinearStepSetup"`` and use it in a linear step sweep
         named ``"LinearStepSweep"``.
 
         >>> setup = hfss.create_setup("LinearStepSetup")
-        >>> linear_step_sweep = setup.create_linear_step_sweep(sweepname="LinearStepSweep",
-        ...                                                   unit="MHz", freqstart=1.1e3,
-        ...                                                   freqstop=1200.1, step_size=153.8)
+        >>> linear_step_sweep = setup.create_linear_step_sweep(name="LinearStepSweep",
+        ...                                                   unit="MHz", start_frequency=1.1e3,
+        ...                                                   stop_frequency=1200.1, step_size=153.8)
         >>> type(linear_step_sweep)
         <class 'pyaedt.modules.SetupTemplates.SweepHFSS'>
 
         """
         if sweep_type not in ["Discrete", "Interpolating", "Fast"]:
             raise AttributeError("Invalid in `sweep_type`. It has to either 'Discrete', 'Interpolating', or 'Fast'")
-        if sweepname is None:
-            sweepname = generate_unique_name("Sweep")
+        if name is None:
+            name = generate_unique_name("Sweep")
 
-        if sweepname in [sweep.name for sweep in self.sweeps]:
-            oldname = sweepname
-            sweepname = generate_unique_name(oldname)
-            self._app.logger.warning("Sweep %s is already present. Sweep has been renamed in %s.", oldname, sweepname)
-        sweepdata = self.add_sweep(sweepname, sweep_type)
+        if name in [sweep.name for sweep in self.sweeps]:
+            oldname = name
+            name = generate_unique_name(oldname)
+            self._app.logger.warning("Sweep %s is already present. Sweep has been renamed in %s.", oldname, name)
+        sweepdata = self.add_sweep(name, sweep_type)
         if not sweepdata:
             return False
         sweepdata.props["RangeType"] = "LinearStep"
-        sweepdata.props["RangeStart"] = str(freqstart) + unit
-        sweepdata.props["RangeEnd"] = str(freqstop) + unit
+        sweepdata.props["RangeStart"] = str(start_frequency) + unit
+        sweepdata.props["RangeEnd"] = str(stop_frequency) + unit
         sweepdata.props["RangeStep"] = str(step_size) + unit
         sweepdata.props["SaveFields"] = save_fields
         sweepdata.props["SaveRadFields"] = save_rad_fields
         sweepdata.props["ExtrapToDC"] = False
         sweepdata.props["Type"] = sweep_type
         if sweep_type == "Interpolating":
             sweepdata.props["InterpTolerance"] = 0.5
             sweepdata.props["InterpMaxSolns"] = 250
             sweepdata.props["InterpMinSolns"] = 0
             sweepdata.props["InterpMinSubranges"] = 1
         sweepdata.update()
-        self._app.logger.info("Linear step sweep {} has been correctly created".format(sweepname))
+        self._app.logger.info("Linear step sweep {} has been correctly created".format(name))
         return sweepdata
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(sweepname="name")
     def create_single_point_sweep(
         self,
         unit="GHz",
         freq=1,
-        sweepname=None,
+        name=None,
         save_single_field=True,
         save_fields=False,
         save_rad_fields=False,
     ):
         """Create a Sweep with a single frequency point.
 
         Parameters
         ----------
-        setupname : str
-            Name of the setup.
         unit : str
             Unit of the frequency. For example, ``"MHz`` or ``"GHz"``.
         freq : float, list
             Frequency of the single point or list of frequencies to create distinct single points.
-        sweepname : str, optional
-            Name of the sweep. The default is ``None``.
+        name : str, optional
+            Name of the sweep. The default is ``None``, in which
+            case a name is automatically assigned.
         save_single_field : bool, list, optional
             Whether to save the fields of the single point. The default is ``True``.
-            If a list is specified, the length must be the same as freq length.
+            If a list is specified, the length must be the same as the frequency length.
         save_fields : bool, optional
             Whether to save the fields for all points and subranges defined in the sweep. The default is ``False``.
         save_rad_fields : bool, optional
             Whether to save only the radiating fields. The default is ``False``.
 
         Returns
         -------
@@ -2547,23 +2516,21 @@
         Examples
         --------
 
         Create a setup named ``"LinearStepSetup"`` and use it in a single point sweep
         named ``"SinglePointSweep"``.
 
         >>> setup = hfss.create_setup("LinearStepSetup")
-        >>> single_point_sweep = hfss.create_single_point_sweep(setupname="LinearStepSetup",
-        ...                                                   sweepname="SinglePointSweep",
-        ...                                                   unit="MHz", freq=1.1e3)
+        >>> single_point_sweep = setup.create_single_point_sweep(name="SinglePointSweep", unit="MHz", freq=1.1e3)
         >>> type(single_point_sweep)
         <class 'pyaedt.modules.SetupTemplates.SweepHFSS'>
 
         """
-        if sweepname is None:
-            sweepname = generate_unique_name("SinglePoint")
+        if name is None:
+            name = generate_unique_name("SinglePoint")
 
         if isinstance(save_single_field, list):
             if not isinstance(freq, list) or len(save_single_field) != len(freq):
                 raise AttributeError("The length of save_single_field must be the same as freq length.")
 
         add_subranges = False
         if isinstance(freq, list):
@@ -2578,94 +2545,96 @@
         if isinstance(save_single_field, list):
             save0 = save_single_field.pop(0)
         else:
             save0 = save_single_field
             if add_subranges:
                 save_single_field = [save0] * len(freq)
 
-        if sweepname in [sweep.name for sweep in self.sweeps]:
-            oldname = sweepname
-            sweepname = generate_unique_name(oldname)
-            self._app.logger.warning("Sweep %s is already present. Sweep has been renamed in %s.", oldname, sweepname)
-        sweepdata = self.add_sweep(sweepname, "Discrete")
+        if name in [sweep.name for sweep in self.sweeps]:
+            oldname = name
+            name = generate_unique_name(oldname)
+            self._app.logger.warning("Sweep %s is already present. Sweep has been renamed in %s.", oldname, name)
+        sweepdata = self.add_sweep(name, "Discrete")
         sweepdata.props["RangeType"] = "SinglePoints"
         sweepdata.props["RangeStart"] = str(freq0) + unit
         sweepdata.props["RangeEnd"] = str(freq0) + unit
         sweepdata.props["SaveSingleField"] = save0
         sweepdata.props["SaveFields"] = save_fields
         sweepdata.props["SaveRadFields"] = save_rad_fields
         sweepdata.props["SMatrixOnlySolveMode"] = "Auto"
         if add_subranges:
             for f, s in zip(freq, save_single_field):
                 sweepdata.add_subrange(rangetype="SinglePoints", start=f, unit=unit, save_single_fields=s)
         sweepdata.update()
-        self._app.logger.info("Single point sweep {} has been correctly created".format(sweepname))
+        self._app.logger.info("Single point sweep {} has been correctly created".format(name))
         return sweepdata
 
-    @pyaedt_function_handler()
-    def add_sweep(self, sweepname=None, sweeptype="Interpolating"):
+    @pyaedt_function_handler(sweepname="name", sweeptype="sweep_type")
+    def add_sweep(self, name=None, sweep_type="Interpolating"):
         """Add a sweep to the project.
 
         Parameters
         ----------
-        sweepname : str, optional
-            Name of the sweep. The default is ``None``.
-        sweeptype : str, optional
+        name : str, optional
+            Name of the sweep. The default is ``None``, in which
+            case a name is automatically assigned.
+        sweep_type : str, optional
             Type of the sweep. The default is ``"Interpolating"``.
 
         Returns
         -------
         :class:`pyaedt.modules.SolveSweeps.SweepHFSS` or :class:`pyaedt.modules.SolveSweeps.SweepMatrix`
             Sweep object.
 
         References
         ----------
 
         >>> oModule.InsertFrequencySweep
         """
-        if not sweepname:
-            sweepname = generate_unique_name("Sweep")
+        if not name:
+            name = generate_unique_name("Sweep")
         if self.setuptype == 7:
             self._app.logger.warning("This method only applies to HFSS and Q3D. Use add_eddy_current_sweep method.")
             return False
         if self.setuptype <= 4:
-            sweep_n = SweepHFSS(self, sweepname=sweepname, sweeptype=sweeptype)
+            sweep_n = SweepHFSS(self, name=name, sweep_type=sweep_type)
         elif self.setuptype in [14, 30, 31]:
-            sweep_n = SweepMatrix(self, sweepname=sweepname, sweeptype=sweeptype)
+            sweep_n = SweepMatrix(self, name=name, sweep_type=sweep_type)
         else:
-            self._app.logger.warning("This method only applies to HFSS, Q2D and Q3D.")
+            self._app.logger.warning("This method only applies to HFSS, Q2D, and Q3D.")
             return False
         sweep_n.create()
         self.sweeps.append(sweep_n)
         return sweep_n
 
-    @pyaedt_function_handler()
-    def get_sweep(self, sweepname=None):
+    @pyaedt_function_handler(sweepname="name")
+    def get_sweep(self, name=None):
         """Return frequency sweep object of a given sweep.
 
         Parameters
         ----------
-        sweepname : str, optional
-            Name of the sweep. the default is ``None`` which returns the first sweep.
+        name : str, optional
+            Name of the sweep. The default is ``None``, in which case the
+            first sweep is used.
 
         Returns
         -------
         :class:`pyaedt.modules.SolveSweeps.SweepHFSS` or :class:`pyaedt.modules.SolveSweeps.SweepMatrix`
 
         Examples
         --------
         >>> hfss = Hfss()
         >>> setup = hfss.get_setup('Pyaedt_setup')
         >>> sweep = setup.get_sweep('Sweep1')
-        >>> sweep.add_subrange("LinearCount", 0, 10, 1, "Hz")
-        >>> sweep.add_subrange("LogScale", 10, 1E8, 100, "Hz")
+        >>> sweep.add_subrange("LinearCount",0,10,1,"Hz")
+        >>> sweep.add_subrange("LogScale",10,1E8,100,"Hz")
         """
-        if sweepname:
+        if name:
             for sweep in self.sweeps:
-                if sweepname == sweep.name:
+                if name == sweep.name:
                     return sweep
         else:
             if self.sweeps:
                 return self.sweeps[0]
         return False
 
     @pyaedt_function_handler()
@@ -2687,21 +2656,21 @@
         >>> import pyaedt
         >>> hfss = pyaedt.Hfss()
         >>> setup = hfss.get_setup('Pyaedt_setup')
         >>> sweeps = setup.get_sweep_names()
         """
         return self.omodule.GetSweeps(self.name)
 
-    @pyaedt_function_handler()
-    def delete_sweep(self, sweepname):
+    @pyaedt_function_handler(sweepname="name")
+    def delete_sweep(self, name):
         """Delete a sweep.
 
         Parameters
         ----------
-        sweepname : str
+        name : str
             Name of the sweep.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
@@ -2712,23 +2681,23 @@
 
         Examples
         --------
         Create a frequency sweep and then delete it.
 
         >>> import pyaedt
         >>> hfss = pyaedt.Hfss()
-        >>> setup1 = hfss.create_setup(setupname='Setup1')
+        >>> setup1 = hfss.create_setup(name='Setup1')
         >>> setup1.create_frequency_sweep(
             "GHz", 24, 24.25, 26, "Sweep1", sweep_type="Fast",
         )
         >>> setup1.delete_sweep("Sweep1")
         """
-        if sweepname in self.get_sweep_names():
-            self.sweeps = [sweep for sweep in self.sweeps if sweep.name != sweepname]
-            self.omodule.DeleteSweep(self.name, sweepname)
+        if name in self.get_sweep_names():
+            self.sweeps = [sweep for sweep in self.sweeps if sweep.name != name]
+            self.omodule.DeleteSweep(self.name, name)
             return True
         return False
 
     @pyaedt_function_handler()
     def enable_adaptive_setup_single(self, freq=None, max_passes=None, max_delta_s=None):
         """Enable HFSS single frequency setup.
 
@@ -2850,28 +2819,28 @@
 
 
 class SetupHFSSAuto(Setup, object):
     """Initializes, creates, and updates an HFSS SBR+ or  HFSS Auto setup.
 
     Parameters
     ----------
-    app : :class:`pyaedt.application.Analysis3D.FieldAnalysis3D`
+    app : :class:`pyaedt.application.Analysis.Analysis`
         Inherited app object.
-    solutiontype : int, str
+    solution_type : int, str
         Type of the setup.
-    setupname : str, optional
+    name : str, optional
         Name of the setup. The default is ``"MySetupAuto"``.
-    isnewsetup : bool, optional
+    is_new_setup : bool, optional
         Whether to create the setup from a template. The default is ``True``.
         If ``False``, access is to the existing setup.
 
     """
 
-    def __init__(self, app, solutiontype, setupname="MySetupAuto", isnewsetup=True):
-        Setup.__init__(self, app, solutiontype, setupname, isnewsetup)
+    def __init__(self, app, solution_type, name="MySetupAuto", is_new_setup=True):
+        Setup.__init__(self, app, solution_type, name, is_new_setup)
 
     @pyaedt_function_handler()
     def get_derivative_variables(self):
         """Return Derivative Enabled variables.
 
         Returns
         -------
@@ -2904,21 +2873,21 @@
         if not isinstance(derivative_list, list):
             derivative_list = [derivative_list]
         self.auto_update = False
         self.props["VariablesForDerivatives"] = derivative_list + self.get_derivative_variables()
         self.auto_update = True
         return self.update()
 
-    @pyaedt_function_handler()
-    def add_subrange(self, rangetype, start, end=None, count=None, unit="GHz", clear=False):
+    @pyaedt_function_handler(rangetype="range_type")
+    def add_subrange(self, range_type, start, end=None, count=None, unit="GHz", clear=False):
         """Add a subrange to the sweep.
 
         Parameters
         ----------
-        rangetype : str
+        range_type : str
             Type of the subrange. Options are ``"LinearCount"``,
             ``"LinearStep"``, and ``"LogScale"``.
         start : float
             Starting frequency.
         end : float
             Stopping frequency.
         count : int or float
@@ -2931,55 +2900,55 @@
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         """
         if clear:
-            self.props["Sweeps"]["Sweep"]["RangeType"] = rangetype
+            self.props["Sweeps"]["Sweep"]["RangeType"] = range_type
             self.props["Sweeps"]["Sweep"]["RangeStart"] = str(start) + unit
-            if rangetype == "LinearCount":
+            if range_type == "LinearCount":
                 self.props["Sweeps"]["Sweep"]["RangeEnd"] = str(end) + unit
                 self.props["Sweeps"]["Sweep"]["RangeCount"] = count
-            elif rangetype == "LinearStep":
+            elif range_type == "LinearStep":
                 self.props["Sweeps"]["Sweep"]["RangeEnd"] = str(end) + unit
                 self.props["Sweeps"]["Sweep"]["RangeStep"] = str(count) + unit
-            elif rangetype == "LogScale":
+            elif range_type == "LogScale":
                 self.props["Sweeps"]["Sweep"]["RangeEnd"] = str(end) + unit
                 self.props["Sweeps"]["Sweep"]["RangeSamples"] = count
             self.props["Sweeps"]["Sweep"]["SweepRanges"] = {"Subrange": []}
             return self.update()
-        sweep_range = {"RangeType": rangetype, "RangeStart": str(start) + unit}
-        if rangetype == "LinearCount":
+        sweep_range = {"RangeType": range_type, "RangeStart": str(start) + unit}
+        if range_type == "LinearCount":
             sweep_range["RangeEnd"] = str(end) + unit
             sweep_range["RangeCount"] = count
-        elif rangetype == "LinearStep":
+        elif range_type == "LinearStep":
             sweep_range["RangeEnd"] = str(end) + unit
             sweep_range["RangeStep"] = str(count) + unit
-        elif rangetype == "LogScale":
+        elif range_type == "LogScale":
             sweep_range["RangeEnd"] = str(end) + unit
             sweep_range["RangeCount"] = self.props["RangeCount"]
             sweep_range["RangeSamples"] = count
         if not self.props["Sweeps"]["Sweep"].get("SweepRanges") or not self.props["Sweeps"]["Sweep"]["SweepRanges"].get(
             "Subrange"
         ):
             self.props["Sweeps"]["Sweep"]["SweepRanges"] = {"Subrange": []}
         self.props["Sweeps"]["Sweep"]["SweepRanges"]["Subrange"].append(sweep_range)
         return self.update()
 
-    @pyaedt_function_handler()
-    def enable_adaptive_setup_single(self, freq=None, max_passes=None, max_delta_s=None):
+    @pyaedt_function_handler(freq="frequency")
+    def enable_adaptive_setup_single(self, frequency=None, max_passes=None, max_delta_s=None):
         """Enable HFSS single frequency setup.
 
         Parameters
         ----------
-        freq : float, str, optional
-            Frequency at which to set the adaptive convergence.
-            The default is ``None`` which will not update the value in setup.
-            You can enter a float value in (GHz) or a string.
+        frequency : float, str, optional
+            Frequency to set the adaptive convergence at.
+            The default is ``None``, in which case the value in the setup is
+            not updated. You can specify a float value (GHz) or a string.
         max_passes : int, optional
             Maximum number of adaptive passes. The default is ``None`` which will not update the value in setup.
         max_delta_s : float, optional
             Delta S convergence criteria. The default is ``None`` which will not update the value in setup.
 
         Returns
         -------
@@ -2987,36 +2956,37 @@
             ``True`` when successful, ``False`` when failed.
         """
         if self.setuptype != 1 or self.p_app.solution_type not in ["Modal", "Terminal"]:
             self._app.logger.error("Method applies only to HFSS-driven solutions.")
             return False
         self.auto_update = False
         self.props["SolveType"] = "Single"
-        if isinstance(freq, (int, float)):
-            freq = "{}GHz".format(freq)
-        if freq:
-            self.props["Frequency"] = freq
+        if isinstance(frequency, (int, float)):
+            frequency = "{}GHz".format(frequency)
+        if frequency:
+            self.props["Frequency"] = frequency
         if max_passes:
             self.props["MaximumPasses"] = max_passes
         if max_delta_s:
             self.props["MaxDeltaS"] = max_delta_s
         self.auto_update = True
         return self.update()
 
-    @pyaedt_function_handler()
-    def enable_adaptive_setup_broadband(self, low_frequency, high_frquency, max_passes=6, max_delta_s=0.02):
+    @pyaedt_function_handler(high_frquency="high_frequency")
+    def enable_adaptive_setup_broadband(self, low_frequency, high_frequency, max_passes=6, max_delta_s=0.02):
         """Enable HFSS broadband setup.
 
         Parameters
         ----------
         low_frequency : float, str
-            Lower Frequency at which set the adaptive convergence.
-            It can be float (GHz) or str.
-        high_frquency : float, str
-            Lower Frequency at which set the adaptive convergence. It can be float (GHz) or str.
+            Lower frequency to set the adaptive convergence at.
+            You can specify a float value (GHz) or a string.
+        high_frequency : float, str
+            Lower frequency to set the adaptive convergence at. You can
+            specify a float value (GHz) or a string.
         max_passes : int, optional
             Maximum number of adaptive passes. The default is ``6``.
         max_delta_s : float, optional
             Delta S Convergence criteria. The default is ``0.02``.
 
         Returns
         -------
@@ -3028,18 +2998,18 @@
             return False
         self.auto_update = False
         self.props["SolveType"] = "BroadBand"
         for el in list(self.props["MultipleAdaptiveFreqsSetup"].keys()):
             del self.props["MultipleAdaptiveFreqsSetup"][el]
         if isinstance(low_frequency, (int, float)):
             low_frequency = "{}GHz".format(low_frequency)
-        if isinstance(high_frquency, (int, float)):
-            high_frquency = "{}GHz".format(high_frquency)
+        if isinstance(high_frequency, (int, float)):
+            high_frequency = "{}GHz".format(high_frequency)
         self.props["MultipleAdaptiveFreqsSetup"]["Low"] = low_frequency
-        self.props["MultipleAdaptiveFreqsSetup"]["High"] = high_frquency
+        self.props["MultipleAdaptiveFreqsSetup"]["High"] = high_frequency
         self.props["MaximumPasses"] = max_passes
         self.props["MaxDeltaS"] = max_delta_s
         self.auto_update = True
         return self.update()
 
     @pyaedt_function_handler()
     def enable_adaptive_setup_multifrequency(self, frequencies, max_delta_s=0.02):
@@ -3084,36 +3054,36 @@
 
 
 class SetupSBR(Setup, object):
     """Initializes, creates, and updates an HFSS SBR+ or  HFSS Auto setup.
 
     Parameters
     ----------
-    app : :class:`pyaedt.application.Analysis3D.FieldAnalysis3D`
+    app : :class:`pyaedt.application.Analysis.Analysis`
         Inherited app object.
-    solutiontype : int, str
+    solution_type : int, str
         Type of the setup.
-    setupname : str, optional
+    name : str, optional
         Name of the setup. The default is ``"MySetupAuto"``.
-    isnewsetup : bool, optional
+    is_new_setup : bool, optional
         Whether to create the setup from a template. The default is ``True``.
         If ``False``, access is to the existing setup.
 
     """
 
-    def __init__(self, app, solutiontype, setupname="MySetupAuto", isnewsetup=True):
-        Setup.__init__(self, app, solutiontype, setupname, isnewsetup)
+    def __init__(self, app, solution_type, name="MySetupAuto", is_new_setup=True):
+        Setup.__init__(self, app, solution_type, name, is_new_setup)
 
-    @pyaedt_function_handler()
-    def add_subrange(self, rangetype, start, end=None, count=None, unit="GHz", clear=False):
+    @pyaedt_function_handler(rangetype="range_type")
+    def add_subrange(self, range_type, start, end=None, count=None, unit="GHz", clear=False):
         """Add a subrange to the sweep.
 
         Parameters
         ----------
-        rangetype : str
+        range_type : str
             Type of the subrange. Options are ``"LinearCount"``,
             ``"LinearStep"``, and ``"LogScale"``.
         start : float
             Starting frequency.
         end : float
             Stopping frequency.
         count : int or float
@@ -3126,35 +3096,35 @@
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         """
         if clear:
-            self.props["Sweeps"]["Sweep"]["RangeType"] = rangetype
+            self.props["Sweeps"]["Sweep"]["RangeType"] = range_type
             self.props["Sweeps"]["Sweep"]["RangeStart"] = str(start) + unit
-            if rangetype == "LinearCount":
+            if range_type == "LinearCount":
                 self.props["Sweeps"]["Sweep"]["RangeEnd"] = str(end) + unit
                 self.props["Sweeps"]["Sweep"]["RangeCount"] = count
-            elif rangetype == "LinearStep":
+            elif range_type == "LinearStep":
                 self.props["Sweeps"]["Sweep"]["RangeEnd"] = str(end) + unit
                 self.props["Sweeps"]["Sweep"]["RangeStep"] = str(count) + unit
-            elif rangetype == "LogScale":
+            elif range_type == "LogScale":
                 self.props["Sweeps"]["Sweep"]["RangeEnd"] = str(end) + unit
                 self.props["Sweeps"]["Sweep"]["RangeSamples"] = count
             self.props["Sweeps"]["Sweep"]["SweepRanges"] = {"Subrange": []}
             return self.update()
-        sweep_range = {"RangeType": rangetype, "RangeStart": str(start) + unit}
-        if rangetype == "LinearCount":
+        sweep_range = {"RangeType": range_type, "RangeStart": str(start) + unit}
+        if range_type == "LinearCount":
             sweep_range["RangeEnd"] = str(end) + unit
             sweep_range["RangeCount"] = count
-        elif rangetype == "LinearStep":
+        elif range_type == "LinearStep":
             sweep_range["RangeEnd"] = str(end) + unit
             sweep_range["RangeStep"] = str(count) + unit
-        elif rangetype == "LogScale":
+        elif range_type == "LogScale":
             sweep_range["RangeEnd"] = str(end) + unit
             sweep_range["RangeCount"] = self.props["RangeCount"]
             sweep_range["RangeSamples"] = count
         if not self.props["Sweeps"]["Sweep"].get("SweepRanges") or not self.props["Sweeps"]["Sweep"]["SweepRanges"].get(
             "Subrange"
         ):
             self.props["Sweeps"]["Sweep"]["SweepRanges"] = {"Subrange": []}
@@ -3163,28 +3133,28 @@
 
 
 class SetupMaxwell(Setup, object):
     """Initializes, creates, and updates an HFSS setup.
 
     Parameters
     ----------
-    app : :class:`pyaedt.application.Analysis3D.FieldAnalysis3D`
+    app : :class:`pyaedt.application.Analysis.Analysis`
         Inherited app object.
-    solutiontype : int, str
+    solution_type : int, str
         Type of the setup.
-    setupname : str, optional
+    name : str, optional
         Name of the setup. The default is ``"MySetupAuto"``.
-    isnewsetup : bool, optional
+    is_new_setup : bool, optional
         Whether to create the setup from a template. The default is ``True``.
         If ``False``, access is to the existing setup.
 
     """
 
-    def __init__(self, app, solutiontype, setupname="MySetupAuto", isnewsetup=True):
-        Setup.__init__(self, app, solutiontype, setupname, isnewsetup)
+    def __init__(self, app, solution_type, name="MySetupAuto", is_new_setup=True):
+        Setup.__init__(self, app, solution_type, name, is_new_setup)
 
     @pyaedt_function_handler()
     def add_eddy_current_sweep(
         self, range_type="LinearStep", start=0.1, end=100, count=0.1, units="Hz", clear=True, save_all_fields=True
     ):
         """Create a Maxwell Eddy Current Sweep.
 
@@ -3192,17 +3162,17 @@
         ----------
         range_type : str
             Type of the subrange. Options are ``"LinearCount"``,
             ``"LinearStep"``, ``"LogScale"`` and ``"SinglePoints"``.
         start : float
             Starting frequency.
         end : float, optional
-            Stopping frequency. Required for ``rangetype="LinearCount"|"LinearStep"|"LogScale"``.
+            Stopping frequency. Required for ``range_type="LinearCount"|"LinearStep"|"LogScale"``.
         count : int or float, optional
-            Frequency count or frequency step. Required for ``rangetype="LinearCount"|"LinearStep"|"LogScale"``.
+            Frequency count or frequency step. Required for ``range_type="LinearCount"|"LinearStep"|"LogScale"``.
         units : str, optional
             Unit of the frequency. For example, ``"MHz`` or ``"GHz"``. The default is ``"Hz"``.
         clear : bool, optional
             If set to ``True``, all other subranges will be suppressed except the current one under creation.
             Default value is ``False``.
         save_all_fields : bool, optional
             Save fields at all frequency points to save fields for the entire set of sweep ranges.
@@ -3305,61 +3275,62 @@
 class SetupQ3D(Setup, object):
     """Initializes, creates, and updates an Q3D setup.
 
     Parameters
     ----------
     app : :class:`pyaedt.application.Analysis3D.FieldAnalysis3D`
         Inherited app object.
-    solutiontype : int, str
+    solution_type : int, str
         Type of the setup.
-    setupname : str, optional
+    name : str, optional
         Name of the setup. The default is ``"MySetupAuto"``.
-    isnewsetup : bool, optional
+    is_new_setup : bool, optional
         Whether to create the setup from a template. The default is ``True``.
         If ``False``, access is to the existing setup.
 
     """
 
-    def __init__(self, app, solutiontype, setupname="MySetupAuto", isnewsetup=True):
-        Setup.__init__(self, app, solutiontype, setupname, isnewsetup)
+    def __init__(self, app, solution_type, name="MySetupAuto", is_new_setup=True):
+        Setup.__init__(self, app, solution_type, name, is_new_setup)
         self._dc_enabled = True
         self._ac_rl_enbled = True
         self._capacitance_enabled = True
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(freqstart="start_frequency", freqstop="stop_frequency", sweepname="name")
     def create_frequency_sweep(
         self,
         unit=None,
-        freqstart=0,
-        freqstop=20,
+        start_frequency=0.0,
+        stop_frequency=20.0,
         num_of_freq_points=None,
-        sweepname=None,
+        name=None,
         save_fields=True,
         sweep_type="Discrete",
         interpolation_tol=0.5,
         interpolation_max_solutions=250,
     ):
         """Create a sweep with the specified number of points.
 
         Parameters
         ----------
         unit : str, optional
-            Frequency units. The default is ``None`` which takes the Default Desktop units.
-        freqstart : float, str, optional
-            Starting frequency of the sweep. The default is ``0``.
+            Frequency units. The default is ``None``, in which case the default desktop units are used.
+        start_frequency : float, str, optional
+            Starting frequency of the sweep. The default is ``0.0``.
             If a unit is passed with the number, such as``"1MHz"``, the unit is ignored.
-        freqstop : float, str, optional
-            Stopping frequency of the sweep. The default is ``20``.
+        stop_frequency : float, str, optional
+            Stopping frequency of the sweep. The default is ``20.0``.
             If a unit is passed with the number, such as ``"1MHz"``, the unit is ignored.
         num_of_freq_points : int
             Number of frequency points in the range. The default is ``401`` for
             a sweep type of ``"Interpolating"`` or ``"Fast"``. The default is ``5`` for a sweep
             type of ``"Discrete"``.
-        sweepname : str, optional
-            Name of the sweep. The default is ``None``.
+        name : str, optional
+            Name of the sweep. The default is ``None``, in which
+            case a name is automatically assigned.
         save_fields : bool, optional
             Whether to save the fields. The default is ``True``.
         sweep_type : str, optional
             Type of the sweep. Options are ``"Fast"``, ``"Interpolating"``,
             and ``"Discrete"``. The default is ``"Discrete"``.
         interpolation_tol : float, optional
             Error tolerance threshold for the interpolation
@@ -3378,75 +3349,77 @@
         >>> oModule.InsertFrequencySweep
 
         Examples
         --------
         >>> from pyaedt import Q3d
         >>> q3d = Q3d()
         >>> setup = q3d.create_setup("LinearCountSetup")
-        >>> sweep = setup.create_frequency_sweep(unit="GHz", freqstart=0.5, freqstop=1.5, sweepname="Sweep1")
+        >>> sweep = setup.create_frequency_sweep(unit="GHz", start_frequency=0.5,
+        ...                                     stop_frequency=1.5, name="Sweep1")
         >>> q3d.release_desktop(True, True)
         """
         if sweep_type in ["Interpolating", "Fast"]:
             num_of_freq_points = num_of_freq_points or 401
         elif sweep_type == "Discrete":
             num_of_freq_points = num_of_freq_points or 5
         else:
             raise AttributeError("Invalid in `sweep_type`. It has to be either 'Discrete', 'Interpolating', or 'Fast'")
 
-        if sweepname is None:
-            sweepname = generate_unique_name("Sweep")
+        if name is None:
+            name = generate_unique_name("Sweep")
 
-        if sweepname in [sweep.name for sweep in self.sweeps]:
-            oldname = sweepname
-            sweepname = generate_unique_name(oldname)
-            self._app.logger.warning("Sweep %s is already present. Sweep has been renamed in %s.", oldname, sweepname)
-        sweepdata = self.add_sweep(sweepname, sweep_type)
+        if name in [sweep.name for sweep in self.sweeps]:
+            oldname = name
+            name = generate_unique_name(oldname)
+            self._app.logger.warning("Sweep %s is already present. Sweep has been renamed in %s.", oldname, name)
+        sweepdata = self.add_sweep(name, sweep_type)
         if not sweepdata:
             return False
         sweepdata.props["RangeType"] = "LinearCount"
-        sweepdata.props["RangeStart"] = self.p_app.value_with_units(freqstart, unit, "Frequency")
-        sweepdata.props["RangeEnd"] = self.p_app.value_with_units(freqstop, unit, "Frequency")
+        sweepdata.props["RangeStart"] = self.p_app.value_with_units(start_frequency, unit, "Frequency")
+        sweepdata.props["RangeEnd"] = self.p_app.value_with_units(stop_frequency, unit, "Frequency")
         sweepdata.props["RangeCount"] = num_of_freq_points
         sweepdata.props["Type"] = sweep_type
         if sweep_type == "Interpolating":
             sweepdata.props["InterpTolerance"] = interpolation_tol
             sweepdata.props["InterpMaxSolns"] = interpolation_max_solutions
             sweepdata.props["InterpMinSolns"] = 0
             sweepdata.props["InterpMinSubranges"] = 1
         sweepdata.props["SaveFields"] = save_fields if sweep_type == "Discrete" else False
         sweepdata.props["SaveRadFields"] = False
         sweepdata.update()
-        self._app.logger.info("Linear count sweep {} has been correctly created".format(sweepname))
+        self._app.logger.info("Linear count sweep {} has been correctly created".format(name))
         return sweepdata
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(freqstart="start_frequency", freqstop="stop_frequency", sweepname="name")
     def create_linear_step_sweep(
         self,
         unit="GHz",
-        freqstart=0,
-        freqstop=2,
+        start_frequency=0.0,
+        stop_frequency=2.0,
         step_size=0.05,
-        sweepname=None,
+        name=None,
         save_fields=True,
         sweep_type="Discrete",
     ):
-        """Create a Sweep with a specified frequency step.
+        """Create a sweep with a specified frequency step.
 
         Parameters
         ----------
-        unit : str
-            Unit of the frequency. For example, ``"MHz`` or ``"GHz"``.
-        freqstart : float
-            Starting frequency of the sweep.
-        freqstop : float
-            Stopping frequency of the sweep.
-        step_size : float
-            Frequency size of the step.
-        sweepname : str, optional
-            Name of the sweep. The default is ``None``.
+        unit : str, optional
+            Unit of the frequency. The default is ``"GHz"``.
+        start_frequency : float, optional
+            Starting frequency of the sweep. The default is ``0.0``.
+        stop_frequency : float, optional
+            Stopping frequency of the sweep. The default is ``2.0``.
+        step_size : float, optional
+            Frequency size of the step. The default is ``0.05``.
+        name : str, optional
+            Name of the sweep. The default is ``None``, in which
+            case a name is automatically assigned.
         save_fields : bool, optional
             Whether to save the fields. The default is ``True``.
         sweep_type : str, optional
             Whether to create a ``"Discrete"`` or``"Interpolating"``  sweep.
             The default is ``"Discrete"``.
 
         Returns
@@ -3462,71 +3435,74 @@
         Examples
         --------
         Create a setup named ``"LinearStepSetup"`` and use it in a linear step sweep
         named ``"LinearStepSweep"``.
         >>> from pyaedt import Q3d
         >>> q3d = Q3d()
         >>> setup = q3d.create_setup("LinearStepSetup")
-        >>> linear_step_sweep = setup.create_linear_step_sweep(sweepname="LinearStepSweep",
-        ...                                                   unit="MHz", freqstart=1.1e3,
-        ...                                                   freqstop=1200.1, step_size=153.8)
+        >>> linear_step_sweep = setup.create_linear_step_sweep(name="LinearStepSweep",
+        ...                                                   unit="MHz", start_frequency=1.1e3,
+        ...                                                   stop_frequency=1200.1, step_size=153.8)
         >>> type(linear_step_sweep)
         >>> q3d.release_desktop(True, True)
         """
         if sweep_type not in ["Discrete", "Interpolating", "Fast"]:
             raise AttributeError("Invalid in `sweep_type`. It has to be either 'Discrete', 'Interpolating', or 'Fast'")
-        if sweepname is None:
-            sweepname = generate_unique_name("Sweep")
+        if name is None:
+            name = generate_unique_name("Sweep")
 
-        if sweepname in [sweep.name for sweep in self.sweeps]:
-            oldname = sweepname
-            sweepname = generate_unique_name(oldname)
-            self._app.logger.warning("Sweep %s is already present. Sweep has been renamed in %s.", oldname, sweepname)
-        sweepdata = self.add_sweep(sweepname, sweep_type)
+        if name in [sweep.name for sweep in self.sweeps]:
+            oldname = name
+            name = generate_unique_name(oldname)
+            self._app.logger.warning("Sweep %s is already present. Sweep has been renamed in %s.", oldname, name)
+        sweepdata = self.add_sweep(name, sweep_type)
         if not sweepdata:
             return False
         sweepdata.props["RangeType"] = "LinearStep"
-        sweepdata.props["RangeStart"] = str(freqstart) + unit
-        sweepdata.props["RangeEnd"] = str(freqstop) + unit
+        sweepdata.props["RangeStart"] = str(start_frequency) + unit
+        sweepdata.props["RangeEnd"] = str(stop_frequency) + unit
         sweepdata.props["RangeStep"] = str(step_size) + unit
         sweepdata.props["SaveFields"] = save_fields if sweep_type == "Discrete" else False
         sweepdata.props["SaveRadFields"] = False
         sweepdata.props["ExtrapToDC"] = False
         sweepdata.props["Type"] = sweep_type
         if sweep_type == "Interpolating":
             sweepdata.props["InterpTolerance"] = 0.5
             sweepdata.props["InterpMaxSolns"] = 250
             sweepdata.props["InterpMinSolns"] = 0
             sweepdata.props["InterpMinSubranges"] = 1
         sweepdata.update()
-        self._app.logger.info("Linear step sweep {} has been correctly created".format(sweepname))
+        self._app.logger.info("Linear step sweep {} has been correctly created".format(name))
         return sweepdata
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(sweepname="name")
     def create_single_point_sweep(
         self,
         unit="GHz",
-        freq=1,
-        sweepname=None,
+        freq=1.0,
+        name=None,
         save_single_field=True,
         save_fields=False,
     ):
-        """Create a Sweep with a single frequency point.
+        """Create a sweep with a single frequency point.
 
         Parameters
         ----------
-        unit : str
-            Unit of the frequency. For example, ``"MHz`` or ``"GHz"``.
-        freq : float, list
-            Frequency of the single point or list of frequencies to create distinct single points.
-        sweepname : str, optional
-            Name of the sweep. The default is ``None``.
+        unit : str, optional
+            Unit of the frequency. The default is ``"GHz"``.
+        freq : float, list, optional
+            One or more frequencies for creating distinct single points.
+            The default is ``1.0``.
+        name : str, optional
+            Name of the sweep. The default is ``None``, in which
+            case a name is automatically assigned.
         save_single_field : bool, list, optional
             Whether to save the fields of the single point. The default is ``True``.
-            If a list is specified, the length must be the same as freq length.
+            If a list is specified, the length must be the same as the
+            frequency length.
         save_fields : bool, optional
             Whether to save the fields for all points and subranges defined in the sweep. The default is ``False``.
 
         Returns
         -------
         :class:`pyaedt.modules.SolveSweeps.SweepQ3D` or bool
             Sweep object if successful, ``False`` otherwise.
@@ -3538,22 +3514,22 @@
         Examples
         --------
         Create a setup named ``"SinglePointSetup"`` and use it in a single point sweep
         named ``"SinglePointSweep"``.
         >>> from pyaedt import Q3d
         >>> q3d = Q3d()
         >>> setup = q3d.create_setup("SinglePointSetup")
-        >>> single_point_sweep = setup.create_single_point_sweep(setupname="SinglePointSetup",
-        ...                                                   sweepname="SinglePointSweep",
+        >>> single_point_sweep = setup.create_single_point_sweep(
+        ...                                                   name="SinglePointSweep",
         ...                                                   unit="MHz", freq=1.1e3)
         >>> type(single_point_sweep)
         >>> q3d.release_desktop(True, True)
         """
-        if sweepname is None:
-            sweepname = generate_unique_name("SinglePoint")
+        if name is None:
+            name = generate_unique_name("SinglePoint")
 
         if isinstance(save_single_field, list):
             if not isinstance(freq, list) or len(save_single_field) != len(freq):
                 raise AttributeError("The length of save_single_field must be the same as freq length.")
 
         add_subranges = False
         if isinstance(freq, list):
@@ -3568,101 +3544,103 @@
         if isinstance(save_single_field, list):
             save0 = save_single_field.pop(0)
         else:
             save0 = save_single_field
             if add_subranges:
                 save_single_field = [save0] * len(freq)
 
-        if sweepname in [sweep.name for sweep in self.sweeps]:
-            oldname = sweepname
-            sweepname = generate_unique_name(oldname)
-            self._app.logger.warning("Sweep %s is already present. Sweep has been renamed in %s.", oldname, sweepname)
-        sweepdata = self.add_sweep(sweepname, "Discrete")
+        if name in [sweep.name for sweep in self.sweeps]:
+            oldname = name
+            name = generate_unique_name(oldname)
+            self._app.logger.warning("Sweep %s is already present. Sweep has been renamed in %s.", oldname, name)
+        sweepdata = self.add_sweep(name, "Discrete")
         sweepdata.props["RangeType"] = "SinglePoints"
         sweepdata.props["RangeStart"] = str(freq0) + unit
         sweepdata.props["RangeEnd"] = str(freq0) + unit
         sweepdata.props["SaveSingleField"] = save0
         sweepdata.props["SaveFields"] = save_fields
         sweepdata.props["SaveRadFields"] = False
         sweepdata.props["SMatrixOnlySolveMode"] = "Auto"
         if add_subranges:
             for f, s in zip(freq, save_single_field):
                 sweepdata.add_subrange(rangetype="SinglePoints", start=f, unit=unit, save_single_fields=s)
         sweepdata.update()
-        self._app.logger.info("Single point sweep {} has been correctly created".format(sweepname))
+        self._app.logger.info("Single point sweep {} has been correctly created".format(name))
         return sweepdata
 
-    @pyaedt_function_handler()
-    def add_sweep(self, sweepname=None, sweeptype="Interpolating"):
+    @pyaedt_function_handler(sweepname="name", sweeptype="sweep_type")
+    def add_sweep(self, name=None, sweep_type="Interpolating"):
         """Add a sweep to the project.
 
         Parameters
         ----------
-        sweepname : str, optional
-            Name of the sweep. The default is ``None``.
-        sweeptype : str, optional
+        name : str, optional
+            Name of the sweep. The default is ``None``, in which
+            case a name is automatically assigned.
+        sweep_type : str, optional
             Type of the sweep. The default is ``"Interpolating"``.
 
         Returns
         -------
         :class:`pyaedt.modules.SolveSweeps.SweepHFSS` or :class:`pyaedt.modules.SolveSweeps.SweepMatrix`
             Sweep object.
 
         References
         ----------
 
         >>> oModule.InsertFrequencySweep
         """
-        if not sweepname:
-            sweepname = generate_unique_name("Sweep")
+        if not name:
+            name = generate_unique_name("Sweep")
         if self.setuptype == 7:
             self._app.logger.warning("This method only applies to HFSS and Q3D. Use add_eddy_current_sweep method.")
             return False
         if self.setuptype <= 4:
-            sweep_n = SweepHFSS(self, sweepname=sweepname, sweeptype=sweeptype)
+            sweep_n = SweepHFSS(self, name=name, sweep_type=sweep_type)
         elif self.setuptype in [14, 30, 31]:
-            sweep_n = SweepMatrix(self, sweepname=sweepname, sweeptype=sweeptype)
+            sweep_n = SweepMatrix(self, name=name, sweep_type=sweep_type)
         else:
-            self._app.logger.warning("This method only applies to HFSS, Q2D and Q3D.")
+            self._app.logger.warning("This method only applies to HFSS, Q2D, and Q3D.")
             return False
         sweep_n.create()
         self.sweeps.append(sweep_n)
         for setup in self.p_app.setups:
             if self.name == setup.name:
                 setup.sweeps.append(sweep_n)
                 break
         return sweep_n
 
-    @pyaedt_function_handler()
-    def get_sweep(self, sweepname=None):
-        """Return frequency sweep object of a given sweep.
+    @pyaedt_function_handler(sweepname="name")
+    def get_sweep(self, name=None):
+        """Get the frequency sweep object of a given sweep.
 
         Parameters
         ----------
-        sweepname : str, optional
-            Name of the sweep. the default is ``None`` which returns the first sweep.
+        name : str, optional
+            Name of the sweep. The default is ``None``, in which case the
+            first sweep is used.
 
         Returns
         -------
         :class:`pyaedt.modules.SolveSweeps.SweepQ3D` or :class:`pyaedt.modules.SolveSweeps.SweepMatrix`
 
         Examples
         --------
         >>> from pyaedt import Q3d
         >>> q3d = Q3d()
         >>> setup = q3d.create_setup()
-        >>> sweep = setup.create_frequency_sweep(sweepname="Sweep1")
-        >>> sweep.add_subrange("LinearCount", 0, 10, 1, "Hz")
-        >>> sweep.add_subrange("LogScale", 10, 1E8, 100, "Hz")
+        >>> sweep = setup.create_frequency_sweep(name="Sweep1")
+        >>> sweep.add_subrange("LinearCount",0,10,1,"Hz")
+        >>> sweep.add_subrange("LogScale",10,1E8,100,"Hz")
         >>> sweep = setup.get_sweep("Sweep1")
         >>> q3d.release_desktop(True, True)
         """
-        if sweepname:
+        if name:
             for sweep in self.sweeps:
-                if sweepname == sweep.name:
+                if name == sweep.name:
                     return sweep
         else:
             if self.sweeps:
                 return self.sweeps[0]
         return False
 
     @property
```

### Comparing `pyaedt-0.8.7/pyaedt/modules/SolveSweeps.py` & `pyaedt-0.8.8/pyaedt/modules/SolveSweeps.py`

 * *Files 8% similar despite different names*

```diff
@@ -58,96 +58,82 @@
 
 
 class SweepHFSS(object):
     """Initializes, creates, and updates sweeps in HFSS.
 
     Parameters
     ----------
-    app : :class 'pyaedt.modules.SolveSetup.Setup'
+    setup : :class 'pyaedt.modules.SolveSetup.Setup'
         Setup to use for the analysis.
-    setupname : str
-        Name of the setup.
-    sweepname : str
+    name : str
         Name of the sweep.
-    sweeptype : str, optional
+    sweep_type : str, optional
         Type of the sweep. Options are ``"Fast"``, ``"Interpolating"``,
         and ``"Discrete"``. The default is ``"Interpolating"``.
     props : dict, optional
         Dictionary of the properties. The default is ``None``, in which case
         the default properties are retrieved.
 
     Examples
     --------
     >>> hfss = Hfss(specified_version=version, projectname=proj, designname=gtemDesign, solution_type=solutiontype,
-                    setup_name=setupname, new_desktop_session=False, close_on_exit=False)
+                    setup_name=setup_name, new_desktop_session=False, close_on_exit=False)
     >>> hfss_setup = hfss.setups[0]
-    >>> hfss_sweep = SweepHFSS(hfss_setup, 'Sweep', sweeptype ='Interpolating', props=None)
+    >>> hfss_sweep = SweepHFSS(hfss_setup, 'Sweep', sweep_type ='Interpolating', props=None)
 
     """
 
-    def __init__(self, setup, sweepname, sweeptype="Interpolating", props=None, **kwargs):
-        if "app" in kwargs:
-            warnings.warn(
-                "`app` is deprecated since v0.6.22. Use `setup` instead.",
-                DeprecationWarning,
-            )
-            setup = kwargs["app"]
-        if "setupname" in kwargs:
-            warnings.warn(
-                "`setupname` is deprecated since v0.6.22. It is no longer required.",
-                DeprecationWarning,
-            )
-
+    def __init__(self, setup, name, sweep_type="Interpolating", props=None):
         self._app = setup
         self.oanalysis = setup.omodule
         self.props = {}
-        self.setupname = setup.name
-        self.name = sweepname
+        self.setup_name = setup.name
+        self.name = name
         if props:
             self.props = props
         else:
             self.props = copy.deepcopy(SweepHfss3D)
             # for t in SweepHfss3D:
             #    _tuple2dict(t, self.props)
-            if SequenceMatcher(None, sweeptype.lower(), "interpolating").ratio() > 0.8:
-                sweeptype = "Interpolating"
-            elif SequenceMatcher(None, sweeptype.lower(), "discrete").ratio() > 0.8:
-                sweeptype = "Discrete"
-            elif SequenceMatcher(None, sweeptype.lower(), "fast").ratio() > 0.8:
-                sweeptype = "Fast"
+            if SequenceMatcher(None, sweep_type.lower(), "interpolating").ratio() > 0.8:
+                sweep_type = "Interpolating"
+            elif SequenceMatcher(None, sweep_type.lower(), "discrete").ratio() > 0.8:
+                sweep_type = "Discrete"
+            elif SequenceMatcher(None, sweep_type.lower(), "fast").ratio() > 0.8:
+                sweep_type = "Fast"
             else:
                 warnings.warn("Invalid sweep type. `Interpolating` will be set as the default.")
-                sweeptype = "Interpolating"
-            self.props["Type"] = sweeptype
+                sweep_type = "Interpolating"
+            self.props["Type"] = sweep_type
 
     @property
     def is_solved(self):
         """Verify if solutions are available for the sweep.
 
         Returns
         -------
         bool
             `True` if solutions are available.
         """
-        sol = self._app.p_app.post.reports_by_category.standard(setup_name="{} : {}".format(self.setupname, self.name))
+        sol = self._app.p_app.post.reports_by_category.standard(setup="{} : {}".format(self.setup_name, self.name))
         if identify_setup(self.props):
             sol.domain = "Time"
         return True if sol.get_solution_data() else False
 
     @property
     def frequencies(self):
         """List of all frequencies of the active sweep.
         To see values, the project must be saved and solved.
 
         Returns
         -------
         list of float
             Frequency points.
         """
-        sol = self._app.p_app.post.reports_by_category.standard(setup_name="{} : {}".format(self.setupname, self.name))
+        sol = self._app.p_app.post.reports_by_category.standard(setup="{} : {}".format(self.setup_name, self.name))
         soldata = sol.get_solution_data()
         if soldata and "Freq" in soldata.intrinsics:
             return soldata.intrinsics["Freq"]
         return []
 
     @property
     def basis_frequencies(self):
@@ -176,101 +162,101 @@
                         )
                         fr.append(new_list)
                     except (KeyError, NameError, IndexError):
                         pass
 
         count = 0
         for el in self._app.p_app.setups:
-            if el.name == self.setupname:
+            if el.name == self.setup_name:
                 for sweep in el.sweeps:
                     if sweep.name == self.name:
                         return fr[count] if len(fr) >= count + 1 else []
             else:
                 for sweep in el.sweeps:
                     if sweep.name == self.name:
                         count += 1
         return []
 
-    @pyaedt_function_handler()
-    def add_subrange(self, rangetype, start, end=None, count=None, unit="GHz", save_single_fields=False, clear=False):
+    @pyaedt_function_handler(rangetype="range_type")
+    def add_subrange(self, range_type, start, end=None, count=None, unit="GHz", save_single_fields=False, clear=False):
         """Add a range to the sweep.
 
         Parameters
         ----------
-        rangetype : str
+        range_type : str
             Type of the range. Options are ``"LinearCount"``,
             ``"LinearStep"``, ``"LogScale"``, and ``"SinglePoints"``.
         start : float
             Starting frequency.
         end : float, optional
             Stopping frequency. The default value is ``None``. A value is required for
-            ``rangetype="LinearCount"|"LinearStep"|"LogScale"``.
+            ``range_type="LinearCount"|"LinearStep"|"LogScale"``.
         count : int or float, optional
             Frequency count or frequency step. The default is ``None``. A value is required for
-            ``rangetype="LinearCount"|"LinearStep"|"LogScale"``.
+            ``range_type="LinearCount"|"LinearStep"|"LogScale"``.
         unit : str, optional
             Unit of the frequency. For example, ``"MHz`` or ``"GHz"``. The default is ``"GHz"``.
         save_single_fields : bool, optional
             Whether to save the fields of the single point. The default is ``False``.
-            This parameter is sed only for ``rangetype="SinglePoints"``.
-        clear : boolean, optional
+            This parameter is used only for ``range_type="SinglePoints"``.
+        clear : bool, optional
             Whether to suppress all other subranges except the current one under creation.
             The default value is ``False``.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         Examples
         --------
         Create a setup in an HFSS design and add multiple sweep ranges.
 
-        >>> setup = hfss.create_setup(setupname="MySetup")
+        >>> setup = hfss.create_setup(setup_name="MySetup")
         >>> sweep = setup.add_sweep()
         >>> sweep.change_type("Interpolating")
         >>> sweep.change_range("LinearStep", 1.1, 2.1, 0.4, "GHz")
-        >>> sweep.add_subrange("LinearCount", 1, 1.5, 5, "MHz")
-        >>> sweep.add_subrange("LogScale", 1, 3, 10, "GHz")
+        >>> sweep.add_subrange("LinearCount",1,1.5,5,"MHz")
+        >>> sweep.add_subrange("LogScale",1,3,10,"GHz")
 
         """
-        if rangetype == "LinearCount" or rangetype == "LinearStep" or rangetype == "LogScale":
+        if range_type == "LinearCount" or range_type == "LinearStep" or range_type == "LogScale":
             if not end or not count:
                 raise AttributeError("Parameters 'end' and 'count' must be present.")
 
         if clear:
-            self.props["RangeType"] = rangetype
+            self.props["RangeType"] = range_type
             self.props["RangeStart"] = str(start) + unit
-            if rangetype == "LinearCount":
+            if range_type == "LinearCount":
                 self.props["RangeEnd"] = str(end) + unit
                 self.props["RangeCount"] = count
-            elif rangetype == "LinearStep":
+            elif range_type == "LinearStep":
                 self.props["RangeEnd"] = str(end) + unit
                 self.props["RangeStep"] = str(count) + unit
-            elif rangetype == "LogScale":
+            elif range_type == "LogScale":
                 self.props["RangeEnd"] = str(end) + unit
                 self.props["RangeSamples"] = count
-            elif rangetype == "SinglePoints":
+            elif range_type == "SinglePoints":
                 self.props["RangeEnd"] = str(start) + unit
                 self.props["SaveSingleField"] = save_single_fields
             self.props["SweepRanges"] = {"Subrange": []}
             return self.update()
 
-        interval = {"RangeType": rangetype, "RangeStart": str(start) + unit}
-        if rangetype == "LinearCount":
+        interval = {"RangeType": range_type, "RangeStart": str(start) + unit}
+        if range_type == "LinearCount":
             interval["RangeEnd"] = str(end) + unit
             interval["RangeCount"] = count
-        elif rangetype == "LinearStep":
+        elif range_type == "LinearStep":
             interval["RangeEnd"] = str(end) + unit
             interval["RangeStep"] = str(count) + unit
-        elif rangetype == "LogScale":
+        elif range_type == "LogScale":
             interval["RangeEnd"] = str(end) + unit
             interval["RangeCount"] = self.props["RangeCount"]
             interval["RangeSamples"] = count
-        elif rangetype == "SinglePoints":
+        elif range_type == "SinglePoints":
             interval["RangeEnd"] = str(start) + unit
             interval["SaveSingleField"] = save_single_fields
         if not self.props.get("SweepRanges", None):
             self.props["SweepRanges"] = {"Subrange": []}
 
         if not isinstance(self.props["SweepRanges"]["Subrange"], list):
             self.props["SweepRanges"]["Subrange"] = [self.props["SweepRanges"]["Subrange"]]
@@ -284,28 +270,28 @@
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         """
-        self.oanalysis.InsertFrequencySweep(self.setupname, self._get_args())
+        self.oanalysis.InsertFrequencySweep(self.setup_name, self._get_args())
         return True
 
     @pyaedt_function_handler()
     def update(self):
         """Update a sweep.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         """
-        self.oanalysis.EditFrequencySweep(self.setupname, self.name, self._get_args())
+        self.oanalysis.EditFrequencySweep(self.setup_name, self.name, self._get_args())
 
         return True
 
     @pyaedt_function_handler()
     def _get_args(self, props=None):
         """Get arguments.
 
@@ -329,114 +315,98 @@
 
 
 class SweepHFSS3DLayout(object):
     """Initializes, creates, and updates sweeps in HFSS 3D Layout.
 
     Parameters
     ----------
-    app : :class 'pyaedt.modules.SolveSetup.Setup'
+    setup : :class 'pyaedt.modules.SolveSetup.Setup'
         Setup to use for the analysis.
-    setupname : str
-        Name of the setup.
-    sweepname : str
+    name : str
         Name of the sweep.
-    sweeptype : str, optional
+    sweep_type : str, optional
         Type of the sweep. Options are ``"Interpolating"`` and ``"Discrete"``. The default is ``"Interpolating"``.
     save_fields : bool, optional
         Whether to save the fields. The default is ``True``.
     props : dict, optional
         Dictionary of the properties. The default is ``None``, in which
         case the default properties are retrieved.
 
     """
 
-    def __init__(self, setup, sweepname, sweeptype="Interpolating", save_fields=True, props=None, **kwargs):
-        if "app" in kwargs:
-            warnings.warn(
-                "`app` is deprecated since v0.6.22. Use `setup` instead.",
-                DeprecationWarning,
-            )
-            setup = kwargs["app"]
-        if "setupname" in kwargs:
-            warnings.warn(
-                "`setupname` is deprecated since v0.6.22. It is no longer required.",
-                DeprecationWarning,
-            )
-
+    def __init__(self, setup, name, sweep_type="Interpolating", save_fields=True, props=None, **kwargs):
         self._app = setup
         self.oanalysis = setup.omodule
         self.props = {}
-        self.setupname = setup.name
-        self.name = sweepname
+        self.setup_name = setup.name
+        self.name = name
         if props:
             self.props = props
         else:
             if setup.setuptype in [40, 41]:
                 self.props = copy.deepcopy(SweepSiwave)
             else:
                 self.props = copy.deepcopy(Sweep3DLayout)
             # for t in props:
             #    _tuple2dict(t, self.props)
-            if SequenceMatcher(None, sweeptype.lower(), "interpolating").ratio() > 0.8:
-                sweeptype = "kInterpolating"
-            elif SequenceMatcher(None, sweeptype.lower(), "discrete").ratio() > 0.8:
-                sweeptype = "kDiscrete"
-            elif SequenceMatcher(None, sweeptype.lower(), "fast").ratio() > 0.8:
-                sweeptype = "kBroadbandFast"
+            if SequenceMatcher(None, sweep_type.lower(), "interpolating").ratio() > 0.8:
+                sweep_type = "kInterpolating"
+            elif SequenceMatcher(None, sweep_type.lower(), "discrete").ratio() > 0.8:
+                sweep_type = "kDiscrete"
+            elif SequenceMatcher(None, sweep_type.lower(), "fast").ratio() > 0.8:
+                sweep_type = "kBroadbandFast"
             else:
                 warnings.warn("Sweep type is invalid. `kInterpolating` is set as the default.")
-                sweeptype = "kInterpolating"
-            self.props["FreqSweepType"] = sweeptype
+                sweep_type = "kInterpolating"
+            self.props["FreqSweepType"] = sweep_type
             self.props["GenerateSurfaceCurrent"] = save_fields
 
     @property
     def combined_name(self):
-        """Compute the setupname : sweepname string.
+        """Compute the setup_name : sweep_name string.
 
         Returns
         -------
         str
         """
-        return "{} : {}".format(self.setupname, self.name)
+        return "{} : {}".format(self.setup_name, self.name)
 
     @property
     def is_solved(self):
         """Verify if solutions are available for the sweep.
 
         Returns
         -------
         bool
             `True` if solutions are available.
         """
         expressions = [i for i in self.p_app.post.available_report_quantities(solution=self.combined_name)]
-        sol = self._app._app.post.reports_by_category.standard(
-            setup_name=self.combined_name, expressions=expressions[0]
-        )
+        sol = self._app._app.post.reports_by_category.standard(expressions=expressions[0], setup=self.combined_name)
         if identify_setup(self.props):
             sol.domain = "Time"
         return True if sol.get_solution_data() else False
 
-    @pyaedt_function_handler()
-    def change_type(self, sweeptype):
+    @pyaedt_function_handler(sweeptype="sweep_type")
+    def change_type(self, sweep_type):
         """Change the type of the sweep.
 
         Parameters
         ----------
-        sweeptype : str
+        sweep_type : str
             Type of the sweep. Options are ``"Interpolating"`` and ``"Discrete"``.
             The default is ``"Interpolating"``.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
         """
-        if sweeptype == "Interpolating":
+        if sweep_type == "Interpolating":
             self.props["FastSweep"] = True
-        elif sweeptype == "Discrete":
+        elif sweep_type == "Discrete":
             self.props["FastSweep"] = False
         else:
             raise AttributeError("Allowed sweep type options are 'Interpolating' and 'Discrete'.")
         return self.update()
 
     @pyaedt_function_handler()
     def set_save_fields(self, save_fields, save_rad_fields=False):
@@ -454,21 +424,21 @@
         bool
             ``True`` when successful, ``False`` when failed.
         """
         self.props["GenerateSurfaceCurrent"] = save_fields
         self.props["SaveRadFieldsOnly"] = save_rad_fields
         return self.update()
 
-    @pyaedt_function_handler()
-    def add_subrange(self, rangetype, start, end=None, count=None, unit="GHz"):
+    @pyaedt_function_handler(rangetype="range_type")
+    def add_subrange(self, range_type, start, end=None, count=None, unit="GHz"):
         """Add a subrange to the sweep.
 
         Parameters
         ----------
-        rangetype : str
+        range_type : str
             Type of the subrange. Options are ``"LinearCount"``, ``"SinglePoint"``,
             ``"LinearStep"``, and ``"LogScale"``.
         start : float
             Starting frequency.
         end : float, optional
             Stopping frequency. The default is ``None``. A value is
             required for these subranges: ``"LinearCount"``, ``"LinearStep"``, and ``"LogScale"``.
@@ -481,44 +451,44 @@
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
         """
         try:
-            if rangetype == "SinglePoint" and self.props["FreqSweepType"] == "kInterpolating":
-                raise AttributeError("'SinglePoint is allowed only when sweeptype is 'Discrete'.'")
-            if rangetype == "LinearCount" or rangetype == "LinearStep" or rangetype == "LogScale":
+            if range_type == "SinglePoint" and self.props["FreqSweepType"] == "kInterpolating":
+                raise AttributeError("'SinglePoint is allowed only when sweep_type is 'Discrete'.'")
+            if range_type == "LinearCount" or range_type == "LinearStep" or range_type == "LogScale":
                 if not end or not count:
                     raise AttributeError("Parameters 'end' and 'count' must be present.")
 
-            if rangetype == "LinearCount":
+            if range_type == "LinearCount":
                 sweep_range = " LINC " + str(start) + unit + " " + str(end) + unit + " " + str(count)
-            elif rangetype == "LinearStep":
+            elif range_type == "LinearStep":
                 sweep_range = " LIN " + str(start) + unit + " " + str(end) + unit + " " + str(count) + unit
-            elif rangetype == "LogScale":
+            elif range_type == "LogScale":
                 sweep_range = " DEC " + str(start) + unit + " " + str(end) + unit + " " + str(count)
-            elif rangetype == "SinglePoint":
+            elif range_type == "SinglePoint":
                 sweep_range = " " + str(start) + unit
             else:
                 raise AttributeError(
-                    'Allowed rangetype are "LinearCount", "SinglePoint", "LinearStep", and "LogScale".'
+                    'Allowed range_type are "LinearCount", "SinglePoint", "LinearStep", and "LogScale".'
                 )
             self.props["Sweeps"]["Data"] += sweep_range
             return self.update()
         except Exception:
             return False
 
-    @pyaedt_function_handler()
-    def change_range(self, rangetype, start, end=None, count=None, unit="GHz"):
+    @pyaedt_function_handler(rangetype="range_type")
+    def change_range(self, range_type, start, end=None, count=None, unit="GHz"):
         """Change the range of the sweep.
 
         Parameters
         ----------
-        rangetype : str
+        range_type : str
             Type of the subrange. Options are ``"LinearCount"``, ``"SinglePoint"``,
             ``"LinearStep"``, and ``"LogScale"``.
         start : float
             Starting frequency.
         end : float, optional
             Stopping frequency. The default is ``None``.  A value is required
             for these subranges: ``"LinearCount"``, ``"LinearStep"``, and ``"LogScale"``.
@@ -531,51 +501,51 @@
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         """
-        if rangetype == "LinearCount":
+        if range_type == "LinearCount":
             sweep_range = "LINC " + str(start) + unit + " " + str(end) + unit + " " + str(count)
-        elif rangetype == "LinearStep":
+        elif range_type == "LinearStep":
             sweep_range = "LIN " + str(start) + unit + " " + str(end) + unit + " " + str(count) + unit
-        elif rangetype == "LogScale":
+        elif range_type == "LogScale":
             sweep_range = "DEC " + str(start) + unit + " " + str(end) + unit + " " + str(count)
-        elif rangetype == "SinglePoint":
+        elif range_type == "SinglePoint":
             sweep_range = str(start) + unit
         else:
-            raise AttributeError('Allowed rangetype are "LinearCount", "SinglePoint", "LinearStep", and "LogScale".')
+            raise AttributeError('Allowed range_type are "LinearCount", "SinglePoint", "LinearStep", and "LogScale".')
         self.props["Sweeps"]["Data"] = sweep_range
         return self.update()
 
     @pyaedt_function_handler()
     def create(self):
         """Create a sweep.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         """
-        self.oanalysis.AddSweep(self.setupname, self._get_args())
+        self.oanalysis.AddSweep(self.setup_name, self._get_args())
         return True
 
     @pyaedt_function_handler()
     def update(self):
         """Update the sweep.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         """
-        self.oanalysis.EditSweep(self.setupname, self.name, self._get_args())
+        self.oanalysis.EditSweep(self.setup_name, self.name, self._get_args())
         return True
 
     @pyaedt_function_handler()
     def _get_args(self, props=None):
         """Retrieve properties.
 
         Parameters
@@ -598,51 +568,38 @@
 
 
 class SweepMatrix(object):
     """Initializes, creates, and updates sweeps in Q3D.
 
     Parameters
     ----------
-    app : :class 'pyaedt.modules.SolveSetup.Setup'
+    setup : :class 'pyaedt.modules.SolveSetup.Setup'
         Setup used for the analysis.
-    setupname : str
-        Name of the setup.
-    sweepname : str
+    name : str
         Name of the sweep.
-    sweeptype : str, optional
+    sweep_type : str, optional
         Type of the sweep. Options are ``"Fast"``, ``"Interpolating"``,
         and ``"Discrete"``. The default is ``"Interpolating"``.
     props : dict
         Dictionary of the properties.  The default is ``None``, in which case
         the default properties are retrieved.
 
     """
 
-    def __init__(self, setup, sweepname, sweeptype="Interpolating", props=None, **kwargs):
-        if "app" in kwargs:
-            warnings.warn(
-                "`app` is deprecated since v0.6.22. Use `setup` instead.",
-                DeprecationWarning,
-            )
-            setup = kwargs["app"]
-        if "setupname" in kwargs:
-            warnings.warn(
-                "`setupname` is deprecated since v0.6.22. It is no longer required.",
-                DeprecationWarning,
-            )
+    def __init__(self, setup, name, sweep_type="Interpolating", props=None):
         self._app = setup
         self.oanalysis = setup.omodule
-        self.setupname = setup.name
-        self.name = sweepname
+        self.setup_name = setup.name
+        self.name = name
         self.props = {}
         if props:
             self.props = props
         else:
-            self.props["Type"] = sweeptype
-            if sweeptype == "Discrete":
+            self.props["Type"] = sweep_type
+            if sweep_type == "Discrete":
                 self.props["isenabled"] = True
                 self.props["RangeType"] = "LinearCount"
                 self.props["RangeStart"] = "2.5GHz"
                 self.props["RangeStep"] = "1GHz"
                 self.props["RangeEnd"] = "7.5GHz"
                 self.props["SaveSingleField"] = False
                 self.props["RangeSamples"] = 3
@@ -668,28 +625,28 @@
         """Verify if solutions are available for given sweep.
 
         Returns
         -------
         bool
             `True` if solutions are available.
         """
-        sol = self._app.p_app.post.reports_by_category.standard(setup_name="{} : {}".format(self.setupname, self.name))
+        sol = self._app.p_app.post.reports_by_category.standard(setup="{} : {}".format(self.setup_name, self.name))
         return True if sol.get_solution_data() else False
 
     @property
     def frequencies(self):
         """List of all frequencies of the active sweep.
         To see values, the project must be saved and solved.
 
         Returns
         -------
         list of float
             Frequency points.
         """
-        sol = self._app.p_app.post.reports_by_category.standard(setup_name="{} : {}".format(self.setupname, self.name))
+        sol = self._app.p_app.post.reports_by_category.standard(setup="{} : {}".format(self.setup_name, self.name))
         soldata = sol.get_solution_data()
         if soldata and "Freq" in soldata.intrinsics:
             return soldata.intrinsics["Freq"]
         return []
 
     @property
     def basis_frequencies(self):
@@ -718,31 +675,31 @@
                         )
                         fr.append(new_list)
                     except (KeyError, NameError, IndexError):
                         pass
 
         count = 0
         for el in self._app.p_app.setups:
-            if el.name == self.setupname:
+            if el.name == self.setup_name:
                 for sweep in el.sweeps:
                     if sweep.name == self.name:
                         return fr[count] if len(fr) >= count + 1 else []
             else:
                 for sweep in el.sweeps:
                     if sweep.name == self.name:
                         count += 1
         return []
 
-    @pyaedt_function_handler()
-    def add_subrange(self, rangetype, start, end=None, count=None, unit="GHz", clear=False, **kwargs):
+    @pyaedt_function_handler(rangetype="range_type")
+    def add_subrange(self, range_type, start, end=None, count=None, unit="GHz", clear=False, **kwargs):
         """Add a subrange to the sweep.
 
         Parameters
         ----------
-        rangetype : str
+        range_type : str
             Type of the subrange. Options are ``"LinearCount"``,
             ``"LinearStep"``, and ``"LogScale"``.
         start : float
             Starting frequency.
         end : float
             Stopping frequency. The default is ``None``.
         count : int or float
@@ -756,38 +713,38 @@
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         """
         if "type" in kwargs:
-            warnings.warn("'type' has been deprecated. Use 'rangetype' instead.", DeprecationWarning)
-            rangetype = kwargs["type"]
+            warnings.warn("'type' has been deprecated. Use 'range_type' instead.", DeprecationWarning)
+            range_type = kwargs["type"]
         if clear:
-            self.props["RangeType"] = rangetype
+            self.props["RangeType"] = range_type
             self.props["RangeStart"] = str(start) + unit
-            if rangetype == "LinearCount":
+            if range_type == "LinearCount":
                 self.props["RangeEnd"] = str(end) + unit
                 self.props["RangeCount"] = count
-            elif rangetype == "LinearStep":
+            elif range_type == "LinearStep":
                 self.props["RangeEnd"] = str(end) + unit
                 self.props["RangeStep"] = str(count) + unit
-            elif rangetype == "LogScale":
+            elif range_type == "LogScale":
                 self.props["RangeEnd"] = str(end) + unit
                 self.props["RangeSamples"] = count
             self.props["SweepRanges"] = {"Subrange": []}
             return self.update()
-        sweep_range = {"RangeType": rangetype, "RangeStart": str(start) + unit}
-        if rangetype == "LinearCount":
+        sweep_range = {"RangeType": range_type, "RangeStart": str(start) + unit}
+        if range_type == "LinearCount":
             sweep_range["RangeEnd"] = str(end) + unit
             sweep_range["RangeCount"] = count
-        elif rangetype == "LinearStep":
+        elif range_type == "LinearStep":
             sweep_range["RangeEnd"] = str(end) + unit
             sweep_range["RangeStep"] = str(count) + unit
-        elif rangetype == "LogScale":
+        elif range_type == "LogScale":
             sweep_range["RangeEnd"] = str(end) + unit
             sweep_range["RangeCount"] = self.props["RangeCount"]
             sweep_range["RangeSamples"] = count
         if not self.props.get("SweepRanges") or not self.props["SweepRanges"].get("Subrange"):
             self.props["SweepRanges"] = {"Subrange": []}
         self.props["SweepRanges"]["Subrange"].append(sweep_range)
         return self.update()
@@ -798,28 +755,28 @@
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         """
-        self.oanalysis.InsertSweep(self.setupname, self._get_args())
+        self.oanalysis.InsertSweep(self.setup_name, self._get_args())
         return True
 
     @pyaedt_function_handler()
     def update(self):
         """Update the sweep.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         """
-        self.oanalysis.EditSweep(self.setupname, self.name, self._get_args())
+        self.oanalysis.EditSweep(self.setup_name, self.name, self._get_args())
 
         return True
 
     @pyaedt_function_handler()
     def _get_args(self, props=None):
         """Get properties.
```

### Comparing `pyaedt-0.8.7/pyaedt/modules/monitor_icepak.py` & `pyaedt-0.8.8/pyaedt/modules/monitor_icepak.py`

 * *Files 2% similar despite different names*

```diff
@@ -743,55 +743,55 @@
 
         Returns
         -------
         str
         """
         return self._type
 
-    @pyaedt_function_handler
-    def value(self, quantity=None, setup_name=None, design_variation_dict=None, si_out=True):
+    @pyaedt_function_handler(setup_name="setup")
+    def value(self, quantity=None, setup=None, design_variation_dict=None, si_out=True):
         """
         Get a list of values obtained from the monitor object. If the simulation is steady state,
         the list will contain just one element.
 
         Parameters
         ----------
         quantity : str or list, optional
             String that specifies the quantity that is retrieved. If this parameter is not provided,
             all monitored quantity will be considered.
         design_variation_dict : dict, optional
             Dictionary containing the project and design variables and values. If this parameter
-            is not provided, all variations will be considered.
-        setup_name : str, optional
-            String that specifies the name of the setup from which to extract the monitor value.
-            If this parameter is not provided, the first one of the design will be selected.
+            is not provided, all variations are considered.
+        setup : str, optional
+            Name of the setup to extract the monitor value from.
+            If this parameter is not provided, the first setup of the design is used.
         si_out : bool, optional
             Whether to return the values of th monitor object in SI units. Default is ``True``.
 
         Returns
         -------
         dict
             Dictionary containing the variables names and values and the monitor values for each
             variation.
         """
-        if not setup_name:
-            setup_name = self._app.existing_analysis_sweeps[0]
+        if not setup:
+            setup = self._app.existing_analysis_sweeps[0]
         design_variation = []
         if not design_variation_dict:
             design_variation_dict = {k: ["All"] for k in self._app.variable_manager.variables.keys()}
         _dict2arg(design_variation_dict, design_variation)
         if not quantity:
             quantity = self.quantities
         elif not isinstance(quantity, list):
             quantity = [quantity]
         return_dict = {}
         for q in quantity:
             for i, monitor_result_obj in enumerate(
                 self._app.oreportsetup.GetSolutionDataPerVariation(
-                    "Monitor", setup_name, [], design_variation, "{}.{}".format(self.name, q)
+                    "Monitor", setup, [], design_variation, "{}.{}".format(self.name, q)
                 )
             ):
                 variation_a = {
                     i: [monitor_result_obj.GetDesignVariableValue(i), monitor_result_obj.GetDesignVariableUnits(i)]
                     for i in monitor_result_obj.GetDesignVariableNames()
                 }
                 variation_b = {
```

### Comparing `pyaedt-0.8.7/pyaedt/modules/report_templates.py` & `pyaedt-0.8.8/pyaedt/modules/report_templates.py`

 * *Files 1% similar despite different names*

```diff
@@ -1054,15 +1054,15 @@
                 sweep_list.append(self.variations[self.primary_sweep])
             else:
                 sweep_list.append(self.secondary_sweep_range)
         for el in sweeps:
             if el in [self.primary_sweep, self.secondary_sweep]:
                 continue
             sweep_list.append(el + ":=")
-            if type(sweeps[el]) is list:
+            if isinstance(sweeps[el], list):
                 sweep_list.append(sweeps[el])
             else:
                 sweep_list.append([sweeps[el]])
         for el in list(self._post._app.available_variations.nominal_w_values_dict.keys()):
             if el not in sweeps:
                 sweep_list.append(el + ":=")
                 sweep_list.append(["Nominal"])
@@ -3782,7 +3782,227 @@
                 "Y Component:=",
                 self._trace_info,
             ],
         )
         self._post.plots.append(self)
         self._is_created = True
         return True
+
+
+class EMIReceiver(CommonReport):
+    """Provides for managing EMI receiver reports."""
+
+    def __init__(self, app, setup_name, expressions=None):
+        CommonReport.__init__(self, app, "EMIReceiver", setup_name, expressions)
+        self.logger = app.logger
+        self.domain = "EMI Receiver"
+        self.available_nets = []
+        self._net = "0"
+        for comp in app.modeler.components.components.values():
+            if comp.name == "CompInst@EMI_RCVR":
+                self.available_nets.append(comp.pins[0].net)
+        if self.available_nets:
+            self._net = self.available_nets[0]
+        self.time_start = "0ns"
+        self.time_stop = "200ns"
+        self._emission = "CE"
+        self.overlap_rate = 95
+        self.band = "0"
+        self.primary_sweep = "Freq"
+
+    @property
+    def net(self):
+        """Net attached to the EMI receiver.
+
+        Returns
+        -------
+        str
+        """
+        return self._net
+
+    @net.setter
+    def net(self, value):
+        if value not in self.available_nets:
+            self.logger.error("Net not available.")
+        else:
+            self._net = value
+
+    @property
+    def band(self):
+        """Band attached to the EMI receiver.
+
+        Returns
+        -------
+        str
+        """
+        return self.props["context"].get("band", None)
+
+    @band.setter
+    def band(self, value):
+        self.props["context"]["band"] = value
+
+    @property
+    def emission(self):
+        """Emission test.
+
+        Options are ``"CE"`` and ``"RE"``.
+
+        Returns
+        -------
+        str
+        """
+        return self._emission
+
+    @emission.setter
+    def emission(self, value):
+        if value == "CE":
+            self._emission = value
+            self.props["context"]["emission"] = "0"
+        elif value == "RE":
+            self._emission = value
+            self.props["context"]["emission"] = "1"
+        else:
+            self.logger.error("Emission must be 'CE' or 'RE', value '{}' is not valid.".format(value))
+
+    @property
+    def time_start(self):
+        """Time start value.
+
+        Returns
+        -------
+        str
+        """
+        return self.props["context"].get("time_start", None)
+
+    @time_start.setter
+    def time_start(self, value):
+        self.props["context"]["time_start"] = value
+
+    @property
+    def time_stop(self):
+        """Time stop value.
+
+        Returns
+        -------
+        str
+        """
+        return self.props["context"].get("time_stop", None)
+
+    @time_stop.setter
+    def time_stop(self, value):
+        self.props["context"]["time_stop"] = value
+
+    @property
+    def _context(self):
+
+        if self.emission == "CE":
+            em = "0"
+        else:
+            em = "1"
+
+        arg = [
+            "NAME:Context",
+            "SimValueContext:=",
+            [
+                55830,
+                0,
+                2,
+                0,
+                False,
+                False,
+                -1,
+                1,
+                0,
+                1,
+                1,
+                self.net,
+                0,
+                0,
+                "BAND",
+                False,
+                self.band,
+                "CG",
+                False,
+                "1",
+                "EM",
+                False,
+                em,
+                "KP",
+                False,
+                "0",
+                "NUMLEVELS",
+                False,
+                "0",
+                "OR",
+                False,
+                str(self.overlap_rate),
+                "RBW",
+                False,
+                "9000Hz",
+                "SIG",
+                False,
+                "0",
+                "TCT",
+                False,
+                "1ms",
+                "TDT",
+                False,
+                "160ms",
+                "TE",
+                False,
+                self.time_stop,
+                "TS",
+                False,
+                self.time_start,
+                "WT",
+                False,
+                "6",
+                "WW",
+                False,
+                "100",
+            ],
+        ]
+        return arg
+
+    @property
+    def _trace_info(self):
+        if isinstance(self.expressions, list):
+            return self.expressions
+        else:
+            return [self.expressions]
+
+    @pyaedt_function_handler()
+    def create(self, plot_name=None):
+        """Create an EMI receiver report.
+
+        Parameters
+        ----------
+        plot_name : str, optional
+            Plot name. The default is ``None``, in which case
+            the default name is used.
+
+        Returns
+        -------
+        bool
+            ``True`` when successful, ``False`` when failed.
+        """
+        if not plot_name:
+            self.plot_name = generate_unique_name("Plot")
+        else:
+            self.plot_name = plot_name
+        self._post.oreportsetup.CreateReport(
+            self.plot_name,
+            "Standard",
+            self.report_type,
+            self.setup,
+            self._context,
+            self._convert_dict_to_report_sel(self.variations),
+            [
+                "X Component:=",
+                self.primary_sweep,
+                "Y Component:=",
+                self._trace_info,
+            ],
+        )
+        self._post.plots.append(self)
+        self._is_created = True
+        return self
```

### Comparing `pyaedt-0.8.7/pyaedt/modules/solutions.py` & `pyaedt-0.8.8/pyaedt/modules/solutions.py`

 * *Files 8% similar despite different names*

```diff
@@ -11,14 +11,15 @@
 from pyaedt import is_ironpython
 from pyaedt import pyaedt_function_handler
 from pyaedt.application.Variables import decompose_variable_value
 from pyaedt.generic.constants import AEDT_UNITS
 from pyaedt.generic.constants import db10
 from pyaedt.generic.constants import db20
 from pyaedt.generic.constants import unit_converter
+from pyaedt.generic.general_methods import check_and_download_file
 from pyaedt.generic.general_methods import check_and_download_folder
 from pyaedt.generic.general_methods import conversion_function
 from pyaedt.generic.general_methods import open_file
 from pyaedt.generic.general_methods import write_csv
 from pyaedt.generic.plot import get_structured_mesh
 from pyaedt.generic.plot import is_notebook
 from pyaedt.generic.plot import plot_2d_chart
@@ -124,34 +125,34 @@
         for data in self._original_data:
             variations = OrderedDict({})
             for v in data.GetDesignVariableNames():
                 variations[v] = data.GetDesignVariableValue(v)
             variations_lists.append(variations)
         return variations_lists
 
-    @pyaedt_function_handler()
-    def variation_values(self, variation_name):
+    @pyaedt_function_handler(variation_name="variation")
+    def variation_values(self, variation):
         """Get the list of the specific variation available values.
 
         Parameters
         ----------
-        variation_name : str
+        variation : str
             Name of variation to return.
 
         Returns
         -------
         list
         """
-        if variation_name in self.intrinsics:
-            return self.intrinsics[variation_name]
+        if variation in self.intrinsics:
+            return self.intrinsics[variation]
         else:
             vars_vals = []
             for el in self.variations:
-                if variation_name in el and el[variation_name] not in vars_vals:
-                    vars_vals.append(el[variation_name])
+                if variation in el and el[variation] not in vars_vals:
+                    vars_vals.append(el[variation])
             return vars_vals
 
     @property
     def intrinsics(self):
         """Get intrinsics dictionary on active variation."""
         if not self._intrinsics:
             self._intrinsics = OrderedDict({})
@@ -447,36 +448,37 @@
                 sol, self._quantity(self.units_data[expression]), self.units_data[expression]
             )
         if self.enable_pandas_output:
             return pd.Series(sol)
         return sol
 
     @staticmethod
-    @pyaedt_function_handler()
-    def _convert_list_to_SI(datalist, dataunits, units):
+    @pyaedt_function_handler(datalist="data", dataunits="data_units")
+    def _convert_list_to_SI(data, data_units, units):
         """Convert a data list to the SI unit system.
 
         Parameters
         ----------
-        datalist : list
+        data : list
            List of data to convert.
-        dataunits :
-
-        units :
+        data_units : str
+            Data units.
+        units : str
+            SI units to convert data into.
 
 
         Returns
         -------
         list
            List of the data converted to the SI unit system.
 
         """
-        sol = datalist
-        if dataunits in AEDT_UNITS and units in AEDT_UNITS[dataunits]:
-            sol = [i * AEDT_UNITS[dataunits][units] for i in datalist]
+        sol = data
+        if data_units in AEDT_UNITS and units in AEDT_UNITS[data_units]:
+            sol = [i * AEDT_UNITS[data_units][units] for i in data]
         return sol
 
     @pyaedt_function_handler()
     def data_db10(self, expression=None, convert_to_SI=False):
         """Retrieve the data in the database for an expression and convert in db10.
 
         Parameters
@@ -660,21 +662,21 @@
             List of the imaginary data for the expression.
 
         """
         if not expression:
             expression = self.active_expression
         temp = self._variation_tuple()
 
-        solution_Data = self._solutions_imag[expression]
+        solution_data = self._solutions_imag[expression]
         sol = []
         position = list(self._sweeps_names).index(self.primary_sweep)
         for el in self.primary_sweep_values:
             temp[position] = el
             try:
-                sol.append(solution_Data[tuple(temp)])
+                sol.append(solution_data[tuple(temp)])
             except KeyError:
                 sol.append(None)
         if convert_to_SI and self._quantity(self.units_data[expression]):
             sol = self._convert_list_to_SI(
                 sol, self._quantity(self.units_data[expression]), self.units_data[expression]
             )
         if self.enable_pandas_output:
@@ -740,47 +742,52 @@
             if not self.is_real_only(el):
                 for e, v in self._solutions_imag[el].items():
                     list_full[i].extend([v])
                     i += 1
 
         return write_csv(output, list_full, delimiter=delimiter)
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(math_formula="formula", xlabel="x_label", ylabel="y_label")
     def plot(
         self,
         curves=None,
-        math_formula=None,
+        formula=None,
         size=(2000, 1000),
         show_legend=True,
-        xlabel="",
-        ylabel="",
+        x_label="",
+        y_label="",
         title="",
         snapshot_path=None,
         is_polar=False,
     ):
         """Create a matplotlib plot based on a list of data.
 
         Parameters
         ----------
         curves : list
-            Curves to be plotted. If None, the first curve will be plotted.
-        math_formula : str , optional
-            Mathematical formula to apply to the plot curve.
-            Valid values are `"re"`, `"im"`, `"db20"`, `"db10"`, `"abs"`, `"mag"`, `"phasedeg"`, `"phaserad"`.
-            `None` value will plot only real value of the data stored in solution data.
+            Curves to be plotted. The default is ``None``, in which case
+            the first curve is plotted.
+        formula : str , optional
+            Mathematical formula to apply to the plot curve. The default is ``None``,
+            in which case only real value of the data stored in the solution data is plotted.
+            Options are ``"abs"``, ``"db10"``, ``"db20"``, ``"im"``, ``"mag"``, ``"phasedeg"``,
+            ``"phaserad"``, and ``"re"``.
+
         size : tuple, optional
-            Image size in pixel (width, height).
+            Image size in pixels (width, height).
         show_legend : bool
-            Either to show legend or not. Flag will be ignored if number of curves to plot is greater than 15.
-        xlabel : str
+            Whether to show the legend. The default is ``True``.
+            This parameter is ignored if the number of curves to plot is
+            greater than 15.
+        x_label : str
             Plot X label.
-        ylabel : str
+        y_label : str
             Plot Y label.
         title : str
-            Plot Title label.
+            Plot title label.
         snapshot_path : str
             Full path to image file if a snapshot is needed.
         is_polar : bool, optional
             Set to `True` if this is a polar plot.
 
         Returns
         -------
@@ -796,126 +803,132 @@
         data_plot = []
         sweep_name = self.primary_sweep
         if is_polar:
             sw = self.to_radians(self.primary_sweep_values)
         else:
             sw = self.primary_sweep_values
         for curve in curves:
-            if not math_formula:
+            if not formula:
                 data_plot.append([sw, self.data_real(curve), curve])
-            elif math_formula == "re":
-                data_plot.append([sw, self.data_real(curve), "{}({})".format(math_formula, curve)])
-            elif math_formula == "im":
-                data_plot.append([sw, self.data_imag(curve), "{}({})".format(math_formula, curve)])
-            elif math_formula == "db20":
-                data_plot.append([sw, self.data_db20(curve), "{}({})".format(math_formula, curve)])
-            elif math_formula == "db10":
-                data_plot.append([sw, self.data_db10(curve), "{}({})".format(math_formula, curve)])
-            elif math_formula == "mag":
-                data_plot.append([sw, self.data_magnitude(curve), "{}({})".format(math_formula, curve)])
-            elif math_formula == "phasedeg":
-                data_plot.append([sw, self.data_phase(curve, False), "{}({})".format(math_formula, curve)])
-            elif math_formula == "phaserad":
-                data_plot.append([sw, self.data_phase(curve, True), "{}({})".format(math_formula, curve)])
-        if not xlabel:
-            xlabel = sweep_name
-        if not ylabel:
-            ylabel = math_formula
+            elif formula == "re":
+                data_plot.append([sw, self.data_real(curve), "{}({})".format(formula, curve)])
+            elif formula == "im":
+                data_plot.append([sw, self.data_imag(curve), "{}({})".format(formula, curve)])
+            elif formula == "db20":
+                data_plot.append([sw, self.data_db20(curve), "{}({})".format(formula, curve)])
+            elif formula == "db10":
+                data_plot.append([sw, self.data_db10(curve), "{}({})".format(formula, curve)])
+            elif formula == "mag":
+                data_plot.append([sw, self.data_magnitude(curve), "{}({})".format(formula, curve)])
+            elif formula == "phasedeg":
+                data_plot.append([sw, self.data_phase(curve, False), "{}({})".format(formula, curve)])
+            elif formula == "phaserad":
+                data_plot.append([sw, self.data_phase(curve, True), "{}({})".format(formula, curve)])
+        if not x_label:
+            x_label = sweep_name
+        if not y_label:
+            y_label = formula
         if not title:
             title = "Simulation Results Plot"
         if len(data_plot) > 15:
             show_legend = False
         if is_polar:
-            return plot_polar_chart(data_plot, size, show_legend, xlabel, ylabel, title, snapshot_path)
+            return plot_polar_chart(data_plot, size, show_legend, x_label, y_label, title, snapshot_path)
         else:
-            return plot_2d_chart(data_plot, size, show_legend, xlabel, ylabel, title, snapshot_path)
+            return plot_2d_chart(data_plot, size, show_legend, x_label, y_label, title, snapshot_path)
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(xlabel="x_label", ylabel="y_label", math_formula="formula")
     def plot_3d(
         self,
         curve=None,
         x_axis="Theta",
         y_axis="Phi",
-        xlabel="",
-        ylabel="",
+        x_label="",
+        y_label="",
         title="",
-        math_formula=None,
+        formula=None,
         size=(2000, 1000),
         snapshot_path=None,
     ):
         """Create a matplotlib 3d plot based on a list of data.
 
         Parameters
         ----------
         curve : str
             Curve to be plotted. If None, the first curve will be plotted.
         x_axis : str, optional
-            X Axis sweep. Default is `"Theta"`.
+            X-axis sweep. The default is ``"Theta"``.
         y_axis : str, optional
-            Y Axis sweep. Default is `"Phi"`.
-        math_formula : str , optional
-            Mathematical formula to apply to the plot curve.
-            Valid values are `"re"`, `"im"`, `"db20"`, `"db10"`, `"abs"`, `"mag"`, `"phasedeg"`, `"phaserad"`.
+            Y-axis sweep. The default is ``"Phi"``.
+        x_label : str
+            Plot X label.
+        y_label : str
+            Plot Y label.
+        title : str
+            Plot title label.
+        formula : str , optional
+            Mathematical formula to apply to the plot curve. The default is ``None``.
+            Options are `"abs"``, ``"db10"``, ``"db20"``, ``"im"``, ``"mag"``, ``"phasedeg"``,
+            ``"phaserad"``, and ``"re"``.
         size : tuple, optional
-            Image size in pixel (width, height).
-        snapshot_path : str
+            Image size in pixels (width, height). The default is ``(2000, 1000)``.
+        snapshot_path : str, optional
             Full path to image file if a snapshot is needed.
-        is_polar : bool, optional
-            Set to `True` if this is a polar plot.
+            The default is ``None``.
 
         Returns
         -------
         :class:`matplotlib.plt`
             Matplotlib fig object.
         """
         if is_ironpython:
             return False  # pragma: no cover
         if not curve:
             curve = self.active_expression
 
-        if not math_formula:
-            math_formula = "mag"
+        if not formula:
+            formula = "mag"
         theta = self.variation_values(x_axis)
         y_axis_val = self.variation_values(y_axis)
 
         phi = []
         r = []
         for el in y_axis_val:
             self.active_variation[y_axis] = el
             phi.append(el * math.pi / 180)
 
-            if math_formula == "re":
+            if formula == "re":
                 r.append(self.data_real(curve))
-            elif math_formula == "im":
+            elif formula == "im":
                 r.append(self.data_imag(curve))
-            elif math_formula == "db20":
+            elif formula == "db20":
                 r.append(self.data_db20(curve))
-            elif math_formula == "db10":
+            elif formula == "db10":
                 r.append(self.data_db10(curve))
-            elif math_formula == "mag":
+            elif formula == "mag":
                 r.append(self.data_magnitude(curve))
-            elif math_formula == "phasedeg":
+            elif formula == "phasedeg":
                 r.append(self.data_phase(curve, False))
-            elif math_formula == "phaserad":
+            elif formula == "phaserad":
                 r.append(self.data_phase(curve, True))
         active_sweep = self.active_intrinsic[self.primary_sweep]
         position = self.variation_values(self.primary_sweep).index(active_sweep)
         if len(self.variation_values(self.primary_sweep)) > 1:
             new_r = []
             for el in r:
                 new_r.append([el[position]])
             r = new_r
         data_plot = [theta, phi, r]
-        if not xlabel:
-            xlabel = x_axis
-        if not ylabel:
-            ylabel = y_axis
+        if not x_label:
+            x_label = x_axis
+        if not y_label:
+            y_label = y_axis
         if not title:
             title = "Simulation Results Plot"
-        return plot_3d_chart(data_plot, size, xlabel, ylabel, title, snapshot_path)
+        return plot_3d_chart(data_plot, size, x_label, y_label, title, snapshot_path)
 
     @pyaedt_function_handler()
     def ifft(self, curve_header="NearE", u_axis="_u", v_axis="_v", window=False):
         """Create IFFT of given complex data.
 
         Parameters
         ----------
@@ -935,96 +948,96 @@
         if is_ironpython:
             return False
         u = self.variation_values(u_axis)
         v = self.variation_values(v_axis)
 
         freq = self.variation_values("Freq")
         if self.enable_pandas_output:
-            E_realx = np.reshape(self._solutions_real[curve_header + "X"].copy().values, (len(freq), len(v), len(u)))
-            E_imagx = np.reshape(self._solutions_imag[curve_header + "X"].copy().values, (len(freq), len(v), len(u)))
-            E_realy = np.reshape(self._solutions_real[curve_header + "Y"].copy().values, (len(freq), len(v), len(u)))
-            E_imagy = np.reshape(self._solutions_imag[curve_header + "Y"].copy().values, (len(freq), len(v), len(u)))
-            E_realz = np.reshape(self._solutions_real[curve_header + "Z"].copy().values, (len(freq), len(v), len(u)))
-            E_imagz = np.reshape(self._solutions_imag[curve_header + "Z"].copy().values, (len(freq), len(v), len(u)))
-        else:
-            vals_real_Ex = [j for j in self._solutions_real[curve_header + "X"].values()]
-            vals_imag_Ex = [j for j in self._solutions_imag[curve_header + "X"].values()]
-            vals_real_Ey = [j for j in self._solutions_real[curve_header + "Y"].values()]
-            vals_imag_Ey = [j for j in self._solutions_imag[curve_header + "Y"].values()]
-            vals_real_Ez = [j for j in self._solutions_real[curve_header + "Z"].values()]
-            vals_imag_Ez = [j for j in self._solutions_imag[curve_header + "Z"].values()]
-
-            E_realx = np.reshape(vals_real_Ex, (len(freq), len(v), len(u)))
-            E_imagx = np.reshape(vals_imag_Ex, (len(freq), len(v), len(u)))
-            E_realy = np.reshape(vals_real_Ey, (len(freq), len(v), len(u)))
-            E_imagy = np.reshape(vals_imag_Ey, (len(freq), len(v), len(u)))
-            E_realz = np.reshape(vals_real_Ez, (len(freq), len(v), len(u)))
-            E_imagz = np.reshape(vals_imag_Ez, (len(freq), len(v), len(u)))
-
-        Temp_E_compx = E_realx + 1j * E_imagx  # Here is the complex FD data matrix, ready for transforming
-        Temp_E_compy = E_realy + 1j * E_imagy
-        Temp_E_compz = E_realz + 1j * E_imagz
-
-        E_compx = np.zeros((len(freq), len(v), len(u)), dtype="complex_")
-        E_compy = np.zeros((len(freq), len(v), len(u)), dtype="complex_")
-        E_compz = np.zeros((len(freq), len(v), len(u)), dtype="complex_")
+            e_real_x = np.reshape(self._solutions_real[curve_header + "X"].copy().values, (len(freq), len(v), len(u)))
+            e_imag_x = np.reshape(self._solutions_imag[curve_header + "X"].copy().values, (len(freq), len(v), len(u)))
+            e_real_y = np.reshape(self._solutions_real[curve_header + "Y"].copy().values, (len(freq), len(v), len(u)))
+            e_imag_y = np.reshape(self._solutions_imag[curve_header + "Y"].copy().values, (len(freq), len(v), len(u)))
+            e_real_z = np.reshape(self._solutions_real[curve_header + "Z"].copy().values, (len(freq), len(v), len(u)))
+            e_imag_z = np.reshape(self._solutions_imag[curve_header + "Z"].copy().values, (len(freq), len(v), len(u)))
+        else:
+            vals_e_real_x = [j for j in self._solutions_real[curve_header + "X"].values()]
+            vals_e_imag_x = [j for j in self._solutions_imag[curve_header + "X"].values()]
+            vals_e_real_y = [j for j in self._solutions_real[curve_header + "Y"].values()]
+            vals_e_imag_y = [j for j in self._solutions_imag[curve_header + "Y"].values()]
+            vals_e_real_z = [j for j in self._solutions_real[curve_header + "Z"].values()]
+            vals_e_imag_z = [j for j in self._solutions_imag[curve_header + "Z"].values()]
+
+            e_real_x = np.reshape(vals_e_real_x, (len(freq), len(v), len(u)))
+            e_imag_x = np.reshape(vals_e_imag_x, (len(freq), len(v), len(u)))
+            e_real_y = np.reshape(vals_e_real_y, (len(freq), len(v), len(u)))
+            e_imag_y = np.reshape(vals_e_imag_y, (len(freq), len(v), len(u)))
+            e_real_z = np.reshape(vals_e_real_z, (len(freq), len(v), len(u)))
+            e_imag_z = np.reshape(vals_e_imag_z, (len(freq), len(v), len(u)))
+
+        temp_e_comp_x = e_real_x + 1j * e_imag_x  # Here is the complex FD data matrix, ready for transforming
+        temp_e_comp_y = e_real_y + 1j * e_imag_y
+        temp_e_comp_z = e_real_z + 1j * e_imag_z
+
+        e_comp_x = np.zeros((len(freq), len(v), len(u)), dtype="complex_")
+        e_comp_y = np.zeros((len(freq), len(v), len(u)), dtype="complex_")
+        e_comp_z = np.zeros((len(freq), len(v), len(u)), dtype="complex_")
         if window:
             timewin = np.hanning(len(freq))
 
             for row in range(0, len(v)):
                 for col in range(0, len(u)):
-                    E_compx[:, row, col] = np.multiply(Temp_E_compx[:, row, col], timewin)
-                    E_compy[:, row, col] = np.multiply(Temp_E_compy[:, row, col], timewin)
-                    E_compz[:, row, col] = np.multiply(Temp_E_compz[:, row, col], timewin)
-        else:
-            E_compx = Temp_E_compx
-            E_compy = Temp_E_compy
-            E_compz = Temp_E_compz
-
-        E_time_x = np.fft.ifft(np.fft.fftshift(E_compx, 0), len(freq), 0, None)
-        E_time_y = np.fft.ifft(np.fft.fftshift(E_compy, 0), len(freq), 0, None)
-        E_time_z = np.fft.ifft(np.fft.fftshift(E_compz, 0), len(freq), 0, None)
-        E_time = np.zeros((np.size(freq), np.size(v), np.size(u)))
+                    e_comp_x[:, row, col] = np.multiply(temp_e_comp_x[:, row, col], timewin)
+                    e_comp_y[:, row, col] = np.multiply(temp_e_comp_y[:, row, col], timewin)
+                    e_comp_z[:, row, col] = np.multiply(temp_e_comp_z[:, row, col], timewin)
+        else:
+            e_comp_x = temp_e_comp_x
+            e_comp_y = temp_e_comp_y
+            e_comp_z = temp_e_comp_z
+
+        e_time_x = np.fft.ifft(np.fft.fftshift(e_comp_x, 0), len(freq), 0, None)
+        e_time_y = np.fft.ifft(np.fft.fftshift(e_comp_y, 0), len(freq), 0, None)
+        e_time_z = np.fft.ifft(np.fft.fftshift(e_comp_z, 0), len(freq), 0, None)
+        e_time = np.zeros((np.size(freq), np.size(v), np.size(u)))
         for i in range(0, len(freq)):
-            E_time[i, :, :] = np.abs(
-                np.sqrt(np.square(E_time_x[i, :, :]) + np.square(E_time_y[i, :, :]) + np.square(E_time_z[i, :, :]))
+            e_time[i, :, :] = np.abs(
+                np.sqrt(np.square(e_time_x[i, :, :]) + np.square(e_time_y[i, :, :]) + np.square(e_time_z[i, :, :]))
             )
-        self._ifft = E_time
+        self._ifft = e_time
 
         return self._ifft
 
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(csv_dir="csv_path", name_str="csv_file_header")
     def ifft_to_file(
         self,
         u_axis="_u",
         v_axis="_v",
         coord_system_center=None,
         db_val=False,
         num_frames=None,
-        csv_dir=None,
-        name_str="res_",
+        csv_path=None,
+        csv_file_header="res_",
     ):
-        """Save IFFT Matrix to a list of csv files (one per time step).
+        """Save IFFT matrix to a list of CSV files (one per time step).
 
         Parameters
         ----------
         u_axis : str, optional
             U Axis name. Default is Hfss name "_u"
         v_axis : str, optional
             V Axis name. Default is Hfss name "_v"
         coord_system_center : list, optional
             List of UV GlobalCS Center.
         db_val : bool, optional
-            Either if data has to be exported in db or not.
+            Whether data must be exported into a database. The default is ``False``.
         num_frames : int, optional
-            Number of frames to export.
-        csv_dir : str
-            Output path
-        name_str : str, optional
-            csv file header.
+            Number of frames to export. The default is ``None``.
+        csv_path : str, optional
+            Output path. The default is ``None``.
+        csv_file_header : str, optional
+            CSV file header. The default is ``"res_"``.
 
         Returns
         -------
         str
             Path to file containing the list of csv files.
         """
         if not coord_system_center:
@@ -1037,23 +1050,23 @@
         adj_y = coord_system_center[1]
         adj_z = coord_system_center[2]
         if num_frames:
             frames = num_frames
         else:
             frames = t_matrix.shape[0]
         csv_list = []
-        if os.path.exists(csv_dir):
-            files = [os.path.join(csv_dir, f) for f in os.listdir(csv_dir) if name_str in f and ".csv" in f]
+        if os.path.exists(csv_path):
+            files = [os.path.join(csv_path, f) for f in os.listdir(csv_path) if csv_file_header in f and ".csv" in f]
             for file in files:
                 os.remove(file)
         else:
-            os.mkdir(csv_dir)
+            os.mkdir(csv_path)
 
         for frame in range(frames):
-            output = os.path.join(csv_dir, name_str + str(frame) + ".csv")
+            output = os.path.join(csv_path, csv_file_header + str(frame) + ".csv")
             list_full = [["x", "y", "z", "val"]]
             for i, y in enumerate(y_c_list):
                 for j, x in enumerate(x_c_list):
                     y_coord = y + adj_y
                     x_coord = x + adj_x
                     z_coord = adj_z
                     if db_val:
@@ -1061,15 +1074,15 @@
                     else:
                         val = t_matrix[frame, i, j]
                     row_lst = [x_coord, y_coord, z_coord, val]
                     list_full.append(row_lst)
             write_csv(output, list_full, delimiter=",")
             csv_list.append(output)
 
-        txt_file_name = csv_dir + "fft_list.txt"
+        txt_file_name = csv_path + "fft_list.txt"
         textfile = open_file(txt_file_name, "w")
 
         for element in csv_list:
             textfile.write(element + "\n")
         textfile.close()
         return txt_file_name
 
@@ -1093,20 +1106,20 @@
 
     >>> import pyaedt
     >>> from pyaedt.modules.solutions import FfdSolutionData
     >>> app = pyaedt.Hfss(specified_version="2023.2", designname="Antenna")
     >>> setup_name = "Setup1 : LastAdaptive"
     >>> frequencies = [77e9]
     >>> sphere = "3D"
-    >>> data = app.get_antenna_ffd_solution_data(frequencies, setup_name, sphere)
+    >>> data = app.get_antenna_ffd_solution_data(frequencies,setup_name,sphere)
     >>> eep_files = data.eep_files
     >>> frequencies = data.frequencies
     >>> app.release_desktop()
     >>> farfield_data = FfdSolutionData(frequencies=frequencies, eep_files=eep_files)
-    >>> farfield_data.polar_plot_3d_pyvista(qty_str="rETotal", quantity_format="dB10")
+    >>> farfield_data.polar_plot_3d_pyvista(quantity_format="dB10",qty_str="rETotal")
     """
 
     def __init__(
         self,
         eep_files,
         frequencies,
     ):
@@ -1154,15 +1167,15 @@
         self._cell_position = []
         self._lattice_vector = []
         self.mesh = None
 
         for eep in eep_files:
             metadata_file = os.path.join(os.path.dirname(eep), "eep.json")
             if os.path.exists(metadata_file):
-                with open(metadata_file) as f:
+                with open_file(metadata_file) as f:
                     # Load JSON data from file
                     metadata = json.load(f)
                 self.model_info.append(metadata["model_info"])
                 if "array_dimension" in metadata and "component_objects" in metadata and "cell_position" in metadata:
                     self._is_array.append(True)
                     self._component_objects.append(metadata["component_objects"])
                     self._array_dimension.append(metadata["array_dimension"])
@@ -1383,21 +1396,21 @@
         a = int(a)
         b = int(b)
         theta = np.deg2rad(theta)
         phi = np.deg2rad(phi)
 
         lattice_vector = self._lattice_vector[self._freq_index]
 
-        Ax, Ay, Bx, By = [lattice_vector[0], lattice_vector[1], lattice_vector[3], lattice_vector[4]]
+        a_x, a_y, b_x, b_y = [lattice_vector[0], lattice_vector[1], lattice_vector[3], lattice_vector[4]]
 
-        phase_shift_A = -((Ax * k * np.sin(theta) * np.cos(phi)) + (Ay * k * np.sin(theta) * np.sin(phi)))
+        phase_shift_a = -((a_x * k * np.sin(theta) * np.cos(phi)) + (a_y * k * np.sin(theta) * np.sin(phi)))
 
-        phase_shift_B = -((Bx * k * np.sin(theta) * np.cos(phi)) + (By * k * np.sin(theta) * np.sin(phi)))
+        phase_shift_b = -((b_x * k * np.sin(theta) * np.cos(phi)) + (b_y * k * np.sin(theta) * np.sin(phi)))
 
-        phase_shift = a * phase_shift_A + b * phase_shift_B
+        phase_shift = a * phase_shift_a + b * phase_shift_b
 
         return np.rad2deg(phase_shift)
 
     @pyaedt_function_handler()
     def combine_farfield(self, phi_scan=0, theta_scan=0):
         """Compute the far field pattern calculated for a specific phi and theta scan angle requested.
 
@@ -1500,47 +1513,50 @@
         farfield_data["RealizedGain_Theta"] = real_gain
         real_gain = 2 * np.pi * np.abs(np.power(farfield_data["rEPhi"], 2)) / incident_power / 377
         farfield_data["RealizedGain_Phi"] = real_gain
         farfield_data["Element_Location"] = port_positions
         return farfield_data
 
     # fmt: off
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(farfield_quantity="quantity",
+                             phi_scan="phi",
+                             theta_scan="theta",
+                             export_image_path="image_path")
     def plot_farfield_contour(
             self,
-            farfield_quantity="RealizedGain",
-            phi_scan=0,
-            theta_scan=0,
+            quantity="RealizedGain",
+            phi=0,
+            theta=0,
             title="RectangularPlot",
             quantity_format="dB10",
-            export_image_path=None,
+            image_path=None,
             levels=64,
             show=True,
             **kwargs
     ):
         # fmt: on
         """Create a contour plot of a specified quantity.
 
         Parameters
         ----------
-        farfield_quantity : str, optional
+        quantity : str, optional
             Far field quantity to plot. The default is ``"RealizedGain"``.
             Available quantities are: ``"RealizedGain"``, ``"RealizedGain_Phi"``, ``"RealizedGain_Theta"``,
             ``"rEPhi"``, ``"rETheta"``, and ``"rETotal"``.
-        phi_scan : float, int, optional
+        phi : float, int, optional
             Phi scan angle in degrees. The default is ``0``.
-        theta_scan : float, int, optional
+        theta : float, int, optional
             Theta scan angle in degrees. The default is ``0``.
         title : str, optional
             Plot title. The default is ``"RectangularPlot"``.
         quantity_format : str, optional
             Conversion data function.
             Available functions are: ``"abs"``, ``"ang"``, ``"dB10"``, ``"dB20"``, ``"deg"``, ``"imag"``, ``"norm"``,
             and ``"real"``.
-        export_image_path : str, optional
+        image_path : str, optional
             Full path for the image file. The default is ``None``, in which case the file is not exported.
         levels : int, optional
             Color map levels. The default is ``64``.
         show : bool, optional
             Whether to show the plot. The default is ``True``. If ``False``, the Matplotlib
             instance of the plot is shown.
 
@@ -1554,36 +1570,36 @@
         Examples
         --------
         >>> import pyaedt
         >>> app = pyaedt.Hfss(specified_version="2023.2", designname="Antenna")
         >>> setup_name = "Setup1 : LastAdaptive"
         >>> frequencies = [77e9]
         >>> sphere = "3D"
-        >>> data = app.get_antenna_ffd_solution_data(frequencies, setup_name, sphere)
+        >>> data = app.get_antenna_ffd_solution_data(frequencies,setup_name,sphere)
         >>> data.plot_farfield_contour()
 
         """
         for k in kwargs:
             if k == "convert_to_db":  # pragma: no cover
                 self.logger.warning("`convert_to_db` is deprecated since v0.7.8. Use `quantity_format` instead.")
                 quantity_format = "dB10" if kwargs["convert_to_db"] else "abs"
             elif k == "qty_str":  # pragma: no cover
-                self.logger.warning("`qty_str` is deprecated since v0.7.8. Use `farfield_quantity` instead.")
-                farfield_quantity = kwargs["qty_str"]
+                self.logger.warning("`qty_str` is deprecated since v0.7.8. Use `quantity` instead.")
+                quantity = kwargs["qty_str"]
             else:  # pragma: no cover
                 msg = "{} not valid.".format(k)
                 self.logger.error(msg)
                 raise TypeError(msg)
 
-        data = self.combine_farfield(phi_scan, theta_scan)
-        if farfield_quantity not in data:  # pragma: no cover
+        data = self.combine_farfield(phi, theta)
+        if quantity not in data:  # pragma: no cover
             self.logger.error("Far field quantity is not available.")
             return False
 
-        data_to_plot = data[farfield_quantity]
+        data_to_plot = data[quantity]
         data_to_plot = conversion_function(data_to_plot, quantity_format)
         if not isinstance(data_to_plot, np.ndarray):  # pragma: no cover
             self.logger.error("Wrong format quantity")
             return False
         data_to_plot = np.reshape(data_to_plot, (data["nTheta"], data["nPhi"]))
         th, ph = np.meshgrid(data["Theta"], data["Phi"])
         if show:
@@ -1591,60 +1607,63 @@
                 x=th,
                 y=ph,
                 qty_to_plot=data_to_plot,
                 xlabel="Theta (degree)",
                 ylabel="Phi (degree)",
                 title=title,
                 levels=levels,
-                snapshot_path=export_image_path,
+                snapshot_path=image_path,
             )
         else:
             return data_to_plot
 
     # fmt: off
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(farfield_quantity="quantity",
+                             phi_scan="phi",
+                             theta_scan="theta",
+                             export_image_path="image_path")
     def plot_2d_cut(
             self,
-            farfield_quantity="RealizedGain",
+            quantity="RealizedGain",
             primary_sweep="phi",
             secondary_sweep_value=0,
-            phi_scan=0,
-            theta_scan=0,
+            phi=0,
+            theta=0,
             title="Far Field Cut",
             quantity_format="dB10",
-            export_image_path=None,
+            image_path=None,
             show=True,
             is_polar=False,
             **kwargs
     ):
         # fmt: on
         """Create a 2D plot of a specified quantity in Matplotlib.
 
         Parameters
         ----------
-        farfield_quantity : str, optional
+        quantity : str, optional
             Quantity to plot. The default is ``"RealizedGain"``.
             Available quantities are: ``"RealizedGain"``, ``"RealizedGain_Theta"``, ``"RealizedGain_Phi"``,
             ``"rETotal"``, ``"rETheta"``, and ``"rEPhi"``.
         primary_sweep : str, optional.
             X axis variable. The default is ``"phi"``. Options are ``"phi"`` and ``"theta"``.
         secondary_sweep_value : float, list, string, optional
             List of cuts on the secondary sweep to plot. The default is ``0``. Options are
             `"all"`, a single value float, or a list of float values.
-        phi_scan : float, int, optional
+        phi : float, int, optional
             Phi scan angle in degrees. The default is ``0``.
-        theta_scan : float, int, optional
+        theta : float, int, optional
             Theta scan angle in degrees. The default is ``0``.
         title : str, optional
             Plot title. The default is ``"RectangularPlot"``.
         quantity_format : str, optional
             Conversion data function.
             Available functions are: ``"abs"``, ``"ang"``, ``"dB10"``, ``"dB20"``, ``"deg"``, ``"imag"``, ``"norm"``,
             and ``"real"``.
-        export_image_path : str, optional
+        image_path : str, optional
             Full path for the image file. The default is ``None``, in which case an image in not exported.
         show : bool, optional
             Whether to show the plot. The default is ``True``.
             If ``False``, the Matplotlib instance of the plot is shown.
         is_polar : bool, optional
             Whether this plot is a polar plot. The default is ``True``.
 
@@ -1659,37 +1678,37 @@
         Examples
         --------
         >>> import pyaedt
         >>> app = pyaedt.Hfss(specified_version="2023.2", designname="Antenna")
         >>> setup_name = "Setup1 : LastAdaptive"
         >>> frequencies = [77e9]
         >>> sphere = "3D"
-        >>> data = app.get_antenna_ffd_solution_data(frequencies, setup_name, sphere)
-        >>> data.plot_2d_cut(theta_scan=20)
+        >>> data = app.get_antenna_ffd_solution_data(frequencies,setup_name,sphere)
+        >>> data.plot_2d_cut(theta=20)
 
         """
 
         for k in kwargs:
             if k == "convert_to_db":  # pragma: no cover
                 self.logger.warning("`convert_to_db` is deprecated since v0.7.8. Use `quantity_format` instead.")
                 quantity_format = "dB10" if kwargs["convert_to_db"] else "abs"
             elif k == "qty_str":  # pragma: no cover
-                self.logger.warning("`qty_str` is deprecated since v0.7.8. Use `farfield_quantity` instead.")
-                farfield_quantity = kwargs["qty_str"]
+                self.logger.warning("`qty_str` is deprecated since v0.7.8. Use `quantity` instead.")
+                quantity = kwargs["qty_str"]
             else:  # pragma: no cover
                 msg = "{} not valid.".format(k)
                 self.logger.error(msg)
                 raise TypeError(msg)
 
-        data = self.combine_farfield(phi_scan, theta_scan)
-        if farfield_quantity not in data:  # pragma: no cover
+        data = self.combine_farfield(phi, theta)
+        if quantity not in data:  # pragma: no cover
             self.logger.error("Far field quantity not available")
             return False
 
-        data_to_plot = data[farfield_quantity]
+        data_to_plot = data[quantity]
 
         curves = []
         if primary_sweep == "phi":
             x_key, y_key = "Phi", "Theta"
             temp = data_to_plot
         else:
             y_key, x_key = "Phi", "Theta"
@@ -1731,64 +1750,67 @@
             show_legend = True
             if len(curves) > 15:
                 show_legend = False
             if is_polar:
                 return plot_polar_chart(
                     curves,
                     xlabel=x_key,
-                    ylabel=farfield_quantity,
+                    ylabel=quantity,
                     title=title,
-                    snapshot_path=export_image_path,
+                    snapshot_path=image_path,
                     show_legend=show_legend,
                 )
             else:
                 return plot_2d_chart(
                     curves,
                     xlabel=x_key,
-                    ylabel=farfield_quantity,
+                    ylabel=quantity,
                     title=title,
-                    snapshot_path=export_image_path,
+                    snapshot_path=image_path,
                     show_legend=show_legend,
                 )
         else:
             return curves
 
     # fmt: off
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(farfield_quantity="quantity",
+                             phi_scan="phi",
+                             theta_scan="theta",
+                             export_image_path="image_path")
     def polar_plot_3d(
             self,
-            farfield_quantity="RealizedGain",
-            phi_scan=0,
-            theta_scan=0,
+            quantity="RealizedGain",
+            phi=0,
+            theta=0,
             title="3D Plot",
             quantity_format="dB10",
-            export_image_path=None,
+            image_path=None,
             show=True,
             **kwargs
     ):
         # fmt: on
         """Create a 3D plot of a specified quantity.
 
         Parameters
         ----------
-        farfield_quantity : str, optional
+        quantity : str, optional
             Far field quantity to plot. The default is ``"RealizedGain"``.
             Available quantities are: ``"RealizedGain"``, ``"RealizedGain_Phi"``, ``"RealizedGain_Theta"``,
             ``"rEPhi"``, ``"rETheta"``, and ``"rETotal"``.
-        phi_scan : float, int, optional
+        phi : float, int, optional
             Phi scan angle in degree. The default is ``0``.
-        theta_scan : float, int, optional
+        theta : float, int, optional
             Theta scan angle in degree. The default is ``0``.
         title : str, optional
             Plot title. The default is ``"3D Plot"``.
         quantity_format : str, optional
             Conversion data function.
             Available functions are: ``"abs"``, ``"ang"``, ``"dB10"``, ``"dB20"``, ``"deg"``, ``"imag"``, ``"norm"``,
             and ``"real"``.
-        export_image_path : str, optional
+        image_path : str, optional
             Full path for the image file. The default is ``None``, in which case a file is not exported.
         show : bool, optional
             Whether to show the plot. The default is ``True``.
             If ``False``, the Matplotlib instance of the plot is shown.
 
         Returns
         -------
@@ -1800,36 +1822,36 @@
         Examples
         --------
         >>> import pyaedt
         >>> app = pyaedt.Hfss(specified_version="2023.2", designname="Antenna")
         >>> setup_name = "Setup1 : LastAdaptive"
         >>> frequencies = [77e9]
         >>> sphere = "3D"
-        >>> data = app.get_antenna_ffd_solution_data(frequencies, setup_name, sphere)
-        >>> data.polar_plot_3d(theta_scan=10)
+        >>> data = app.get_antenna_ffd_solution_data(frequencies,setup_name,sphere)
+        >>> data.polar_plot_3d(theta=10)
 
         """
         for k in kwargs:
             if k == "convert_to_db":  # pragma: no cover
                 self.logger.warning("`convert_to_db` is deprecated since v0.7.8. Use `quantity_format` instead.")
                 quantity_format = "dB10" if kwargs["convert_to_db"] else "abs"
             elif k == "qty_str":  # pragma: no cover
-                self.logger.warning("`qty_str` is deprecated since v0.7.8. Use `farfield_quantity` instead.")
-                farfield_quantity = kwargs["qty_str"]
+                self.logger.warning("`qty_str` is deprecated since v0.7.8. Use `quantity` instead.")
+                quantity = kwargs["qty_str"]
             else:  # pragma: no cover
                 msg = "{} not valid.".format(k)
                 self.logger.error(msg)
                 raise TypeError(msg)
 
-        data = self.combine_farfield(phi_scan, theta_scan)
-        if farfield_quantity not in data:  # pragma: no cover
+        data = self.combine_farfield(phi, theta)
+        if quantity not in data:  # pragma: no cover
             self.logger.error("Far field quantity is not available.")
             return False
 
-        ff_data = conversion_function(data[farfield_quantity], quantity_format)
+        ff_data = conversion_function(data[quantity], quantity_format)
         if not isinstance(ff_data, np.ndarray):  # pragma: no cover
             self.logger.error("Format of the quantity is wrong.")
             return False
 
         # renormalize to 0 and 1
         ff_max = np.max(ff_data)
         ff_min = np.min(ff_data)
@@ -1840,49 +1862,49 @@
         phi_grid, theta_grid = np.meshgrid(phi, theta)
         r = np.reshape(ff_data_renorm, (len(data["Theta"]), len(data["Phi"])))
 
         x = r * np.sin(theta_grid) * np.cos(phi_grid)
         y = r * np.sin(theta_grid) * np.sin(phi_grid)
         z = r * np.cos(theta_grid)
         if show:
-            plot_3d_chart([x, y, z], xlabel="Theta", ylabel="Phi", title=title, snapshot_path=export_image_path)
+            plot_3d_chart([x, y, z], xlabel="Theta", ylabel="Phi", title=title, snapshot_path=image_path)
         else:
             return x, y, z
 
     # fmt: off
-    @pyaedt_function_handler()
+    @pyaedt_function_handler(farfield_quantity="quantity", export_image_path="image_path")
     def polar_plot_3d_pyvista(
             self,
-            farfield_quantity="RealizedGain",
+            quantity="RealizedGain",
             quantity_format="dB10",
             rotation=None,
-            export_image_path=None,
+            image_path=None,
             show=True,
             show_as_standalone=False,
             pyvista_object=None,
             background=None,
             scale_farfield=None,
             show_beam_slider=True,
             show_geometry=True,
             **kwargs
     ):
         # fmt: on
         """Create a 3D polar plot of the geometry with a radiation pattern in PyVista.
 
         Parameters
         ----------
-        farfield_quantity : str, optional
+        quantity : str, optional
             Quantity to plot. The default is ``"RealizedGain"``.
             Available quantities are: ``"RealizedGain"``, ``"RealizedGain_Theta"``, ``"RealizedGain_Phi"``,
             ``"rETotal"``, ``"rETheta"``, and ``"rEPhi"``.
         quantity_format : str, optional
             Conversion data function.
             Available functions are: ``"abs"``, ``"ang"``, ``"dB10"``, ``"dB20"``, ``"deg"``, ``"imag"``, ``"norm"``,
             and ``"real"``.
-        export_image_path : str, optional
+        image_path : str, optional
             Full path for the image file. The default is ``None``, in which case a file is not exported.
         rotation : list, optional
             Far field rotation matrix. The matrix contains three vectors, around x, y, and z axes.
             The default is ``[[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]]``.
         show : bool, optional
             Whether to show the plot. The default is ``True``.
         show_as_standalone : bool, optional
@@ -1909,25 +1931,25 @@
         Examples
         --------
         >>> import pyaedt
         >>> app = pyaedt.Hfss(specified_version="2023.2", designname="Antenna")
         >>> setup_name = "Setup1 : LastAdaptive"
         >>> frequencies = [77e9]
         >>> sphere = "3D"
-        >>> data = app.get_antenna_ffd_solution_data(frequencies, setup_name, sphere)
-        >>> data.polar_plot_3d_pyvista(qty_str="RealizedGain", quantity_format="dB10")
+        >>> data = app.get_antenna_ffd_solution_data(frequencies,setup_name,sphere)
+        >>> data.polar_plot_3d_pyvista(quantity_format="dB10",qty_str="RealizedGain")
 
         """
         for k in kwargs:
             if k == "convert_to_db":  # pragma: no cover
                 self.logger.warning("`convert_to_db` is deprecated since v0.7.8. Use `quantity_format` instead.")
                 quantity_format = "dB10" if kwargs["convert_to_db"] else "abs"
             elif k == "qty_str":  # pragma: no cover
-                self.logger.warning("`qty_str` is deprecated since v0.7.8. Use `farfield_quantity` instead.")
-                farfield_quantity = kwargs["qty_str"]
+                self.logger.warning("`qty_str` is deprecated since v0.7.8. Use `quantity` instead.")
+                quantity = kwargs["qty_str"]
             else:  # pragma: no cover
                 msg = "{} not valid.".format(k)
                 self.logger.error(msg)
                 raise TypeError(msg)
 
         if not rotation:
             rotation = np.eye(3)
@@ -1935,38 +1957,38 @@
             rotation = np.array(rotation)
         text_color = "white"
         if background is None:
             background = [255, 255, 255]
             text_color = "black"
 
         farfield_data = self.combine_farfield(phi_scan=0, theta_scan=0)
-        if farfield_quantity not in farfield_data:  # pragma: no cover
+        if quantity not in farfield_data:  # pragma: no cover
             self.logger.error("Far field quantity is not available.")
             return False
 
         self.farfield_data = farfield_data
 
-        self.mesh = self.get_far_field_mesh(farfield_quantity=farfield_quantity, quantity_format=quantity_format)
+        self.mesh = self.get_far_field_mesh(quantity=quantity, quantity_format=quantity_format)
 
         rotation_euler = self._rotation_to_euler_angles(rotation) * 180 / np.pi
 
-        if not export_image_path and not show:
+        if not image_path and not show:
             off_screen = False
         else:
             off_screen = not show
 
         if not pyvista_object:
             if show_as_standalone:
                 p = pv.Plotter(notebook=False, off_screen=off_screen)
             else:
                 p = pv.Plotter(notebook=is_notebook(), off_screen=off_screen)
         else:  # pragma: no cover
             p = pyvista_object
 
-        uf = UpdateBeamForm(self, farfield_quantity, quantity_format)
+        uf = UpdateBeamForm(self, quantity, quantity_format)
 
         default_background = [255, 255, 255]
         axes_color = [i / 255 for i in default_background]
 
         if isinstance(background, list):
             background_color = [i / 255 for i in background]
             p.background_color = background_color
@@ -2015,15 +2037,15 @@
             width=0.06,
             color=axes_color,
             title=None,
             outline=False,
         )
 
         cad_mesh = self._get_geometry()
-        data = conversion_function(self.farfield_data[farfield_quantity], function_str=quantity_format)
+        data = conversion_function(self.farfield_data[quantity], function_str=quantity_format)
         if not isinstance(data, np.ndarray):  # pragma: no cover
             self.logger.error("Wrong format quantity")
             return False
         max_data = np.max(data)
         min_data = np.min(data)
         ff_mesh_inst = p.add_mesh(uf.output, cmap="jet", clim=[min_data, max_data], scalar_bar_args=sargs)
 
@@ -2077,16 +2099,16 @@
                 p.add_checkbox_button_widget(toggle_vis_cad, value=False, position=(10, 70), size=30)
                 toggle_vis_cad(False)
             else:
                 p.add_checkbox_button_widget(toggle_vis_cad, value=True, position=(10, 70), size=30)
 
             p.add_text("Show Geometry", position=(70, 75), color=text_color, font_size=10)
 
-        if export_image_path:
-            p.show(screenshot=export_image_path)
+        if image_path:
+            p.show(screenshot=image_path)
             return True
         elif show:  # pragma: no cover
             p.show()
             return True
         return p
 
     @pyaedt_function_handler()
@@ -2104,15 +2126,15 @@
         bool
             ``True`` when successful, ``False`` when failed.
         """
         all_ports = self.all_port_names
         valid_ffd = True
 
         if os.path.exists(eep_file_info[all_ports[0]][0]):
-            with open(eep_file_info[all_ports[0]][0], "r") as reader:
+            with open_file(eep_file_info[all_ports[0]][0], "r") as reader:
                 theta = [int(i) for i in reader.readline().split()]
                 phi = [int(i) for i in reader.readline().split()]
             reader.close()
             for port in eep_file_info.keys():
                 temp_dict = {}
                 if ":" in port:
                     port = port.split(":")[0]
@@ -2134,21 +2156,21 @@
             return False
 
         if not valid_ffd:
             return False
 
         return True
 
-    @pyaedt_function_handler()
-    def get_far_field_mesh(self, farfield_quantity="RealizedGain", quantity_format="dB10", **kwargs):
+    @pyaedt_function_handler(farfield_quantity="quantity")
+    def get_far_field_mesh(self, quantity="RealizedGain", quantity_format="dB10", **kwargs):
         """Generate a PyVista ``UnstructuredGrid`` object that represents the far field mesh.
 
         Parameters
         ----------
-        farfield_quantity : str, optional
+        quantity : str, optional
             Far field quantity to plot. The default is ``"RealizedGain"``.
             Available quantities are: ``"RealizedGain"``, ``"RealizedGain_Phi"``, ``"RealizedGain_Theta"``,
             ``"rEPhi"``, ``"rETheta"``, and ``"rETotal"``.
         quantity_format : str, optional
             Conversion data function.
             Available functions are: ``"abs"``, ``"ang"``, ``"dB10"``, ``"dB20"``, ``"deg"``, ``"imag"``, ``"norm"``,
             and ``"real"``.
@@ -2164,19 +2186,19 @@
                 self.logger.warning("`convert_to_db` is deprecated since v0.7.8. Use `quantity_format` instead.")
                 quantity_format = "dB10" if kwargs["convert_to_db"] else "abs"
             else:  # pragma: no cover
                 msg = "{} not valid.".format(k)
                 self.logger.error(msg)
                 raise TypeError(msg)
 
-        if farfield_quantity not in self.farfield_data:
+        if quantity not in self.farfield_data:
             self.logger.error("Far field quantity is not available.")
             return False
 
-        data = self.farfield_data[farfield_quantity]
+        data = self.farfield_data[quantity]
 
         ff_data = conversion_function(data, quantity_format)
 
         if not isinstance(ff_data, np.ndarray):  # pragma: no cover
             self.logger.error("Format of the quantity is wrong.")
             return False
 
@@ -2198,15 +2220,15 @@
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         """
         self._eep_file_info_list.append({})
         if os.path.exists(eep_path):
-            with open(eep_path, "r") as reader:
+            with open_file(eep_path, "r") as reader:
                 lines = [line.split(None) for line in reader]
             lines = lines[1:]  # remove header
             for pattern in lines:
                 if len(pattern) >= 2:
                     port = pattern[0]
                     if ":" in port:
                         port = port.split(":")[0] + "_" + port.split(":")[1]
@@ -2419,16 +2441,16 @@
     Examples
     --------
     >>> import pyaedt
     >>> app = pyaedt.Hfss(specified_version="2023.2", designname="Antenna")
     >>> setup_name = "Setup1 : LastAdaptive"
     >>> frequencies = [77e9]
     >>> sphere = "3D"
-    >>> data = app.get_antenna_ffd_solution_data(frequencies, setup_name, sphere)
-    >>> data.polar_plot_3d_pyvista(qty_str="rETotal", quantity_format="dB10")
+    >>> data = app.get_antenna_ffd_solution_data(frequencies,setup_name,sphere)
+    >>> data.polar_plot_3d_pyvista(quantity_format="dB10",qty_str="rETotal")
 
     """
 
     def __init__(
         self,
         app,
         sphere_name,
@@ -2525,15 +2547,15 @@
                         component_array.a_length,
                         component_array.b_length,
                         component_array.a_length / component_array.a_size,
                         component_array.b_length / component_array.b_size,
                     ]
                     items["lattice_vector"] = component_array.lattice_vector()
 
-                with open(metadata_file_name, "w") as f:
+                with open_file(metadata_file_name, "w") as f:
                     json.dump(items, f, indent=2)
         elapsed_time = time.time() - time_before
         self._app.logger.info("Exporting embedded element patterns.... Done: %s seconds", elapsed_time)
         return path_dict
 
     @pyaedt_function_handler()
     def _create_geometries(self, export_path):
@@ -2578,29 +2600,30 @@
         ``"rEPhi"``, ``"rETheta"``, and ``"rETotal"``.
     quantity_format : str, optional
         Conversion data function.
         Available functions are: ``"abs"``, ``"ang"``, ``"dB10"``, ``"dB20"``, ``"deg"``, ``"imag"``, ``"norm"``,
             and ``"real"``.
     """
 
+    @pyaedt_function_handler(farfield_quantity="quantity")
     def __init__(self, ff, farfield_quantity="RealizedGain", quantity_format="abs"):
         self.output = ff.mesh
         self._phi = 0
         self._theta = 0
         # default parameters
         self.ff = ff
-        self.farfield_quantity = farfield_quantity
+        self.quantity = farfield_quantity
         self.quantity_format = quantity_format
 
     @pyaedt_function_handler()
     def _update_both(self):
         """Update far field."""
         self.ff.farfield_data = self.ff.combine_farfield(phi_scan=self._phi, theta_scan=self._theta)
 
-        self.ff.mesh = self.ff.get_far_field_mesh(self.farfield_quantity, self.quantity_format)
+        self.ff.mesh = self.ff.get_far_field_mesh(self.quantity, self.quantity_format)
 
         self.output.copy_from(self.ff.mesh)
         return
 
     @pyaedt_function_handler()
     def update_phi(self, phi):
         """Update the Phi value."""
@@ -2616,53 +2639,65 @@
 
 class FieldPlot:
     """Provides for creating and editing field plots.
 
     Parameters
     ----------
     postprocessor : :class:`pyaedt.modules.PostProcessor.PostProcessor`
-    objlist : list
+    objects : list
         List of objects.
-    solutionName : str
+    solution : str
         Name of the solution.
-    quantityName : str
+    quantity : str
         Name of the plot or the name of the object.
-    intrinsincList : dict, optional
+    intrinsics : dict, optional
         Name of the intrinsic dictionary. The default is ``{}``.
 
     """
 
+    @pyaedt_function_handler(
+        objlist="objects",
+        surfacelist="surfaces",
+        linelist="lines",
+        cutplanelist="cutplanes",
+        solutionName="solution",
+        quantityName="quantity",
+        IntrinsincList="intrinsics",
+        seedingFaces="seeding_faces",
+        layers_nets="layer_nets",
+        layers_plot_type="layer_plot_type",
+    )
     def __init__(
         self,
         postprocessor,
-        objlist=[],
-        surfacelist=[],
-        linelist=[],
-        cutplanelist=[],
-        solutionName="",
-        quantityName="",
-        intrinsincList={},
-        seedingFaces=[],
-        layers_nets=[],
-        layers_plot_type="LayerNetsExtFace",
+        objects=[],
+        surfaces=[],
+        lines=[],
+        cutplanes=[],
+        solution="",
+        quantity="",
+        intrinsics={},
+        seeding_faces=[],
+        layer_nets=[],
+        layer_plot_type="LayerNetsExtFace",
     ):
         self._postprocessor = postprocessor
         self.oField = postprocessor.ofieldsreporter
-        self.volume_indexes = objlist
-        self.surfaces_indexes = surfacelist
-        self.line_indexes = linelist
-        self.cutplane_indexes = cutplanelist
-        self.layers_nets = layers_nets
-        self.layers_plot_type = layers_plot_type
-        self.seeding_faces = seedingFaces
-        self.solutionName = solutionName
-        self.quantityName = quantityName
-        self.intrinsincList = intrinsincList
+        self.volumes = objects
+        self.surfaces = surfaces
+        self.lines = lines
+        self.cutplanes = cutplanes
+        self.layer_nets = layer_nets
+        self.layer_plot_type = layer_plot_type
+        self.seeding_faces = seeding_faces
+        self.solution = solution
+        self.quantity = quantity
+        self.intrinsics = intrinsics
         self.name = "Field_Plot"
-        self.plotFolder = "Field_Plot"
+        self.plot_folder = "Field_Plot"
         self.Filled = False
         self.IsoVal = "Fringe"
         self.SmoothShade = True
         self.AddGrid = False
         self.MapTransparency = True
         self.Refinement = 0
         self.Transparency = 0
@@ -2700,40 +2735,40 @@
             val = [val]
         self._filter_boxes = val
 
     @property
     def plotGeomInfo(self):
         """Plot geometry information."""
         idx = 0
-        if self.volume_indexes:
+        if self.volumes:
             idx += 1
-        if self.surfaces_indexes:
+        if self.surfaces:
             idx += 1
-        if self.cutplane_indexes:
+        if self.cutplanes:
             idx += 1
-        if self.line_indexes:
+        if self.lines:
             idx += 1
-        if self.layers_nets:
+        if self.layer_nets:
             idx += 1
 
         info = [idx]
-        if self.volume_indexes:
+        if self.volumes:
             info.append("Volume")
             info.append("ObjList")
-            info.append(len(self.volume_indexes))
-            for index in self.volume_indexes:
+            info.append(len(self.volumes))
+            for index in self.volumes:
                 info.append(str(index))
-        if self.surfaces_indexes:
+        if self.surfaces:
             model_faces = []
             nonmodel_faces = []
             if self._postprocessor._app.design_type == "HFSS 3D Layout Design":
-                model_faces = [str(i) for i in self.surfaces_indexes]
+                model_faces = [str(i) for i in self.surfaces]
             else:
                 models = self._postprocessor.modeler.model_objects
-                for index in self.surfaces_indexes:
+                for index in self.surfaces:
                     try:
                         if isinstance(index, FacePrimitive):
                             index = index.id
                         oname = self._postprocessor.modeler.oeditor.GetObjectNameByFaceID(index)
                         if oname in models:
                             model_faces.append(str(index))
                         else:
@@ -2747,34 +2782,34 @@
                 for index in model_faces:
                     info.append(index)
             if nonmodel_faces:
                 info.append("NonModelFaceList")
                 info.append(len(nonmodel_faces))
                 for index in nonmodel_faces:
                     info.append(index)
-        if self.cutplane_indexes:
+        if self.cutplanes:
             info.append("Surface")
             info.append("CutPlane")
-            info.append(len(self.cutplane_indexes))
-            for index in self.cutplane_indexes:
+            info.append(len(self.cutplanes))
+            for index in self.cutplanes:
                 info.append(str(index))
-        if self.line_indexes:
+        if self.lines:
             info.append("Line")
-            info.append(len(self.line_indexes))
-            for index in self.line_indexes:
+            info.append(len(self.lines))
+            for index in self.lines:
                 info.append(str(index))
-        if self.layers_nets:
-            if self.layers_plot_type == "LayerNets":
+        if self.layer_nets:
+            if self.layer_plot_type == "LayerNets":
                 info.append("Volume")
                 info.append("LayerNets")
             else:
                 info.append("Surface")
                 info.append("LayerNetsExtFace")
-            info.append(len(self.layers_nets))
-            for index in self.layers_nets:
+            info.append(len(self.layer_nets))
+            for index in self.layer_nets:
                 info.append(index[0])
                 info.append(len(index[1:]))
                 info.extend(index[1:])
         return info
 
     @property
     def intrinsicVar(self):
@@ -2782,42 +2817,38 @@
 
         Returns
         -------
         list or dict
             List or dictionary of the variables for the field plot.
         """
         var = ""
-        if type(self.intrinsincList) is list:
+        if isinstance(self.intrinsics, list):
             l = 0
-            while l < len(self.intrinsincList):
-                val = self.intrinsincList[l + 1]
-                if ":=" in self.intrinsincList[l] and isinstance(self.intrinsincList[l + 1], list):
-                    val = self.intrinsincList[l + 1][0]
-                ll = self.intrinsincList[l].split(":=")
+            while l < len(self.intrinsics):
+                val = self.intrinsics[l + 1]
+                if ":=" in self.intrinsics[l] and isinstance(self.intrinsics[l + 1], list):
+                    val = self.intrinsics[l + 1][0]
+                ll = self.intrinsics[l].split(":=")
                 var += ll[0] + "='" + str(val) + "' "
                 l += 2
         else:
-            for a in self.intrinsincList:
-                var += a + "='" + str(self.intrinsincList[a]) + "' "
+            for a in self.intrinsics:
+                var += a + "='" + str(self.intrinsics[a]) + "' "
         return var
 
     @property
     def plotsettings(self):
         """Plot settings.
 
         Returns
         -------
         list
             List of plot settings.
         """
-        if (
-            self.surfaces_indexes
-            or self.cutplane_indexes
-            or (self.layers_nets and self.layers_plot_type == "LayerNetsExtFace")
-        ):
+        if self.surfaces or self.cutplanes or (self.layer_nets and self.layer_plot_type == "LayerNetsExtFace"):
             arg = [
                 "NAME:PlotOnSurfaceSettings",
                 "Filled:=",
                 self.Filled,
                 "IsoValType:=",
                 self.IsoVal,
                 "SmoothShade:=",
@@ -2842,15 +2873,15 @@
                     self.MinArrowSpacing,
                     "MaxArrowSpacing:=",
                     self.MaxArrowSpacing,
                 ],
                 "GridColor:=",
                 self.GridColor,
             ]
-        elif self.line_indexes:
+        elif self.lines:
             arg = [
                 "NAME:PlotOnLineSettings",
                 ["NAME:LineSettingsID", "Width:=", self.LineWidth, "Style:=", self.LineStyle],
                 "IsoValType:=",
                 self.IsoValType,
                 "ArrowUniform:=",
                 self.ArrowUniform,
@@ -2897,19 +2928,19 @@
         list
             List of surface plot settings.
 
         """
         out = [
             "NAME:" + self.name,
             "SolutionName:=",
-            self.solutionName,
+            self.solution,
             "QuantityName:=",
-            self.quantityName,
+            self.quantity,
             "PlotFolder:=",
-            self.plotFolder,
+            self.plot_folder,
         ]
         if self.field_type:
             out.extend(["FieldType:=", self.field_type])
         out.extend(
             [
                 "UserSpecifyName:=",
                 1,
@@ -2946,23 +2977,23 @@
         list
             List of plot settings for line traces.
 
         """
         out = [
             "NAME:" + self.name,
             "SolutionName:=",
-            self.solutionName,
+            self.solution,
             "UserSpecifyName:=",
             0,
             "UserSpecifyFolder:=",
             0,
             "QuantityName:=",
             "QuantityName_FieldLineTrace",
             "PlotFolder:=",
-            self.plotFolder,
+            self.plot_folder,
         ]
         if self.field_type:
             out.extend(["FieldType:=", self.field_type])
         out.extend(
             [
                 "IntrinsicVar:=",
                 self.intrinsicVar,
@@ -2971,17 +3002,17 @@
                 "Use Adaptive Step:=",
                 self.UseAdaptiveStep,
                 "Seeding Faces:=",
                 self.seeding_faces,
                 "Seeding Markers:=",
                 [0],
                 "Surface Tracing Objects:=",
-                self.surfaces_indexes,
+                self.surfaces,
                 "Volume Tracing Objects:=",
-                self.volume_indexes,
+                self.volumes,
                 "Seeding Sampling Option:=",
                 self.SeedingSamplingOption,
                 "Seeding Points Number:=",
                 self.SeedingPointsNumber,
                 "Fractional of Maximal:=",
                 self.FractionOfMaximum,
                 "Discrete Seeds Option:=",
@@ -3108,36 +3139,36 @@
                             return False
                         else:
                             if face not in list(self._postprocessor._app.modeler.objects.keys()):
                                 self._postprocessor.logger.error("Invalid object id.")
                                 self.seeding_faces.remove(face)
                                 return False
                     self.seeding_faces[0] = len(self.seeding_faces) - 1
-                if self.volume_indexes[0] != len(self.volume_indexes) - 1:
-                    for obj in self.volume_indexes[1:]:
+                if self.volumes[0] != len(self.volumes) - 1:
+                    for obj in self.volumes[1:]:
                         if not isinstance(obj, int):
                             self._postprocessor.logger.error("Provide valid object id for in-volume object.")
                             return False
                         else:
                             if obj not in list(self._postprocessor._app.modeler.objects.keys()):
                                 self._postprocessor.logger.error("Invalid object id.")
-                                self.volume_indexes.remove(obj)
+                                self.volumes.remove(obj)
                                 return False
-                    self.volume_indexes[0] = len(self.volume_indexes) - 1
-                if self.surfaces_indexes[0] != len(self.surfaces_indexes) - 1:
-                    for obj in self.surfaces_indexes[1:]:
+                    self.volumes[0] = len(self.volumes) - 1
+                if self.surfaces[0] != len(self.surfaces) - 1:
+                    for obj in self.surfaces[1:]:
                         if not isinstance(obj, int):
                             self._postprocessor.logger.error("Provide valid object id for surface object.")
                             return False
                         else:
                             if obj not in list(self._postprocessor._app.modeler.objects.keys()):
                                 self._postprocessor.logger.error("Invalid object id.")
-                                self.surfaces_indexes.remove(obj)
+                                self.surfaces.remove(obj)
                                 return False
-                    self.surfaces_indexes[0] = len(self.surfaces_indexes) - 1
+                    self.surfaces[0] = len(self.surfaces) - 1
                 self.oField.ModifyFieldPlot(self.name, self.surfacePlotInstructionLineTraces)
             else:
                 self.oField.ModifyFieldPlot(self.name, self.surfacePlotInstruction)
             return True
         except Exception:
             return False
 
@@ -3212,15 +3243,15 @@
                 not is_log,
                 "dB:=",
                 is_db,
                 "ScaleType:=",
                 1,
             ]
         ]
-        self.oField.SetPlotFolderSettings(self.plotFolder, args)
+        self.oField.SetPlotFolderSettings(self.plot_folder, args)
         return True
 
     @pyaedt_function_handler()
     def export_image(self, full_path=None, width=1920, height=1080, orientation="isometric", display_wireframe=True):
         """Export the active plot to an image file.
 
         .. note::
@@ -3248,26 +3279,27 @@
         References
         ----------
 
         >>> oModule.ExportPlotImageToFile
         >>> oModule.ExportModelImageToFile
         >>> oModule.ExportPlotImageWithViewToFile
         """
-        self.oField.UpdateQuantityFieldsPlots(self.plotFolder)
+        self.oField.UpdateQuantityFieldsPlots(self.plot_folder)
         if not full_path:
             full_path = os.path.join(self._postprocessor._app.working_directory, self.name + ".png")
         status = self._postprocessor.export_field_jpg(
             full_path,
             self.name,
-            self.plotFolder,
+            self.plot_folder,
             orientation=orientation,
             width=width,
             height=height,
             display_wireframe=display_wireframe,
         )
+        full_path = check_and_download_file(full_path)
         if status:
             return full_path
         else:
             return False
 
     @pyaedt_function_handler()
     def export_image_from_aedtplt(
@@ -3309,15 +3341,15 @@
         if sys.version_info.major > 2:
             return self._postprocessor.plot_field_from_fieldplot(
                 self.name,
                 project_path=export_path,
                 meshplot=plot_mesh,
                 imageformat="jpg",
                 view=view,
-                plot_label=self.quantityName,
+                plot_label=self.quantity,
                 show=False,
                 scale_min=scale_min,
                 scale_max=scale_max,
             )
         else:
             self._postprocessor.logger.info("This method works only on CPython with PyVista")
             return False
@@ -3327,42 +3359,43 @@
     """Creates and edits VRT field plots for SBR+ and Creeping Waves.
 
     Parameters
     ----------
     postprocessor : :class:`pyaedt.modules.PostProcessor.PostProcessor`
     is_creeping_wave : bool
         Whether it is a creeping wave model or not.
-    quantity_name : str, optional
+    quantity : str, optional
         Name of the plot or the name of the object.
     max_frequency : str, optional
         Maximum Frequency. The default is ``"1GHz"``.
     ray_density : int, optional
         Ray Density. The default is ``2``.
     bounces : int, optional
         Maximum number of bounces. The default is ``5``.
-    intrinsinc_list : dict, optional
+    intrinsics : dict, optional
         Name of the intrinsic dictionary. The default is ``{}``.
 
     """
 
+    @pyaedt_function_handler(quantity_name="quantity")
     def __init__(
         self,
         postprocessor,
         is_creeping_wave=False,
-        quantity_name="QuantityName_SBR",
+        quantity="QuantityName_SBR",
         max_frequency="1GHz",
         ray_density=2,
         bounces=5,
-        intrinsinc_list={},
+        intrinsics={},
     ):
         self.is_creeping_wave = is_creeping_wave
         self._postprocessor = postprocessor
         self._ofield = postprocessor.ofieldsreporter
-        self.quantity_name = quantity_name
-        self.intrinsics = intrinsinc_list
+        self.quantity = quantity
+        self.intrinsics = intrinsics
         self.name = "Field_Plot"
         self.plot_folder = "Field_Plot"
         self.max_frequency = max_frequency
         self.ray_density = ray_density
         self.number_of_bounces = bounces
         self.multi_bounce_ray_density_control = False
         self.mbrd_max_subdivision = 2
@@ -3413,15 +3446,15 @@
         args = [
             "NAME:" + self.name,
             "UserSpecifyName:=",
             0,
             "UserSpecifyFolder:=",
             0,
             "QuantityName:=",
-            self.quantity_name,
+            self.quantity,
             "PlotFolder:=",
             "Visual Ray Trace SBR",
             "IntrinsicVar:=",
             self.intrinsicVar,
             "MaxFrequency:=",
             self.max_frequency,
             "RayDensity:=",
@@ -3483,15 +3516,15 @@
         args = [
             "NAME:" + self.name,
             "UserSpecifyName:=",
             0,
             "UserSpecifyFolder:=",
             0,
             "QuantityName:=",
-            self.quantity_name,
+            self.quantity,
             "PlotFolder:=",
             "Visual Ray Trace CW",
             "IntrinsicVar:=",
             "",
             "MaxFrequency:=",
             self.max_frequency,
             "SampleDensity:=",
@@ -3562,25 +3595,26 @@
 
     @pyaedt_function_handler()
     def delete(self):
         """Delete the field plot."""
         self._ofield.DeleteFieldPlot([self.name])
         return True
 
-    @pyaedt_function_handler()
-    def export(self, path_to_hdm_file=None):
+    @pyaedt_function_handler(path_to_hdm_file="path")
+    def export(self, path=None):
         """Export the Visual Ray Tracing to ``hdm`` file.
 
         Parameters
         ----------
-        path_to_hdm_file : str, optional
-            Full path to output file. If ``None``, the file will be exported in working directory.
+        path : str, optional
+            Full path to the output file. The default is ``None``, in which case the file is
+            exported to the working directory.
 
         Returns
         -------
         str
             Path to the file.
         """
-        if not path_to_hdm_file:
-            path_to_hdm_file = os.path.join(self._postprocessor._app.working_directory, self.name + ".hdm")
-        self._ofield.ExportFieldPlot(self.name, False, path_to_hdm_file)
-        return path_to_hdm_file
+        if not path:
+            path = os.path.join(self._postprocessor._app.working_directory, self.name + ".hdm")
+        self._ofield.ExportFieldPlot(self.name, False, path)
+        return path
```

### Comparing `pyaedt-0.8.7/pyaedt/q3d.py` & `pyaedt-0.8.8/pyaedt/q3d.py`

 * *Files 1% similar despite different names*

```diff
@@ -79,26 +79,30 @@
             port,
             aedt_process_id,
         )
         self.matrices = []
         for el in list(self.omatrix.ListReduceMatrixes()):
             self.matrices.append(Matrix(self, el))
 
-    @property
-    def excitations(self):
-        """Get all excitation names.
+    @pyaedt_function_handler()
+    def sources(self, matrix_index=0, is_gc_sources=True):
+        """List of matrix sources.
+
+        Parameters
+        ----------
+        matrix_index : int, optional
+            Matrix index in matrices list. Default is ``0`` to use main matrix with no reduction.
+        is_gc_sources : bool,
+            In Q3d, define if to return GC sources or RL sources. Default `True`.
 
         Returns
         -------
-        list
-            List of excitation names. Excitations with multiple modes will return one
-            excitation for each mode.
-
+        List
         """
-        return self.matrices[0].sources(False)
+        return self.matrices[matrix_index].sources(is_gc_sources=is_gc_sources)
 
     @pyaedt_function_handler()
     def insert_reduced_matrix(
         self,
         operation_name,
         source_names=None,
         rm_name=None,
@@ -156,15 +160,15 @@
             List of all setup sources.
 
         References
         ----------
 
         >>> oModule.GetAllSources
         """
-        return self.excitations
+        return self.sources(0, False)
 
     @pyaedt_function_handler()
     def get_traces_for_plot(
         self,
         get_self_terms=True,
         get_mutual_terms=True,
         first_element_filter=None,
@@ -205,21 +209,21 @@
             get_self_terms=get_self_terms,
             get_mutual_terms=get_mutual_terms,
             first_element_filter=first_element_filter,
             second_element_filter=second_element_filter,
             category=category,
         )
 
-    @pyaedt_function_handler()
-    def export_mesh_stats(self, setup_name, variation_string="", mesh_path=None, setup_type="CG"):
+    @pyaedt_function_handler(setup_name="setup")
+    def export_mesh_stats(self, setup, variation_string="", mesh_path=None, setup_type="CG"):
         """Export mesh statistics to a file.
 
         Parameters
         ----------
-        setup_name : str
+        setup : str
             Setup name.
         variation_string : str, optional
             Variation list. The default is ``""``.
         mesh_path : str, optional
             Full path to the mesh statistics file. The default is ``None``, in which
             case the working directory is used.
         setup_type : str, optional
@@ -233,15 +237,15 @@
 
         References
         ----------
         >>> oDesign.ExportMeshStats
         """
         if not mesh_path:
             mesh_path = os.path.join(self.working_directory, "meshstats.ms")
-        self.odesign.ExportMeshStats(setup_name, variation_string, setup_type, mesh_path)
+        self.odesign.ExportMeshStats(setup, variation_string, setup_type, mesh_path)
         return mesh_path
 
     @pyaedt_function_handler()
     def edit_sources(
         self,
         cg=None,
         acrl=None,
@@ -273,25 +277,23 @@
             ``True`` when successful, ``False`` when failed.
 
         Examples
         --------
         >>> sources_cg = {"Box1": ("1V", "0deg"), "Box1_2": "1V"}
         >>> sources_acrl = {"Box1:Source1": ("5A", "0deg")}
         >>> sources_dcrl = {"Box1_1:Source2": ("5V", "0deg")}
-        >>> hfss.edit_sources(sources_cg, sources_acrl, sources_dcrl)
+        >>> hfss.edit_sources(sources_cg,sources_acrl,sources_dcrl)
         """
         setting_AC = []
         setting_CG = []
         setting_DC = []
         if cg:
             net_list = ["NAME:Source Names"]
-            if self.default_solution_type == "Q3D Extractor":
-                excitation = self.nets
-            else:
-                excitation = self.excitations
+
+            excitation = self.excitations
 
             for key, value in cg.items():
                 if key not in excitation:
                     self.logger.error("Not existing net " + key)
                     return False
                 else:
                     net_list.append(key)
@@ -318,16 +320,16 @@
             if self.default_solution_type == "Q3D Extractor":
                 setting_CG = ["NAME:Cap", "Value Type:=", "N", net_list, value_list, phase_list]
             else:
                 setting_CG = ["NAME:CGSources", net_list, value_list, phase_list]
         if acrl:
             source_list = ["NAME:Source Names"]
             unit = "V"
+            excitation = self.sources(0, False)
             for key, value in acrl.items():
-                excitation = self.excitations
                 if key not in excitation:
                     self.logger.error("Not existing excitation " + key)
                     return False
                 else:
                     source_list.append(key)
             if self.default_solution_type == "Q3D Extractor":
                 value_list = ["NAME:Source Values"]
@@ -358,16 +360,16 @@
             if self.default_solution_type == "Q3D Extractor":
                 setting_AC = ["NAME:AC", "Value Type:=", unit, source_list, value_list]
             else:
                 setting_AC = ["NAME:RLSources", source_list, value_list, phase_list]
         if dcrl and self.default_solution_type == "Q3D Extractor":
             unit = "V"
             source_list = ["NAME:Source Names"]
+            excitation = self.sources(0, False)
             for key, value in dcrl.items():
-                excitation = self.excitations
                 if key not in excitation:
                     self.logger.error("Not existing excitation " + key)
                     return False
                 else:
                     source_list.append(key)
             if self.default_solution_type == "Q3D Extractor":
                 value_list = ["NAME:Source Values"]
@@ -389,30 +391,31 @@
         if self.default_solution_type == "Q3D Extractor":
             self.osolution.EditSources(setting_AC, setting_CG, setting_DC)
         else:
             self.osolution.EditSources(setting_CG, setting_AC)
 
         return True
 
+    @pyaedt_function_handler(setup_name="setup")
     def export_matrix_data(
         self,
         file_name,
         problem_type=None,
         variations=None,
-        setup_name=None,
+        setup=None,
         sweep=None,
         reduce_matrix=None,
         r_unit="ohm",
         l_unit="nH",
         c_unit="pF",
         g_unit="mho",
         freq=None,
         freq_unit=None,
         matrix_type=None,
-        export_AC_DC_res=False,
+        export_ac_dc_res=False,
         precision=None,
         field_width=None,
         use_sci_notation=True,
         length_setting="Distributed",
         length="1meter",
     ):
         """Export matrix data.
@@ -425,15 +428,15 @@
             and ``*.txt``.
         problem_type : str, optional
             Problem type. The default value is ``None``, in which case ``"C"`` is
             used. Options are ``"C"``, ``"AC RL"``, and ``"DC RL"``.
         variations : str, optional
             Design variation. The default is ``None``, in which case the
             current nominal variation is used.
-        setup_name : str, optional
+        setup : str, optional
             Setup name. The default value is ``None``, in which case the first
             analysis setup is used.
         sweep : str, optional
             Solution frequency. The default is ``None``, in which case
             the default adaptive is used.
         reduce_matrix : str, optional
             Name of the matrix to display.
@@ -453,20 +456,19 @@
         freq : str, optional
             Selected frequency.
             The default value is ``"0Hz"``.
         freq_unit : str, optional
             Frequency unit. The default value is ``None``, in which case the
             default unit is used.
         matrix_type : str, optional
-            Matrix Type.
-            Possible Values are "Maxwell", "Spice" and "Couple".
-            The default value is ``None``.
-        export_AC_DC_res : bool, optional
-            Whether to add the AC and DC res.
-            The default value is ``False``.
+            Matrix type. The default is ``None``.
+            Options are ``"Couple"``, ``"Maxwell"``, and ``"Spice"``.
+        export_ac_dc_res : bool, optional
+            Whether to add the AC and DC resistance.
+            The default is ``False``.
         precision : int, optional
             Precision format.
             The default value is ``15``.
         field_width : int, optional
             Field Width.
             The default value is ``20``.
         use_sci_notation : bool, optional
@@ -554,27 +556,27 @@
                     variation = "{}='{}'".format(
                         list(self.available_variations.nominal_w_values_dict.keys())[x],
                         list(self.available_variations.nominal_w_values_dict.values())[x],
                     )
                     variations_list.append(variation)
                 variations = ",".join(variations_list)
 
-        if setup_name is None:
-            setup_name = self.active_setup
-        elif setup_name != self.active_setup:
-            self.logger.error("Setup named: %s is invalid. Provide a valid analysis setup name.", setup_name)
+        if setup is None:
+            setup = self.active_setup
+        elif setup != self.active_setup:
+            self.logger.error("Setup named: %s is invalid. Provide a valid analysis setup name.", setup)
             return False
         if sweep is None:
             sweep = self.design_solutions.default_adaptive
         else:
             sweep_array = [x.split(": ")[1] for x in self.existing_analysis_sweeps]
             if sweep.replace(" ", "") not in sweep_array:
                 self.logger.error("Sweep is invalid. Provide a valid sweep.")
                 return False
-        analysis_setup = setup_name + " : " + sweep.replace(" ", "")
+        analysis_setup = setup + " : " + sweep.replace(" ", "")
 
         if reduce_matrix is None:
             reduce_matrix = "Original"
         else:
             if self.matrices:
                 if not [matrix for matrix in self.matrices if matrix.name == reduce_matrix]:
                     self.logger.error("Matrix doesn't exist. Provide an existing matrix.")
@@ -617,26 +619,24 @@
                 self.logger.error("Provide a valid unit for conductance.")
                 return False
 
         if freq is None:
             freq = (
                 re.compile(r"(\d+)\s*(\w+)")
                 .match(
-                    self.modeler._odesign.GetChildObject("Analysis")
-                    .GetChildObject(setup_name)
-                    .GetPropValue("Adaptive Freq")
+                    self.modeler._odesign.GetChildObject("Analysis").GetChildObject(setup).GetPropValue("Adaptive Freq")
                 )
                 .groups()[0]
             )
         else:
             if freq_unit != self.odesktop.GetDefaultUnit("Frequency") and freq_unit is not None:
                 freq = go.parse_dim_arg("{}{}".format(freq, freq_unit), self.odesktop.GetDefaultUnit("Frequency"))
 
-        if export_AC_DC_res is None:
-            export_AC_DC_res = False
+        if export_ac_dc_res is None:
+            export_ac_dc_res = False
 
         if precision is None:
             precision = 15
         else:
             if not isinstance(precision, int):
                 self.logger.error("Precision type must be integer.")
                 return False
@@ -696,15 +696,15 @@
                     l_unit,
                     c_unit,
                     g_unit,
                     freq,
                     length_setting,
                     length,
                     matrix_type,
-                    export_AC_DC_res,
+                    export_ac_dc_res,
                     precision,
                     field_width,
                     use_sci_notation,
                 )
                 return True
             except Exception:
                 self.logger.error("Export of matrix data was unsuccessful.")
@@ -719,15 +719,15 @@
                     reduce_matrix,
                     r_unit,
                     l_unit,
                     c_unit,
                     g_unit,
                     freq,
                     matrix_type,
-                    export_AC_DC_res,
+                    export_ac_dc_res,
                     precision,
                     field_width,
                     use_sci_notation,
                 )
                 return True
             except Exception:
                 self.logger.error("Export of matrix data was unsuccessful.")
@@ -1784,15 +1784,15 @@
         .. deprecated:: 0.7.12
             This method is deprecated. To create a frequency sweep use ``create_frequency_sweep()``
             from setup object.
             Example
             -------
             >>> from pyaedt import Q3d
             >>> q3d = Q3d()
-            >>> setup1 = q3d.create_setup(setupname="Setup1")
+            >>> setup1 = q3d.create_setup(name="Setup1")
             >>> sweep1 = setup1.create_frequency_sweep(unit="GHz", freqstart=0.5, freqstop=1.5, sweepname="Sweep1")
             >>> q3d.release_desktop(True, True)
 
         Parameters
         ----------
         setupname : str
             Name of the setup that is attached to the sweep.
@@ -1855,15 +1855,15 @@
         .. deprecated:: 0.7.12
             This method is deprecated. To create a discrete frequency sweep use ``create_frequency_sweep()``
             from setup object.
             Example
             -------
             >>> from pyaedt import Q3d
             >>> q3d = Q3d()
-            >>> setup1 = q3d.create_setup(setupname="Setup1")
+            >>> setup1 = q3d.create_setup(name="Setup1")
             >>> sweep1 = setup1.create_frequency_sweep(unit="GHz",
             ...                                        freqstart=0.5,
             ...                                        freqstop=1.5,
             ...                                        sweepname="Sweep1",
             ...                                        sweep_type="Discrete")
             >>> q3d.release_desktop(True, True)
 
@@ -1970,25 +1970,24 @@
                 magnetic_threshold = np.longdouble(magnetic_threshold)
 
             self.oboundary.SetMaterialThresholds(insulator_threshold, perfect_conductor_threshold, magnetic_threshold)
             return True
         except Exception:
             return False
 
-    @pyaedt_function_handler()
-    def create_setup(self, setupname="MySetupAuto", **kwargs):
+    @pyaedt_function_handler(setupname="name")
+    def create_setup(self, name="MySetupAuto", **kwargs):
         """Create an analysis setup for Q3D Extractor.
 
-        Optional arguments are passed along with the ``setupname`` parameter.
-
+        Optional arguments are passed along with the ``name`` parameter.
 
         Parameters
         ----------
 
-        setupname : str, optional
+        name : str, optional
             Name of the setup. The default is "Setup1".
         **kwargs : dict, optional
             Available keys depend on the setup chosen.
             For more information, see :doc:`../SetupTemplatesQ3D`.
 
         Returns
         -------
@@ -2001,23 +2000,23 @@
         >>> oModule.InsertSetup
 
         Examples
         --------
 
         >>> from pyaedt import Q3d
         >>> app = Q3d()
-        >>> app.create_setup(setupname="Setup1", DC__MinPass=2)
+        >>> app.create_setup(name="Setup1",DC__MinPass=2)
 
         """
-        setuptype = self.design_solutions.default_setup
+        setup_type = self.design_solutions.default_setup
 
         if "props" in kwargs:
-            return self._create_setup(setupname=setupname, setuptype=setuptype, props=kwargs["props"])
+            return self._create_setup(name=name, setup_type=setup_type, props=kwargs["props"])
         else:
-            setup = self._create_setup(setupname=setupname, setuptype=setuptype)
+            setup = self._create_setup(name=name, setup_type=setup_type)
         setup.auto_update = False
         for arg_name, arg_value in kwargs.items():
             if setup[arg_name] is not None:
                 setup[arg_name] = arg_value
         setup.auto_update = True
         setup.update()
         return setup
@@ -2486,36 +2485,34 @@
                     bound.type = new_type
             self.logger.info("Conductor type correctly updated")
             return True
         except Exception:
             self.logger.error("Error in updating conductor type")
             return False
 
-    @pyaedt_function_handler()
-    def create_setup(self, setupname="MySetupAuto", setuptype=None, **kwargs):
+    @pyaedt_function_handler(setup_name="name", setuptype="setup_type")
+    def create_setup(self, name="MySetupAuto", setup_type=None, **kwargs):
         """Create an analysis setup for 2D Extractor.
 
-        Optional arguments are passed along with the ``setuptype`` and ``setupname``
-        parameters.  Keyword names correspond to the ``setuptype``
+        Optional arguments are passed along with the ``setup_type`` and ``name``
+        parameters.  Keyword names correspond to the ``setup_type``
         corresponding to the native AEDT API.  The list of
         keywords here is not exhaustive.
 
-
         Parameters
         ----------
-        setuptype : int, str, optional
+        name : str, optional
+            Name of the setup. The default is "Setup1".
+        setup_type : int, str, optional
             Type of the setup. Options are "IcepakSteadyState"
             and "IcepakTransient". The default is "IcepakSteadyState".
-        setupname : str, optional
-            Name of the setup. The default is "Setup1".
         **kwargs : dict, optional
             Available keys depend on the setup chosen.
             For more information, see :doc:`../SetupTemplatesQ3D`.
 
-
         Returns
         -------
         :class:`pyaedt.modules.SolveSetup.SetupHFSS`
             Solver Setup object.
 
         References
         ----------
@@ -2523,25 +2520,25 @@
         >>> oModule.InsertSetup
 
         Examples
         --------
 
         >>> from pyaedt import Q2d
         >>> app = Q2d()
-        >>> app.create_setup(setupname="Setup1", RLDataBlock__MinPass=2))
+        >>> app.create_setup(name="Setup1",RLDataBlock__MinPass=2)
 
         """
-        if setuptype is None:
-            setuptype = self.design_solutions.default_setup
-        elif setuptype in SetupKeys.SetupNames:
-            setuptype = SetupKeys.SetupNames.index(setuptype)
+        if setup_type is None:
+            setup_type = self.design_solutions.default_setup
+        elif setup_type in SetupKeys.SetupNames:
+            setup_type = SetupKeys.SetupNames.index(setup_type)
         if "props" in kwargs:
-            return self._create_setup(setupname=setupname, setuptype=setuptype, props=kwargs["props"])
+            return self._create_setup(name=name, setup_type=setup_type, props=kwargs["props"])
         else:
-            setup = self._create_setup(setupname=setupname, setuptype=setuptype)
+            setup = self._create_setup(name=name, setup_type=setup_type)
         setup.auto_update = False
         for arg_name, arg_value in kwargs.items():
             if setup[arg_name] is not None:
                 setup[arg_name] = arg_value
         setup.auto_update = True
         setup.update()
         return setup
```

### Comparing `pyaedt-0.8.7/pyaedt/rmxprt.py` & `pyaedt-0.8.8/pyaedt/rmxprt.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,13 +1,14 @@
 """This module contains these classes: ``RMXprtModule`` and ``Rmxprt``."""
 
 from __future__ import absolute_import  # noreorder
 
 from pyaedt.application.AnalysisRMxprt import FieldAnalysisRMxprt
 from pyaedt.generic.general_methods import pyaedt_function_handler
+from pyaedt.modules.SetupTemplates import SetupKeys
 
 
 class RMXprtModule(object):
     """Provides RMxprt module properties."""
 
     component = None
     prop_servers = None
@@ -245,35 +246,34 @@
         """Machine design type."""
         return self.design_solutions.design_type
 
     @design_type.setter
     def design_type(self, value):
         self.design_solutions.design_type = value
 
-    @pyaedt_function_handler()
-    def create_setup(self, setupname="MySetupAuto", setuptype=None, **kwargs):
+    @pyaedt_function_handler(name="name", setuptype="setup_type")
+    def create_setup(self, name="MySetupAuto", setup_type=None, **kwargs):
         """Create an analysis setup for RmXport.
 
-        Optional arguments are passed along with the ``setuptype`` and ``setupname``
-        parameters. Keyword names correspond to the ``setuptype``
+        Optional arguments are passed along with the ``setup_type`` and ``name``
+        parameters. Keyword names correspond to the ``setup_type``
         corresponding to the native AEDT API.  The list of
         keywords here is not exhaustive.
 
         Parameters
         ----------
-        setuptype : int, str, optional
+        name : str, optional
+            Name of the setup. The default is "Setup1".
+        setup_type : int, str, optional
             Type of the setup. Options are "IcepakSteadyState"
             and "IcepakTransient". The default is "IcepakSteadyState".
-        setupname : str, optional
-            Name of the setup. The default is "Setup1".
         **kwargs : dict, optional
             Available keys depend on the setup chosen.
             For more information, see :doc:`../SetupTemplatesRmxprt`.
 
-
         Returns
         -------
         :class:`pyaedt.modules.SolveSetup.SetupHFSS`
             Solver Setup object.
 
         References
         ----------
@@ -281,25 +281,25 @@
         >>> oModule.InsertSetup
 
         Examples
         --------
 
         >>> from pyaedt import Hfss
         >>> hfss = Hfss()
-        >>> hfss.create_setup(setupname="Setup1", setuptype="HFSSDriven", Frequency="10GHz")
+        >>> hfss.create_setup(name="Setup1",setup_type="HFSSDriven",Frequency="10GHz")
 
         """
-        if setuptype is None:
-            setuptype = self.design_solutions.default_setup
-        elif setuptype in SetupKeys.SetupNames:
-            setuptype = SetupKeys.SetupNames.index(setuptype)
+        if setup_type is None:
+            setup_type = self.design_solutions.default_setup
+        elif setup_type in SetupKeys.SetupNames:
+            setup_type = SetupKeys.SetupNames.index(setup_type)
         if "props" in kwargs:
-            return self._create_setup(setupname=setupname, setuptype=setuptype, props=kwargs["props"])
+            return self._create_setup(name=name, setup_type=setup_type, props=kwargs["props"])
         else:
-            setup = self._create_setup(setupname=setupname, setuptype=setuptype)
+            setup = self._create_setup(name=name, setup_type=setup_type)
         setup.auto_update = False
         for arg_name, arg_value in kwargs.items():
             if setup[arg_name] is not None:
                 setup[arg_name] = arg_value
         setup.auto_update = True
         setup.update()
         return setup
```

### Comparing `pyaedt-0.8.7/pyaedt/rpc/rpyc_services.py` & `pyaedt-0.8.8/pyaedt/rpc/rpyc_services.py`

 * *Files 0% similar despite different names*

```diff
@@ -143,19 +143,19 @@
             if self.client.root.isdir(rfn):
                 self._download_dir(rfn, lfn, overwrite=overwrite)
             else:
                 self._download_file(rfn, lfn, overwrite=overwrite)
             i += 1
         logger.info("Directory %s downloaded. %s files copied", localpath, i)
 
-    def open_file(self, remote_file, open_options="r"):
-        return self.client.root.open(remote_file, open_options=open_options)
+    def open_file(self, remote_file, open_options="r", encoding=None):
+        return self.client.root.open(remote_file, open_options=open_options, encoding=encoding)
 
-    def create_file(self, remote_file, create_options="w"):
-        return self.client.root.open(remote_file, open_options=create_options)
+    def create_file(self, remote_file, create_options="w", encoding=None, override=True):
+        return self.client.root.create(remote_file, open_options=create_options, encoding=encoding, override=override)
 
     def makedirs(self, remotepath):
         if self.client.root.pathexists(remotepath):
             return "Directory Exists!"
         self.client.root.makedirs(remotepath)
         return "Directory created."
 
@@ -168,14 +168,18 @@
             return self.client.root.listdir(remotepath)
         return []
 
     def pathexists(self, remotepath):
         if self.client.root.pathexists(remotepath):
             return True
         return False
+    def unlink(self, remotepath):
+        if self.client.root.unlink(remotepath):
+            return True
+        return False
     def normpath(self, remotepath):
         return self.client.root.normpath(remotepath)
     def isdir(self, remotepath):
         return self.client.root.isdir(remotepath)
     def temp_dir(self):
         return self.client.root.temp_dir()
 
@@ -1021,23 +1025,23 @@
                   edbversion=edbversion,
                   isaedtowned=isaedtowned,
                   oproject=oproject,
                   student_version=student_version,
                   use_ppe=use_ppe, )
 
     @staticmethod
-    def exposed_open(filename, open_options="rb"):
-        f = open(filename, open_options)
+    def exposed_open(filename, open_options="rb", encoding=None):
+        f = open(filename, open_options, encoding=encoding)
         return rpyc.restricted(f, ["read", "readlines", "close"], [])
 
     @staticmethod
-    def exposed_create(filename,create_options="wb"):
-        if os.path.exists(filename):
+    def exposed_create(filename,create_options="wb", encoding=None, override=True):
+        if os.path.exists(filename) and not override:
             return "File already exists"
-        f = open(filename, create_options)
+        f = open(filename, create_options, encoding=encoding)
         return rpyc.restricted(f, ["read", "readlines", "write", "writelines", "close"], [])
 
     @staticmethod
     def exposed_makedirs(remotepath):
         if os.path.exists(remotepath):
             return "Directory Exists!"
         os.makedirs(remotepath)
@@ -1052,14 +1056,20 @@
     @staticmethod
     def exposed_pathexists(remotepath):
         if os.path.exists(remotepath):
             return True
         return False
 
     @staticmethod
+    def exposed_unlink(remotepath):
+        if os.unlink(remotepath):
+            return True
+        return False
+
+    @staticmethod
     def exposed_isdir(remotepath):
         return os.path.isdir(remotepath)
 
     @staticmethod
     def exposed_tempdir():
         return tempfile.gettempdir()
```

### Comparing `pyaedt-0.8.7/pyaedt/sbrplus/hdm_parser.py` & `pyaedt-0.8.8/pyaedt/sbrplus/hdm_parser.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/sbrplus/hdm_utils.py` & `pyaedt-0.8.8/pyaedt/sbrplus/hdm_utils.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/sbrplus/matlab/HdmObject.m` & `pyaedt-0.8.8/pyaedt/sbrplus/matlab/HdmObject.m`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/sbrplus/matlab/SbrBounceType.m` & `pyaedt-0.8.8/pyaedt/sbrplus/matlab/SbrBounceType.m`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/sbrplus/matlab/StopWatch.m` & `pyaedt-0.8.8/pyaedt/sbrplus/matlab/StopWatch.m`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/sbrplus/matlab/add_3dlight.m` & `pyaedt-0.8.8/pyaedt/sbrplus/matlab/add_3dlight.m`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/sbrplus/matlab/draw_rays1.m` & `pyaedt-0.8.8/pyaedt/sbrplus/matlab/draw_rays1.m`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/sbrplus/matlab/draw_wfobj.m` & `pyaedt-0.8.8/pyaedt/sbrplus/matlab/draw_wfobj.m`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/sbrplus/matlab/filter_rays1.m` & `pyaedt-0.8.8/pyaedt/sbrplus/matlab/filter_rays1.m`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/sbrplus/matlab/filtered_tracks.m` & `pyaedt-0.8.8/pyaedt/sbrplus/matlab/filtered_tracks.m`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/sbrplus/matlab/ld_sbrplushdm.m` & `pyaedt-0.8.8/pyaedt/sbrplus/matlab/ld_sbrplushdm.m`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/sbrplus/matlab/ld_wfobj.m` & `pyaedt-0.8.8/pyaedt/sbrplus/matlab/ld_wfobj.m`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/sbrplus/matlab/validate_sfields.m` & `pyaedt-0.8.8/pyaedt/sbrplus/matlab/validate_sfields.m`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyaedt/sbrplus/plot.py` & `pyaedt-0.8.8/pyaedt/sbrplus/plot.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.8.7/pyproject.toml` & `pyaedt-0.8.8/pyproject.toml`

 * *Files 1% similar despite different names*

```diff
@@ -35,15 +35,15 @@
     "rpyc>=6.0.0,<6.1",
 ]
 
 [project.optional-dependencies]
 tests = [
     "imageio>=2.30.0,<2.35",
     "ipython>=7.30.0,<8.24",
-    "joblib>=1.0.0,<1.4",
+    "joblib>=1.0.0,<1.5",
     "matplotlib>=3.5.0,<3.9",
     "mock>=5.1.0,<5.2",
     "numpy>=1.20.0,<2",
     "openpyxl>=3.1.0,<3.3",
     "osmnx>=1.1.0,<1.10",
     "pandas>=1.1.0,<2.3",
     "pytest>=7.4.0,<8.2",
@@ -68,32 +68,32 @@
 doc = [
     "ansys-sphinx-theme>=0.10.0,<0.16",
     "imageio>=2.30.0,<2.35",
     #"imageio-ffmpeg>=0.4.0,<0.5",
     "ipython>=7.34.0; python_version == '3.7'",
     "ipython>=8.13.0,<8.24; python_version > '3.7'",
     #"ipywidgets>=8.0.0,<8.2",
-    "joblib>=1.3.0,<1.4",
+    "joblib>=1.3.0,<1.5",
     "jupyterlab>=4.0.0,<4.3",
     "matplotlib>=3.5.0,<3.9",
     "nbsphinx>=0.9.0,<0.10",
     "numpydoc>=1.5.0,<1.8",
     "openpyxl>=3.0.0,<3.2",
     "osmnx>=1.1.0,<1.10",
     "pypandoc>=1.10.0,<1.14",
     #"pytest-sphinx",
     "pyvista>=0.38.0,<0.44",
-    #"recommonmark",
+    "recommonmark",
     #"scikit-learn",
     "scikit-rf>=0.30.0,<0.33",
     "Sphinx==5.3.0; python_version == '3.7'",
     "Sphinx>=7.1.0,<7.3; python_version > '3.7'",
     "sphinx-autobuild==2021.3.14; python_version == '3.7'",
     "sphinx-autobuild==2021.3.14; python_version == '3.8'",
-    "sphinx-autobuild==2024.2.4; python_version > '3.8'",
+    "sphinx-autobuild==2024.4.13; python_version > '3.8'",
     #"sphinx-autodoc-typehints",
     "sphinx-copybutton>=0.5.0,<0.6",
     "sphinx-gallery>=0.14.0,<0.16",
     "sphinx-jinja>=2.0,<2.1",
     #"sphinx-notfound-page",
     "sphinx_design>=0.4.0,<0.6",
     #"sphinxcontrib-websupport",
@@ -107,15 +107,15 @@
     #"imageio-ffmpeg",
     "numpydoc>=1.5.0,<1.8",
     # "recommonmark",
     "Sphinx==5.3.0; python_version == '3.7'",
     "Sphinx>=7.1.0,<7.3; python_version > '3.7'",
     "sphinx-autobuild==2021.3.14; python_version == '3.7'",
     "sphinx-autobuild==2021.3.14; python_version == '3.8'",
-    "sphinx-autobuild==2024.2.4; python_version > '3.8'",
+    "sphinx-autobuild==2024.4.13; python_version > '3.8'",
     #"sphinx-autodoc-typehints",
     "sphinx-copybutton>=0.5.0,<0.6",
     "sphinx-gallery>=0.14.0,<0.16",
     #"sphinx-notfound-page",
     #"sphinxcontrib-websupport",
     "sphinx_design>=0.4.0,<0.6",
     "sphinx-jinja>=2.0,<2.1",
```

### Comparing `pyaedt-0.8.7/PKG-INFO` & `pyaedt-0.8.8/PKG-INFO`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: pyaedt
-Version: 0.8.7
+Version: 0.8.8
 Summary: Higher-Level Pythonic Ansys Electronics Desktop Framework
 Author-email: "ANSYS, Inc." <pyansys.core@ansys.com>
 Maintainer-email: PyAEDT developers <massimo.capodiferro@ansys.com>
 Requires-Python: >=3.7,<4
 Description-Content-Type: text/markdown
 Classifier: Development Status :: 4 - Beta
 Classifier: Intended Audience :: Science/Research
@@ -34,56 +34,57 @@
 Requires-Dist: SRTM.py ; extra == "all"
 Requires-Dist: utm ; extra == "all"
 Requires-Dist: vtk==9.2.6 ; extra == "all"
 Requires-Dist: ansys-sphinx-theme>=0.10.0,<0.16 ; extra == "doc"
 Requires-Dist: imageio>=2.30.0,<2.35 ; extra == "doc"
 Requires-Dist: ipython>=7.34.0 ; extra == "doc" and ( python_version == '3.7')
 Requires-Dist: ipython>=8.13.0,<8.24 ; extra == "doc" and ( python_version > '3.7')
-Requires-Dist: joblib>=1.3.0,<1.4 ; extra == "doc"
+Requires-Dist: joblib>=1.3.0,<1.5 ; extra == "doc"
 Requires-Dist: jupyterlab>=4.0.0,<4.3 ; extra == "doc"
 Requires-Dist: matplotlib>=3.5.0,<3.9 ; extra == "doc"
 Requires-Dist: nbsphinx>=0.9.0,<0.10 ; extra == "doc"
 Requires-Dist: numpydoc>=1.5.0,<1.8 ; extra == "doc"
 Requires-Dist: openpyxl>=3.0.0,<3.2 ; extra == "doc"
 Requires-Dist: osmnx>=1.1.0,<1.10 ; extra == "doc"
 Requires-Dist: pypandoc>=1.10.0,<1.14 ; extra == "doc"
 Requires-Dist: pyvista>=0.38.0,<0.44 ; extra == "doc"
+Requires-Dist: recommonmark ; extra == "doc"
 Requires-Dist: scikit-rf>=0.30.0,<0.33 ; extra == "doc"
 Requires-Dist: Sphinx==5.3.0 ; extra == "doc" and ( python_version == '3.7')
 Requires-Dist: Sphinx>=7.1.0,<7.3 ; extra == "doc" and ( python_version > '3.7')
 Requires-Dist: sphinx-autobuild==2021.3.14 ; extra == "doc" and ( python_version == '3.7')
 Requires-Dist: sphinx-autobuild==2021.3.14 ; extra == "doc" and ( python_version == '3.8')
-Requires-Dist: sphinx-autobuild==2024.2.4 ; extra == "doc" and ( python_version > '3.8')
+Requires-Dist: sphinx-autobuild==2024.4.13 ; extra == "doc" and ( python_version > '3.8')
 Requires-Dist: sphinx-copybutton>=0.5.0,<0.6 ; extra == "doc"
 Requires-Dist: sphinx-gallery>=0.14.0,<0.16 ; extra == "doc"
 Requires-Dist: sphinx-jinja>=2.0,<2.1 ; extra == "doc"
 Requires-Dist: sphinx_design>=0.4.0,<0.6 ; extra == "doc"
 Requires-Dist: SRTM.py ; extra == "doc"
 Requires-Dist: utm ; extra == "doc"
 Requires-Dist: vtk==9.2.6 ; extra == "doc"
 Requires-Dist: ansys-sphinx-theme>=0.10.0,<0.16 ; extra == "doc-noexamples"
 Requires-Dist: imageio>=2.30.0,<2.35 ; extra == "doc-noexamples"
 Requires-Dist: numpydoc>=1.5.0,<1.8 ; extra == "doc-noexamples"
 Requires-Dist: Sphinx==5.3.0 ; extra == "doc-noexamples" and ( python_version == '3.7')
 Requires-Dist: Sphinx>=7.1.0,<7.3 ; extra == "doc-noexamples" and ( python_version > '3.7')
 Requires-Dist: sphinx-autobuild==2021.3.14 ; extra == "doc-noexamples" and ( python_version == '3.7')
 Requires-Dist: sphinx-autobuild==2021.3.14 ; extra == "doc-noexamples" and ( python_version == '3.8')
-Requires-Dist: sphinx-autobuild==2024.2.4 ; extra == "doc-noexamples" and ( python_version > '3.8')
+Requires-Dist: sphinx-autobuild==2024.4.13 ; extra == "doc-noexamples" and ( python_version > '3.8')
 Requires-Dist: sphinx-copybutton>=0.5.0,<0.6 ; extra == "doc-noexamples"
 Requires-Dist: sphinx-gallery>=0.14.0,<0.16 ; extra == "doc-noexamples"
 Requires-Dist: sphinx_design>=0.4.0,<0.6 ; extra == "doc-noexamples"
 Requires-Dist: sphinx-jinja>=2.0,<2.1 ; extra == "doc-noexamples"
 Requires-Dist: ansys-pythonnet>=3.1.0rc3 ; extra == "dotnet"
 Requires-Dist: cffi==1.15.1 ; extra == "dotnet" and ( platform_system=='Linux' and python_version == '3.7')
 Requires-Dist: cffi>=1.16.0,<1.17 ; extra == "dotnet" and ( platform_system=='Linux' and python_version > '3.7')
 Requires-Dist: dotnetcore2==3.1.23 ; extra == "dotnet" and ( platform_system=='Linux')
 Requires-Dist: pywin32>=303 ; extra == "dotnet" and ( platform_system=='Windows')
 Requires-Dist: imageio>=2.30.0,<2.35 ; extra == "tests"
 Requires-Dist: ipython>=7.30.0,<8.24 ; extra == "tests"
-Requires-Dist: joblib>=1.0.0,<1.4 ; extra == "tests"
+Requires-Dist: joblib>=1.0.0,<1.5 ; extra == "tests"
 Requires-Dist: matplotlib>=3.5.0,<3.9 ; extra == "tests"
 Requires-Dist: mock>=5.1.0,<5.2 ; extra == "tests"
 Requires-Dist: numpy>=1.20.0,<2 ; extra == "tests"
 Requires-Dist: openpyxl>=3.1.0,<3.3 ; extra == "tests"
 Requires-Dist: osmnx>=1.1.0,<1.10 ; extra == "tests"
 Requires-Dist: pandas>=1.1.0,<2.3 ; extra == "tests"
 Requires-Dist: pytest>=7.4.0,<8.2 ; extra == "tests"
```

